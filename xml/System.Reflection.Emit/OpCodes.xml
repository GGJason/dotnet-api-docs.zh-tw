<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3d83d76933977f09396d3785edac9c15d9fd4cf6" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52919042" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="c1087-101">提供用於 Microsoft Intermediate Language (MSIL) 指令的欄位表示<see cref="T:System.Reflection.Emit.ILGenerator" />類別成員 (例如<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="c1087-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-102">如成員 opcode 的詳細說明，請參閱 Common Language Infrastructure (CLI) 文件，特別是"Partition III: CIL 指令集 」 和 「 磁碟分割 II:: 中繼資料定義和語意 >。</span><span class="sxs-lookup"><span data-stu-id="c1087-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="c1087-103">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](https://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="c1087-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1087-104">下列範例會示範動態方法，使用的建構<xref:System.Reflection.Emit.ILGenerator>發出`OpCodes`到<xref:System.Reflection.Emit.MethodBuilder>。</span><span class="sxs-lookup"><span data-stu-id="c1087-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-105">相加兩個值，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-105">Adds two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-106">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-107">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-107">Format</span></span>|<span data-ttu-id="c1087-108">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-108">Assembly Format</span></span>|<span data-ttu-id="c1087-109">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-110">58</span><span class="sxs-lookup"><span data-stu-id="c1087-110">58</span></span>|<span data-ttu-id="c1087-111">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-111">add</span></span>|<span data-ttu-id="c1087-112">將兩個數字的值，傳回新的數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="c1087-113">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-114">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-115">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-116">`value2` 和`value1`會彈出從堆疊;`value1`新增至`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-117">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-118">整數運算溢位都沒有偵測到 (處理適當的溢位，請參閱<xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="c1087-119">整數加法包裝，而不是飽和。</span><span class="sxs-lookup"><span data-stu-id="c1087-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="c1087-120">比方說，假設 8 位元整數，其中`value1`設定為 255 和`value2`設為 1，已包裝的結果會是 0，而不是 256。</span><span class="sxs-lookup"><span data-stu-id="c1087-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="c1087-121">傳回浮點溢位`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="c1087-122">可接受的運算元類型和其對應的結果資料類型會列在下表中。</span><span class="sxs-lookup"><span data-stu-id="c1087-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="c1087-123">如果沒有任何項目，針對特定類型的組合 (例如`int32`和`float`;`int32`和`int64`)，它是無效 Microsoft Intermediate Language (MSIL)，並產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="c1087-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="c1087-124">運算元</span><span class="sxs-lookup"><span data-stu-id="c1087-124">operand</span></span>|<span data-ttu-id="c1087-125">value1 類型</span><span class="sxs-lookup"><span data-stu-id="c1087-125">value1 type</span></span>|<span data-ttu-id="c1087-126">value2 類型</span><span class="sxs-lookup"><span data-stu-id="c1087-126">value2 type</span></span>|<span data-ttu-id="c1087-127">結果型別</span><span class="sxs-lookup"><span data-stu-id="c1087-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="c1087-128">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="c1087-129">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="c1087-130">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="c1087-131">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="c1087-132">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="c1087-133">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="c1087-134">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="c1087-135">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="c1087-136">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="c1087-137">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="c1087-138">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="c1087-139">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="c1087-140">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="c1087-141">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="c1087-142">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`add`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-144">相加兩個整數、執行溢位檢查，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-145">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-146">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-146">Format</span></span>|<span data-ttu-id="c1087-147">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-147">Assembly Format</span></span>|<span data-ttu-id="c1087-148">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-149">D6</span><span class="sxs-lookup"><span data-stu-id="c1087-149">D6</span></span>|<span data-ttu-id="c1087-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="c1087-150">add.ovf</span></span>|<span data-ttu-id="c1087-151">相加兩個的帶正負號的整數值，具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="c1087-152">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-153">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-154">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-155">`value2` 和`value1`會彈出從堆疊;`value1`新增至`value2`具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="c1087-156">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-157"><xref:System.OverflowException> 如果結果未顯示的結果型別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-158">您可以執行這項作業帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="c1087-159">浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Add>。</span><span class="sxs-lookup"><span data-stu-id="c1087-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="c1087-160">可接受的運算元類型和其對應的結果資料類型會列在下表中。</span><span class="sxs-lookup"><span data-stu-id="c1087-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="c1087-161">如果沒有任何項目，針對特定類型的組合 (例如`int32`和`float`;`int32`和`int64`)，它是無效的 Microsoft Intermediate Language (MSIL) 指示並產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="c1087-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="c1087-162">運算元</span><span class="sxs-lookup"><span data-stu-id="c1087-162">operand</span></span>|<span data-ttu-id="c1087-163">value1 類型</span><span class="sxs-lookup"><span data-stu-id="c1087-163">value1 type</span></span>|<span data-ttu-id="c1087-164">value2 類型</span><span class="sxs-lookup"><span data-stu-id="c1087-164">value2 type</span></span>|<span data-ttu-id="c1087-165">結果型別</span><span class="sxs-lookup"><span data-stu-id="c1087-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="c1087-166">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="c1087-167">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="c1087-168">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="c1087-169">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="c1087-170">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="c1087-171">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="c1087-172">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="c1087-173">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="c1087-174">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="c1087-175">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="c1087-176">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="c1087-177">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="c1087-178">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="c1087-179">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="c1087-180">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`add.ovf`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-182">相加兩個不帶正負號的整數 (Unsigned Integer) 值、執行溢位檢查，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-183">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-184">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-184">Format</span></span>|<span data-ttu-id="c1087-185">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-185">Assembly Format</span></span>|<span data-ttu-id="c1087-186">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-187">D7</span><span class="sxs-lookup"><span data-stu-id="c1087-187">D7</span></span>|<span data-ttu-id="c1087-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="c1087-188">add.ovf.un</span></span>|<span data-ttu-id="c1087-189">新增兩個不帶正負號的整數值，具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="c1087-190">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-191">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-192">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-193">`value2` 和`value1`會彈出從堆疊;`value1`新增至`value2`具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="c1087-194">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-195"><xref:System.OverflowException> 如果結果未顯示的結果型別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-196">您可以執行這項作業帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="c1087-197">浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Add>。</span><span class="sxs-lookup"><span data-stu-id="c1087-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="c1087-198">可接受的運算元類型和其對應的結果資料類型會列在下表中。</span><span class="sxs-lookup"><span data-stu-id="c1087-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="c1087-199">如果沒有任何項目，針對特定類型的組合 (例如`int32`和`float`;`int32`和`int64`)，它是無效的 Microsoft Intermediate Language (MSIL) 指示並產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="c1087-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="c1087-200">運算元</span><span class="sxs-lookup"><span data-stu-id="c1087-200">operand</span></span>|<span data-ttu-id="c1087-201">value1 類型</span><span class="sxs-lookup"><span data-stu-id="c1087-201">value1 type</span></span>|<span data-ttu-id="c1087-202">value2 類型</span><span class="sxs-lookup"><span data-stu-id="c1087-202">value2 type</span></span>|<span data-ttu-id="c1087-203">結果型別</span><span class="sxs-lookup"><span data-stu-id="c1087-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="c1087-204">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="c1087-205">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="c1087-206">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="c1087-207">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="c1087-208">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="c1087-209">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="c1087-210">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="c1087-211">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="c1087-212">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="c1087-213">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="c1087-214">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="c1087-215">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="c1087-216">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="c1087-217">加入</span><span class="sxs-lookup"><span data-stu-id="c1087-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="c1087-218">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`add.ovf.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-220">計算兩個值的位元 AND 運算，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-221">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-222">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-222">Format</span></span>|<span data-ttu-id="c1087-223">指令</span><span class="sxs-lookup"><span data-stu-id="c1087-223">Instruction</span></span>|<span data-ttu-id="c1087-224">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="c1087-225">5F</span><span class="sxs-lookup"><span data-stu-id="c1087-225">5F</span></span>|<span data-ttu-id="c1087-226">和</span><span class="sxs-lookup"><span data-stu-id="c1087-226">and</span></span>|<span data-ttu-id="c1087-227">判斷兩個整數值的位元 AND。</span><span class="sxs-lookup"><span data-stu-id="c1087-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="c1087-228">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-229">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-230">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-231">`value1` 和`value2`從堆疊; 所推出的兩個值的位元 AND 的計算。</span><span class="sxs-lookup"><span data-stu-id="c1087-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="c1087-232">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-233">`and`指令會在堆疊上的前兩個值的位元 AND 的計算，並將結果留在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="c1087-234">`And` 是整數特定作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="c1087-235">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`and`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-237">將 Unmanaged 指標傳回目前方法的引數清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-237">Returns an unmanaged pointer to the argument list of the current method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-238">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-239">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-239">Format</span></span>|<span data-ttu-id="c1087-240">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-240">Assembly Format</span></span>|<span data-ttu-id="c1087-241">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="c1087-242">FE 00</span></span>|<span data-ttu-id="c1087-243">arglist</span><span class="sxs-lookup"><span data-stu-id="c1087-243">arglist</span></span>|<span data-ttu-id="c1087-244">傳回目前方法的引數清單的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="c1087-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="c1087-245">沒有評估堆疊行為都是透過這項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="c1087-246">`arglist`指令傳回的不透明的控制代碼 (類型的 unmanaged 的指標`native int`)，表示目前方法的引數清單。</span><span class="sxs-lookup"><span data-stu-id="c1087-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="c1087-247">只有在目前方法的存留期期間，這個控制代碼是有效的。</span><span class="sxs-lookup"><span data-stu-id="c1087-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="c1087-248">只要目前的方法是在控制項的執行緒上，可以不過，其他方法來傳遞控制代碼。</span><span class="sxs-lookup"><span data-stu-id="c1087-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="c1087-249">您只能執行`arglist`採用可變數目的引數的方法中的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="c1087-250">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`arglist`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-252">如果兩個值相等，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-252">Transfers control to a target instruction if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-253">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-254">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-254">Format</span></span>|<span data-ttu-id="c1087-255">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-255">Assembly Format</span></span>|<span data-ttu-id="c1087-256">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-257">3B < `int32` ></span></span>|<span data-ttu-id="c1087-258">beq `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-258">beq `target`</span></span>|<span data-ttu-id="c1087-259">分支至目標指令，位移`target`兩個值是否相等。</span><span class="sxs-lookup"><span data-stu-id="c1087-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="c1087-260">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-261">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-262">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-263">`value2` 並`value1`如果從堆疊; 快顯`value1`等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-264">`beq`指令將控制權傳輸至指定的目標指示如果`value1`等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="c1087-265">效果等同於執行`ceq`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-266">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-267">封裝可接受的運算元類型如下：</span><span class="sxs-lookup"><span data-stu-id="c1087-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="c1087-268">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="c1087-269">控制傳入和傳出傳輸`try`， `catch`， `filter`，以及`finally`區塊無法執行此指令 (這類傳輸有嚴格限制，而且必須使用<xref:System.Reflection.Emit.OpCodes.Leave>指令改為)。</span><span class="sxs-lookup"><span data-stu-id="c1087-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="c1087-270">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`beq`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-271">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-272">如果兩個值相等，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-272">Transfers control to a target instruction (short form) if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-273">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-274">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-274">Format</span></span>|<span data-ttu-id="c1087-275">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-275">Assembly Format</span></span>|<span data-ttu-id="c1087-276">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-277">2E < `int8` ></span></span>|<span data-ttu-id="c1087-278">後 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-278">beq.s `target`</span></span>|<span data-ttu-id="c1087-279">分支至目標指令，位移`target`相等，如果簡短形式</span><span class="sxs-lookup"><span data-stu-id="c1087-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="c1087-280">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-281">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-282">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-283">`value2` 並`value1`如果從堆疊; 快顯`value1`等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-284">`beq.s`指令將控制權傳輸至指定的目標指示如果`value1`等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="c1087-285">效果等同於執行`ceq`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-286">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-287">封裝可接受的運算元類型如下：</span><span class="sxs-lookup"><span data-stu-id="c1087-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="c1087-288">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="c1087-289">控制傳入和傳出傳輸`try`， `catch`， `filter`，以及`finally`區塊無法執行此指令 (這類傳輸有嚴格限制，而且必須使用<xref:System.Reflection.Emit.OpCodes.Leave>指令改為)。</span><span class="sxs-lookup"><span data-stu-id="c1087-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="c1087-290">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`beq.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-291">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-292">如果第一個值大於或等於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-293">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-294">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-294">Format</span></span>|<span data-ttu-id="c1087-295">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-295">Assembly Format</span></span>|<span data-ttu-id="c1087-296">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="c1087-297">3C `<int32>`</span></span>|<span data-ttu-id="c1087-298">bge.s 使用 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-298">bge `target`</span></span>|<span data-ttu-id="c1087-299">分支至目標指令中指定的位移的第一個值是否大於或等於第二個值。</span><span class="sxs-lookup"><span data-stu-id="c1087-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="c1087-300">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-301">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-302">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-303">`value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-304">`bge`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="c1087-305">效果等同於執行`clt.un`後面的指示`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-306">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-307">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-308">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-309">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-310">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-311">如果第一個值大於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-312">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-313">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-313">Format</span></span>|<span data-ttu-id="c1087-314">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-314">Assembly Format</span></span>|<span data-ttu-id="c1087-315">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="c1087-316">2F `<int8>`</span></span>|<span data-ttu-id="c1087-317">後 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-317">bge.s `target`</span></span>|<span data-ttu-id="c1087-318">分支至目標指令中指定的位移的第一個值是否大於或等於第二個值，也就是簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="c1087-319">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-320">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-321">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-322">`value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-323">`bge.s`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="c1087-324">效果等同於執行`clt.un`後面的指示`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-325">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-326">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-327">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-328">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-329">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-330">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-331">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-332">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-332">Format</span></span>|<span data-ttu-id="c1087-333">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-333">Assembly Format</span></span>|<span data-ttu-id="c1087-334">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="c1087-335">41 `<int32>`</span></span>|<span data-ttu-id="c1087-336">bge.un `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-336">bge.un `target`</span></span>|<span data-ttu-id="c1087-337">分支至目標指令中指定的位移的第一個值是否大於或等於第二個值 （不帶正負號的值）。</span><span class="sxs-lookup"><span data-stu-id="c1087-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-338">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-339">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-340">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-341">`value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-342">`bge.un`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-343">效果等同於執行`clt`後面的指示`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-344">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-345">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-346">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-347">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-348">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-349">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-350">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-351">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-351">Format</span></span>|<span data-ttu-id="c1087-352">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-352">Assembly Format</span></span>|<span data-ttu-id="c1087-353">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-354">34 < `int8` ></span></span>|<span data-ttu-id="c1087-355">bge.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-355">bge.un.s `target`</span></span>|<span data-ttu-id="c1087-356">分支至目標指令中指定的位移的第一個值是否大於或等於第二個值 （不帶正負號的值）、 簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="c1087-357">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-358">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-359">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-360">`value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-361">`bge.un.s`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-362">效果等同於執行`clt`後面的指示`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-363">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-364">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-365">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-366">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge.un.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-367">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-368">如果第一個值大於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-368">Transfers control to a target instruction if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-369">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-370">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-370">Format</span></span>|<span data-ttu-id="c1087-371">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-371">Assembly Format</span></span>|<span data-ttu-id="c1087-372">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-373">3D < `int32` ></span></span>|<span data-ttu-id="c1087-374">bgt.s 使用 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-374">bgt `target`</span></span>|<span data-ttu-id="c1087-375">分支至目標指令中指定的位移的第一個值是否大於第二個值。</span><span class="sxs-lookup"><span data-stu-id="c1087-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="c1087-376">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-377">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-378">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-379">`value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-380">`bgt`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="c1087-381">效果等同於執行`cgt`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-382">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-383">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-384">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-385">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-386">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-387">如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-388">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-389">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-389">Format</span></span>|<span data-ttu-id="c1087-390">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-390">Assembly Format</span></span>|<span data-ttu-id="c1087-391">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-392">30 < `int8` ></span></span>|<span data-ttu-id="c1087-393">後 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-393">bgt.s `target`</span></span>|<span data-ttu-id="c1087-394">分支至目標指令中指定的位移的第一個值是否大於第二個值，也就是簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="c1087-395">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-396">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-397">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-398">`value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-399">`bgt.s`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="c1087-400">效果等同於執行`cgt`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-401">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-402">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-403">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-404">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-405">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-406">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-407">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-408">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-408">Format</span></span>|<span data-ttu-id="c1087-409">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-409">Assembly Format</span></span>|<span data-ttu-id="c1087-410">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-411">42 < `int32` ></span></span>|<span data-ttu-id="c1087-412">bgt.un `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-412">bgt.un `target`</span></span>|<span data-ttu-id="c1087-413">分支至目標指令中指定的位移的第一個值是否大於第二個值 （不帶正負號的值）。</span><span class="sxs-lookup"><span data-stu-id="c1087-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-414">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-415">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-416">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-417">`value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-418">`bgt.un`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-419">效果等同於執行`cgt.un`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-420">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-421">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-422">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-423">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-424">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-425">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-426">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-427">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-427">Format</span></span>|<span data-ttu-id="c1087-428">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-428">Assembly Format</span></span>|<span data-ttu-id="c1087-429">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-430">35 < `int8` ></span></span>|<span data-ttu-id="c1087-431">bgt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-431">bgt.un.s `target`</span></span>|<span data-ttu-id="c1087-432">分支至目標指令中指定的位移的第一個值是否大於第二個值 （不帶正負號的值）、 簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="c1087-433">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-434">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-435">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-436">`value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-437">`bgt.un.s`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-438">效果等同於執行`cgt.un`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-439">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-440">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-441">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-442">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt.un.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-443">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-444">如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-445">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-446">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-446">Format</span></span>|<span data-ttu-id="c1087-447">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-447">Assembly Format</span></span>|<span data-ttu-id="c1087-448">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="c1087-449">3E `<int32>`</span></span>|<span data-ttu-id="c1087-450">ble `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-450">ble `target`</span></span>|<span data-ttu-id="c1087-451">分支至目標指令中指定的位移的第一個值是否小於或等於第二個值。</span><span class="sxs-lookup"><span data-stu-id="c1087-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="c1087-452">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-453">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-454">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-455">`value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-456">`ble`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="c1087-457">效果等同於執行`cgt`指令 (`cgt.un`的浮點數) 後面接著`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-458">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-459">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-460">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-461">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-462">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-463">如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-464">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-465">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-465">Format</span></span>|<span data-ttu-id="c1087-466">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-466">Assembly Format</span></span>|<span data-ttu-id="c1087-467">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="c1087-468">31 `<int8>`</span></span>|<span data-ttu-id="c1087-469">後 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-469">ble.s `target`</span></span>|<span data-ttu-id="c1087-470">分支至目標指令中指定的位移的第一個值是否小於或等於第二個值，也就是簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="c1087-471">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-472">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-473">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-474">`value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-475">`ble.s`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="c1087-476">效果等同於執行`cgt`指令 (`cgt.un`的浮點數) 指令，後面跟著`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-477">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-478">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-479">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-480">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-481">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-482">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-483">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-484">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-484">Format</span></span>|<span data-ttu-id="c1087-485">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-485">Assembly Format</span></span>|<span data-ttu-id="c1087-486">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="c1087-487">43 `<int32>`</span></span>|<span data-ttu-id="c1087-488">ble.un `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-488">ble.un `target`</span></span>|<span data-ttu-id="c1087-489">分支至目標指令中指定的位移的第一個值是否小於或等於第二個值 （不帶正負號的值）。</span><span class="sxs-lookup"><span data-stu-id="c1087-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-490">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-491">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-492">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-493">`value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-494">`ble.un`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-495">效果等同於執行`cgt.un`指令 (`cgt`的浮點數) 後面接著`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-496">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-497">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-498">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-499">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-500">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-501">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-502">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-503">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-503">Format</span></span>|<span data-ttu-id="c1087-504">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-504">Assembly Format</span></span>|<span data-ttu-id="c1087-505">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="c1087-506">36 `<int8>`</span></span>|<span data-ttu-id="c1087-507">ble.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-507">ble.un.s `target`</span></span>|<span data-ttu-id="c1087-508">分支至目標指令中指定的位移的第一個值是否小於或等於第二個值 （不帶正負號的值）、 簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="c1087-509">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-510">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-511">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-512">`value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-513">`ble.un.s`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-514">效果等同於執行`cgt.un`指令 (`cgt`的浮點數) 後面接著`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-515">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-516">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-517">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-518">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble.un.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-519">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-520">如果第一個值小於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-520">Transfers control to a target instruction if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-521">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-522">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-522">Format</span></span>|<span data-ttu-id="c1087-523">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-523">Assembly Format</span></span>|<span data-ttu-id="c1087-524">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-525">3F < `int32` ></span></span>|<span data-ttu-id="c1087-526">blt `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-526">blt `target`</span></span>|<span data-ttu-id="c1087-527">分支到在指定的位移的第一個值是否小於第二個值的目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="c1087-528">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-529">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-530">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-531">`value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-532">`blt`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="c1087-533">效果等同於執行`clt`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-534">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-535">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-536">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-537">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-538">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-539">如果第一個值小於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-540">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-541">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-541">Format</span></span>|<span data-ttu-id="c1087-542">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-542">Assembly Format</span></span>|<span data-ttu-id="c1087-543">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-544">32 < `int8` ></span></span>|<span data-ttu-id="c1087-545">後 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-545">blt.s `target`</span></span>|<span data-ttu-id="c1087-546">分支至目標指令，在指定的位移的第一個值是否小於第二個值，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="c1087-547">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-548">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-549">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-550">`value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-551">`blt.s`指令將控制權傳輸至指定的目標指示如果`value1`是小於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="c1087-552">效果等同於執行`clt`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-553">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-554">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-555">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-556">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-557">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-558">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於第二個值，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-559">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-560">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-560">Format</span></span>|<span data-ttu-id="c1087-561">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-561">Assembly Format</span></span>|<span data-ttu-id="c1087-562">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-563">44 < `int32` ></span></span>|<span data-ttu-id="c1087-564">blt.un `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-564">blt.un `target`</span></span>|<span data-ttu-id="c1087-565">分支至目標指令，在指定的位移的第一個值是否小於第二個值 （不帶正負號的值）。</span><span class="sxs-lookup"><span data-stu-id="c1087-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-566">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-567">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-568">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-569">`value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-570">`blt.un`指令將控制權傳輸至指定的目標指示如果`value1`是小於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-571">效果等同於執行`clt.un`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-572">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-573">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-574">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-575">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-576">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-577">當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-578">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-579">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-579">Format</span></span>|<span data-ttu-id="c1087-580">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-580">Assembly Format</span></span>|<span data-ttu-id="c1087-581">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-582">37 < `int8` ></span></span>|<span data-ttu-id="c1087-583">blt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-583">blt.un.s `target`</span></span>|<span data-ttu-id="c1087-584">分支至目標指令，在指定的位移的第一個值是否小於第二個值 （不帶正負號的值）、 簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="c1087-585">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-586">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-587">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-588">`value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-589">`blt.un`指令將控制權傳輸至指定的目標指示如果`value1`是小於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-590">效果等同於執行`clt.un`後面的指示`brtrue`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-591">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-592">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-593">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-594">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt.un.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-595">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-596">當兩個不帶正負號的整數值或未按順序的浮點值不相等時，則將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-597">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-598">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-598">Format</span></span>|<span data-ttu-id="c1087-599">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-599">Assembly Format</span></span>|<span data-ttu-id="c1087-600">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-601">40 < `int32` ></span></span>|<span data-ttu-id="c1087-602">bne.un `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-602">bne.un `target`</span></span>|<span data-ttu-id="c1087-603">分支至目標指令時所指定的位移，如果兩個不帶正負號的整數值是不相等的 （不帶正負號的值）。</span><span class="sxs-lookup"><span data-stu-id="c1087-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-604">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-605">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-606">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-607">`value2` 並`value1`如果從堆疊; 快顯`value1`不等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-608">`bne.un`指令將控制權傳輸至指定的目標指示如果`value1`不等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-609">效果等同於執行`ceq`後面的指示`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-610">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-611">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-612">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-613">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bne.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-614">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-615">當兩個不帶正負號的整數值或未按順序的浮點值不相等時，則將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-616">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-617">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-617">Format</span></span>|<span data-ttu-id="c1087-618">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-618">Assembly Format</span></span>|<span data-ttu-id="c1087-619">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-620">33 < `int8` ></span></span>|<span data-ttu-id="c1087-621">bne.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-621">bne.un.s `target`</span></span>|<span data-ttu-id="c1087-622">分支至目標指令時所指定的位移，如果兩個不帶正負號的整數值是不相等的 （不帶正負號的值）、 簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="c1087-623">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-624">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-625">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-626">`value2` 並`value1`如果從堆疊; 快顯`value1`不等於`value2`，執行分支作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="c1087-627">`bne.un`指令將控制權傳輸至指定的目標指示如果`value1`不等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。</span><span class="sxs-lookup"><span data-stu-id="c1087-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="c1087-628">效果等同於執行`ceq`後面的指示`brfalse`分支至的特定目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="c1087-629">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-630">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-631">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-632">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bne.un.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-633">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-634">將實值型別轉換成物件參考 (型別<see langword="O" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-634">Converts a value type to an object reference (type <see langword="O" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-635">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-636">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-636">Format</span></span>|<span data-ttu-id="c1087-637">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-637">Assembly Format</span></span>|<span data-ttu-id="c1087-638">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-639">8C < `T` ></span></span>|<span data-ttu-id="c1087-640">方塊 `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="c1087-640">box `valTypeToken`</span></span>|<span data-ttu-id="c1087-641">將實值型別轉換 (在指定之型別的`valTypeToken`)，則為 true 的物件參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="c1087-642">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-643">實值型別會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-644">實值型別會從堆疊; 推出`box`作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="c1087-645">產生的"boxed"的值類型的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-646">實值型別有兩種不同的表示法在 Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="c1087-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="c1087-647">當實值型別會內嵌在另一個物件，或在堆疊上時，使用 'raw' 格式。</span><span class="sxs-lookup"><span data-stu-id="c1087-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="c1087-648">'Boxed' 格式，其中實值型別中的資料會包裝 （進行 boxed 處理） 到物件讓它可以當作獨立的實體存在。</span><span class="sxs-lookup"><span data-stu-id="c1087-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="c1087-649">`box`指令會將未經處理 」 (unboxed) 實值類型轉換成物件參考 (型別`O`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="c1087-650">這被透過建立新的物件和資料複製到新配置物件的實值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="c1087-651">`valTypeToken` 這中繼資料語彙基元，表示在堆疊上之值型別的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="c1087-652"><xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="c1087-653"><xref:System.TypeLoadException> 如果找不到類別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="c1087-654">這通常是偵測到 Microsoft Intermediate Language (MSIL) 轉換成機器碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-655">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`box`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-656">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-657">無條件地將控制權傳輸至目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-657">Unconditionally transfers control to a target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-658">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-659">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-659">Format</span></span>|<span data-ttu-id="c1087-660">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-660">Assembly Format</span></span>|<span data-ttu-id="c1087-661">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-662">38 < `int32` ></span></span>|<span data-ttu-id="c1087-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-663">br `target`</span></span>|<span data-ttu-id="c1087-664">分支至目標指令中指定的位移。</span><span class="sxs-lookup"><span data-stu-id="c1087-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="c1087-665">沒有評估堆疊行為都是透過這項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="c1087-666">`br`指令無條件地將控制權傳輸至目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="c1087-667">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-668">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-669">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-670">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`br`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-671">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-672">無條件地將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-672">Unconditionally transfers control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-673">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-674">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-674">Format</span></span>|<span data-ttu-id="c1087-675">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-675">Assembly Format</span></span>|<span data-ttu-id="c1087-676">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-677">2B < `int8` ></span></span>|<span data-ttu-id="c1087-678">br.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-678">br.s `target`</span></span>|<span data-ttu-id="c1087-679">分支至目標指令中指定的位移，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="c1087-680">沒有評估堆疊行為都是透過這項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="c1087-681">`br.s`指令無條件地將控制權傳輸至目標指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="c1087-682">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-683">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-684">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-685">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`br.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-686">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-687">以訊號指示 Common Language Infrastructure (CLI) 向偵錯工具告知已經過中斷點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-688">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-689">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-689">Format</span></span>|<span data-ttu-id="c1087-690">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-690">Assembly Format</span></span>|<span data-ttu-id="c1087-691">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-692">01</span><span class="sxs-lookup"><span data-stu-id="c1087-692">01</span></span>|<span data-ttu-id="c1087-693">break</span><span class="sxs-lookup"><span data-stu-id="c1087-693">break</span></span>|<span data-ttu-id="c1087-694">告知偵錯工具已到達中斷點。</span><span class="sxs-lookup"><span data-stu-id="c1087-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="c1087-695">沒有評估堆疊行為都是透過這項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="c1087-696">`break`指示是針對偵錯支援。</span><span class="sxs-lookup"><span data-stu-id="c1087-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="c1087-697">它會通知來通知偵錯工具中斷點已跳脫 CLI。</span><span class="sxs-lookup"><span data-stu-id="c1087-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="c1087-698">它有沒有其他作用在解譯器的狀態。</span><span class="sxs-lookup"><span data-stu-id="c1087-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="c1087-699">`break`指令具有最小可能指令的大小可讓程式碼修補設有中斷點，並產生周圍的程式碼所造成的最小影響。</span><span class="sxs-lookup"><span data-stu-id="c1087-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="c1087-700">`break`指令可以捕捉到偵錯工具，不執行任何動作，或引發安全性例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="c1087-701">確切的行為是由實作定義。</span><span class="sxs-lookup"><span data-stu-id="c1087-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="c1087-702">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`break`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-704">如果將控制權傳輸至目標指令<paramref name="value" />是<see langword="false" />，為 null 參考 (<see langword="Nothing" /> Visual Basic 中)，則為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-705">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-706">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-706">Format</span></span>|<span data-ttu-id="c1087-707">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-707">Assembly Format</span></span>|<span data-ttu-id="c1087-708">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-709">39 < `int32` ></span></span>|<span data-ttu-id="c1087-710">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="c1087-711">brnull `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="c1087-712">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-712">brzero `target`</span></span>|<span data-ttu-id="c1087-713">分支至目標指令在指定的位移 if `false`。</span><span class="sxs-lookup"><span data-stu-id="c1087-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="c1087-714">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-715">`value` 推送至堆疊的前一項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="c1087-716">`value` 會從堆疊; 推出如果`value`已`false`，分支到`target`。</span><span class="sxs-lookup"><span data-stu-id="c1087-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="c1087-717">`brfalse`指令 (和其別名`brnull`並`brzero`) 將控制權傳輸至指定的目標指令，如果`value`(型別的`int32`， `int64`，物件參考`O`、 managed 指標`&`，暫時性指標`*`， `native int`) 為零 (`false`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="c1087-718">如果`value`為非零 (`true`) 會繼續在下一步 的指示執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="c1087-719">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-720">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-721">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-722">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brfalse`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-723">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-724">如果將控制權傳輸至目標指令<paramref name="value" />是<see langword="false" />，null 參考或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-725">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-726">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-726">Format</span></span>|<span data-ttu-id="c1087-727">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-727">Assembly Format</span></span>|<span data-ttu-id="c1087-728">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-729">2C <`int8` ></span></span>|<span data-ttu-id="c1087-730">brfalse.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="c1087-731">brnull.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="c1087-732">brzero.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-732">brzero.s `target`</span></span>|<span data-ttu-id="c1087-733">分支至目標指令在指定的位移 if `false`，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="c1087-734">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-735">`value` 推送至堆疊的前一項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="c1087-736">`value` 會從堆疊; 推出如果`value`已`false`，分支到`target`。</span><span class="sxs-lookup"><span data-stu-id="c1087-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="c1087-737">`brfalse.s`指令 (和其別名`brnull`並`brzero`) 將控制權傳輸至指定的目標指令，如果`value`(型別的`int32`， `int64`，物件參考`O`、 managed 指標`&`，暫時性指標`*`， `native int`) 為零 (`false`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="c1087-738">如果`value`為非零 (`true`) 會繼續在下一步 的指示執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="c1087-739">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-740">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-741">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-742">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brfalse.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-743">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-744">如果將控制權傳輸至目標指令<paramref name="value" />是<see langword="true" />、 非 null 或非零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-745">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-746">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-746">Format</span></span>|<span data-ttu-id="c1087-747">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-747">Assembly Format</span></span>|<span data-ttu-id="c1087-748">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-749">3A < `int32` ></span></span>|<span data-ttu-id="c1087-750">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="c1087-751">brinst `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-751">brinst `target`</span></span>|<span data-ttu-id="c1087-752">如果不是零，分支至目標指令中指定的位移 (`true`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="c1087-753">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-754">`value` 推送至堆疊的前一項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="c1087-755">`value` 會從堆疊; 推出如果`value`已`true`，分支到`target`。</span><span class="sxs-lookup"><span data-stu-id="c1087-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="c1087-756">`brtrue`指令將控制權傳輸至指定的目標指示如果`value`(型別`native int`) 為非零值 (`true`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="c1087-757">如果`value`為零 (`false`) 會繼續在下一步 的指示執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="c1087-758">如果`value`是物件參考 (型別`O`) 然後`brinst`(的別名`brtrue`) 將控制權轉移，如果它代表物件的執行個體 (例如，如果不是 null 的物件參考，請參閱<xref:System.Reflection.Emit.OpCodes.Ldnull>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="c1087-759">目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。</span><span class="sxs-lookup"><span data-stu-id="c1087-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-760">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-761">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-762">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brtrue`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-763">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-764">將控制權傳輸至目標指令 （簡短形式），如果<paramref name="value" />是<see langword="true" />、 非 null 或非零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-765">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-766">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-766">Format</span></span>|<span data-ttu-id="c1087-767">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-767">Assembly Format</span></span>|<span data-ttu-id="c1087-768">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-769">2D < `int8` ></span></span>|<span data-ttu-id="c1087-770">brtrue.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="c1087-771">brinst.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-771">brinst.s `target`</span></span>|<span data-ttu-id="c1087-772">如果不是零，分支至目標指令中指定的位移 (`true`)，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="c1087-773">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-774">`value` 推送至堆疊的前一項作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="c1087-775">`value` 會從堆疊; 推出如果`value`已`true`，分支到`target`。</span><span class="sxs-lookup"><span data-stu-id="c1087-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="c1087-776">`brtrue.s`指令將控制權傳輸至指定的目標指示如果`value`(型別`native int`) 為非零值 (`true`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="c1087-777">如果`value`為零 (`false`) 會繼續在下一步 的指示執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="c1087-778">如果`value`是物件參考 (型別`O`) 然後`brinst`(的別名`brtrue`) 將控制權轉移，如果它代表物件的執行個體 (例如，如果不是 null 的物件參考，請參閱<xref:System.Reflection.Emit.OpCodes.Ldnull>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="c1087-779">目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-780">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="c1087-781">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="c1087-782">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brtrue.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-783">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-784">呼叫傳遞的方法描述項所指示的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-784">Calls the method indicated by the passed method descriptor.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-785">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-786">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-786">Format</span></span>|<span data-ttu-id="c1087-787">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-787">Assembly Format</span></span>|<span data-ttu-id="c1087-788">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-789">28 < `T` ></span></span>|<span data-ttu-id="c1087-790">呼叫 `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="c1087-790">call `methodDesc`</span></span>|<span data-ttu-id="c1087-791">呼叫所描述方法`methodDesc`。</span><span class="sxs-lookup"><span data-stu-id="c1087-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="c1087-792">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-793">方法引數`arg1`透過`argN`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-794">方法引數`arg1`透過`argN`會彈出從堆疊; 方法呼叫會使用這些引數來執行，而且控制權會轉移至方法描述元所參考的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="c1087-795">完成時，傳回的值就是被呼叫端方法所產生，並傳送至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="c1087-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="c1087-796">傳回值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-797">`call`指令呼叫傳遞指令的方法描述項所指定的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="c1087-798">方法描述元是中繼資料語彙基元，表示要呼叫數目、 類型和放置要傳遞至該方法，以及要使用的呼叫慣例在堆疊的引數順序的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="c1087-799">`call`指令可以前面緊接`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前置詞來指定應該釋放目前的方法狀態，才能將控制權轉移的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="c1087-800">如果呼叫會將控制權傳輸至較高的信任，比原始方法的方法，是不會釋放堆疊框架。</span><span class="sxs-lookup"><span data-stu-id="c1087-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="c1087-801">相反地，會繼續執行無訊息方式如同`tail`尚未提供。</span><span class="sxs-lookup"><span data-stu-id="c1087-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="c1087-802">的中繼資料語彙基元會傳送足夠的資訊來判斷呼叫是否為靜態方法，執行個體方法，虛擬方法，或全域函式。</span><span class="sxs-lookup"><span data-stu-id="c1087-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="c1087-803">在這些情況下的所有目的地位址由都決定完全從方法描述元 (與<xref:System.Reflection.Emit.OpCodes.Callvirt>呼叫虛擬方法，其中的目的地位址也取決於執行階段類型的執行個體的指示參考推入之前<xref:System.Reflection.Emit.OpCodes.Callvirt>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="c1087-804">引數會放在堆疊上，在左到右的順序。</span><span class="sxs-lookup"><span data-stu-id="c1087-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="c1087-805">也就是第一個引數會計算並放置在堆疊上，則第二個引數，則第三個，直到所有必要的引數是以遞減順序堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="c1087-806">有三個重要的特殊情況：</span><span class="sxs-lookup"><span data-stu-id="c1087-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="c1087-807">呼叫執行個體 （或虛擬） 方法必須將推入執行個體參考之前的任何使用者可見的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="c1087-808">執行個體的參考不能為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="c1087-809">執行中繼資料中的簽章不包含的參數清單中的項目`this`指標，而是使用位元來指出方法是否需要傳遞`this`指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="c1087-810">它會有效地呼叫虛擬方法，使用`call`(而非`callvirt`); 這表示，方法是使用指定方法，而不是以動態方式從物件叫用指定的類別來解決。</span><span class="sxs-lookup"><span data-stu-id="c1087-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="c1087-811">請注意，委派`Invoke`可以使用呼叫方法`call`或`callvirt`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="c1087-812"><xref:System.Security.SecurityException> 可能會擲回，如果系統安全性不會授與被呼叫的方法的呼叫端存取。</span><span class="sxs-lookup"><span data-stu-id="c1087-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="c1087-813">Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時，可能會發生安全性檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c1087-814">當實值型別上呼叫 System.Object 的方法，請考慮使用`constrained`加上前置詞`callvirt`而不是發出指令`call`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="c1087-815">這可免除發出不同 IL 根據實值型別會覆寫方法，避免潛在的版本控制問題。</span><span class="sxs-lookup"><span data-stu-id="c1087-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="c1087-816">請考慮使用`constrained`可以使用變更時叫用介面方法上實值型別，因為實作介面方法的值類型方法的前置詞`MethodImpl`。</span><span class="sxs-lookup"><span data-stu-id="c1087-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="c1087-817">會更詳細地說明這些問題<xref:System.Reflection.Emit.OpCodes.Constrained>opcode。</span><span class="sxs-lookup"><span data-stu-id="c1087-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="c1087-818">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`call`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-819">ILGenerator.Emit （OpCode、 MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="c1087-820">ILGenerator.EmitCall (OpCode MethodInfo Type[])</span><span class="sxs-lookup"><span data-stu-id="c1087-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c1087-821"><xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法提供給`varargs`呼叫。</span><span class="sxs-lookup"><span data-stu-id="c1087-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="c1087-822">使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>一般呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-823">以呼叫慣例所描述的引數，呼叫在評估堆疊上指示的方法 (做為進入點的指標)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-824">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-825">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-825">Format</span></span>|<span data-ttu-id="c1087-826">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-826">Assembly Format</span></span>|<span data-ttu-id="c1087-827">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-828">29 < `T` ></span></span>|<span data-ttu-id="c1087-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="c1087-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="c1087-830">呼叫方法的呼叫慣例所描述的引數所指向。</span><span class="sxs-lookup"><span data-stu-id="c1087-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="c1087-831">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-832">方法引數`arg1`透過`argN`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-833">方法項目指標會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-834">方法引數`arg1`透過`argN`和方法的項目指標會從堆疊推出; 方法的呼叫會執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="c1087-835">完成時，傳回的值就是被呼叫端方法所產生，並傳送至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="c1087-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="c1087-836">傳回值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-837">`calli`指令呼叫方法的項目指標使用的引數`arg1`透過`argN`。</span><span class="sxs-lookup"><span data-stu-id="c1087-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="c1087-838">這些引數類型會描述特定的呼叫慣例 (`callSiteDesc`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="c1087-839">`calli`指示可能前面緊接`tail`前置詞 (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 來指定應該釋放目前的方法狀態，才能將控制權轉移。</span><span class="sxs-lookup"><span data-stu-id="c1087-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="c1087-840">如果呼叫，就會傳輸將不會釋放控制項的信任層級高於原始方法的堆疊框架的方法;相反地，執行會以無訊息模式繼續如同`tail`尚未提供。</span><span class="sxs-lookup"><span data-stu-id="c1087-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="c1087-841">方法的項目指標會假設為原生程式碼 （的目標電腦） 可以合法地呼叫 （獨立的簽章的中繼資料語彙基元） 的呼叫慣例所描述的引數的特定指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="c1087-842">您可以使用建立這類指標<xref:System.Reflection.Emit.OpCodes.Ldftn>或<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>的指示，或傳入的原生程式碼。</span><span class="sxs-lookup"><span data-stu-id="c1087-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="c1087-843">呼叫慣例不會以動態方式檢查，因此程式碼該使用`calli`指令無法正常運作如果目的地不會實際使用指定的呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="c1087-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="c1087-844">引數會放在堆疊上，在左到右的順序。</span><span class="sxs-lookup"><span data-stu-id="c1087-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="c1087-845">也就是第一個引數會計算並放置在堆疊上，則第二個引數，則第三個，直到所有必要的引數是以遞減順序堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="c1087-846">執行個體或虛擬方法的引數建置程式碼順序必須將該執行個體參考 （不得為 null 參考） 之前的任何使用者可見的引數推入。</span><span class="sxs-lookup"><span data-stu-id="c1087-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="c1087-847"><xref:System.Security.SecurityException> 可能會擲回，如果系統安全性不會授與被呼叫的方法的呼叫端存取。</span><span class="sxs-lookup"><span data-stu-id="c1087-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="c1087-848">Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時，可以發生安全性檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-849">下列<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法可用來執行`calli`堆疊上的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="c1087-850">請注意，`calli`應該透過呼叫以下方法，而不是使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>類別將直接在堆疊上的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="c1087-851">ILGenerator.EmitCalli (Opcode、 CallingConventions、 型別，Type []，Type[]) 呼叫使用的 managed 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="c1087-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="c1087-852">ILGenerator.EmitCalli (Opcode CallingConvention，型別，Type[]) 呼叫使用的 unmanaged 呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="c1087-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-853">在物件上呼叫晚期繫結方法，將傳回值推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-854">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-855">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-855">Format</span></span>|<span data-ttu-id="c1087-856">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-856">Assembly Format</span></span>|<span data-ttu-id="c1087-857">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-858">6F < `T` ></span></span>|<span data-ttu-id="c1087-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="c1087-859">callvirt `method`</span></span>|<span data-ttu-id="c1087-860">呼叫相關聯的特定方法`obj`。</span><span class="sxs-lookup"><span data-stu-id="c1087-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="c1087-861">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-862">物件參考`obj`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-863">方法引數`arg1`透過`argN`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-864">方法引數`arg1`透過`argN`和物件參考`obj`會彈出從堆疊; 方法呼叫會使用這些引數來執行，而且控制權會轉移至中的方法`obj`指方法中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="c1087-865">完成時，傳回的值就是被呼叫端方法所產生，並傳送至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="c1087-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="c1087-866">傳回值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-867">`callvirt`指令的物件上呼叫晚期繫結方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="c1087-868">也就是說，方法選擇根據執行階段類型的`obj`而不是編譯時期類別顯示在方法的指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="c1087-869">`Callvirt` 可用來呼叫虛擬和執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="c1087-870">`callvirt`指示可能前面緊接`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前置詞，以指定應該釋放目前的堆疊框架，才能將控制權轉移。</span><span class="sxs-lookup"><span data-stu-id="c1087-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="c1087-871">如果呼叫，就會傳輸不會釋放控制項的信任層級高於原始方法的堆疊框架的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="c1087-872">方法的中繼資料語彙基元提供名稱、 類別和要呼叫之方法的簽章。</span><span class="sxs-lookup"><span data-stu-id="c1087-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="c1087-873">與相關聯的類別`obj`是它的執行個體的類別。</span><span class="sxs-lookup"><span data-stu-id="c1087-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="c1087-874">如果類別定義了符合指定的方法名稱和簽章的非靜態方法，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="c1087-875">否則順序會檢查此類別的基底類別鏈結中的所有類別。</span><span class="sxs-lookup"><span data-stu-id="c1087-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="c1087-876">如果找不到任何方法，它就會是錯誤。</span><span class="sxs-lookup"><span data-stu-id="c1087-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="c1087-877">`Callvirt` 在呼叫方法之前出現的物件和相關聯的引數，從評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="c1087-878">如果方法具有傳回值，則會將它推入方法完成時的堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="c1087-879">被呼叫端一端`obj`參數會當做引數為 0，`arg1`做為引數 1，依此類推。</span><span class="sxs-lookup"><span data-stu-id="c1087-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="c1087-880">引數會放在堆疊上，在左到右的順序。</span><span class="sxs-lookup"><span data-stu-id="c1087-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="c1087-881">也就是第一個引數會計算並放置在堆疊上，則第二個引數，則第三個，直到所有必要的引數是以遞減順序堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="c1087-882">執行個體參考`obj`(一律所需的`callvirt`) 必須推送之前的任何使用者可見的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="c1087-883">（包含在中繼資料語彙基元） 的簽章不需要這個包含的參數清單中的項目指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="c1087-884">請注意，虛擬方法也可以呼叫使用<xref:System.Reflection.Emit.OpCodes.Call>指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="c1087-885"><xref:System.MissingMethodException> 如果相關聯的類別中找不到具有指定的名稱和簽章的非靜態方法會擲回`obj`或任何其基底類別。</span><span class="sxs-lookup"><span data-stu-id="c1087-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="c1087-886">這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-887"><xref:System.NullReferenceException> 如果 obj 為 null，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="c1087-888"><xref:System.Security.SecurityException> 如果系統安全性不會授與被呼叫的方法的呼叫端存取，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="c1087-889">CIL 轉換至原生程式碼，而不是在執行階段時，可能會發生安全性檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c1087-890">當實值型別上呼叫 System.Object 的方法，請考慮使用`constrained`加上前置詞`callvirt`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="c1087-891">這可免除發出不同 IL 根據實值型別會覆寫方法，避免潛在的版本控制問題。</span><span class="sxs-lookup"><span data-stu-id="c1087-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="c1087-892">請考慮使用`constrained`可以使用變更時叫用介面方法上實值型別，因為實作介面方法的值類型方法的前置詞`MethodImpl`。</span><span class="sxs-lookup"><span data-stu-id="c1087-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="c1087-893">會更詳細地說明這些問題<xref:System.Reflection.Emit.OpCodes.Constrained>opcode。</span><span class="sxs-lookup"><span data-stu-id="c1087-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="c1087-894">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`callvirt`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-895">ILGenerator.Emit （OpCode、 MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="c1087-896">ILGenerator.EmitCall (OpCode MethodInfo Type[])</span><span class="sxs-lookup"><span data-stu-id="c1087-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-897">嘗試將參考所傳遞的物件轉型為指定的類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-897">Attempts to cast an object passed by reference to the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-898">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-899">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-899">Format</span></span>|<span data-ttu-id="c1087-900">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-900">Assembly Format</span></span>|<span data-ttu-id="c1087-901">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-902">74 < `T` ></span></span>|<span data-ttu-id="c1087-903">castclass `class`</span><span class="sxs-lookup"><span data-stu-id="c1087-903">castclass `class`</span></span>|<span data-ttu-id="c1087-904">將轉換至新的物件型別的物件`class`。</span><span class="sxs-lookup"><span data-stu-id="c1087-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="c1087-905">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-906">物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-907">物件參考是從堆疊; 推出參考的物件轉換為指定`class`。</span><span class="sxs-lookup"><span data-stu-id="c1087-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="c1087-908">如果成功，則會將新的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-909">`castclass`指令會嘗試轉換的物件參考 (型別`O`) 指定的類別到堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="c1087-910">新的類別被指定的中繼資料語彙基元，指出所需的類別。</span><span class="sxs-lookup"><span data-stu-id="c1087-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="c1087-911">如果堆疊頂端的物件類別不會實作新的類別 （假設新的類別介面），而不是在衍生的類別的新類別則<xref:System.InvalidCastException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="c1087-912">如果物件參考為 null 參考，`castclass`成功並傳回新的物件為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="c1087-913"><xref:System.InvalidCastException> 如果 obj 無法轉換成類別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="c1087-914"><xref:System.TypeLoadException> 如果找不到類別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="c1087-915">這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-916">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`castclass`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-917">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-918">比較兩個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-918">Compares two values.</span>
          </span>
          <span data-ttu-id="c1087-919">如果兩者相等，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-920">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-921">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-921">Format</span></span>|<span data-ttu-id="c1087-922">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-922">Assembly Format</span></span>|<span data-ttu-id="c1087-923">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="c1087-924">FE 01</span></span>|<span data-ttu-id="c1087-925">ceq</span><span class="sxs-lookup"><span data-stu-id="c1087-925">ceq</span></span>|<span data-ttu-id="c1087-926">推送 1，如果`value1`等於`value2`，否則將 0 推入。</span><span class="sxs-lookup"><span data-stu-id="c1087-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="c1087-927">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-928">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-929">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-930">`value2` 和`value1`會彈出從堆疊;`value1`相較於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-931">如果`value1`等於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-932">`ceq`指示比較`value1`和`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="c1087-933">如果`value1`等於`value2`，然後 1 (型別`int32`) 推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="c1087-934">否則為 0 (型別`int32`) 推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="c1087-935">浮點數的`ceq`會傳回 0，如果數字排序 （或兩者皆是 NaN）。</span><span class="sxs-lookup"><span data-stu-id="c1087-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="c1087-936">對其本身的無限值相等。</span><span class="sxs-lookup"><span data-stu-id="c1087-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="c1087-937">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ceq`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-939">比較兩個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-939">Compares two values.</span>
          </span>
          <span data-ttu-id="c1087-940">如果第一個值大於第二個，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-941">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-942">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-942">Format</span></span>|<span data-ttu-id="c1087-943">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-943">Assembly Format</span></span>|<span data-ttu-id="c1087-944">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="c1087-945">FE 02</span></span>|<span data-ttu-id="c1087-946">cgt</span><span class="sxs-lookup"><span data-stu-id="c1087-946">cgt</span></span>|<span data-ttu-id="c1087-947">推送 1，如果`value1`大於`value2`，否則將 0 推入。</span><span class="sxs-lookup"><span data-stu-id="c1087-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="c1087-948">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-949">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-950">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-951">`value2` 和`value1`會彈出從堆疊;`cgt`測試`value1`大於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-952">如果`value1`大於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-953">`cgt`指示比較`value1`和`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="c1087-954">如果`value1`必定大於`value2`，然後`int32`值 1 會推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="c1087-955">否則， `int32` 0 值推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="c1087-956">浮點數，`cgt`會傳回 0，如果數字排序 （亦即，如果一或兩個引數是 NaN）。</span><span class="sxs-lookup"><span data-stu-id="c1087-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="c1087-957">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cgt`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-959">比較兩個沒有正負號或未排序的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-959">Compares two unsigned or unordered values.</span>
          </span>
          <span data-ttu-id="c1087-960">如果第一個值大於第二個，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-961">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-962">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-962">Format</span></span>|<span data-ttu-id="c1087-963">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-963">Assembly Format</span></span>|<span data-ttu-id="c1087-964">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="c1087-965">FE 03</span></span>|<span data-ttu-id="c1087-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="c1087-966">cgt.un</span></span>|<span data-ttu-id="c1087-967">推送 1，如果`value1`大於`value2`，否則將 0 （不帶正負號的值） 推入。</span><span class="sxs-lookup"><span data-stu-id="c1087-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-968">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-969">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-970">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-971">`value2` 和`value1`會彈出從堆疊;`cgt.un`測試`value1`大於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-972">如果`value1`大於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-973">`int32`值為 1 會推送到堆疊上，如果下列任一項為`true`:</span><span class="sxs-lookup"><span data-stu-id="c1087-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="c1087-974">浮點數，如`value1`相對於未經過排序`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="c1087-975">對於整數值`value1`必定大於`value2`時視為不帶正負號的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="c1087-976">否則`int32`0 值推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="c1087-977">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cgt.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-979">會擲回<see cref="T:System.ArithmeticException" />如果值不是有限的數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-980">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-981">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-981">Format</span></span>|<span data-ttu-id="c1087-982">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-982">Assembly Format</span></span>|<span data-ttu-id="c1087-983">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-984">C3</span><span class="sxs-lookup"><span data-stu-id="c1087-984">C3</span></span>|<span data-ttu-id="c1087-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="c1087-985">ckfinite</span></span>|<span data-ttu-id="c1087-986">擲回<xref:System.ArithmeticException>如果值不是有限的數量。</span><span class="sxs-lookup"><span data-stu-id="c1087-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="c1087-987">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-988">`value` 推送至堆疊...</span><span class="sxs-lookup"><span data-stu-id="c1087-988">`value` is pushed onto the stack..</span></span>  
  
2.  <span data-ttu-id="c1087-989">`value` 會從堆疊推出和`ckfinite`指令會在其上執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="c1087-990">`value` 推送回至堆疊在擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-991">`ckfinite instruction`會擲回<xref:System.ArithmeticException>如果`value`（浮點數） 是 「 不是數字 」 值 (NaN) 或`+-`無限大值。</span><span class="sxs-lookup"><span data-stu-id="c1087-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="c1087-992">`Ckfinite` 如果擲不回任何例外狀況，請將值保留在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="c1087-993">如果未指定執行，是`value`不是浮點數的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="c1087-994"><xref:System.ArithmeticException> 如果擲回`value`不是 'normal' 的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="c1087-995">請注意，特殊的例外狀況或衍生的類別的<xref:System.ArithmeticException>可能更合適，將不正確的值傳遞至例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="c1087-996">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ckfinite`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-998">比較兩個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-998">Compares two values.</span>
          </span>
          <span data-ttu-id="c1087-999">如果第一個值小於第二個，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1000">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1001">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1001">Format</span></span>|<span data-ttu-id="c1087-1002">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1002">Assembly Format</span></span>|<span data-ttu-id="c1087-1003">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="c1087-1004">FE 04</span></span>|<span data-ttu-id="c1087-1005">clt</span><span class="sxs-lookup"><span data-stu-id="c1087-1005">clt</span></span>|<span data-ttu-id="c1087-1006">推送 1，如果`value1`是小於`value2`，否則將 0 推入。</span><span class="sxs-lookup"><span data-stu-id="c1087-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="c1087-1007">Stack 轉換行為的循序順序是：`value1`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1007">The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack.</span></span>  
  
1.  <span data-ttu-id="c1087-1008">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1008">`value2` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1009">`value2` 和`value1`會彈出從堆疊;`clt`測試`value1`是小於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1009">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
3.  <span data-ttu-id="c1087-1010">如果`value1`是小於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1010">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1011">`clt`指示比較`value1`和`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1011">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="c1087-1012">如果`value1`是小於`value2`，然後`int32`值 1 會推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1012">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="c1087-1013">否則， `int32` 0 值推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1013">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="c1087-1014">浮點數，`clt`會傳回 0，如果數字排序 （亦即，如果一或兩個引數是 NaN）。</span><span class="sxs-lookup"><span data-stu-id="c1087-1014">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="c1087-1015">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`clt`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1015">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1016">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1016">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1017">比較不帶正負號或未排序的值<paramref name="value1" />和<paramref name="value2" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1017">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span>
          </span>
          <span data-ttu-id="c1087-1018">如果<paramref name="value1" />是小於<paramref name="value2" />，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊，否則將 0 (<see langword="int32" />) 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1018">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1019">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1019">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1020">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1020">Format</span></span>|<span data-ttu-id="c1087-1021">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1021">Assembly Format</span></span>|<span data-ttu-id="c1087-1022">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1022">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1023">FE 05</span><span class="sxs-lookup"><span data-stu-id="c1087-1023">FE 05</span></span>|<span data-ttu-id="c1087-1024">clt.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1024">clt.un</span></span>|<span data-ttu-id="c1087-1025">推送 1，如果`value1`是小於`value2`，否則將 0 （不帶正負號的值） 推入。</span><span class="sxs-lookup"><span data-stu-id="c1087-1025">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="c1087-1026">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1026">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1027">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1027">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1028">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1028">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-1029">`value2` 和`value1`會彈出從堆疊;`clt.un`測試`value1`是小於`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1029">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-1030">如果`value1`是小於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1030">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1031">`clt.un`指示比較`value1`和`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1031">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="c1087-1032">`int32`值 1 會推送到堆疊上，如果下列任一項為真：</span><span class="sxs-lookup"><span data-stu-id="c1087-1032">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="c1087-1033">`value1` 是小於`value2`(與`clt`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1033">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="c1087-1034">浮點數，如`value1`相對於未經過排序`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1034">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="c1087-1035">對於整數值`value1`是小於`value2`時視為不帶正負號的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1035">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="c1087-1036">否則， `int32` 0 值推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1036">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="c1087-1037">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`clt.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1039">限制其上可進行虛擬方法呼叫的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1039">Constrains the type on which a virtual method call is made.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1040">下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1040">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1041">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1041">Format</span></span>|<span data-ttu-id="c1087-1042">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1042">Assembly Format</span></span>|<span data-ttu-id="c1087-1043">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1044">FE 16 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-1044">FE 16 < `T` ></span></span>|<span data-ttu-id="c1087-1045">限制。</span><span class="sxs-lookup"><span data-stu-id="c1087-1045">constrained.</span></span> `thisType`|<span data-ttu-id="c1087-1046">呼叫虛擬方法的型別上限制為型別`T`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1046">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="c1087-1047">`constrained`前置詞僅允許`callvirt`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1047">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="c1087-1048">MSIL 堆疊目前的狀態必須如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1087-1048">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="c1087-1049">受管理的指標， `ptr`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1049">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="c1087-1050">型別`ptr`必須是 managed 的指標 (`&`) 以`thisType`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1050">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="c1087-1051">請注意，這是從無前置詞的大小寫不同`callvirt`指令，這需要的參考`thisType`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1051">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="c1087-1052">方法引數`arg1`經由`argN`推送到堆疊上，就如同無前置詞`callvirt`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1052">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="c1087-1053">`constrained`前置詞設計成允許`callvirt`指示，設定成以統一方式獨立是否`thisType`是實值類型或參考型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1053">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="c1087-1054">當`callvirt``method`指示加`constrained` `thisType`，指示執行，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c1087-1054">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="c1087-1055">如果`thisType`是參考型別 （而不是實值型別），則`ptr`已取值，而且傳遞 'this' 指標`callvirt`的`method`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1055">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="c1087-1056">如果`thisType`是實值類型和`thisType`實作`method`然後`ptr`傳遞未修改為 'this' 指標`call``method`實作的指示，`method`由`thisType`.</span><span class="sxs-lookup"><span data-stu-id="c1087-1056">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="c1087-1057">如果`thisType`是實值類型和`thisType`不會實作`method`然後`ptr`取值、 boxed，和以 'this' 指標傳遞`callvirt``method`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1057">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="c1087-1058">最後這個情況下可能會發生時，才`method`上已定義<xref:System.Object>， <xref:System.ValueType>，或<xref:System.Enum>並沒有覆寫`thisType`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1058">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="c1087-1059">在此情況下，boxing 會導致設為原始物件的複本。</span><span class="sxs-lookup"><span data-stu-id="c1087-1059">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="c1087-1060">不過，因為沒有任何方法<xref:System.Object>， <xref:System.ValueType>，和<xref:System.Enum>修改狀態的物件，無法偵測到這項事實。</span><span class="sxs-lookup"><span data-stu-id="c1087-1060">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="c1087-1061">`constrained`前置詞支援建立泛型的程式碼的 IL 產生器。</span><span class="sxs-lookup"><span data-stu-id="c1087-1061">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="c1087-1062">通常`callvirt`指令無效，無法在實值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1062">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="c1087-1063">而是需要 IL 編譯器會有效地執行上面所述，在編譯時期，視類型而定的 'this' 的轉換`ptr`和被呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-1063">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="c1087-1064">不過，當`ptr`是在編譯時期不知道泛型型別不可能進行這項轉換，在編譯時期。</span><span class="sxs-lookup"><span data-stu-id="c1087-1064">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="c1087-1065">`constrained` Opcode 允許 IL 編譯器來進行統一的虛擬函式呼叫是否方式獨立`ptr`是實值類型或參考型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1065">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="c1087-1066">雖然它適用於案例所在`thisType`是泛型型別變數，`constrained`前置詞也適用於非泛型型別，並且可以減少產生隱藏實值型別之間的差異的語言中的虛擬呼叫的複雜性和參考型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1066">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="c1087-1067">使用`constrained`前置詞也可避免潛在的實值類型的版本控制問題。</span><span class="sxs-lookup"><span data-stu-id="c1087-1067">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="c1087-1068">如果`constrained`不使用前置詞，根據實值型別是否會覆寫 System.Object 的方法必須發出不同的 IL。</span><span class="sxs-lookup"><span data-stu-id="c1087-1068">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="c1087-1069">比方說，如果實值型別`V`object.tostring （） 方法，就會覆寫`call``V.ToString()`指令，就會發出; 如果沒有出現，請`box`指令並`callvirt``Object.ToString()`發出指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1069">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="c1087-1070">版本控制問題可能發生在先前的情況下，如果稍後移除覆寫，並在後者的情況下，如果稍後新增覆寫。</span><span class="sxs-lookup"><span data-stu-id="c1087-1070">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="c1087-1071">`constrained`前置詞可以也實值類型上的介面方法引動過程使用，因為實作介面方法的值型別方法可以使用變更`MethodImpl`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1071">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="c1087-1072">如果`constrained`不使用前置詞，編譯器會強迫選擇其中一個值在編譯時期繫結至類型的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-1072">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="c1087-1073">使用`constrained`前置詞可讓繫結至的方法，在執行階段，而不是在編譯時期，會實作介面方法的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="c1087-1073">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="c1087-1074">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`constrained`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1074">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1075">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-1075">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1076">將評估堆疊頂端值，轉換<see langword="native int" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1076">Converts the value on top of the evaluation stack to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1077">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1077">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1078">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1078">Format</span></span>|<span data-ttu-id="c1087-1079">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1079">Assembly Format</span></span>|<span data-ttu-id="c1087-1080">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1080">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1081">D3</span><span class="sxs-lookup"><span data-stu-id="c1087-1081">D3</span></span>|<span data-ttu-id="c1087-1082">conv.i</span><span class="sxs-lookup"><span data-stu-id="c1087-1082">conv.i</span></span>|<span data-ttu-id="c1087-1083">將轉換成`native int`推送、`native int`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1083">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1084">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1084">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1085">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1085">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1086">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1086">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1087">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1087">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1088">`conv.i` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1088">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1089">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1089">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1090">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1090">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1091">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1091">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1092">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1092">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1093">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1093">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1094">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1094">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1095">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1095">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1096">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1096">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1097">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1097">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1098">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1098">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1099">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1099">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1100">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1100">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1101">將評估堆疊頂端值轉換<see langword="int8" />，然後擴充 （填補） 到<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1101">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1102">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1102">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1103">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1103">Format</span></span>|<span data-ttu-id="c1087-1104">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1104">Assembly Format</span></span>|<span data-ttu-id="c1087-1105">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1105">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1106">67</span><span class="sxs-lookup"><span data-stu-id="c1087-1106">67</span></span>|<span data-ttu-id="c1087-1107">conv.i1</span><span class="sxs-lookup"><span data-stu-id="c1087-1107">conv.i1</span></span>|<span data-ttu-id="c1087-1108">將轉換成`int8`推送、`int32`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1108">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1109">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1109">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1110">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1110">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1111">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1111">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1112">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1112">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1113">`conv.i1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1113">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1114">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1114">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1115">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1115">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1116">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1116">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1117">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1117">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1118">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1118">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1119">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1119">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1120">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1120">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1121">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1121">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1122">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1122">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1123">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1123">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1124">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1124">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1125">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1125">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1126">將評估堆疊頂端值轉換<see langword="int16" />，然後擴充 （填補） 到<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1126">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1127">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1127">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1128">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1128">Format</span></span>|<span data-ttu-id="c1087-1129">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1129">Assembly Format</span></span>|<span data-ttu-id="c1087-1130">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1130">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1131">68</span><span class="sxs-lookup"><span data-stu-id="c1087-1131">68</span></span>|<span data-ttu-id="c1087-1132">conv.i2</span><span class="sxs-lookup"><span data-stu-id="c1087-1132">conv.i2</span></span>|<span data-ttu-id="c1087-1133">將轉換成`int16`推送、`int32`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1133">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1134">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1134">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1135">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1135">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1136">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1136">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1137">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1137">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1138">`conv.i2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1138">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1139">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1139">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1140">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1140">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1141">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1141">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1142">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1142">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1143">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1143">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1144">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1144">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1145">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1145">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1146">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1146">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1147">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1147">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1148">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1148">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1149">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1149">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1150">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1150">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1151">將評估堆疊頂端值，轉換<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1151">Converts the value on top of the evaluation stack to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1152">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1152">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1153">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1153">Format</span></span>|<span data-ttu-id="c1087-1154">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1154">Assembly Format</span></span>|<span data-ttu-id="c1087-1155">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1155">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1156">69</span><span class="sxs-lookup"><span data-stu-id="c1087-1156">69</span></span>|<span data-ttu-id="c1087-1157">conv.i4</span><span class="sxs-lookup"><span data-stu-id="c1087-1157">conv.i4</span></span>|<span data-ttu-id="c1087-1158">將轉換成`int32`推送、`int32`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1158">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1159">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1159">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1160">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1160">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1161">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1161">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1162">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1162">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1163">`conv.i4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1163">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1164">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1164">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1165">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1165">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1166">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1166">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1167">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1167">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1168">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1168">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1169">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1169">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1170">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1170">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1171">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1171">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1172">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1172">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1173">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1173">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1174">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1175">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1175">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1176">將評估堆疊頂端值，轉換<see langword="int64" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1176">Converts the value on top of the evaluation stack to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1177">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1178">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1178">Format</span></span>|<span data-ttu-id="c1087-1179">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1179">Assembly Format</span></span>|<span data-ttu-id="c1087-1180">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1181">6A</span><span class="sxs-lookup"><span data-stu-id="c1087-1181">6A</span></span>|<span data-ttu-id="c1087-1182">conv.i8</span><span class="sxs-lookup"><span data-stu-id="c1087-1182">conv.i8</span></span>|<span data-ttu-id="c1087-1183">將轉換成`int64`推送、`int64`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1183">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1184">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1185">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1185">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1186">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1186">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1187">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1187">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1188">`conv.i8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1188">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1189">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1189">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1190">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1190">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1191">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1191">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1192">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1192">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1193">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1193">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1194">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1194">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1195">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1195">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1196">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1196">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1197">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1197">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1198">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1198">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1199">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1201">將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="native int" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1201">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1202">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1203">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1203">Format</span></span>|<span data-ttu-id="c1087-1204">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1204">Assembly Format</span></span>|<span data-ttu-id="c1087-1205">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1206">D4</span><span class="sxs-lookup"><span data-stu-id="c1087-1206">D4</span></span>|<span data-ttu-id="c1087-1207">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="c1087-1207">conv.ovf.i</span></span>|<span data-ttu-id="c1087-1208">將轉換成`native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1208">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1209">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1210">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1210">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1211">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1211">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1212">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1212">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1213">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1213">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1214">`conv.ovf.i` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1214">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1215">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1215">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1216">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1216">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1217">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1217">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1218"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1218"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1219">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1219">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1220">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1220">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1221">將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="native int" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1221">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1222">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1222">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1223">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1223">Format</span></span>|<span data-ttu-id="c1087-1224">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1224">Assembly Format</span></span>|<span data-ttu-id="c1087-1225">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1225">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1226">8A</span><span class="sxs-lookup"><span data-stu-id="c1087-1226">8A</span></span>|<span data-ttu-id="c1087-1227">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1227">conv.ovf.i.un</span></span>|<span data-ttu-id="c1087-1228">將不帶正負號的值轉換`native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1228">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1229">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1229">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1230">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1230">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1231">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1231">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1232">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1232">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1233">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1233">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1234">`conv.ovf.i.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1234">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1235">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1235">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1236">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1236">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1237">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1237">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1238"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1238"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1239">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1240">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1240">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1241">將評估堆疊頂端帶正負號的值轉換成帶正負號 <see langword="int8" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1241">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1242">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1242">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1243">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1243">Format</span></span>|<span data-ttu-id="c1087-1244">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1244">Assembly Format</span></span>|<span data-ttu-id="c1087-1245">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1245">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1246">B3</span><span class="sxs-lookup"><span data-stu-id="c1087-1246">B3</span></span>|<span data-ttu-id="c1087-1247">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="c1087-1247">conv.ovf.i1</span></span>|<span data-ttu-id="c1087-1248">將轉換成`int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1248">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1249">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1249">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1250">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1250">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1251">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1251">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1252">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1252">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1253">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1253">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1254">`conv.ovf.i1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1254">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1255">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1255">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1256">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1256">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1257">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1257">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1258"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1258"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1259">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1260">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1260">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1261">將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int8" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1261">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1262">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1263">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1263">Format</span></span>|<span data-ttu-id="c1087-1264">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1264">Assembly Format</span></span>|<span data-ttu-id="c1087-1265">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1266">82</span><span class="sxs-lookup"><span data-stu-id="c1087-1266">82</span></span>|<span data-ttu-id="c1087-1267">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1267">conv.ovf.i1.un</span></span>|<span data-ttu-id="c1087-1268">將不帶正負號的值轉換`int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1268">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1269">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1269">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1270">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1270">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1271">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1271">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1272">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1272">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1273">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1273">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1274">`conv.ovf.i1.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1274">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1275">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1275">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1276">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1276">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1277">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1277">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1278"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1278"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1279">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i1.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1281">將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1281">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1282">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1283">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1283">Format</span></span>|<span data-ttu-id="c1087-1284">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1284">Assembly Format</span></span>|<span data-ttu-id="c1087-1285">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1286">B5</span><span class="sxs-lookup"><span data-stu-id="c1087-1286">B5</span></span>|<span data-ttu-id="c1087-1287">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="c1087-1287">conv.ovf.i2</span></span>|<span data-ttu-id="c1087-1288">將轉換成`int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1288">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1289">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1290">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1290">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1291">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1291">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1292">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1292">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1293">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1293">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1294">`conv.ovf.i2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1294">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1295">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1295">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1296">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1296">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1297">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1297">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1298"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1298"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1299">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1299">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1300">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1300">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1301">將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1301">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1302">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1302">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1303">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1303">Format</span></span>|<span data-ttu-id="c1087-1304">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1304">Assembly Format</span></span>|<span data-ttu-id="c1087-1305">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1305">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1306">83</span><span class="sxs-lookup"><span data-stu-id="c1087-1306">83</span></span>|<span data-ttu-id="c1087-1307">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1307">conv.ovf.i2.un</span></span>|<span data-ttu-id="c1087-1308">將不帶正負號的值轉換`int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1308">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1309">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1309">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1310">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1310">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1311">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1311">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1312">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1312">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1313">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1313">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1314">`conv.ovf.i2.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1314">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1315">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1315">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1316">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1316">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1317">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1317">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1318"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1318"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1319">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i2.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1319">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1320">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1320">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1321">將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1321">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1322">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1322">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1323">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1323">Format</span></span>|<span data-ttu-id="c1087-1324">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1324">Assembly Format</span></span>|<span data-ttu-id="c1087-1325">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1325">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1326">B7</span><span class="sxs-lookup"><span data-stu-id="c1087-1326">B7</span></span>|<span data-ttu-id="c1087-1327">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="c1087-1327">conv.ovf.i4</span></span>|<span data-ttu-id="c1087-1328">將轉換成`int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1328">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1329">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1329">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1330">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1330">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1331">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1331">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1332">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1332">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1333">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1333">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1334">`conv.ovf.i4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1334">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1335">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1335">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1336">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1336">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1337">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1337">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1338"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1338"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1339">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1339">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1340">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1340">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1341">將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1341">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1342">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1342">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1343">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1343">Format</span></span>|<span data-ttu-id="c1087-1344">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1344">Assembly Format</span></span>|<span data-ttu-id="c1087-1345">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1345">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1346">84</span><span class="sxs-lookup"><span data-stu-id="c1087-1346">84</span></span>|<span data-ttu-id="c1087-1347">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1347">conv.ovf.i4.un</span></span>|<span data-ttu-id="c1087-1348">將不帶正負號的值轉換`int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1348">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1349">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1349">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1350">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1350">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1351">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1351">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1352">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1352">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1353">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1353">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1354">`conv.ovf.i4.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1354">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1355">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1355">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1356">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1356">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1357">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1357">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1358"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1358"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1359">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i4.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1360">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1360">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1361">將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="int64" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1361">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1362">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1363">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1363">Format</span></span>|<span data-ttu-id="c1087-1364">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1364">Assembly Format</span></span>|<span data-ttu-id="c1087-1365">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1366">B9</span><span class="sxs-lookup"><span data-stu-id="c1087-1366">B9</span></span>|<span data-ttu-id="c1087-1367">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="c1087-1367">conv.ovf.i8</span></span>|<span data-ttu-id="c1087-1368">將轉換成`int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1368">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1369">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1370">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1370">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1371">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1371">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1372">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1372">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1373">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1373">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1374">`conv.ovf.i8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1374">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1375">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1375">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1376">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1376">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1377">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1377">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1378"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1378"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1379">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1379">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1380">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1380">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1381">將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int64" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1381">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1382">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1382">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1383">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1383">Format</span></span>|<span data-ttu-id="c1087-1384">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1384">Assembly Format</span></span>|<span data-ttu-id="c1087-1385">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1385">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1386">85</span><span class="sxs-lookup"><span data-stu-id="c1087-1386">85</span></span>|<span data-ttu-id="c1087-1387">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1387">conv.ovf.i8.un</span></span>|<span data-ttu-id="c1087-1388">將不帶正負號的值轉換`int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1388">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1389">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1389">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1390">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1390">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1391">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1391">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1392">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1392">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1393">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1393">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1394">`conv.ovf.i8.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1394">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1395">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1395">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1396">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1396">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1397">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1397">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1398"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1398"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1399">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i8.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1399">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1400">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1400">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1401">將評估堆疊頂端帶正負號的值轉換<see langword="unsigned native int" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1401">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1402">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1402">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1403">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1403">Format</span></span>|<span data-ttu-id="c1087-1404">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1404">Assembly Format</span></span>|<span data-ttu-id="c1087-1405">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1405">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1406">D5</span><span class="sxs-lookup"><span data-stu-id="c1087-1406">D5</span></span>|<span data-ttu-id="c1087-1407">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="c1087-1407">conv.ovf.u</span></span>|<span data-ttu-id="c1087-1408">將轉換成`unsigned native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1408">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1409">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1409">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1410">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1410">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1411">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1411">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1412">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1412">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1413">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1413">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1414">`conv.ovf.u` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1414">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1415">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1415">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1416">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1416">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1417">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1417">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1418"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1418"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1419">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1419">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1420">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1420">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1421">將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned native int" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1421">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1422">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1422">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1423">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1423">Format</span></span>|<span data-ttu-id="c1087-1424">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1424">Assembly Format</span></span>|<span data-ttu-id="c1087-1425">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1425">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1426">8B</span><span class="sxs-lookup"><span data-stu-id="c1087-1426">8B</span></span>|<span data-ttu-id="c1087-1427">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1427">conv.ovf.u.un</span></span>|<span data-ttu-id="c1087-1428">將取消不帶正負號值`unsigned native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1428">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1429">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1429">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1430">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1430">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1431">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1431">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1432">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1432">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1433">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1433">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1434">`conv.ovf.u.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1434">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1435">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1435">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1436">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1436">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1437">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1437">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1438"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1438"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1439">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.uvf.u.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1439">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1440">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1440">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1441">將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int8" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1441">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1442">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1442">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1443">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1443">Format</span></span>|<span data-ttu-id="c1087-1444">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1444">Assembly Format</span></span>|<span data-ttu-id="c1087-1445">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1445">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1446">B4</span><span class="sxs-lookup"><span data-stu-id="c1087-1446">B4</span></span>|<span data-ttu-id="c1087-1447">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="c1087-1447">conv.ovf.u1</span></span>|<span data-ttu-id="c1087-1448">將轉換成`unsigned int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1448">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1449">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1449">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1450">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1450">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1451">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1451">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1452">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1452">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1453">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1453">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1454">`conv.ovf.u1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1454">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1455">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1455">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1456">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1456">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1457">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1457">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1458"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1458"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1459">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1460">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1461">將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int8" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1461">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1462">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1463">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1463">Format</span></span>|<span data-ttu-id="c1087-1464">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1464">Assembly Format</span></span>|<span data-ttu-id="c1087-1465">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1466">86</span><span class="sxs-lookup"><span data-stu-id="c1087-1466">86</span></span>|<span data-ttu-id="c1087-1467">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1467">conv.ovf.u1.un</span></span>|<span data-ttu-id="c1087-1468">將不帶正負號的值轉換`unsigned int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1468">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1469">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1470">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1470">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1471">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1471">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1472">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1472">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1473">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1473">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1474">`conv.ovf.u1.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1474">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1475">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1475">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1476">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1476">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1477">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1477">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1478"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1478"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1479">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u1.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1479">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1480">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1480">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1481">將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1481">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1482">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1482">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1483">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1483">Format</span></span>|<span data-ttu-id="c1087-1484">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1484">Assembly Format</span></span>|<span data-ttu-id="c1087-1485">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1485">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1486">B6</span><span class="sxs-lookup"><span data-stu-id="c1087-1486">B6</span></span>|<span data-ttu-id="c1087-1487">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="c1087-1487">conv.ovf.u2</span></span>|<span data-ttu-id="c1087-1488">將轉換成`unsigned int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1488">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1489">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1489">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1490">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1490">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1491">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1491">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1492">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1492">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1493">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1493">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1494">`conv.ovf.u2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1494">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1495">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1495">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1496">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1496">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1497">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1497">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1498"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1498"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1499">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1500">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1500">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1501">將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1501">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1502">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1503">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1503">Format</span></span>|<span data-ttu-id="c1087-1504">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1504">Assembly Format</span></span>|<span data-ttu-id="c1087-1505">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1506">87</span><span class="sxs-lookup"><span data-stu-id="c1087-1506">87</span></span>|<span data-ttu-id="c1087-1507">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1507">conv.ovf.u2.un</span></span>|<span data-ttu-id="c1087-1508">將不帶正負號的值轉換`unsigned int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1508">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1509">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1510">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1510">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1511">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1511">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1512">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1512">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1513">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1513">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1514">`conv.ovf.u2.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1514">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1515">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1515">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1516">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1516">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1517">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1517">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1518"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1518"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1519">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u2.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1519">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1520">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1520">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1521">將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1521">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1522">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1522">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1523">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1523">Format</span></span>|<span data-ttu-id="c1087-1524">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1524">Assembly Format</span></span>|<span data-ttu-id="c1087-1525">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1525">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1526">B8</span><span class="sxs-lookup"><span data-stu-id="c1087-1526">B8</span></span>|<span data-ttu-id="c1087-1527">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="c1087-1527">conv.ovf.u4</span></span>|<span data-ttu-id="c1087-1528">將轉換成`unsigned int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1528">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1529">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1529">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1530">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1530">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1531">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1531">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1532">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1532">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1533">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1533">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1534">`conv.ovf.u4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1534">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1535">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1535">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1536">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1536">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1537">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1537">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1538"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1538"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1539">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1539">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1540">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1540">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1541">將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int32" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1541">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1542">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1542">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1543">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1543">Format</span></span>|<span data-ttu-id="c1087-1544">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1544">Assembly Format</span></span>|<span data-ttu-id="c1087-1545">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1545">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1546">88</span><span class="sxs-lookup"><span data-stu-id="c1087-1546">88</span></span>|<span data-ttu-id="c1087-1547">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1547">conv.ovf.u4.un</span></span>|<span data-ttu-id="c1087-1548">將不帶正負號的值轉換`unsigned int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1548">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1549">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1549">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1550">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1550">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1551">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1551">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1552">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1552">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1553">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1553">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1554">`conv.ovf.u4.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1554">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1555">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1555">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1556">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1556">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1557">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1557">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1558"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1558"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1559">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u4.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1559">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1560">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1560">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1561">將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int64" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1561">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1562">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1562">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1563">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1563">Format</span></span>|<span data-ttu-id="c1087-1564">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1564">Assembly Format</span></span>|<span data-ttu-id="c1087-1565">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1565">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1566">BA</span><span class="sxs-lookup"><span data-stu-id="c1087-1566">BA</span></span>|<span data-ttu-id="c1087-1567">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="c1087-1567">conv.ovf.u8</span></span>|<span data-ttu-id="c1087-1568">將轉換成`unsigned int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1568">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1569">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1569">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1570">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1570">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1571">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1571">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1572">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1572">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1573">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1573">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1574">`conv.ovf.u8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1574">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1575">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1575">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1576">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1576">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1577">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1577">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1578"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1578"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1579">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1579">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1580">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1580">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1581">將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int64" />擲回、<see cref="T:System.OverflowException" />溢位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1581">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1582">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1582">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1583">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1583">Format</span></span>|<span data-ttu-id="c1087-1584">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1584">Assembly Format</span></span>|<span data-ttu-id="c1087-1585">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1585">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1586">89</span><span class="sxs-lookup"><span data-stu-id="c1087-1586">89</span></span>|<span data-ttu-id="c1087-1587">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1587">conv.ovf.u8.un</span></span>|<span data-ttu-id="c1087-1588">將不帶正負號的值轉換`unsigned int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1588">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="c1087-1589">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1589">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1590">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1590">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1591">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1591">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="c1087-1592">如果發生溢位，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1592">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="c1087-1593">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1593">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1594">`conv.ovf.u8.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1594">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1595">如果值太大或太小，表示目標類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1595">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c1087-1596">浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1596">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="c1087-1597">請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1597">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="c1087-1598"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1598"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-1599">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u8.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1599">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1600">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1600">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1601">將評估堆疊頂端不帶正負號的整數值轉換<see langword="float32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1601">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1602">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1602">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1603">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1603">Format</span></span>|<span data-ttu-id="c1087-1604">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1604">Assembly Format</span></span>|<span data-ttu-id="c1087-1605">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1605">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1606">76</span><span class="sxs-lookup"><span data-stu-id="c1087-1606">76</span></span>|<span data-ttu-id="c1087-1607">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1607">conv.r.un</span></span>|<span data-ttu-id="c1087-1608">Convert 不帶正負號的整數到浮點數，推送`F`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1608">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1609">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1609">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1610">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1610">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1611">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1611">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1612">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1612">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1613">`conv.r.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1613">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1614">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1614">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1615">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1615">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1616">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1616">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1617">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1617">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1618">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1618">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1619">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1619">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1620">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1620">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1621">如果發生溢位浮點類型轉換成整數`result`傳回未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1621">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="c1087-1622">`conv.r.un`作業會接受整數堆疊、 將它解譯為不帶正負號，並取代浮點數，表示整數： 任一`float32`，如果這是寬度不足以代表整數而不會遺失有效位數，或其他`float64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1622">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="c1087-1623">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1623">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="c1087-1624">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.r.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1626">將評估堆疊頂端值，轉換<see langword="float32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1626">Converts the value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1627">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1628">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1628">Format</span></span>|<span data-ttu-id="c1087-1629">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1629">Assembly Format</span></span>|<span data-ttu-id="c1087-1630">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1631">6B</span><span class="sxs-lookup"><span data-stu-id="c1087-1631">6B</span></span>|<span data-ttu-id="c1087-1632">conv.r4</span><span class="sxs-lookup"><span data-stu-id="c1087-1632">conv.r4</span></span>|<span data-ttu-id="c1087-1633">將轉換成`float32`推送、`F`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1633">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1634">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1635">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1635">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1636">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1636">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1637">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1637">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1638">`conv.r4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1638">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1639">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1639">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1640">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1640">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1641">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1641">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1642">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1642">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1643">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1643">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1644">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1644">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1645">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1645">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1646">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1646">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1647">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1647">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="c1087-1648">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.r4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1648">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1649">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1649">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1650">將評估堆疊頂端值，轉換<see langword="float64" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1650">Converts the value on top of the evaluation stack to <see langword="float64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1651">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1651">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1652">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1652">Format</span></span>|<span data-ttu-id="c1087-1653">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1653">Assembly Format</span></span>|<span data-ttu-id="c1087-1654">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1654">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1655">6C</span><span class="sxs-lookup"><span data-stu-id="c1087-1655">6C</span></span>|<span data-ttu-id="c1087-1656">conv.r8</span><span class="sxs-lookup"><span data-stu-id="c1087-1656">conv.r8</span></span>|<span data-ttu-id="c1087-1657">將轉換成`float64`推送、`F`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1657">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1658">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1658">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1659">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1659">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1660">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1660">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1661">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1661">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1662">`conv.r8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1662">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1663">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1663">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1664">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1664">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1665">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1665">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1666">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1666">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1667">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1667">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1668">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1668">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1669">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1669">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1670">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1670">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1671">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1671">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="c1087-1672">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.r8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1672">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1673">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1673">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1674">將評估堆疊頂端值轉換<see langword="unsigned native int" />，並將它擴充到<see langword="native int" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1674">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1675">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1675">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1676">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1676">Format</span></span>|<span data-ttu-id="c1087-1677">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1677">Assembly Format</span></span>|<span data-ttu-id="c1087-1678">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1678">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1679">E0</span><span class="sxs-lookup"><span data-stu-id="c1087-1679">E0</span></span>|<span data-ttu-id="c1087-1680">conv.u</span><span class="sxs-lookup"><span data-stu-id="c1087-1680">conv.u</span></span>|<span data-ttu-id="c1087-1681">將轉換成`unsigned native int`推送、`native int`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1681">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1682">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1682">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1683">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1683">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1684">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1684">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1685">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1685">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1686">`conv.u` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1686">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1687">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1687">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1688">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1688">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1689">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1689">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1690">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1690">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1691">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1691">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1692">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1692">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1693">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1693">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1694">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1694">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1695">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1695">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1696">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1696">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1697">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1699">將評估堆疊頂端值轉換<see langword="unsigned int8" />，並將它擴充到<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1699">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1700">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1701">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1701">Format</span></span>|<span data-ttu-id="c1087-1702">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1702">Assembly Format</span></span>|<span data-ttu-id="c1087-1703">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1704">D2</span><span class="sxs-lookup"><span data-stu-id="c1087-1704">D2</span></span>|<span data-ttu-id="c1087-1705">conv.u1</span><span class="sxs-lookup"><span data-stu-id="c1087-1705">conv.u1</span></span>|<span data-ttu-id="c1087-1706">將轉換成`int8`推送、`int32`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1706">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1707">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1708">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1708">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1709">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1709">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1710">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1710">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1711">`conv.u1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1711">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1712">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1712">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1713">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1713">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1714">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1714">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1715">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1715">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1716">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1716">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1717">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1717">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1718">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1718">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1719">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1719">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1720">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1720">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1721">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1721">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1722">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1723">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1723">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1724">將評估堆疊頂端值轉換<see langword="unsigned int16" />，並將它擴充到<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1724">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1725">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1726">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1726">Format</span></span>|<span data-ttu-id="c1087-1727">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1727">Assembly Format</span></span>|<span data-ttu-id="c1087-1728">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1729">D1</span><span class="sxs-lookup"><span data-stu-id="c1087-1729">D1</span></span>|<span data-ttu-id="c1087-1730">conv.u2</span><span class="sxs-lookup"><span data-stu-id="c1087-1730">conv.u2</span></span>|<span data-ttu-id="c1087-1731">將轉換成`int16`推送、`int32`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1731">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1732">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1733">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1733">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1734">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1734">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1735">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1735">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1736">`conv.u2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1736">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1737">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1737">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1738">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1738">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1739">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1739">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1740">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1740">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1741">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1741">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1742">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1742">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1743">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1743">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1744">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1744">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1745">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1745">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1746">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1746">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1747">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1747">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1748">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1748">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1749">將評估堆疊頂端值轉換<see langword="unsigned int32" />，並將它擴充到<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1749">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1750">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1750">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1751">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1751">Format</span></span>|<span data-ttu-id="c1087-1752">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1752">Assembly Format</span></span>|<span data-ttu-id="c1087-1753">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1753">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1754">6D</span><span class="sxs-lookup"><span data-stu-id="c1087-1754">6D</span></span>|<span data-ttu-id="c1087-1755">conv.u4</span><span class="sxs-lookup"><span data-stu-id="c1087-1755">conv.u4</span></span>|<span data-ttu-id="c1087-1756">將轉換成`unsigned int32`推送、`int32`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1756">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1757">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1757">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1758">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1758">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1759">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1759">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1760">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1760">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1761">`conv.u4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1761">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1762">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1762">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1763">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1763">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1764">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1764">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1765">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1765">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1766">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1766">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1767">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1767">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1768">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1768">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1769">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1769">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1770">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1770">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1771">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1771">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1772">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1772">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1773">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1773">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1774">將評估堆疊頂端值轉換<see langword="unsigned int64" />，並將它擴充到<see langword="int64" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1774">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1775">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1775">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1776">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1776">Format</span></span>|<span data-ttu-id="c1087-1777">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1777">Assembly Format</span></span>|<span data-ttu-id="c1087-1778">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1778">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1779">6E</span><span class="sxs-lookup"><span data-stu-id="c1087-1779">6E</span></span>|<span data-ttu-id="c1087-1780">conv.u8</span><span class="sxs-lookup"><span data-stu-id="c1087-1780">conv.u8</span></span>|<span data-ttu-id="c1087-1781">將轉換成`int64`推送、`int64`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1781">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="c1087-1782">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1782">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1783">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1783">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1784">`value` 時會推出堆疊，並轉換從嘗試作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-1784">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="c1087-1785">如果轉換成功，則會將產生的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1785">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1786">`conv.u8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-1786">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="c1087-1787">少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1787">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="c1087-1788">浮點數的值會轉換成`F`型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1788">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="c1087-1789">從浮點數轉換成整數值會截斷趨近於零的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-1789">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="c1087-1790">從轉換時`float64`至`float32`，有效位數可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="c1087-1790">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="c1087-1791">如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1791">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="c1087-1792">如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-1792">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="c1087-1793">如果結果為小於`int32`，值是 sign-extended 以填滿的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-1793">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="c1087-1794">如果發生溢位而將浮點類型轉換成整數傳回的值未指定。</span><span class="sxs-lookup"><span data-stu-id="c1087-1794">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="c1087-1795">使用此欄位時，以往會擲不回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-1795">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="c1087-1796">請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1796">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="c1087-1797">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1797">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1798">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1798">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1799">將指定的數值位元組數從來源位址複製到目的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1799">Copies a specified number bytes from a source address to a destination address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1800">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1800">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1801">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1801">Format</span></span>|<span data-ttu-id="c1087-1802">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1802">Assembly Format</span></span>|<span data-ttu-id="c1087-1803">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1803">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1804">FE 17</span><span class="sxs-lookup"><span data-stu-id="c1087-1804">FE 17</span></span>|<span data-ttu-id="c1087-1805">cpblk</span><span class="sxs-lookup"><span data-stu-id="c1087-1805">cpblk</span></span>|<span data-ttu-id="c1087-1806">將資料從一個記憶體區塊複製到另一個。</span><span class="sxs-lookup"><span data-stu-id="c1087-1806">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="c1087-1807">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1807">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1808">目的地位址被推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1808">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1809">來源地址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1809">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-1810">要複製的位元組數目會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1810">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-1811">從堆疊; 所推出的位元組、 來源位址和目的地位址數目指定的位元組數目會從來源位址複製，其目的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-1811">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="c1087-1812">`cpblk`指令會將複製的數字 (型別`unsigned int32`) 的位元組從來源位址 (型別的`*`， `native int`，或`&`) 到目的地位址 (型別的`*`， `native int`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1812">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="c1087-1813">行為`cpblk`是未指定，如果來源和目的地區域重疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1813">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="c1087-1814">`cpblk` 假設來源和目的位址對齊自然機器的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-1814">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="c1087-1815">`cpblk`指令可以前面緊接`unaligned.<prefix>`表示未對齊的來源或目的地的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1815">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="c1087-1816">營運`cpblk`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1816">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-1817"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-1817"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-1818">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cpblk`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1819">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1820">實值型別位於物件位址的複本 (型別<see langword="&amp;" />，<see langword="*" />或是<see langword="native int" />) 到目的地物件的位址 (型別<see langword="&amp;" />，<see langword="*" />或<see langword="native int" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1820">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1821">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1822">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1822">Format</span></span>|<span data-ttu-id="c1087-1823">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1823">Assembly Format</span></span>|<span data-ttu-id="c1087-1824">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1825">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-1825">70 < `T` ></span></span>|<span data-ttu-id="c1087-1826">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="c1087-1826">cpobj `classTok`</span></span>|<span data-ttu-id="c1087-1827">目的地物件，從來源物件類型值的複本。</span><span class="sxs-lookup"><span data-stu-id="c1087-1827">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="c1087-1828">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1829">目的地物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1829">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1830">來源物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1830">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-1831">從堆疊; 所推出的兩個物件參考實值型別在位址的來源物件會複製到目的地物件的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-1831">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="c1087-1832">行為`cpobj`未指定的來源和目的端物件的參考不是類別的語彙基元所代表的類別的執行個體的指標是否`classTok`(`typeref`或是`typedef`)，或如果`classTok`不代表實值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1832">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="c1087-1833"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-1833"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-1834">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cpobj`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1834">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1835">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-1835">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1836">將兩個值相除，並將結果做為浮點 (型別<see langword="F" />) 或商數 (類型<see langword="int32" />) 至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1836">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1837">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1837">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1838">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1838">Format</span></span>|<span data-ttu-id="c1087-1839">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1839">Assembly Format</span></span>|<span data-ttu-id="c1087-1840">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1840">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1841">5B</span><span class="sxs-lookup"><span data-stu-id="c1087-1841">5B</span></span>|<span data-ttu-id="c1087-1842">div</span><span class="sxs-lookup"><span data-stu-id="c1087-1842">div</span></span>|<span data-ttu-id="c1087-1843">兩個值相除並傳回商數或浮點結果。</span><span class="sxs-lookup"><span data-stu-id="c1087-1843">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="c1087-1844">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1844">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1845">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1845">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1846">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1846">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-1847">`value2` 和`value1`會彈出從堆疊;`value1`除以`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1847">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-1848">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1848">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1849">`result` = `value1` div value2 滿足以下條件：</span><span class="sxs-lookup"><span data-stu-id="c1087-1849">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="c1087-1850">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;，和：</span><span class="sxs-lookup"><span data-stu-id="c1087-1850">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="c1087-1851">正負號 (`result`) = +，如果登入 (`value1`) = 號 (`value2`)，或-，如果登 (`value1`) ~ = 登 (`value2`)</span><span class="sxs-lookup"><span data-stu-id="c1087-1851">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="c1087-1852">`div`指令會計算結果，並將它推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1852">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="c1087-1853">整數除法運算會截斷推向零。</span><span class="sxs-lookup"><span data-stu-id="c1087-1853">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="c1087-1854">有限數字為零的除法中，會產生正確簽署的無限值。</span><span class="sxs-lookup"><span data-stu-id="c1087-1854">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="c1087-1855">除以零的零或無限大的無限值，便會產生 NaN （Not A-數字） 值。</span><span class="sxs-lookup"><span data-stu-id="c1087-1855">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="c1087-1856">任何數字除以無限大，會產生零值。</span><span class="sxs-lookup"><span data-stu-id="c1087-1856">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="c1087-1857">整數類資料的作業會擲回<xref:System.ArithmeticException>如果結果無法表示的結果型別中。</span><span class="sxs-lookup"><span data-stu-id="c1087-1857">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="c1087-1858">如果此情形`value1`的最大負數的值，和`value2`為-1。</span><span class="sxs-lookup"><span data-stu-id="c1087-1858">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="c1087-1859">整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。</span><span class="sxs-lookup"><span data-stu-id="c1087-1859">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="c1087-1860">請注意，在 Intel 平台上<xref:System.OverflowException>計算 (minint div-1) 時，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1860">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="c1087-1861">浮點運算絕不會擲回例外狀況 （會產生 Nan 或無限大改為）。</span><span class="sxs-lookup"><span data-stu-id="c1087-1861">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="c1087-1862">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`div`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1862">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1863">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1863">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1864">將兩個不帶正負號的整數值相除，並將結果 (<see langword="int32" />) 至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1864">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1865">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1865">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1866">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1866">Format</span></span>|<span data-ttu-id="c1087-1867">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1867">Assembly Format</span></span>|<span data-ttu-id="c1087-1868">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1868">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1869">5C</span><span class="sxs-lookup"><span data-stu-id="c1087-1869">5C</span></span>|<span data-ttu-id="c1087-1870">div.un</span><span class="sxs-lookup"><span data-stu-id="c1087-1870">div.un</span></span>|<span data-ttu-id="c1087-1871">兩個值相除，不帶正負號，並傳回商數。</span><span class="sxs-lookup"><span data-stu-id="c1087-1871">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="c1087-1872">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1872">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1873">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1873">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1874">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1874">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-1875">`value2` 和`value1`會彈出從堆疊;`value1`除以`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1875">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-1876">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1876">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1877">`div.un`指示計算`value1`除以`value2`，同時將其視為不帶正負號的整數和推播`result`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1877">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="c1087-1878">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`div.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1878">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1879">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1879">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1880">複製評估堆疊上目前最頂端的值，然後將複製推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1880">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1881">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1881">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1882">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1882">Format</span></span>|<span data-ttu-id="c1087-1883">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1883">Assembly Format</span></span>|<span data-ttu-id="c1087-1884">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1884">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1885">25</span><span class="sxs-lookup"><span data-stu-id="c1087-1885">25</span></span>|<span data-ttu-id="c1087-1886">dup</span><span class="sxs-lookup"><span data-stu-id="c1087-1886">dup</span></span>|<span data-ttu-id="c1087-1887">重複的堆疊頂端的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-1887">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="c1087-1888">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1888">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1889">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1889">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1890">`value` 是從重複資料刪除的堆疊取出。</span><span class="sxs-lookup"><span data-stu-id="c1087-1890">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="c1087-1891">`value` 是回推至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1891">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-1892">重複的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1892">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1893">`dup`指令重複項目堆疊中的最上層的項目，並將留在它之上的兩個相同的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-1893">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="c1087-1894">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`dup`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1895">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1895">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1896">將控制權從<see langword="filter" />子句傳回 Common Language Infrastructure (CLI) 例外狀況處理常式的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1896">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1897">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1897">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1898">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1898">Format</span></span>|<span data-ttu-id="c1087-1899">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1899">Assembly Format</span></span>|<span data-ttu-id="c1087-1900">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1900">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1901">FE 11</span><span class="sxs-lookup"><span data-stu-id="c1087-1901">FE 11</span></span>|<span data-ttu-id="c1087-1902">endfilter</span><span class="sxs-lookup"><span data-stu-id="c1087-1902">endfilter</span></span>|<span data-ttu-id="c1087-1903">結束 SEH 例外狀況處理的篩選子句。</span><span class="sxs-lookup"><span data-stu-id="c1087-1903">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="c1087-1904">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1904">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1905">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1905">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1906">`value` 會從堆疊; 推出`endfilter`執行時，控制權會轉移到例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-1906">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="c1087-1907">`Value` (這必須是型別`int32`的一組特定值的其中一個) 會傳回篩選子句。</span><span class="sxs-lookup"><span data-stu-id="c1087-1907">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="c1087-1908">它應該是其中之一：</span><span class="sxs-lookup"><span data-stu-id="c1087-1908">It should be one of:</span></span>  
  
-   <span data-ttu-id="c1087-1909">`exception_continue_search` (`value` = 0) 繼續搜尋例外狀況處理常式</span><span class="sxs-lookup"><span data-stu-id="c1087-1909">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="c1087-1910">`exception_execute_handler` (`value` = 1) 啟動第二個階段，就是最後區塊會執行直到與這個篩選條件子句的處理常式相關聯的例外狀況處理的所在。</span><span class="sxs-lookup"><span data-stu-id="c1087-1910">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="c1087-1911">發現時，會執行處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-1911">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="c1087-1912">其他的整數值會產生未指定的結果。</span><span class="sxs-lookup"><span data-stu-id="c1087-1912">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="c1087-1913">使用的篩選器的進入點方法的例外狀況資料表中所示必須是在篩選條件的程式碼區塊的第一個指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1913">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="c1087-1914">`endfilter`指令必須是最後一個指令，篩選條件的程式碼區塊中 (因此只能有一個`endfilter`針對單一篩選條件的所有區塊)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1914">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="c1087-1915">在執行後`endfilter`指令，控制以邏輯方式流動回到 CLI 例外狀況處理機制。</span><span class="sxs-lookup"><span data-stu-id="c1087-1915">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="c1087-1916">控制項無法傳輸到篩選區塊以外，透過例外狀況機制。</span><span class="sxs-lookup"><span data-stu-id="c1087-1916">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="c1087-1917">控制項無法傳出使用篩選區塊以外`throw`指示或藉由執行最終`endfilter`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1917">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="c1087-1918">您無法內嵌`try`區塊`filter`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1918">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="c1087-1919">如果在擲回例外狀況`filter`區塊中，遭到攔截和值為 0 (`exception_continue_search`) 會傳回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1919">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="c1087-1920">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`endfilter`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1920">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1921">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1921">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1922">將控制權從<see langword="fault" />或<see langword="finally" />回到 Common Language Infrastructure (CLI) 例外狀況處理常式的例外狀況區塊的子句。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1922">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1923">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1923">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1924">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1924">Format</span></span>|<span data-ttu-id="c1087-1925">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1925">Assembly Format</span></span>|<span data-ttu-id="c1087-1926">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1926">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1927">DC</span><span class="sxs-lookup"><span data-stu-id="c1087-1927">DC</span></span>|<span data-ttu-id="c1087-1928">endfinally</span><span class="sxs-lookup"><span data-stu-id="c1087-1928">endfinally</span></span><br /><br /> <span data-ttu-id="c1087-1929">endfault</span><span class="sxs-lookup"><span data-stu-id="c1087-1929">endfault</span></span>|<span data-ttu-id="c1087-1930">結束`finally`或`fault`例外狀況區塊的子句。</span><span class="sxs-lookup"><span data-stu-id="c1087-1930">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="c1087-1931">這個指示的轉換行為有任何堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1931">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-1932">`Endfinally` 並`endfault`表示結束`finally`或`fault`子句，該堆疊回溯可以繼續，直到例外狀況處理常式會叫用。</span><span class="sxs-lookup"><span data-stu-id="c1087-1932">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="c1087-1933">`endfinally`或`endfault`指令會將控制權傳輸至 CLI 例外狀況機制。</span><span class="sxs-lookup"><span data-stu-id="c1087-1933">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="c1087-1934">[機制] 和 [下一步] 會搜尋`finally`如果受保護的區塊已結束與 leave 鏈結中的子句。</span><span class="sxs-lookup"><span data-stu-id="c1087-1934">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="c1087-1935">如果受保護的區塊已結束並發生例外狀況，CLI 會搜尋在接下來`finally`或`fault`，或輸入例外狀況處理的第一個階段期間所選擇的例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-1935">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="c1087-1936">`endfinally`指示可能只會顯示語彙內`finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1936">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="c1087-1937">不同於`endfilter`的指示，在區塊結尾不需要`endfinally`的指示，而且可以有多個`endfinally`所需區塊中的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-1937">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="c1087-1938">這些相同的限制適用於`endfault`指令和`fault`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1938">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="c1087-1939">控制項無法傳輸到`finally`(或`fault`) 除了封鎖透過例外狀況機制。</span><span class="sxs-lookup"><span data-stu-id="c1087-1939">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="c1087-1940">控制項無法轉移共`finally`(或`fault`) 除了封鎖使用`throw`指示或執行`endfinally`(或`endfault`) 指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1940">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="c1087-1941">特別的是，您無法 「 切換 」 的`finally`(或`fault`) 區塊，或執行<xref:System.Reflection.Emit.OpCodes.Ret>或是<xref:System.Reflection.Emit.OpCodes.Leave>內的指令`finally`(或`fault`) 區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1941">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="c1087-1942">請注意，`endfault`和`endfinally`指示別名-它們對應至相同的 opcode。</span><span class="sxs-lookup"><span data-stu-id="c1087-1942">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="c1087-1943">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可用`endfinally`(`endfault`) 作業碼，以及`ILGenerator`方法<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>。</span><span class="sxs-lookup"><span data-stu-id="c1087-1943">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="c1087-1944">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1944">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="c1087-1945">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="c1087-1945">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1946">將指定位址上的指定記憶體區塊初始化為指定的大小和初始值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1946">Initializes a specified block of memory at a specific address to a given size and initial value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1947">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1947">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1948">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1948">Format</span></span>|<span data-ttu-id="c1087-1949">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1949">Assembly Format</span></span>|<span data-ttu-id="c1087-1950">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1950">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1951">FE 18</span><span class="sxs-lookup"><span data-stu-id="c1087-1951">FE 18</span></span>|<span data-ttu-id="c1087-1952">initblk</span><span class="sxs-lookup"><span data-stu-id="c1087-1952">initblk</span></span>|<span data-ttu-id="c1087-1953">設定每個位置中的指定值的記憶體區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1953">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="c1087-1954">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1954">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1955">起始位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1955">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1956">初始化值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1956">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-1957">要初始化的位元組數目會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1957">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-1958">位元組，初始化值的起始位址的數目會從堆疊彈出，並根據其值會執行初始化。</span><span class="sxs-lookup"><span data-stu-id="c1087-1958">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="c1087-1959">`initblk`指令會設定數字 (`unsigned int32`) 的指定位址開頭的位元組 (型別的`native int`， `&`，或`*`) 來初始化值 (類型的`unsigned int8`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-1959">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="c1087-1960">`initblk` 假設的起始位址的對齊自然機器的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-1960">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="c1087-1961">營運`initblk`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-1961">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-1962"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-1962"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-1963">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`initblk`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1963">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1964">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-1964">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1965">將位於指定位址之值類型的各個欄位，初始化為適當之基本類型的 null 參考或 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1965">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1966">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1966">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1967">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1967">Format</span></span>|<span data-ttu-id="c1087-1968">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1968">Assembly Format</span></span>|<span data-ttu-id="c1087-1969">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1969">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1970">FE 15 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-1970">FE 15 < `T` ></span></span>|<span data-ttu-id="c1087-1971">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="c1087-1971">`initobj` `typeTok`</span></span>|<span data-ttu-id="c1087-1972">初始化實值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1972">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="c1087-1973">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1973">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1974">實值型別，初始化的地址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1974">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1975">位址會從堆疊; 推出實值型別，在指定的位址會初始化為型別`typeTok`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1975">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="c1087-1976">`initobj`指令會初始化推入位址所指定之值型別的每個欄位 (型別的`native int`， `&`，或`*`) 為 null 參考或 0，以適當的基本類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-1976">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="c1087-1977">會呼叫這個方法之後，就有一個執行個體可供要呼叫的建構函式方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-1977">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="c1087-1978">如果`typeTok`是參考型別，這個指令會有相同的效果`ldnull`後面`stind.ref`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1978">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="c1087-1979">不同於<xref:System.Reflection.Emit.OpCodes.Newobj>，`initobj`不會呼叫建構函式方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-1979">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="c1087-1980">`Initobj` 是要用於初始化實值型別，而`newobj`用來配置並初始化物件。</span><span class="sxs-lookup"><span data-stu-id="c1087-1980">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="c1087-1981">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`initobj`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-1981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-1982">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-1982">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-1983">測試是否有物件參考 (型別<see langword="O" />) 是特定類別的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-1983">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-1984">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-1984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-1985">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1985">Format</span></span>|<span data-ttu-id="c1087-1986">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-1986">Assembly Format</span></span>|<span data-ttu-id="c1087-1987">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-1987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-1988">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-1988">75 < `T` ></span></span>|<span data-ttu-id="c1087-1989">isinst `class`</span><span class="sxs-lookup"><span data-stu-id="c1087-1989">isinst `class`</span></span>|<span data-ttu-id="c1087-1990">測試的執行個體的物件參考是否`class`、 傳回 null 參考或該類別的執行個體，或介面。</span><span class="sxs-lookup"><span data-stu-id="c1087-1990">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="c1087-1991">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-1991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-1992">物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1992">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-1993">物件參考是從堆疊推出，並測試以查看它是否傳入類別的執行個體`class`。</span><span class="sxs-lookup"><span data-stu-id="c1087-1993">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="c1087-1994">將結果 （物件參考或 null 參考） 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-1994">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-1995">`Class` 這中繼資料語彙基元，表示所需的類別。</span><span class="sxs-lookup"><span data-stu-id="c1087-1995">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="c1087-1996">堆疊頂端的物件類別會實作`class`(如果`class`是一種介面) 的衍生的類別是否`class`(如果`class`是規則的類別) 則將它轉換成輸入`class`和結果推入堆疊，完全如同<xref:System.Reflection.Emit.OpCodes.Castclass>呼叫。</span><span class="sxs-lookup"><span data-stu-id="c1087-1996">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="c1087-1997">否則為 null 參考為推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-1997">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="c1087-1998">如果物件參考本身是 null 參考，則`isinst`同樣的則傳回 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-1998">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="c1087-1999"><xref:System.TypeLoadException> 如果找不到類別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-1999"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="c1087-2000">這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-2000">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-2001">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`isinst`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2002">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-2002">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2003">結束目前方法，並跳至指定的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2003">Exits current method and jumps to specified method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2004">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2005">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2005">Format</span></span>|<span data-ttu-id="c1087-2006">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2006">Assembly Format</span></span>|<span data-ttu-id="c1087-2007">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2008">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2008">27 < `T` ></span></span>|<span data-ttu-id="c1087-2009">jmp `method`</span><span class="sxs-lookup"><span data-stu-id="c1087-2009">jmp `method`</span></span>|<span data-ttu-id="c1087-2010">結束目前的方法，並跳至指定的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-2010">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="c1087-2011">這個指示的轉換行為有任何堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2011">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-2012">`jmp` （跳躍） 指示將控制權傳輸至指定的方法`method`，這是方法參考的中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-2012">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="c1087-2013">目前的引數會傳輸至目標方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-2013">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="c1087-2014">執行此指令時，必須是空評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2014">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="c1087-2015">呼叫慣例、 類型與數量的引數，在目的地位址必須符合目前的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-2015">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="c1087-2016">`jmp`指令不能用來傳輸控制項，共`try`， `filter`， `catch`，或`finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2016">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="c1087-2017">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`jmp`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2017">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2018">ILGenerator.Emit （OpCode、 MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-2018">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2019">載入引數 (為指定的索引值所參考) 至堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2019">Loads an argument (referenced by a specified index value) onto the stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2020">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2021">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2021">Format</span></span>|<span data-ttu-id="c1087-2022">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2022">Assembly Format</span></span>|<span data-ttu-id="c1087-2023">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2024">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2024">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="c1087-2025">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-2025">ldarg `index`</span></span>|<span data-ttu-id="c1087-2026">載入位於引數`index`至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2026">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="c1087-2027">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2028">在引數值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2028">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2029">`ldarg`指令會在索引的引數推入`index`，其中引數則是從 0 開始，至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2029">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2030">`ldarg`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2030">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="c1087-2031">引數，目前的方法簽章所指定的型別相同的引數值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-2031">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-2032">程序，使用可變長度引數清單，如`ldarg`指示可以僅用於初始的固定引數，不是這些簽章的變動部分 (請參閱<xref:System.Reflection.Emit.OpCodes.Arglist>指令，如需詳細資訊)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2032">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="c1087-2033">存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2033">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-2034">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2034">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-2035">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2035">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2036">ILGenerator.Emit (OpCode，short)</span><span class="sxs-lookup"><span data-stu-id="c1087-2036">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2037">載入位於索引 0 的引數至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2037">Loads the argument at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2038">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2038">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2039">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2039">Format</span></span>|<span data-ttu-id="c1087-2040">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2040">Assembly Format</span></span>|<span data-ttu-id="c1087-2041">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2041">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2042">02</span><span class="sxs-lookup"><span data-stu-id="c1087-2042">02</span></span>|<span data-ttu-id="c1087-2043">ldarg.0</span><span class="sxs-lookup"><span data-stu-id="c1087-2043">ldarg.0</span></span>|<span data-ttu-id="c1087-2044">載入至堆疊的引數 0</span><span class="sxs-lookup"><span data-stu-id="c1087-2044">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="c1087-2045">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2045">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2046">位於索引 0 的引數值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2046">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2047">`ldarg.0`指令都是有效的編碼方式，來載入位於索引 0 的引數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2047">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="c1087-2048">`ldarg.0`指令會推入至評估堆疊的 0 編製索引的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2048">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2049">`ldarg.0`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2049">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="c1087-2050">引數，目前的方法簽章所指定的型別相同的引數值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-2050">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-2051">存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2051">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-2052">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2052">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-2053">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.0`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2053">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2054">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2054">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2055">載入位於索引 1 的引數至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2055">Loads the argument at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2056">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2056">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2057">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2057">Format</span></span>|<span data-ttu-id="c1087-2058">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2058">Assembly Format</span></span>|<span data-ttu-id="c1087-2059">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2059">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2060">03</span><span class="sxs-lookup"><span data-stu-id="c1087-2060">03</span></span>|<span data-ttu-id="c1087-2061">ldarg.1</span><span class="sxs-lookup"><span data-stu-id="c1087-2061">ldarg.1</span></span>|<span data-ttu-id="c1087-2062">載入至堆疊的引數 1。</span><span class="sxs-lookup"><span data-stu-id="c1087-2062">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="c1087-2063">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2063">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2064">位於索引 1 的引數值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2064">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2065">`ldarg.1`指令都是有效的編碼方式，來載入位於索引 1 的引數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2065">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="c1087-2066">`ldarg.1`指令會推入至評估堆疊的 1 編製索引的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2066">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2067">`ldarg.1`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2067">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="c1087-2068">引數，目前的方法簽章所指定的型別相同的引數值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-2068">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-2069">存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2069">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-2070">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2070">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-2071">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2071">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2072">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2072">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2073">載入位於索引 2 的引數至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2073">Loads the argument at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2074">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2074">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2075">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2075">Format</span></span>|<span data-ttu-id="c1087-2076">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2076">Assembly Format</span></span>|<span data-ttu-id="c1087-2077">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2077">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2078">04</span><span class="sxs-lookup"><span data-stu-id="c1087-2078">04</span></span>|<span data-ttu-id="c1087-2079">ldarg.2</span><span class="sxs-lookup"><span data-stu-id="c1087-2079">ldarg.2</span></span>|<span data-ttu-id="c1087-2080">載入至堆疊的引數 2。</span><span class="sxs-lookup"><span data-stu-id="c1087-2080">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="c1087-2081">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2081">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2082">位於索引 2 的引數值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2082">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2083">`ldarg.2`指令都是有效的編碼方式，來載入位於索引 2 的引數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2083">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="c1087-2084">`ldarg.2`指令會推入至評估堆疊的 2 編製索引的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2084">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2085">`ldarg.2`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2085">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="c1087-2086">引數，目前的方法簽章所指定的型別相同的引數值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-2086">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-2087">存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2087">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-2088">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-2089">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2091">載入位於索引 3 的引數至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2091">Loads the argument at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2092">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2093">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2093">Format</span></span>|<span data-ttu-id="c1087-2094">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2094">Assembly Format</span></span>|<span data-ttu-id="c1087-2095">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2096">05</span><span class="sxs-lookup"><span data-stu-id="c1087-2096">05</span></span>|<span data-ttu-id="c1087-2097">ldarg.3</span><span class="sxs-lookup"><span data-stu-id="c1087-2097">ldarg.3</span></span>|<span data-ttu-id="c1087-2098">載入至堆疊的引數 3。</span><span class="sxs-lookup"><span data-stu-id="c1087-2098">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="c1087-2099">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2100">位於索引 3 的引數值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2100">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2101">`ldarg.3`指令都是有效的編碼方式，來載入位於索引 3 的引數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2101">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="c1087-2102">`ldarg.3`指令會推入至評估堆疊的 3 編製索引的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2102">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2103">`ldarg.3`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2103">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="c1087-2104">引數，目前的方法簽章所指定的型別相同的引數值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-2104">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-2105">存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2105">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-2106">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-2107">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.3`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2108">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2108">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2109">載入引數 (為指定的簡短形式索引所參考) 至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2109">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2110">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2111">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2111">Format</span></span>|<span data-ttu-id="c1087-2112">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2112">Assembly Format</span></span>|<span data-ttu-id="c1087-2113">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2114">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2114">0E < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-2115">ldarg.s `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-2115">ldarg.s `index`</span></span>|<span data-ttu-id="c1087-2116">載入位於引數`index`至堆疊，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2116">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="c1087-2117">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2118">在引數值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2118">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2119">`ldarg.s`指令都是有效的編碼方式為載入引數從 4 到 255 的編製索引。</span><span class="sxs-lookup"><span data-stu-id="c1087-2119">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="c1087-2120">`ldarg.s`指令會在索引的引數推入`index`，其中引數則是從 0 開始，至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2120">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2121">`ldarg.s`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2121">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="c1087-2122">引數，目前的方法簽章所指定的型別相同的引數值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-2122">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-2123">程序，使用可變長度引數清單，如`ldarg.s`指示可以僅用於初始的固定引數，不是這些簽章的變動部分 (請參閱<xref:System.Reflection.Emit.OpCodes.Arglist>指令，如需詳細資訊)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2123">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="c1087-2124">存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2124">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-2125">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2125">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-2126">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2127">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-2127">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2128">載入引數位址至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2128">Load an argument address onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2129">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2130">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2130">Format</span></span>|<span data-ttu-id="c1087-2131">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2131">Assembly Format</span></span>|<span data-ttu-id="c1087-2132">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2133">FE 0A &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2133">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="c1087-2134">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-2134">ldarga `index`</span></span>|<span data-ttu-id="c1087-2135">擷取由編製索引的引數位址`index`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2135">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="c1087-2136">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2137">地址`addr`編製索引的引數的`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2137">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2138">`ldarga`指令會擷取位址 (型別的`*`) 以編製索引的引數的`index`，其中的引數則是從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="c1087-2138">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="c1087-2139">位址`addr`一律會在目標電腦上的自然界限對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2139">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="c1087-2140">如需使用可變長度引數清單的程序`ldarga`指示可以僅用於初始的固定引數不簽章的變動部分中的那些。</span><span class="sxs-lookup"><span data-stu-id="c1087-2140">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="c1087-2141">`ldarga` 用於依 ref 參數傳遞。</span><span class="sxs-lookup"><span data-stu-id="c1087-2141">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="c1087-2142">其他情況下，如<xref:System.Reflection.Emit.OpCodes.Ldarg>和<xref:System.Reflection.Emit.OpCodes.Starg>應該使用。</span><span class="sxs-lookup"><span data-stu-id="c1087-2142">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="c1087-2143">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarga`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2143">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2144">ILGenerator.Emit (OpCode，short)</span><span class="sxs-lookup"><span data-stu-id="c1087-2144">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2145">以簡短形式，載入引數位址至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2145">Load an argument address, in short form, onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2146">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2146">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2147">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2147">Format</span></span>|<span data-ttu-id="c1087-2148">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2148">Assembly Format</span></span>|<span data-ttu-id="c1087-2149">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2149">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2150">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2150">0F < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-2151">ldarga.s `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-2151">ldarga.s `index`</span></span>|<span data-ttu-id="c1087-2152">擷取由編製索引的引數位址`index`，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2152">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="c1087-2153">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2153">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2154">地址`addr`編製索引的引數的`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2154">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2155">`ldarga.s` (簡短形式`ldarga`) 應該使用引數的數字 0 到 255，而且是更有效率的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2155">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="c1087-2156">`ldarga.s`指令會擷取位址 (型別的`*`) 以編製索引的引數的`index`，其中的引數則是從 0 開始。</span><span class="sxs-lookup"><span data-stu-id="c1087-2156">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="c1087-2157">位址`addr`一律會在目標電腦上的自然界限對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2157">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="c1087-2158">如需使用可變長度引數清單的程序`ldarga.s`指示可以僅用於初始的固定引數不簽章的變動部分中的那些。</span><span class="sxs-lookup"><span data-stu-id="c1087-2158">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="c1087-2159">`ldarga.s` 用於依 ref 參數傳遞。</span><span class="sxs-lookup"><span data-stu-id="c1087-2159">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="c1087-2160">其他情況下，如<xref:System.Reflection.Emit.OpCodes.Ldarg_S>和<xref:System.Reflection.Emit.OpCodes.Starg_S>應該使用。</span><span class="sxs-lookup"><span data-stu-id="c1087-2160">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="c1087-2161">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarga.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2161">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2162">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-2162">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2163">推送提供的值型別的<see langword="int32" />至評估堆疊做為<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2163">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2164">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2164">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2165">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2165">Format</span></span>|<span data-ttu-id="c1087-2166">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2166">Assembly Format</span></span>|<span data-ttu-id="c1087-2167">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2167">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2168">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2168">20 < `int32` ></span></span>|<span data-ttu-id="c1087-2169">ldc.i4 `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-2169">ldc.i4 `num`</span></span>|<span data-ttu-id="c1087-2170">將值推入`num`至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2170">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2171">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2171">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2172">值`num`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2172">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2173">請注意，有特殊的簡短 （並因此會更有效率） 編碼的整數-128 到 127，以及特別是簡短的編碼方式，-1 到 8。</span><span class="sxs-lookup"><span data-stu-id="c1087-2173">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="c1087-2174">所有較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2174">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="c1087-2175">較長的編碼會用於 8 位元組整數和 4 和 8 位元組浮點數，以及無法放入簡短形式的 4 位元組值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2175">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="c1087-2176">有三種方式可推送至堆疊的 8 位元組整數常數</span><span class="sxs-lookup"><span data-stu-id="c1087-2176">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="c1087-2177">使用<xref:System.Reflection.Emit.OpCodes.Ldc_I8>指示必須以多個 32 位元的常數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2177">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="c1087-2178">使用<xref:System.Reflection.Emit.OpCodes.Ldc_I4>後面的指示<xref:System.Reflection.Emit.OpCodes.Conv_I8>需要 9 到 32 位元的常數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="c1087-2179">使用簡短形式指令，後面跟著<xref:System.Reflection.Emit.OpCodes.Conv_I8>可以表示小於或等於 8 位元數的常數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2179">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="c1087-2180">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2181">ILGenerator.Emit (OpCode，int)</span><span class="sxs-lookup"><span data-stu-id="c1087-2181">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2182">推送至評估堆疊做為 0 的整數值<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2182">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2183">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2184">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2184">Format</span></span>|<span data-ttu-id="c1087-2185">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2185">Assembly Format</span></span>|<span data-ttu-id="c1087-2186">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2187">16</span><span class="sxs-lookup"><span data-stu-id="c1087-2187">16</span></span>|<span data-ttu-id="c1087-2188">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="c1087-2188">ldc.i4.0</span></span>|<span data-ttu-id="c1087-2189">推送至堆疊的 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-2189">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2190">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2191">值 0 推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2191">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2192">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2192">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2193">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2193">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2194">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.0`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2194">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2195">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2195">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2196">將整數值 1 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2196">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2197">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2197">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2198">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2198">Format</span></span>|<span data-ttu-id="c1087-2199">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2199">Assembly Format</span></span>|<span data-ttu-id="c1087-2200">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2200">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2201">17</span><span class="sxs-lookup"><span data-stu-id="c1087-2201">17</span></span>|<span data-ttu-id="c1087-2202">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="c1087-2202">ldc.i4.1</span></span>|<span data-ttu-id="c1087-2203">推送至堆疊的 1。</span><span class="sxs-lookup"><span data-stu-id="c1087-2203">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2204">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2204">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2205">值 1 會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2205">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2206">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2206">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2207">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2207">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2208">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2209">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2209">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2210">將整數值 2 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2210">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2211">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2212">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2212">Format</span></span>|<span data-ttu-id="c1087-2213">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2213">Assembly Format</span></span>|<span data-ttu-id="c1087-2214">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2215">18</span><span class="sxs-lookup"><span data-stu-id="c1087-2215">18</span></span>|<span data-ttu-id="c1087-2216">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="c1087-2216">ldc.i4.2</span></span>|<span data-ttu-id="c1087-2217">推送至堆疊的 2。</span><span class="sxs-lookup"><span data-stu-id="c1087-2217">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2218">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2219">值 2 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2219">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2220">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2220">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2221">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2221">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2222">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2222">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2223">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2223">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2224">將整數值 3 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2224">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2225">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2225">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2226">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2226">Format</span></span>|<span data-ttu-id="c1087-2227">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2227">Assembly Format</span></span>|<span data-ttu-id="c1087-2228">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2228">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2229">19</span><span class="sxs-lookup"><span data-stu-id="c1087-2229">19</span></span>|<span data-ttu-id="c1087-2230">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="c1087-2230">ldc.i4.3</span></span>|<span data-ttu-id="c1087-2231">推送至堆疊的 3。</span><span class="sxs-lookup"><span data-stu-id="c1087-2231">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2232">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2232">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2233">3 這個值會推入堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2233">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2234">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2234">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2235">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2235">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2236">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.3`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2236">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2237">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2237">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2238">將整數值 4 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2238">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2239">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2239">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2240">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2240">Format</span></span>|<span data-ttu-id="c1087-2241">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2241">Assembly Format</span></span>|<span data-ttu-id="c1087-2242">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2242">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2243">1A</span><span class="sxs-lookup"><span data-stu-id="c1087-2243">1A</span></span>|<span data-ttu-id="c1087-2244">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="c1087-2244">ldc.i4.4</span></span>|<span data-ttu-id="c1087-2245">推送至堆疊的 4。</span><span class="sxs-lookup"><span data-stu-id="c1087-2245">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2246">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2246">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2247">4 這個值會推入堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2247">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2248">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2248">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2249">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2249">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2250">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2252">將整數值 5 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2252">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2253">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2254">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2254">Format</span></span>|<span data-ttu-id="c1087-2255">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2255">Assembly Format</span></span>|<span data-ttu-id="c1087-2256">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2257">1B</span><span class="sxs-lookup"><span data-stu-id="c1087-2257">1B</span></span>|<span data-ttu-id="c1087-2258">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="c1087-2258">ldc.i4.5</span></span>|<span data-ttu-id="c1087-2259">推送至堆疊的 5。</span><span class="sxs-lookup"><span data-stu-id="c1087-2259">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2260">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2261">值為 5 會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2261">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2262">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2262">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2263">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2263">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2264">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.5`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2264">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2265">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2265">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2266">將整數值 6 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2266">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2267">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2267">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2268">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2268">Format</span></span>|<span data-ttu-id="c1087-2269">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2269">Assembly Format</span></span>|<span data-ttu-id="c1087-2270">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2270">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2271">1C</span><span class="sxs-lookup"><span data-stu-id="c1087-2271">1C</span></span>|<span data-ttu-id="c1087-2272">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="c1087-2272">ldc.i4.6</span></span>|<span data-ttu-id="c1087-2273">推送至堆疊的 6。</span><span class="sxs-lookup"><span data-stu-id="c1087-2273">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2274">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2274">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2275">將值 6 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2275">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2276">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2276">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2277">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2277">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2278">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.6`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2278">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2279">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2279">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2280">將整數值 7 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2280">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2281">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2281">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2282">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2282">Format</span></span>|<span data-ttu-id="c1087-2283">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2283">Assembly Format</span></span>|<span data-ttu-id="c1087-2284">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2284">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2285">1D</span><span class="sxs-lookup"><span data-stu-id="c1087-2285">1D</span></span>|<span data-ttu-id="c1087-2286">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="c1087-2286">ldc.i4.7</span></span>|<span data-ttu-id="c1087-2287">推送至堆疊的 7。</span><span class="sxs-lookup"><span data-stu-id="c1087-2287">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2288">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2288">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2289">值 7 會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2289">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2290">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2290">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2291">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2291">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2292">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.7`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2293">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2293">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2294">將整數值 8 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2294">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2295">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2296">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2296">Format</span></span>|<span data-ttu-id="c1087-2297">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2297">Assembly Format</span></span>|<span data-ttu-id="c1087-2298">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2299">1E</span><span class="sxs-lookup"><span data-stu-id="c1087-2299">1E</span></span>|<span data-ttu-id="c1087-2300">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="c1087-2300">ldc.i4.8</span></span>|<span data-ttu-id="c1087-2301">將 8 推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2301">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2302">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2303">值為 8 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2303">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2304">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2304">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2305">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2305">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2306">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2306">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2307">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2307">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2308">將整數值 -1 以 <see langword="int32" /> 推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2308">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2309">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2309">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2310">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2310">Format</span></span>|<span data-ttu-id="c1087-2311">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2311">Assembly Format</span></span>|<span data-ttu-id="c1087-2312">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2312">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2313">15</span><span class="sxs-lookup"><span data-stu-id="c1087-2313">15</span></span>|<span data-ttu-id="c1087-2314">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="c1087-2314">ldc.i4.m1</span></span>|<span data-ttu-id="c1087-2315">推送至堆疊的-1。</span><span class="sxs-lookup"><span data-stu-id="c1087-2315">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2316">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2316">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2317">值-1 會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2317">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2318">這是特殊短的編碼方式的整數值 0 推播。</span><span class="sxs-lookup"><span data-stu-id="c1087-2318">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="c1087-2319">所有特殊較短的編碼會推入堆疊的 4 位元組整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-2319">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="c1087-2320">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.m1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2322">推送提供<see langword="int8" />值至評估堆疊做為<see langword="int32" />，簡短形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2322">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2323">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2324">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2324">Format</span></span>|<span data-ttu-id="c1087-2325">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2325">Assembly Format</span></span>|<span data-ttu-id="c1087-2326">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2327">1F &LT; `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2327">1F < `int8` ></span></span>|<span data-ttu-id="c1087-2328">ldc.i4.s `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-2328">ldc.i4.s `num`</span></span>|<span data-ttu-id="c1087-2329">推播`num`至堆疊`int32`，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2329">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="c1087-2330">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2331">值`num`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2331">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2332">`ldc.i4.s` 是以更有效率的編碼方式，就將整數介於-128 的資料到 127 推送至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2332">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2333">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2333">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2334">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-2334">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2335">推送提供的值型別的<see langword="int64" />至評估堆疊做為<see langword="int64" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2336">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2337">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2337">Format</span></span>|<span data-ttu-id="c1087-2338">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2338">Assembly Format</span></span>|<span data-ttu-id="c1087-2339">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2340">21 < `int64` ></span></span>|<span data-ttu-id="c1087-2341">ldc.i8 `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="c1087-2342">推播`num`至堆疊`int64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="c1087-2343">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2344">值`num`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2345">這種編碼方式將推入`int64`值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2346">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2347">ILGenerator.Emit (OpCode，long)</span><span class="sxs-lookup"><span data-stu-id="c1087-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2348">推送提供的值型別的<see langword="float32" />至評估堆疊做為類型<see langword="F" />（浮點數）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2349">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2350">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2350">Format</span></span>|<span data-ttu-id="c1087-2351">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2351">Assembly Format</span></span>|<span data-ttu-id="c1087-2352">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2353">22 < `float32` ></span></span>|<span data-ttu-id="c1087-2354">ldc.r4 `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="c1087-2355">推播`num`至堆疊`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="c1087-2356">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2357">值`num`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2358">這種編碼方式將推入`float32`值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2359">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.r4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2360">ILGenerator.Emit (OpCode 單一)</span><span class="sxs-lookup"><span data-stu-id="c1087-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2361">推送提供的值型別的<see langword="float64" />至評估堆疊做為類型<see langword="F" />（浮點數）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2362">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2363">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2363">Format</span></span>|<span data-ttu-id="c1087-2364">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2364">Assembly Format</span></span>|<span data-ttu-id="c1087-2365">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2366">23 < `float64` ></span></span>|<span data-ttu-id="c1087-2367">ldc.r8 `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="c1087-2368">推播`num`至堆疊`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="c1087-2369">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2370">值`num`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2371">這種編碼方式將推入`float64`值至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2372">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.r8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2373">ILGenerator.Emit (OpCode，double)</span><span class="sxs-lookup"><span data-stu-id="c1087-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2374">將位於指定之陣列索引處的項目當做指令中指定的類型載入至評估堆疊的頂端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2375">下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2376">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2376">Format</span></span>|<span data-ttu-id="c1087-2377">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2377">Assembly Format</span></span>|<span data-ttu-id="c1087-2378">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2379">A3 < `T` ></span></span>|<span data-ttu-id="c1087-2380">ldelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="c1087-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="c1087-2381">載入處的項目`index`類型堆疊的頂端`typeTok`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="c1087-2382">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2383">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2384">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2385">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2386">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2387">`ldelem`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2388">陣列也是物件，表示型別的值`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2389">傳回值的型別由權杖`typeTok`指令中。</span><span class="sxs-lookup"><span data-stu-id="c1087-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="c1087-2390"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2391"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於上限`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2392">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2393">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2394">載入項目類型<see langword="native int" />位於評估堆疊頂端指定的陣列索引處<see langword="native int" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2395">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2396">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2396">Format</span></span>|<span data-ttu-id="c1087-2397">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2397">Assembly Format</span></span>|<span data-ttu-id="c1087-2398">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2399">97</span><span class="sxs-lookup"><span data-stu-id="c1087-2399">97</span></span>|<span data-ttu-id="c1087-2400">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="c1087-2400">ldelem.i</span></span>|<span data-ttu-id="c1087-2401">載入項目類型`native int`位於`index`堆疊的頂端`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="c1087-2402">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2403">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2404">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2405">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2406">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2407">`ldelem.i`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2408">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2409">傳回值`ldelem.i`是`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="c1087-2410">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2411"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2412"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2413"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2414">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2416">載入項目類型<see langword="int8" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2417">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2418">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2418">Format</span></span>|<span data-ttu-id="c1087-2419">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2419">Assembly Format</span></span>|<span data-ttu-id="c1087-2420">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2421">90</span><span class="sxs-lookup"><span data-stu-id="c1087-2421">90</span></span>|<span data-ttu-id="c1087-2422">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="c1087-2422">ldelem.i1</span></span>|<span data-ttu-id="c1087-2423">載入項目類型`int8`位於`index`堆疊的頂端`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2424">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2425">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2426">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2427">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2428">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2429">`ldelem.i1`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2430">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2431">傳回值`ldelem.i1`是`int8`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="c1087-2432">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2433"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2434"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2435"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2436">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2438">載入項目類型<see langword="int16" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2439">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2440">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2440">Format</span></span>|<span data-ttu-id="c1087-2441">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2441">Assembly Format</span></span>|<span data-ttu-id="c1087-2442">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2443">92</span><span class="sxs-lookup"><span data-stu-id="c1087-2443">92</span></span>|<span data-ttu-id="c1087-2444">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="c1087-2444">ldelem.i2</span></span>|<span data-ttu-id="c1087-2445">載入項目類型`int16`位於`index`堆疊的頂端`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2446">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2447">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2448">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2449">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2450">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2451">`ldelem.i2`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2452">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2453">傳回值`ldelem.i2`是`int16`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="c1087-2454">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2455"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2456"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2457"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2458">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2460">載入項目類型<see langword="int32" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2461">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2462">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2462">Format</span></span>|<span data-ttu-id="c1087-2463">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2463">Assembly Format</span></span>|<span data-ttu-id="c1087-2464">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2465">94</span><span class="sxs-lookup"><span data-stu-id="c1087-2465">94</span></span>|<span data-ttu-id="c1087-2466">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="c1087-2466">ldelem.i4</span></span>|<span data-ttu-id="c1087-2467">載入項目類型`int32`位於`index`堆疊的頂端`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2468">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2469">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2470">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2471">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2472">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2473">`ldelem.i4`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2474">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2475">傳回值`ldelem.i4`是`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2476">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2477"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2478"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2479"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2480">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2482">載入項目類型<see langword="int64" />位於評估堆疊頂端指定的陣列索引處<see langword="int64" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2483">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2484">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2484">Format</span></span>|<span data-ttu-id="c1087-2485">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2485">Assembly Format</span></span>|<span data-ttu-id="c1087-2486">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2487">96</span><span class="sxs-lookup"><span data-stu-id="c1087-2487">96</span></span>|<span data-ttu-id="c1087-2488">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="c1087-2488">ldelem.i8</span></span>|<span data-ttu-id="c1087-2489">載入項目類型`int64`位於`index`堆疊的頂端`int64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="c1087-2490">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2491">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2492">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2493">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2494">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2495">`ldelem.i8`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2496">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2497">傳回值`ldelem.i8`是`int64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="c1087-2498">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2499"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2500"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2501"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2502">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2504">載入項目類型<see langword="float32" />指定的陣列索引至類型評估堆疊的頂端<see langword="F" />（浮點數）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2505">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2506">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2506">Format</span></span>|<span data-ttu-id="c1087-2507">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2507">Assembly Format</span></span>|<span data-ttu-id="c1087-2508">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2509">98</span><span class="sxs-lookup"><span data-stu-id="c1087-2509">98</span></span>|<span data-ttu-id="c1087-2510">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="c1087-2510">ldelem.r4</span></span>|<span data-ttu-id="c1087-2511">載入項目類型`float32`位於`index`做為類型堆疊的頂端`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="c1087-2512">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2513">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2514">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2515">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2516">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2517">`ldelem.r4`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2518">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2519">傳回值`ldelem.r4`是`float32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="c1087-2520">浮點數的值會轉換成輸入`F`時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2521"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2522"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2523"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2524">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.r4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2526">載入項目類型<see langword="float64" />指定的陣列索引至類型評估堆疊的頂端<see langword="F" />（浮點數）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2527">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2528">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2528">Format</span></span>|<span data-ttu-id="c1087-2529">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2529">Assembly Format</span></span>|<span data-ttu-id="c1087-2530">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2531">99</span><span class="sxs-lookup"><span data-stu-id="c1087-2531">99</span></span>|<span data-ttu-id="c1087-2532">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="c1087-2532">ldelem.r8</span></span>|<span data-ttu-id="c1087-2533">載入項目類型`float64`位於`index`類型堆疊的頂端`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="c1087-2534">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2535">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2536">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2537">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2538">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2539">`ldelem.r8`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2540">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2541">傳回值`ldelem.r8`是`float64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="c1087-2542">浮點數的值會轉換成輸入`F`時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2543"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2544"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2545"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2546">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.r8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2548">載入包含位於評估堆疊頂端做為類型指定的陣列索引處的物件參考的項目<see langword="O" />（物件參考）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2549">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2550">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2550">Format</span></span>|<span data-ttu-id="c1087-2551">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2551">Assembly Format</span></span>|<span data-ttu-id="c1087-2552">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2553">9A</span><span class="sxs-lookup"><span data-stu-id="c1087-2553">9A</span></span>|<span data-ttu-id="c1087-2554">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="c1087-2554">ldelem.ref</span></span>|<span data-ttu-id="c1087-2555">載入位於的物件參考的項目`index`類型堆疊的頂端`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="c1087-2556">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2557">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2558">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2559">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2560">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2561">`ldelem.ref`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2562">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2563">傳回值`ldelem.ref`是型別`O`（物件參考）。</span><span class="sxs-lookup"><span data-stu-id="c1087-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="c1087-2564"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2565"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2566"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2567">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.ref`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2569">載入項目類型<see langword="unsigned int8" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2570">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2571">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2571">Format</span></span>|<span data-ttu-id="c1087-2572">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2572">Assembly Format</span></span>|<span data-ttu-id="c1087-2573">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2574">91</span><span class="sxs-lookup"><span data-stu-id="c1087-2574">91</span></span>|<span data-ttu-id="c1087-2575">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="c1087-2575">ldelem.u1</span></span>|<span data-ttu-id="c1087-2576">載入項目類型`unsigned int8`位於`index`堆疊的頂端`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2577">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2578">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2579">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2580">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2581">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2582">`ldelem.u1`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2583">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2584">傳回值`ldelem.u1`是`int8`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="c1087-2585">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2586"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2587"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2588"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2589">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.u1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2591">載入項目類型<see langword="unsigned int16" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2592">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2593">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2593">Format</span></span>|<span data-ttu-id="c1087-2594">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2594">Assembly Format</span></span>|<span data-ttu-id="c1087-2595">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2596">93</span><span class="sxs-lookup"><span data-stu-id="c1087-2596">93</span></span>|<span data-ttu-id="c1087-2597">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="c1087-2597">ldelem.u2</span></span>|<span data-ttu-id="c1087-2598">載入項目類型`unsigned int16`堆疊的頂端的索引處`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2599">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2600">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2601">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2602">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2603">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2604">`ldelem.u2`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2605">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2606">傳回值`ldelem.u2`是`int16`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="c1087-2607">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2608"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2609"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2610"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2611">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.u2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2613">載入項目類型<see langword="unsigned int32" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2614">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2615">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2615">Format</span></span>|<span data-ttu-id="c1087-2616">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2616">Assembly Format</span></span>|<span data-ttu-id="c1087-2617">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2618">95</span><span class="sxs-lookup"><span data-stu-id="c1087-2618">95</span></span>|<span data-ttu-id="c1087-2619">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="c1087-2619">ldelem.u4</span></span>|<span data-ttu-id="c1087-2620">載入項目類型`unsigned int32`堆疊的頂端的索引處`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2621">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2622">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2623">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2624">`index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2625">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2626">`ldelem.u4`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2627">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2628">傳回值`ldelem.u4`是`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2629">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2630"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2631"><xref:System.ArrayTypeMismatchException> 如果陣列不會保留項目所需型別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2632"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2633">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.u4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2635">載入至評估堆疊做為類型的頂端，指定的陣列索引處的陣列元素的位址<see langword="&amp;" />（managed 的指標）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2636">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2637">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2637">Format</span></span>|<span data-ttu-id="c1087-2638">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2638">Assembly Format</span></span>|<span data-ttu-id="c1087-2639">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2640">8F < `T` ></span></span>|<span data-ttu-id="c1087-2641">ldelema `class`</span><span class="sxs-lookup"><span data-stu-id="c1087-2641">ldelema `class`</span></span>|<span data-ttu-id="c1087-2642">在陣列元素的位址載入`index`的型別評估堆疊頂端`&`（managed 的指標）。</span><span class="sxs-lookup"><span data-stu-id="c1087-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="c1087-2643">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2644">物件參考`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2645">索引值`index`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-2646">`index` 並`array`會從堆疊; 推出儲存位置的位址`index`在`array`查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="c1087-2647">地址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2648">`ldelema`用來擷取物件的陣列中特定索引處的物件的位址 (型別`class`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="c1087-2649">`ldelema`指令載入位址的索引處的值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="c1087-2650">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-2651">值必須是型別`class`傳遞與指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="c1087-2652">傳回值`ldelema`是 managed 的指標 (型別`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="c1087-2653">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2654"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-2655"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-2656"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-2657">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelema`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2658">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2659">尋找物件中的欄位值，該值的參考目前位於評估堆疊中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2660">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2661">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2661">Format</span></span>|<span data-ttu-id="c1087-2662">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2662">Assembly Format</span></span>|<span data-ttu-id="c1087-2663">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2664">7B < `T` ></span></span>|<span data-ttu-id="c1087-2665">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="c1087-2665">ldfld `field`</span></span>|<span data-ttu-id="c1087-2666">推入指定的物件至堆疊中的欄位值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2667">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2668">物件參考 （或指標） 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2669">物件參考 （或指標） 會從堆疊; 中推出找到的物件中指定的欄位值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="c1087-2670">在欄位中儲存的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2671">`ldfld`指令會推入至堆疊的物件中欄位的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="c1087-2672">物件必須位於堆疊的物件參考 (型別`O`)，managed 的指標 (型別`&`) 的 unmanaged 的指標 (型別`native int`)，暫時性指標 (型別`*`)，或實值類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="c1087-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="c1087-2673">可驗證的程式碼中不允許使用的 unmanaged 指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="c1087-2674">指定物件的欄位的欄位成員必須參考中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="c1087-2675">傳回的型別是與欄位關聯的一個相同。</span><span class="sxs-lookup"><span data-stu-id="c1087-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="c1087-2676">欄位可能是 （在此情況下的物件不得為 null 參考） 的執行個體欄位或靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="c1087-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="c1087-2677">`ldfld`指令可以加上一個或兩個<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="c1087-2678"><xref:System.NullReferenceException> 如果物件是 null，且該欄位不是靜態，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="c1087-2679"><xref:System.MissingFieldException> 如果在中繼資料中找不到指定的欄位，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="c1087-2680">這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="c1087-2681">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldfld`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2682">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2683">尋找物件中的欄位位址，該位址的參考目前位於評估堆疊中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2684">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2685">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2685">Format</span></span>|<span data-ttu-id="c1087-2686">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2686">Assembly Format</span></span>|<span data-ttu-id="c1087-2687">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2688">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2688">7C < `T` ></span></span>|<span data-ttu-id="c1087-2689">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="c1087-2689">ldflda `field`</span></span>|<span data-ttu-id="c1087-2690">推入的位址`field`中指定的物件至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2691">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2692">物件參考 （或指標） 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2693">物件參考 （或指標） 會從堆疊; 中推出找到的物件中的指定欄位的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="c1087-2694">指定欄位的位址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2695">`ldflda`指令會推入至堆疊的物件中欄位的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="c1087-2696">物件必須位於堆疊的物件參考 (型別`O`)，managed 的指標 (型別`&`) 的 unmanaged 的指標 (型別`native int`)，暫時性指標 (型別`*`)，或實值類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="c1087-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="c1087-2697">可驗證的程式碼中不允許使用的 unmanaged 指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="c1087-2698">指定物件的欄位的欄位成員必須參考中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="c1087-2699">所傳回的值`ldflda`是 managed 的指標 (型別`&`) 除非物件已推送至堆疊的 unmanaged 指標，在此情況下傳回地址還有的 unmanaged 的指標 (型別`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="c1087-2700">`ldflda`指令可以加上一個或兩個<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="c1087-2701"><xref:System.InvalidOperationException> 如果物件不是從中進行存取的應用程式定義域中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="c1087-2702">無法載入存取的應用程式定義域內不是欄位的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="c1087-2703"><xref:System.NullReferenceException> 如果物件是 null，且該欄位不是靜態，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="c1087-2704"><xref:System.MissingFieldException> 如果在中繼資料中找不到指定的欄位，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="c1087-2705">這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="c1087-2706">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldflda`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2707">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2708">推送的 unmanaged 的指標 (型別<see langword="native int" />) 來實作特定方法至評估堆疊的原生程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2709">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2710">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2710">Format</span></span>|<span data-ttu-id="c1087-2711">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2711">Assembly Format</span></span>|<span data-ttu-id="c1087-2712">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2713">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="c1087-2714">instrukce `method`</span><span class="sxs-lookup"><span data-stu-id="c1087-2714">ldftn `method`</span></span>|<span data-ttu-id="c1087-2715">將指標所參考的方法推入`method`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2716">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2717">特定方法的 unmanaged 的指標會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2718">特定的方法 (`method`) 可以用來呼叫<xref:System.Reflection.Emit.OpCodes.Calli>看它所參考的 managed 的方法 （或從 managed 轉換到 unmanaged 程式碼 stub） 的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="c1087-2719">使用 CLR 的呼叫慣例的原生程式碼點傳回的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="c1087-2720">這個方法的指標不應該傳遞至未受管理的原生程式碼中，但會做為回呼常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="c1087-2721">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldftn`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2722">ILGenerator.Emit （OpCode、 MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2723">載入型別的值<see langword="native int" />做為<see langword="native int" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2724">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2725">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2725">Format</span></span>|<span data-ttu-id="c1087-2726">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2726">Assembly Format</span></span>|<span data-ttu-id="c1087-2727">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2728">4D</span><span class="sxs-lookup"><span data-stu-id="c1087-2728">4D</span></span>|<span data-ttu-id="c1087-2729">ldind.i</span><span class="sxs-lookup"><span data-stu-id="c1087-2729">ldind.i</span></span>|<span data-ttu-id="c1087-2730">載入`native int`位址的值`addr`至堆疊`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="c1087-2731">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2732">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2733">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2734">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2735">`ldind.i`間接載入指令`native int`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="c1087-2736">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2737">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2738">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2739">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2740">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2741">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2742">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2743">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2744"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2745">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2747">載入型別的值<see langword="int8" />做為<see langword="int32" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2748">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2749">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2749">Format</span></span>|<span data-ttu-id="c1087-2750">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2750">Assembly Format</span></span>|<span data-ttu-id="c1087-2751">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2752">46</span><span class="sxs-lookup"><span data-stu-id="c1087-2752">46</span></span>|<span data-ttu-id="c1087-2753">ldind.i1</span><span class="sxs-lookup"><span data-stu-id="c1087-2753">ldind.i1</span></span>|<span data-ttu-id="c1087-2754">載入`int8`位址的值`addr`至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2755">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2756">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2757">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2758">將擷取的值會推入堆疊...</span><span class="sxs-lookup"><span data-stu-id="c1087-2758">The fetched value is pushed onto the stack..</span></span>  
  
 <span data-ttu-id="c1087-2759">`ldind.i1`間接載入指令`int8`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2760">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2761">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2762">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2763">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2764">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2765">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2766">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2767">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2768"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2769">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2771">載入型別的值<see langword="int16" />做為<see langword="int32" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2772">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2773">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2773">Format</span></span>|<span data-ttu-id="c1087-2774">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2774">Assembly Format</span></span>|<span data-ttu-id="c1087-2775">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2776">48</span><span class="sxs-lookup"><span data-stu-id="c1087-2776">48</span></span>|<span data-ttu-id="c1087-2777">ldind.i2</span><span class="sxs-lookup"><span data-stu-id="c1087-2777">ldind.i2</span></span>|<span data-ttu-id="c1087-2778">載入`int16`位址的值`addr`至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2779">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2780">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2781">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2782">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2783">`ldind.i2`間接載入指令`int16`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2784">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2785">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2786">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2787">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2788">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2789">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2790">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2791">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2792"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2793">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2795">載入型別的值<see langword="int32" />做為<see langword="int32" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2796">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2797">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2797">Format</span></span>|<span data-ttu-id="c1087-2798">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2798">Assembly Format</span></span>|<span data-ttu-id="c1087-2799">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2800">4A</span><span class="sxs-lookup"><span data-stu-id="c1087-2800">4A</span></span>|<span data-ttu-id="c1087-2801">ldind.i4</span><span class="sxs-lookup"><span data-stu-id="c1087-2801">ldind.i4</span></span>|<span data-ttu-id="c1087-2802">載入`int32`位址的值`addr`至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2803">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2804">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2805">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2806">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2807">`ldind.i4`間接載入指令`int32`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2808">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2809">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2810">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2811">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2812">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2813">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2814">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2815">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2816"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2817">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2819">載入型別的值<see langword="int64" />做為<see langword="int64" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2820">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2821">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2821">Format</span></span>|<span data-ttu-id="c1087-2822">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2822">Assembly Format</span></span>|<span data-ttu-id="c1087-2823">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2824">4C</span><span class="sxs-lookup"><span data-stu-id="c1087-2824">4C</span></span>|<span data-ttu-id="c1087-2825">ldind.i8</span><span class="sxs-lookup"><span data-stu-id="c1087-2825">ldind.i8</span></span>|<span data-ttu-id="c1087-2826">載入`int64`位址的值`addr`至堆疊`int64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="c1087-2827">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2828">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2829">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2830">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2831">`ldind.i8`間接載入指令`int64`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="c1087-2832">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2833">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2834">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2835">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2836">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2837">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2838">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2839">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2840"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2841">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2843">載入型別的值<see langword="float32" />做為類型<see langword="F" />（浮點數） 至評估堆疊間接。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2844">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2845">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2845">Format</span></span>|<span data-ttu-id="c1087-2846">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2846">Assembly Format</span></span>|<span data-ttu-id="c1087-2847">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2848">4E</span><span class="sxs-lookup"><span data-stu-id="c1087-2848">4E</span></span>|<span data-ttu-id="c1087-2849">ldind.r4</span><span class="sxs-lookup"><span data-stu-id="c1087-2849">ldind.r4</span></span>|<span data-ttu-id="c1087-2850">載入`float32`位址的值`addr`至堆疊做為型別`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="c1087-2851">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2852">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2853">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2854">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2855">`ldind.r4`間接載入指令`float32`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊做為型別`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="c1087-2856">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2857">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2858">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2859">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2860">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2861">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2862">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2863">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2864"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2865">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.r4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2867">載入型別的值<see langword="float64" />做為類型<see langword="F" />（浮點數） 至評估堆疊間接。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2868">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2869">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2869">Format</span></span>|<span data-ttu-id="c1087-2870">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2870">Assembly Format</span></span>|<span data-ttu-id="c1087-2871">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2872">4F</span><span class="sxs-lookup"><span data-stu-id="c1087-2872">4F</span></span>|<span data-ttu-id="c1087-2873">ldind.r8</span><span class="sxs-lookup"><span data-stu-id="c1087-2873">ldind.r8</span></span>|<span data-ttu-id="c1087-2874">載入`float64`位址的值`addr`至堆疊做為型別`F`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="c1087-2875">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2876">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2877">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2878">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2879">`ldind.r8`間接載入指令`float64`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`float64`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="c1087-2880">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2881">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2882">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2883">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2884">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2885">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2886">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2887">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2888"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2889">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.r8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2891">載入物件參考做為型別<see langword="O" />（物件參考） 至評估堆疊間接。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2892">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2893">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2893">Format</span></span>|<span data-ttu-id="c1087-2894">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2894">Assembly Format</span></span>|<span data-ttu-id="c1087-2895">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2896">50</span><span class="sxs-lookup"><span data-stu-id="c1087-2896">50</span></span>|<span data-ttu-id="c1087-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="c1087-2897">ldind.ref</span></span>|<span data-ttu-id="c1087-2898">載入位址的物件參考`addr`至堆疊做為型別 `O`</span><span class="sxs-lookup"><span data-stu-id="c1087-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="c1087-2899">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2900">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2901">位址會從堆疊; 推出擷取位於位址的物件參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2902">擷取的參考會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2903">`ldind.ref`間接載入指令的物件參考指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊類型`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="c1087-2904">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2905">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2906">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2907">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2908">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2909">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2910">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2911">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2912"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2913">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.ref`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2915">載入型別的值<see langword="unsigned int8" />做為<see langword="int32" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2916">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2917">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2917">Format</span></span>|<span data-ttu-id="c1087-2918">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2918">Assembly Format</span></span>|<span data-ttu-id="c1087-2919">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2920">47</span><span class="sxs-lookup"><span data-stu-id="c1087-2920">47</span></span>|<span data-ttu-id="c1087-2921">ldind.u1</span><span class="sxs-lookup"><span data-stu-id="c1087-2921">ldind.u1</span></span>|<span data-ttu-id="c1087-2922">載入`unsigned int8`位址的值`addr`至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2923">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2924">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2925">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2926">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2927">`ldind.u1`間接載入指令`unsigned int8`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2928">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2929">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2930">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2931">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2932">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2933">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2934">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2935">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2936"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2937">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.u1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2939">載入型別的值<see langword="unsigned int16" />做為<see langword="int32" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2940">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2941">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2941">Format</span></span>|<span data-ttu-id="c1087-2942">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2942">Assembly Format</span></span>|<span data-ttu-id="c1087-2943">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2944">49</span><span class="sxs-lookup"><span data-stu-id="c1087-2944">49</span></span>|<span data-ttu-id="c1087-2945">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="c1087-2945">ldind.u2</span></span>|<span data-ttu-id="c1087-2946">載入`unsigned int16`位址的值`addr`至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2947">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2948">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2949">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2950">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2951">`ldind.u2`間接載入指令`unsigned int16`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2952">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2953">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2954">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2955">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2956">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2957">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2958">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2959">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2960"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2961">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.u2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2963">載入型別的值<see langword="unsigned int32" />做為<see langword="int32" />間接至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2964">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2965">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2965">Format</span></span>|<span data-ttu-id="c1087-2966">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2966">Assembly Format</span></span>|<span data-ttu-id="c1087-2967">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2968">4B</span><span class="sxs-lookup"><span data-stu-id="c1087-2968">4B</span></span>|<span data-ttu-id="c1087-2969">ldind.u4</span><span class="sxs-lookup"><span data-stu-id="c1087-2969">ldind.u4</span></span>|<span data-ttu-id="c1087-2970">載入`unsigned int32`位址的值`addr`至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="c1087-2971">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2972">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2973">位址會從堆疊; 推出擷取位於位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="c1087-2974">將擷取的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2975">`ldind.u4`間接載入指令`unsigned int32`值，從指定的位址 (型別的`native int`， `&`，或 \*) 至堆疊`int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="c1087-2976">所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="c1087-2977">請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="c1087-2978">浮點數的值會轉換成`F`輸入時載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-2979">正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="c1087-2980">一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。</span><span class="sxs-lookup"><span data-stu-id="c1087-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="c1087-2981">所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="c1087-2982">對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU</span><span class="sxs-lookup"><span data-stu-id="c1087-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="c1087-2983">取決於位元組順序的程式碼可能無法執行所有平台上。</span><span class="sxs-lookup"><span data-stu-id="c1087-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="c1087-2984"><xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="c1087-2985">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.u4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-2987">推送以零為起始的一維陣列的項目數至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-2988">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-2989">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2989">Format</span></span>|<span data-ttu-id="c1087-2990">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-2990">Assembly Format</span></span>|<span data-ttu-id="c1087-2991">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-2992">8E</span><span class="sxs-lookup"><span data-stu-id="c1087-2992">8E</span></span>|<span data-ttu-id="c1087-2993">ldlen</span><span class="sxs-lookup"><span data-stu-id="c1087-2993">ldlen</span></span>|<span data-ttu-id="c1087-2994">推播長度 (型別`natural unsigned int`) 的堆疊上的陣列。</span><span class="sxs-lookup"><span data-stu-id="c1087-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-2995">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-2996">陣列的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-2997">陣列參考從堆疊推出，並計算長度。</span><span class="sxs-lookup"><span data-stu-id="c1087-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="c1087-2998">長度會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-2999">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3000">將會傳回長度為`natural unsigned int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="c1087-3001"><xref:System.NullReferenceException> 如果陣列參考為 null 參考，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3002">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldlen`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3004">載入位於指定索引的區域變數至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3004">Loads the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3005">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3006">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3006">Format</span></span>|<span data-ttu-id="c1087-3007">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3007">Assembly Format</span></span>|<span data-ttu-id="c1087-3008">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3009">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="c1087-3010">ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-3010">ldloc `index`</span></span>|<span data-ttu-id="c1087-3011">載入位於索引的區域變數`index`至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="c1087-3012">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3013">指定索引處的區域變數值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3014">`ldloc`指令會推入內容的本機變數數目在傳遞的索引至評估堆疊，區域變數所在及更新版本編號為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="c1087-3015">本機變數會初始化旗標，方法是，則為 true 時，才進入方法之前初始化為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="c1087-3016">有 65,535 (2 ^16-1） 本機變數可能 (0-65534)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="c1087-3017">索引 65,535 無效，因為可能的實作會使用 2 位元組的整數，來追蹤這兩個區域的索引，以及指定方法的區域變數的總數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="c1087-3018">如果 65535 的索引已經變成有效，它將需要更多的整數，用來追蹤這類方法中的區域變數的數目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="c1087-3019">`ldloc.0`， `ldloc.1`， `ldloc.2`，和`ldloc.3`指示可讓您提供有效的編碼方式，來存取前四個區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="c1087-3020">方法標頭中指定的本機變數的類型相同之值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="c1087-3021">請參閱小於 4 個位元組會展開成輸入的資料分割 I.本機變數`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-3022">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-3023">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3024">ILGenerator.Emit （OpCode、 LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="c1087-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="c1087-3025">ILGenerator.Emit (OpCode，short)</span><span class="sxs-lookup"><span data-stu-id="c1087-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3026">將位於索引 0 的區域變數載入至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3026">Loads the local variable at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3027">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3028">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3028">Format</span></span>|<span data-ttu-id="c1087-3029">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3029">Assembly Format</span></span>|<span data-ttu-id="c1087-3030">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3031">06</span><span class="sxs-lookup"><span data-stu-id="c1087-3031">06</span></span>|<span data-ttu-id="c1087-3032">ldloc.0</span><span class="sxs-lookup"><span data-stu-id="c1087-3032">ldloc.0</span></span>|<span data-ttu-id="c1087-3033">將位於索引 0 的區域變數載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="c1087-3034">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3035">位於索引 0 的區域變數值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3036">`ldloc.0` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 0 的本機變數的存取。</span><span class="sxs-lookup"><span data-stu-id="c1087-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="c1087-3037">方法標頭中指定的本機變數的類型相同之值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="c1087-3038">小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-3039">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-3040">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.0`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3042">將位於索引 1 的區域變數載入至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3042">Loads the local variable at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3043">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3044">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3044">Format</span></span>|<span data-ttu-id="c1087-3045">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3045">Assembly Format</span></span>|<span data-ttu-id="c1087-3046">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3047">07</span><span class="sxs-lookup"><span data-stu-id="c1087-3047">07</span></span>|<span data-ttu-id="c1087-3048">ldloc.1</span><span class="sxs-lookup"><span data-stu-id="c1087-3048">ldloc.1</span></span>|<span data-ttu-id="c1087-3049">將位於索引 1 的區域變數載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="c1087-3050">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3051">位於索引 1 的區域變數值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3052">`ldloc.1` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 1 的本機變數的存取。</span><span class="sxs-lookup"><span data-stu-id="c1087-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="c1087-3053">方法標頭中指定的本機變數的類型相同之值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="c1087-3054">小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-3055">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-3056">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3058">將位於索引 2 的區域變數載入至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3058">Loads the local variable at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3059">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3060">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3060">Format</span></span>|<span data-ttu-id="c1087-3061">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3061">Assembly Format</span></span>|<span data-ttu-id="c1087-3062">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3063">08</span><span class="sxs-lookup"><span data-stu-id="c1087-3063">08</span></span>|<span data-ttu-id="c1087-3064">ldloc.2</span><span class="sxs-lookup"><span data-stu-id="c1087-3064">ldloc.2</span></span>|<span data-ttu-id="c1087-3065">將位於索引 2 的區域變數載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="c1087-3066">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3067">位於索引 2 的區域變數值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3068">`ldloc.2` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 2 的存取權的本機變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="c1087-3069">方法標頭中指定的本機變數的類型相同之值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="c1087-3070">小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-3071">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-3072">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3074">將位於索引 3 的區域變數載入至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3074">Loads the local variable at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3075">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3076">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3076">Format</span></span>|<span data-ttu-id="c1087-3077">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3077">Assembly Format</span></span>|<span data-ttu-id="c1087-3078">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3079">09</span><span class="sxs-lookup"><span data-stu-id="c1087-3079">09</span></span>|<span data-ttu-id="c1087-3080">ldloc.3</span><span class="sxs-lookup"><span data-stu-id="c1087-3080">ldloc.3</span></span>|<span data-ttu-id="c1087-3081">將位於索引 3 的區域變數載入至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="c1087-3082">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3083">位於索引 3 的區域變數值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3084">`ldloc.3` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 3 的存取權的本機變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="c1087-3085">方法標頭中指定的本機變數的類型相同之值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="c1087-3086">小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-3087">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-3088">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.3`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3090">載入位於指定索引的區域變數至評估堆疊 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3091">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3092">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3092">Format</span></span>|<span data-ttu-id="c1087-3093">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3093">Assembly Format</span></span>|<span data-ttu-id="c1087-3094">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-3096">ldloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-3096">ldloc.s `index`</span></span>|<span data-ttu-id="c1087-3097">載入位於索引的區域變數`index`至堆疊，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="c1087-3098">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3099">指定索引處的區域變數值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3100">`ldloc.s`指令會推入內容的本機變數數目在傳遞的索引至評估堆疊，區域變數所在及更新版本編號為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="c1087-3101">如果初始化旗標，方法是，則為 true，進入方法之前，本機變數會初始化為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="c1087-3102">有 256 (2 ^8) 中的區域變數可能 (0-255) 的簡短形式，這是以更有效率的編碼方式，就比`ldloc`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="c1087-3103">方法標頭中指定的本機變數的類型相同之值的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="c1087-3104">請參閱小於 4 個位元組會展開成輸入的資料分割 I.本機變數`int32`時載入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="c1087-3105">浮點數的值會展開成其原生的大小 (型別`F`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="c1087-3106">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3107">ILGenerator.Emit （OpCode、 LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="c1087-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="c1087-3108">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3109">載入位於指定索引的區域變數位址至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3110">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3111">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3111">Format</span></span>|<span data-ttu-id="c1087-3112">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3112">Assembly Format</span></span>|<span data-ttu-id="c1087-3113">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3114">FE OD &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="c1087-3115">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-3115">ldloca `index`</span></span>|<span data-ttu-id="c1087-3116">在本機變數的位址載入`index`至評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="c1087-3117">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3118">儲存在位於指定索引的區域變數的位址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3119">`ldloca`指令會推入本機變數的數字的位址傳遞的索引，到堆疊上，在本機變數所在及更新版本編號為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="c1087-3120">推送到堆疊上的值已正確對齊使用類似的指示<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。</span><span class="sxs-lookup"><span data-stu-id="c1087-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="c1087-3121">結果是暫時性的指標 (型別`*`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="c1087-3122">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloca`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3123">ILGenerator.Emit (OpCode，short)</span><span class="sxs-lookup"><span data-stu-id="c1087-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3124">載入位於指定索引的區域變數位址至評估堆疊 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3125">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3126">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3126">Format</span></span>|<span data-ttu-id="c1087-3127">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3127">Assembly Format</span></span>|<span data-ttu-id="c1087-3128">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-3130">ldloca.s `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-3130">ldloca.s `index`</span></span>|<span data-ttu-id="c1087-3131">在本機變數的位址載入`index`至評估堆疊，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="c1087-3132">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3133">儲存在位於指定索引的區域變數的位址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3134">`ldloca.s`指令會推入本機變數的數字的位址傳遞的索引，到堆疊上，在本機變數所在及更新版本編號為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="c1087-3135">推送到堆疊上的值已正確對齊使用類似的指示<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。</span><span class="sxs-lookup"><span data-stu-id="c1087-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="c1087-3136">結果是暫時性的指標 (型別`*`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="c1087-3137">`ldloca.s`指令可讓您提供有效的編碼方式，搭配本機變數 0 到 255 之間。</span><span class="sxs-lookup"><span data-stu-id="c1087-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="c1087-3138">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloca.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3139">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3140">推送 null 參考 (型別<see langword="O" />) 至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3141">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3142">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3142">Format</span></span>|<span data-ttu-id="c1087-3143">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3143">Assembly Format</span></span>|<span data-ttu-id="c1087-3144">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3145">14</span><span class="sxs-lookup"><span data-stu-id="c1087-3145">14</span></span>|<span data-ttu-id="c1087-3146">ldnull</span><span class="sxs-lookup"><span data-stu-id="c1087-3146">ldnull</span></span>|<span data-ttu-id="c1087-3147">推送至堆疊的 null 參考</span><span class="sxs-lookup"><span data-stu-id="c1087-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="c1087-3148">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3149">Null 物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3150">`ldnull` 推送 null 參考 (型別`O`) 堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="c1087-3151">這用來初始化位置，它們會填入資料之前，或當它們變成已被取代。</span><span class="sxs-lookup"><span data-stu-id="c1087-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="c1087-3152">`ldnull` 提供與大小無關的 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="c1087-3153">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldnull`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3155">複製位址所指向的實值類型物件到評估堆疊的頂端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3156">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3157">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3157">Format</span></span>|<span data-ttu-id="c1087-3158">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3158">Assembly Format</span></span>|<span data-ttu-id="c1087-3159">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3160">71 < `T` ></span></span>|<span data-ttu-id="c1087-3161">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="c1087-3161">ldobj `class`</span></span>|<span data-ttu-id="c1087-3162">複製實值型別執行個體`class`堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3163">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3164">實值型別物件的位址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3165">位址從堆疊推出，並在該特定位址的執行個體則會查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="c1087-3166">儲存在該位址之物件的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3167">`ldobj`指令用來做為參數傳遞實值類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="c1087-3168">`ldobj`指令會將複製所指向的值`addrOfValObj`(型別的`&`， `*`，或`native int`) 至堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="c1087-3169">複製的位元組數目取決於類別的大小 (依指定`class`參數)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="c1087-3170">`class`參數是代表實值型別中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="c1087-3171">營運`ldobj`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-3172"><xref:System.TypeLoadException> 如果找不到類別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="c1087-3173">這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-3174">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldobj`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3175">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3176">推送靜態欄位的值至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3176">Pushes the value of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3177">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3178">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3178">Format</span></span>|<span data-ttu-id="c1087-3179">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3179">Assembly Format</span></span>|<span data-ttu-id="c1087-3180">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3181">7E < `T` ></span></span>|<span data-ttu-id="c1087-3182">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="c1087-3182">ldsfld `field`</span></span>|<span data-ttu-id="c1087-3183">推播的值`field`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3184">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3185">特定欄位的值推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3186">`ldsfld`指令會推入靜態 （在類別的所有執行個體之間共用） 的值在堆疊上的欄位。</span><span class="sxs-lookup"><span data-stu-id="c1087-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="c1087-3187">傳遞的中繼資料語彙基元相關聯的傳回型別是`field`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="c1087-3188">`ldsfld`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="c1087-3189">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldsfld`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3190">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3191">推送靜態欄位的位址至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3191">Pushes the address of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3192">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3193">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3193">Format</span></span>|<span data-ttu-id="c1087-3194">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3194">Assembly Format</span></span>|<span data-ttu-id="c1087-3195">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3196">7F < `T` ></span></span>|<span data-ttu-id="c1087-3197">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="c1087-3197">ldsflda `field`</span></span>|<span data-ttu-id="c1087-3198">推播的位址`field`堆疊上</span><span class="sxs-lookup"><span data-stu-id="c1087-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="c1087-3199">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3200">特定欄位的位址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3201">`ldsflda`指令會推入靜態 （在類別的所有執行個體之間共用） 的位址欄位在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="c1087-3202">位址可表示為暫時性指標 (型別`*`) 如果中繼資料語彙基元`field`參考型別，其記憶體進行管理。</span><span class="sxs-lookup"><span data-stu-id="c1087-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="c1087-3203">否則，它會對應至的 unmanaged 指標 (型別`native int`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="c1087-3204">請注意，`field`可能是靜態全域具有相對虛擬位址 （其包含的 PE 檔案載入到記憶體的基底地址中的欄位位移） 的記憶體是未受管理的位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="c1087-3205">`ldsflda`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="c1087-3206"><xref:System.MissingFieldException> 如果在中繼資料中找不到欄位，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="c1087-3207">這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="c1087-3208">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldsflda`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3209">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3210">推送新的物件參考至儲存於中繼資料的字串常值 (String Literal)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3210">Pushes a new object reference to a string literal stored in the metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3211">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3212">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3212">Format</span></span>|<span data-ttu-id="c1087-3213">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3213">Assembly Format</span></span>|<span data-ttu-id="c1087-3214">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3215">72 < `T` ></span></span>|<span data-ttu-id="c1087-3216">ldstr `mdToken`</span><span class="sxs-lookup"><span data-stu-id="c1087-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="c1087-3217">將中繼資料字串語彙基元的字串物件推入`mdToken`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="c1087-3218">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3219">字串的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3220">`ldstr`指令會推入的物件參考 (型別`O`) 至新的字串物件，表示特定字串常值儲存在中繼資料。</span><span class="sxs-lookup"><span data-stu-id="c1087-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="c1087-3221">`ldstr`指令會配置必要的記憶體數量，並執行任何轉換的字串常值字串所需的格式在執行階段檔案中所使用的形式所需的格式轉換。</span><span class="sxs-lookup"><span data-stu-id="c1087-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="c1087-3222">Common Language Infrastructure (CLI) 可確保兩個結果`ldstr`指示參考兩個具有相同的字元序列的中繼資料語彙基元傳回精確的相同字串物件 （稱為 「 字串暫留 」 的程序）。</span><span class="sxs-lookup"><span data-stu-id="c1087-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="c1087-3223">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldstr`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3224">ILGenerator.Emit (OpCode 字串)</span><span class="sxs-lookup"><span data-stu-id="c1087-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3225">將中繼資料語彙基元轉換成它的執行階段表示，並將它推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3226">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3227">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3227">Format</span></span>|<span data-ttu-id="c1087-3228">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3228">Assembly Format</span></span>|<span data-ttu-id="c1087-3229">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3230">D0 < `T` ></span></span>|<span data-ttu-id="c1087-3231">ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="c1087-3231">ldtoken `token`</span></span>|<span data-ttu-id="c1087-3232">將中繼資料語彙基元轉換成它的執行階段表示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="c1087-3233">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3234">傳入的語彙基元轉換成`RuntimeHandle`並推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3235">`ldtoken`指示推播`RuntimeHandle`針對指定的中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="c1087-3236">A`RuntimeHandle`可以是`fieldref/fielddef`，則`methodref/methoddef`，或`typeref/typedef`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="c1087-3237">推送到堆疊上的值可用於呼叫`Reflection`系統類別庫中的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="c1087-3238">在執行階段控制代碼上的資訊，請參閱下列類別： <xref:System.RuntimeFieldHandle>， <xref:System.RuntimeTypeHandle>，和<xref:System.RuntimeMethodHandle>。</span><span class="sxs-lookup"><span data-stu-id="c1087-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="c1087-3239">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldtoken`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3240">ILGenerator.Emit （OpCode、 MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="c1087-3241">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="c1087-3242">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3243">推送的 unmanaged 的指標 (型別<see langword="native int" />) 實作與指定的物件至評估堆疊相關聯的特定虛擬方法的原生程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3244">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3245">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3245">Format</span></span>|<span data-ttu-id="c1087-3246">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3246">Assembly Format</span></span>|<span data-ttu-id="c1087-3247">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3248">FE 07 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="c1087-3249">v `method`</span><span class="sxs-lookup"><span data-stu-id="c1087-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="c1087-3250">將滑鼠指標物件的虛擬方法推入`method`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3251">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3252">物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3253">物件參考會從堆疊和進入點位址推出方法 (指定中繼資料語彙基元`method`) 查閱。</span><span class="sxs-lookup"><span data-stu-id="c1087-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="c1087-3254">將指標`method`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3255">產生的 unmanaged 的指標推入堆疊所`ldvirtftn`指令可以用來呼叫<xref:System.Reflection.Emit.OpCodes.Calli>看它所參考的 managed 的方法 （或從 managed 轉換到 unmanaged 程式碼 stub） 的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="c1087-3256">Unmanaged 的指標會指向使用 CLR 的呼叫慣例的原生程式碼。</span><span class="sxs-lookup"><span data-stu-id="c1087-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="c1087-3257">這個方法的指標不應該傳遞至未受管理的原生程式碼中，但會做為回呼常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="c1087-3258">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldvirtftn`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3259">ILGenerator.Emit （OpCode、 MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3260">結束程式碼的保護區，無條件地將控制權傳輸至特定的目標指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3261">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3262">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3262">Format</span></span>|<span data-ttu-id="c1087-3263">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3263">Assembly Format</span></span>|<span data-ttu-id="c1087-3264">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3265">DD < `int32` ></span></span>|<span data-ttu-id="c1087-3266">保留 `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-3266">leave `target`</span></span>|<span data-ttu-id="c1087-3267">結束程式碼的受保護的區域。</span><span class="sxs-lookup"><span data-stu-id="c1087-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="c1087-3268">不沒有指定這個指示任何堆疊轉換行為。</span><span class="sxs-lookup"><span data-stu-id="c1087-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-3269">`leave`指令無條件地將控制權傳輸至特定目標的指示，以 4 位元組帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-3270">`leave`指示大致`br`的指示，但它可以用來結束`try`， `filter`，或`catch`封鎖而一般的分支指令可以只能在這類區塊內的控制權轉移它。</span><span class="sxs-lookup"><span data-stu-id="c1087-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="c1087-3271">`leave`指令會清空評估堆疊，並確保適當的周圍`finally`區塊會執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="c1087-3272">您無法使用`leave`結束指令`finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="c1087-3273">為了簡化程式碼產生作業是使用在 catch 區塊內有效的例外狀況處理常式`leave`指令，以便將控制權移轉給中相關聯的任何指令`try`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="c1087-3274">指令會有一或多個前置詞程式碼，如果控制項只傳送至第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="c1087-3275">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`leave`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3276">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3277">結束程式碼的保護區，無條件地將控制權傳輸至目標指令 (簡短形式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3278">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3279">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3279">Format</span></span>|<span data-ttu-id="c1087-3280">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3280">Assembly Format</span></span>|<span data-ttu-id="c1087-3281">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3282">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3282">DE < `int8` ></span></span>|<span data-ttu-id="c1087-3283">leave.s `target`</span><span class="sxs-lookup"><span data-stu-id="c1087-3283">leave.s `target`</span></span>|<span data-ttu-id="c1087-3284">結束程式碼中，簡短形式的保護的區。</span><span class="sxs-lookup"><span data-stu-id="c1087-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="c1087-3285">不沒有指定這個指示任何堆疊轉換行為。</span><span class="sxs-lookup"><span data-stu-id="c1087-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-3286">`leave.s`指令無條件地將控制權傳輸至傳遞的目標的指示，以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="c1087-3287">`leave.s`指示大致`br`的指示，但它可以用來結束`try`， `filter`，或`catch`封鎖而一般的分支指令可以只能在這類區塊內的控制權轉移它。</span><span class="sxs-lookup"><span data-stu-id="c1087-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="c1087-3288">`leave.s`指令會清空評估堆疊，並確保適當的周圍`finally`區塊會執行。</span><span class="sxs-lookup"><span data-stu-id="c1087-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="c1087-3289">您無法使用`leave.s`結束指令`finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="c1087-3290">為了簡化程式碼產生作業是使用在 catch 區塊內有效的例外狀況處理常式`leave.s`指令，以便將控制權移轉給中相關聯的任何指令`try`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="c1087-3291">指令會有一或多個前置詞程式碼，如果控制項只傳送至第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="c1087-3292">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`leave.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3293">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3294">從區域動態記憶體集區中配置某些數量的位元組，並將推送的位址 (暫時性指標，類型<see langword="*" />) 至評估堆疊的第一個配置的位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3295">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3296">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3296">Format</span></span>|<span data-ttu-id="c1087-3297">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3297">Assembly Format</span></span>|<span data-ttu-id="c1087-3298">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="c1087-3299">FE 0F</span></span>|<span data-ttu-id="c1087-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="c1087-3300">localloc</span></span>|<span data-ttu-id="c1087-3301">從本機堆積中配置空間。</span><span class="sxs-lookup"><span data-stu-id="c1087-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="c1087-3302">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3303">要配置的位元組數目會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3304">從堆疊; 彈出的位元組數目，本機堆積中配置的大小所對應的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="c1087-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="c1087-3305">配置的記憶體中的第一個位元組的指標會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3306">`localloc`指令會配置`size`(型別`natural unsigned int`) 個位元組，從區域動態記憶體集區，並將位址傳回 (暫時性指標，類型`*`) 的第一個配置的位元組。</span><span class="sxs-lookup"><span data-stu-id="c1087-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="c1087-3307">方法上的初始化旗標才會初始化為 0 的記憶體區塊傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="c1087-3308">當目前的方法執行<xref:System.Reflection.Emit.OpCodes.Ret>，本機記憶體集區將可重複使用。</span><span class="sxs-lookup"><span data-stu-id="c1087-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="c1087-3309">產生的位址，讓任何基本資料型別可以儲存在該處使用對齊`stind`指示 (例如<xref:System.Reflection.Emit.OpCodes.Stind_I4>) 並載入使用`ldind`指示 (例如<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="c1087-3310">`localloc`指令不能出現在`filter`， `catch`， `finally`，或`fault`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="c1087-3311"><xref:System.StackOverflowException> 如果沒有記憶體不足，無法服務要求，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="c1087-3312">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`localloc`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3314">將特定類型的執行個體之類型參考推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3315">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3316">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3316">Format</span></span>|<span data-ttu-id="c1087-3317">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3317">Assembly Format</span></span>|<span data-ttu-id="c1087-3318">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3319">C6 < `T` ></span></span>|<span data-ttu-id="c1087-3320">mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="c1087-3320">mkrefany `class`</span></span>|<span data-ttu-id="c1087-3321">類型的類型的參考推送`class`至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3322">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3323">指標的資料推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3324">指標是快顯，轉換成具類型的參考型別的`class`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="c1087-3325">具類型的參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3326">`mkrefany`指示支援的動態類型的參考傳遞。</span><span class="sxs-lookup"><span data-stu-id="c1087-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="c1087-3327">類型必須是指標`&`， `*`，或`native int`，並保留一段資料的有效位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="c1087-3328">`Class` 類別的語彙基元所描述指標所參考的資料的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="c1087-3329">`Mkrefany` 在堆疊上，提供不透明的描述元的指標和類型的類型的參考推送`class`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="c1087-3330">唯一有效的作業允許的型別參考時，就是將它傳遞至要求做為參數的型別的參考的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="c1087-3331">被呼叫者接著可以使用<xref:System.Reflection.Emit.OpCodes.Refanytype>和<xref:System.Reflection.Emit.OpCodes.Refanyval>分別擷取的型別 （類別） 與位址的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="c1087-3332"><xref:System.TypeLoadException> 如果擲回`class`找不到。</span><span class="sxs-lookup"><span data-stu-id="c1087-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="c1087-3333">這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-3334">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mkrefany`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3335">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3336">將兩個值相乘，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3336">Multiplies two values and pushes the result on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3337">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3338">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3338">Format</span></span>|<span data-ttu-id="c1087-3339">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3339">Assembly Format</span></span>|<span data-ttu-id="c1087-3340">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3341">5A</span><span class="sxs-lookup"><span data-stu-id="c1087-3341">5A</span></span>|<span data-ttu-id="c1087-3342">mul</span><span class="sxs-lookup"><span data-stu-id="c1087-3342">mul</span></span>|<span data-ttu-id="c1087-3343">將在堆疊上的兩個值相乘。</span><span class="sxs-lookup"><span data-stu-id="c1087-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3344">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3345">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3346">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3347">`value2` 和`value1`會彈出從堆疊;`value1`乘以`value2`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="c1087-3348">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3349">`mul`指示乘以`value1`由`value2`並將結果推至堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="c1087-3350">整數運算溢位截斷發生溢位較高的位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="c1087-3351">請參閱<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整數特定乘法運算溢位處理的作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="c1087-3352">浮點類型，0 \* 無限大 = NaN。</span><span class="sxs-lookup"><span data-stu-id="c1087-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="c1087-3353">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mul`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3355">將兩個整數值相乘、執行溢位檢查，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3356">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3357">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3357">Format</span></span>|<span data-ttu-id="c1087-3358">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3358">Assembly Format</span></span>|<span data-ttu-id="c1087-3359">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3360">D8</span><span class="sxs-lookup"><span data-stu-id="c1087-3360">D8</span></span>|<span data-ttu-id="c1087-3361">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="c1087-3361">mul.ovf</span></span>|<span data-ttu-id="c1087-3362">將具有溢位檢查的堆疊上的兩個整數值相乘。</span><span class="sxs-lookup"><span data-stu-id="c1087-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="c1087-3363">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3364">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3365">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3366">`value2` 和`value1`會彈出從堆疊;`value1`乘以`value2`，具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="c1087-3367">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3368">`mul.ovf`指示乘以整數`value1`整數`value2`並將結果推至堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="c1087-3369">如果結果無法納入結果類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="c1087-3370"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-3371">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mul.ovf`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3373">將兩個不帶正負號的整數值相乘、執行溢位檢查，再將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3374">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3375">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3375">Format</span></span>|<span data-ttu-id="c1087-3376">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3376">Assembly Format</span></span>|<span data-ttu-id="c1087-3377">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3378">D9</span><span class="sxs-lookup"><span data-stu-id="c1087-3378">D9</span></span>|<span data-ttu-id="c1087-3379">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="c1087-3379">mul.ovf.un</span></span>|<span data-ttu-id="c1087-3380">將具有溢位檢查的堆疊上的兩個不帶正負號的值相乘。</span><span class="sxs-lookup"><span data-stu-id="c1087-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="c1087-3381">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3382">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3383">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3384">`value2` 和`value1`會彈出從堆疊;`value1`乘以`value2`，具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="c1087-3385">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3386">`mul.ovf.un`指示乘以不帶正負號的整數`value1`不帶正負號的整數`value2`並將結果推至堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="c1087-3387">如果結果無法納入結果類型，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="c1087-3388"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-3389">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mul.ovf.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3391">將值變成相反值，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3391">Negates a value and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3392">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3393">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3393">Format</span></span>|<span data-ttu-id="c1087-3394">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3394">Assembly Format</span></span>|<span data-ttu-id="c1087-3395">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3396">65</span><span class="sxs-lookup"><span data-stu-id="c1087-3396">65</span></span>|<span data-ttu-id="c1087-3397">neg</span><span class="sxs-lookup"><span data-stu-id="c1087-3397">neg</span></span>|<span data-ttu-id="c1087-3398">目前在堆疊頂端值的否定運算。</span><span class="sxs-lookup"><span data-stu-id="c1087-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3399">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3400">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3401">值是從堆疊推出，否定。</span><span class="sxs-lookup"><span data-stu-id="c1087-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="c1087-3402">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3403">`neg`指令執行值的否定運算，並將結果的堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="c1087-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="c1087-3404">傳回類型是運算元類型相同。</span><span class="sxs-lookup"><span data-stu-id="c1087-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="c1087-3405">整數值的否定是標準二補數否定。</span><span class="sxs-lookup"><span data-stu-id="c1087-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="c1087-3406">特別是，否定最大負數的數字 （但不需要正的對應項目） 會產生最大負數的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="c1087-3407">若要偵測此溢位，請使用<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>指令改為 （也就是減去 0）。</span><span class="sxs-lookup"><span data-stu-id="c1087-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="c1087-3408">將浮點數值不能溢位，並取消 NaN 會傳回 NaN。</span><span class="sxs-lookup"><span data-stu-id="c1087-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="c1087-3409">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`neg`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3411">將新的以零為起始一維陣列 (其項目屬於特定類型) 的物件參考推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3412">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3413">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3413">Format</span></span>|<span data-ttu-id="c1087-3414">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3414">Assembly Format</span></span>|<span data-ttu-id="c1087-3415">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3416">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3416">8D < `T` ></span></span>|<span data-ttu-id="c1087-3417">newarr `etype`</span><span class="sxs-lookup"><span data-stu-id="c1087-3417">newarr `etype`</span></span>|<span data-ttu-id="c1087-3418">建立新的陣列類型的項目`etype`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="c1087-3419">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3420">陣列中的項目數會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3421">項目數會從堆疊推出，並在建立陣列。</span><span class="sxs-lookup"><span data-stu-id="c1087-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="c1087-3422">新陣列的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3423">`newarr`指令會推入的物件參考 (型別`O`) 以其元素為型別的新之以零起始的一維陣列`etype`（中繼資料語彙基元來描述型別）。</span><span class="sxs-lookup"><span data-stu-id="c1087-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="c1087-3424">新陣列中的項目數應指定為`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="c1087-3425">陣列的有效索引範圍從零到最大項目數減一。</span><span class="sxs-lookup"><span data-stu-id="c1087-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="c1087-3426">陣列的項目可以是任何類型，包括實值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="c1087-3427">會使用參考適當的值類型的中繼資料語彙基元 」 來建立 「 數字的以零為起始的一維陣列 (<xref:System.Int32>等等)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="c1087-3428">陣列的元素會初始化為 0 或適當的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="c1087-3429">Nonzero-基礎的一維陣列和多維度陣列使用建立<xref:System.Reflection.Emit.OpCodes.Newobj>而非`newarr`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="c1087-3430">通常，在建立使用的方法<xref:System.Array>.NET Framework 中的類別。</span><span class="sxs-lookup"><span data-stu-id="c1087-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="c1087-3431"><xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="c1087-3432"><xref:System.OverflowException> 如果擲回`numElems`小於 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="c1087-3433">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`newarr`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3434">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3435">建立新的物件或實值類型，將物件參考的新執行個體 (型別<see langword="O" />) 至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3436">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3437">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3437">Format</span></span>|<span data-ttu-id="c1087-3438">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3438">Assembly Format</span></span>|<span data-ttu-id="c1087-3439">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3440">73 < `T` ></span></span>|<span data-ttu-id="c1087-3441">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="c1087-3441">newobj `ctor`</span></span>|<span data-ttu-id="c1087-3442">配置未初始化的物件或實值類型，並呼叫建構函式方法`ctor`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="c1087-3443">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3444">引數`arg1`透過`argn`序列中推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="c1087-3445">引數`argn`經由`arg1`會從堆疊推出，並傳遞至`ctor`建立物件。</span><span class="sxs-lookup"><span data-stu-id="c1087-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="c1087-3446">新的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3447">`newobj`指示會建立新的物件或實值類型的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="c1087-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="c1087-3448">`Ctor` 為中繼資料語彙基元 (`methodref`或`methoddef`，必須標示為建構函式)，表示名稱、 類別和建構函式呼叫的簽章。</span><span class="sxs-lookup"><span data-stu-id="c1087-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="c1087-3449">`newobj`指令會配置與相關聯類別的新執行個體`ctor`並初始化 0 （或適當的型別） 或 null 參考為適當的新執行個體中的所有欄位。</span><span class="sxs-lookup"><span data-stu-id="c1087-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="c1087-3450">然後它會呼叫建構函式`ctor`與指定的引數，以及新建立的執行個體。</span><span class="sxs-lookup"><span data-stu-id="c1087-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="c1087-3451">在呼叫建構函式之後，現在會初始化物件參考 (型別`O`) 推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="c1087-3452">從建構函式的觀點來看，未初始化的物件是引數 0，而其他引數傳遞至 newobj 順序。</span><span class="sxs-lookup"><span data-stu-id="c1087-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="c1087-3453">使用建立所有的以零為起始的一維陣列<xref:System.Reflection.Emit.OpCodes.Newarr>，而非`newobj`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="c1087-3454">相反地，所有其他陣列 （一個維度，或是一維但不是以零為起始） 會建立使用`newobj`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="c1087-3455">實值型別不通常會建立使用`newobj`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="c1087-3456">通常會配置做為引數或區域變數，使用`newarr`（適用於以零為起始的一維陣列），或做為欄位的物件。</span><span class="sxs-lookup"><span data-stu-id="c1087-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="c1087-3457">配置之後，它們會初始化使用<xref:System.Reflection.Emit.OpCodes.Initobj>。</span><span class="sxs-lookup"><span data-stu-id="c1087-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="c1087-3458">不過，`newobj`指令可以用來建立實值類型的新執行個體上的堆疊，然後當做引數，儲存在區域變數中等等。</span><span class="sxs-lookup"><span data-stu-id="c1087-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="c1087-3459"><xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="c1087-3460"><xref:System.MissingMethodException> 如果建構函式方法會擲回`ctor`使用指定的名稱、 類別和簽章找不到。</span><span class="sxs-lookup"><span data-stu-id="c1087-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="c1087-3461">這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-3462">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`newobj`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3463">ILGenerator.Emit （OpCode、 ConstructorInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3464">如果已完成修補作業碼，則填滿空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3464">Fills space if opcodes are patched.</span>
          </span>
          <span data-ttu-id="c1087-3465">雖然會耗用處理循環，卻不會執行任何有意義的運算。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3465">No meaningful operation is performed although a processing cycle can be consumed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3466">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3467">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3467">Format</span></span>|<span data-ttu-id="c1087-3468">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3468">Assembly Format</span></span>|<span data-ttu-id="c1087-3469">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3470">00</span><span class="sxs-lookup"><span data-stu-id="c1087-3470">00</span></span>|<span data-ttu-id="c1087-3471">nop</span><span class="sxs-lookup"><span data-stu-id="c1087-3471">nop</span></span>|<span data-ttu-id="c1087-3472">執行作業而不需要的行為。</span><span class="sxs-lookup"><span data-stu-id="c1087-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="c1087-3473">定義這個指示沒有堆疊轉換行為。</span><span class="sxs-lookup"><span data-stu-id="c1087-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-3474">`nop`作業不執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="c1087-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="c1087-3475">它被用來填滿空間中，如果修補作業碼。</span><span class="sxs-lookup"><span data-stu-id="c1087-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="c1087-3476">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`nop`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3478">計算堆疊頂端的整數值的位元補數 (Complement)，並將結果當做相同類型來推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3479">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3480">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3480">Format</span></span>|<span data-ttu-id="c1087-3481">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3481">Assembly Format</span></span>|<span data-ttu-id="c1087-3482">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3483">66</span><span class="sxs-lookup"><span data-stu-id="c1087-3483">66</span></span>|<span data-ttu-id="c1087-3484">not</span><span class="sxs-lookup"><span data-stu-id="c1087-3484">not</span></span>|<span data-ttu-id="c1087-3485">計算值的位元補數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="c1087-3486">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3487">`value` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3488">`value` 會從堆疊和其位元推出計算的補數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="c1087-3489">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3490">`not`指令會計算整數值的位元補數，並推送至堆疊的結果。</span><span class="sxs-lookup"><span data-stu-id="c1087-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="c1087-3491">傳回類型是運算元類型相同。</span><span class="sxs-lookup"><span data-stu-id="c1087-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="c1087-3492">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`not`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3494">計算堆疊頂端兩個整數值的位元補數，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3495">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3496">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3496">Format</span></span>|<span data-ttu-id="c1087-3497">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3497">Assembly Format</span></span>|<span data-ttu-id="c1087-3498">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3499">60</span><span class="sxs-lookup"><span data-stu-id="c1087-3499">60</span></span>|<span data-ttu-id="c1087-3500">或</span><span class="sxs-lookup"><span data-stu-id="c1087-3500">or</span></span>|<span data-ttu-id="c1087-3501">計算位元，或兩個整數值，傳回一個整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="c1087-3502">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3503">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3504">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3505">`value2` 和`value1`會彈出從堆疊和其位元 OR 運算計算。</span><span class="sxs-lookup"><span data-stu-id="c1087-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="c1087-3506">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3507">`or`指令會計算位於堆疊中，頂端的兩個值的位元 OR，推送到堆疊上的結果。</span><span class="sxs-lookup"><span data-stu-id="c1087-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3508">`Or` 是整數特定作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="c1087-3509">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`or`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3511">目前在評估堆疊頂端移除值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3511">Removes the value currently on top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3512">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3513">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3513">Format</span></span>|<span data-ttu-id="c1087-3514">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3514">Assembly Format</span></span>|<span data-ttu-id="c1087-3515">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3516">26</span><span class="sxs-lookup"><span data-stu-id="c1087-3516">26</span></span>|<span data-ttu-id="c1087-3517">pop</span><span class="sxs-lookup"><span data-stu-id="c1087-3517">pop</span></span>|<span data-ttu-id="c1087-3518">從最高的值從堆疊中取出。</span><span class="sxs-lookup"><span data-stu-id="c1087-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3519">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3520">最高的值是從堆疊取出。</span><span class="sxs-lookup"><span data-stu-id="c1087-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="c1087-3521">`pop`指令從堆疊移除最上層的項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="c1087-3522">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`pop`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3524">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3524">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3525">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3525">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3526">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3526">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3527">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3527">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3528">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3528">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3529">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3529">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3530">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3530">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3531">這是保留的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3531">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3532">指定後續陣列位址作業在執行階段不執行任何類型檢查，且會傳回限制其變動性的 Managed 指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3533">下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3534">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3534">Format</span></span>|<span data-ttu-id="c1087-3535">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3535">Assembly Format</span></span>|<span data-ttu-id="c1087-3536">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="c1087-3537">FE 1E</span></span>|<span data-ttu-id="c1087-3538">readonly。</span><span class="sxs-lookup"><span data-stu-id="c1087-3538">readonly.</span></span>|<span data-ttu-id="c1087-3539">指定後續陣列位址作業會執行任何型別檢查，在執行階段，以及它與受限制的可變動性，傳回的 managed 的指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="c1087-3540">此前置詞只能出現正前面`ldelema`指令和呼叫特殊`Address`陣列上的方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="c1087-3541">其會影響後續的作業有兩個：</span><span class="sxs-lookup"><span data-stu-id="c1087-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="c1087-3542">在執行階段類型檢查會不執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="c1087-3543">請注意，正常的隱含型別檢查`ldelema`和`stelem`指示在參考上使用時輸入陣列。</span><span class="sxs-lookup"><span data-stu-id="c1087-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="c1087-3544">都不會實值類別的執行階段類型檢查因此`readonly`在此情況下會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="c1087-3545">驗證器視為的 managed 指標與受限制的可變動性的地址的作業結果。</span><span class="sxs-lookup"><span data-stu-id="c1087-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="c1087-3546">指標則稱為已限制可變動性，因為定義的型別可讓您控制是否可以變更值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="c1087-3547">公開 （expose） 沒有公用欄位或更新進行中的值的方法的實值類別，指標是唯讀的 (因此前置詞的名稱)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="c1087-3548">特別的是，表示基本類型 (例如 System.Int32) 的類別不會公開 mutator，並因此處於唯讀狀態。</span><span class="sxs-lookup"><span data-stu-id="c1087-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="c1087-3549">這種方式在受限制的 managed 的指標只能用於透過下列方式：</span><span class="sxs-lookup"><span data-stu-id="c1087-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="c1087-3550">作為`object`參數`ldfld`， `ldflda`， `stfld`， `call`，或`constrained callvirt`指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="c1087-3551">作為`pointer`參數來`ldobj`指示或其中一個`ldind`指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="c1087-3552">作為`source`參數來`cpobj`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="c1087-3553">所有其他作業，包括`stobj`， `initobj`，或`mkrefany`作業，或任何`stind`指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="c1087-3554">目的`readonly`前置詞是以擷取從泛型程式碼中陣列的項目時，避免類型檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="c1087-3555">例如，運算式`arr[i].m()`，其中的項目類型的陣列`arr`限定於都有一個介面以方法為泛型型別`m`，可能會編譯為下列的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="c1087-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="c1087-3556">不含`readonly`前置詞，`ldelema`指令會執行類型檢查，萬一其中 ！ 0 是參考型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="c1087-3557">不只是這個型別檢查效率不佳，但語意不正確。</span><span class="sxs-lookup"><span data-stu-id="c1087-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="c1087-3558">型別檢查`ldelema`完全相符，也就是太強式。</span><span class="sxs-lookup"><span data-stu-id="c1087-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="c1087-3559">如果陣列類型的子類別 ！ 0，上述程式碼將會失敗類型檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="c1087-3560">陣列元素的位址會擷取，而不是項目本身，才會有的控制代碼`arr[i]`適用於同時實值類型和參考型別，並因此可以傳遞至`constrained callvirt`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="c1087-3561">一般情況下會略過執行階段檢查，如果陣列是參考類型的項目不安全。</span><span class="sxs-lookup"><span data-stu-id="c1087-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="c1087-3562">為了安全起見，就必須確保對陣列進行任何修改都會經過這個指標。</span><span class="sxs-lookup"><span data-stu-id="c1087-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="c1087-3563">驗證器規則，請確定這。</span><span class="sxs-lookup"><span data-stu-id="c1087-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="c1087-3564">受限制的 managed 的指標可以傳遞做為物件的執行個體方法呼叫，因此它不是嚴格來說唯讀的實值型別，但是是實值型別沒有型別安全問題。</span><span class="sxs-lookup"><span data-stu-id="c1087-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="c1087-3565">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`readonly`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3567">擷取內嵌於類型參考中的類型語彙基元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3567">Retrieves the type token embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3568">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3569">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3569">Format</span></span>|<span data-ttu-id="c1087-3570">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3570">Assembly Format</span></span>|<span data-ttu-id="c1087-3571">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="c1087-3572">FE 1D</span></span>|<span data-ttu-id="c1087-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="c1087-3573">refanytype</span></span>|<span data-ttu-id="c1087-3574">將推送儲存在具類型的參考型別語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="c1087-3575">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3576">實值類型參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3577">具類型的參考會從堆疊推出，並擷取其對應的型別語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="c1087-3578">型別語彙基元會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3579">具類型的參考包含型別語彙基元和物件執行個體的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="c1087-3580">`refanytype`指令擷取內嵌於型別參考中的型別語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="c1087-3581">請參閱<xref:System.Reflection.Emit.OpCodes.Mkrefany>指令，如需建立資訊型別參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="c1087-3582">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`refanytype`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3584">擷取位址 (型別<see langword="&amp;" />) 內嵌在具類型的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3585">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3586">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3586">Format</span></span>|<span data-ttu-id="c1087-3587">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3587">Assembly Format</span></span>|<span data-ttu-id="c1087-3588">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3589">C2 < `T` ></span></span>|<span data-ttu-id="c1087-3590">refanyval `type`</span><span class="sxs-lookup"><span data-stu-id="c1087-3590">refanyval `type`</span></span>|<span data-ttu-id="c1087-3591">將推送儲存在具類型參考的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="c1087-3592">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3593">實值類型參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3594">具類型的參考會從堆疊推出，擷取對應的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="c1087-3595">地址推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3596">具類型的參考包含型別語彙基元和物件執行個體的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="c1087-3597">`refanyval`指令會擷取內嵌於位址的型別的參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="c1087-3598">內嵌在堆疊上提供的型別參考的型別必須符合所指定的型別`type`(中繼資料語彙基元，請`typedef`或`typeref`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="c1087-3599">請參閱<xref:System.Reflection.Emit.OpCodes.Mkrefany>相關內容的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="c1087-3600"><xref:System.InvalidCastException> 如果擲回`type`不等於儲存在型別參考的型別 (在此情況下，`type`類別提供給<xref:System.Reflection.Emit.OpCodes.Mkrefany>建構的指示所說的具類型的參考)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="c1087-3601"><xref:System.TypeLoadException> 如果擲回`type`找不到。</span><span class="sxs-lookup"><span data-stu-id="c1087-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="c1087-3602">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`refanyval`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3603">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3604">將兩個值相除，並將餘數推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3604">Divides two values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3605">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3606">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3606">Format</span></span>|<span data-ttu-id="c1087-3607">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3607">Assembly Format</span></span>|<span data-ttu-id="c1087-3608">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3609">5D</span><span class="sxs-lookup"><span data-stu-id="c1087-3609">5D</span></span>|<span data-ttu-id="c1087-3610">rem</span><span class="sxs-lookup"><span data-stu-id="c1087-3610">rem</span></span>|<span data-ttu-id="c1087-3611">將餘數推送`value1`由`value2`至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="c1087-3612">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3612">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3613">A`value1`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3613">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3614">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3614">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3615">`value2` 並`value1`與在堆疊的其餘部分會彈出`value1` `div` `value2`計算。</span><span class="sxs-lookup"><span data-stu-id="c1087-3615">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="c1087-3616">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3616">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3617">`result` = `value1` `rem` `value2` 符合下列條件：</span><span class="sxs-lookup"><span data-stu-id="c1087-3617">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="c1087-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`)，以及：</span><span class="sxs-lookup"><span data-stu-id="c1087-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="c1087-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;，符號 (`result`) = 號 (`value1`)，其中`div`推向零會截斷除法指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="c1087-3620">如果`value2`為零或`value1`是的無限大的結果為 NaN。</span><span class="sxs-lookup"><span data-stu-id="c1087-3620">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="c1087-3621">如果`value2`是無限大，結果就是`value1`(否定的`-infinity`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3621">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="c1087-3622">整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。</span><span class="sxs-lookup"><span data-stu-id="c1087-3622">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="c1087-3623">請注意，在 Intel 平台上<xref:System.OverflowException>計算時，會擲回 (minint `rem` -1)。</span><span class="sxs-lookup"><span data-stu-id="c1087-3623">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="c1087-3624">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`rem`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3626">將兩個不帶正負號的值相除，並將餘數推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3626">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3627">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3628">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3628">Format</span></span>|<span data-ttu-id="c1087-3629">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3629">Assembly Format</span></span>|<span data-ttu-id="c1087-3630">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3631">5E</span><span class="sxs-lookup"><span data-stu-id="c1087-3631">5E</span></span>|<span data-ttu-id="c1087-3632">rem.un</span><span class="sxs-lookup"><span data-stu-id="c1087-3632">rem.un</span></span>|<span data-ttu-id="c1087-3633">將餘數推送不帶正負號`value1`的不帶正負號`value2`至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3633">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3634">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3635">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3635">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3636">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3636">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3637">`value2` 並`value1`與在堆疊的其餘部分會彈出`value1` `div` `value2`計算。</span><span class="sxs-lookup"><span data-stu-id="c1087-3637">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="c1087-3638">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3638">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3639">`result` = `value1` `rem.un` `value2` 符合下列條件：</span><span class="sxs-lookup"><span data-stu-id="c1087-3639">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="c1087-3640">`result` = `value1` - `value2` x (`value1` `div.un` `value2`)，以及：</span><span class="sxs-lookup"><span data-stu-id="c1087-3640">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="c1087-3641">0 = `result`  <  `value2`，其中`div.un`為不帶正負號的除法指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-3641">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="c1087-3642">`rem.un`指示計算`result`並將其推送到堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3642">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="c1087-3643">`Rem.un` 其引數視為不帶正負號的整數，而<xref:System.Reflection.Emit.OpCodes.Rem>將它們視為為帶正負號的整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3643">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="c1087-3644">`Rem.un` 未指定為浮點數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3644">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="c1087-3645">整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。</span><span class="sxs-lookup"><span data-stu-id="c1087-3645">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="c1087-3646">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`rem.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3646">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3647">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3647">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3648">從目前方法傳回，將被呼叫端評估堆疊的傳回值 (如果有) 推送至呼叫端的評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3648">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3649">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3649">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3650">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3650">Format</span></span>|<span data-ttu-id="c1087-3651">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3651">Assembly Format</span></span>|<span data-ttu-id="c1087-3652">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3652">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3653">2A</span><span class="sxs-lookup"><span data-stu-id="c1087-3653">2A</span></span>|<span data-ttu-id="c1087-3654">ret</span><span class="sxs-lookup"><span data-stu-id="c1087-3654">ret</span></span>|<span data-ttu-id="c1087-3655">從方法傳回，可能傳回值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3655">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="c1087-3656">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3656">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3657">傳回值會從被呼叫端評估堆疊推出。</span><span class="sxs-lookup"><span data-stu-id="c1087-3657">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3658">步驟 1 中取得的傳回值會推入至呼叫端評估堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3658">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="c1087-3659">如果傳回的值不存在，被呼叫端評估堆疊上，會傳回任何值 （沒有被呼叫端或呼叫端的方法使用 stack 轉換將行為）。</span><span class="sxs-lookup"><span data-stu-id="c1087-3659">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="c1087-3660">類型的傳回值，如果有的話，目前的方法會決定從堆疊的頂端和複製到堆疊呼叫目前方法的方法中擷取值的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-3660">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="c1087-3661">評估堆疊目前的方法必須是空的除了要傳回的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3661">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="c1087-3662">`ret`指令不能用於 out 的控制權轉移`try`， `filter`， `catch`，或`finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3662">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="c1087-3663">內在`try`或`catch`，使用<xref:System.Reflection.Emit.OpCodes.Leave>指令，目的地為`ret`之外所有封入的例外狀況區塊的指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-3663">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="c1087-3664">因為`filter`和`finally`區塊在邏輯上是例外狀況處理與不在其中內嵌程式碼方法的組件、 正確地產生的 Microsoft Intermediate Language (MSIL) 指示不會執行方法會傳回從`filter`或`finally`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3664">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="c1087-3665">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ret`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3665">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3666">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3666">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3667">重新擲回目前的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3667">Rethrows the current exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3668">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3668">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3669">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3669">Format</span></span>|<span data-ttu-id="c1087-3670">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3670">Assembly Format</span></span>|<span data-ttu-id="c1087-3671">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3671">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3672">FE 1A</span><span class="sxs-lookup"><span data-stu-id="c1087-3672">FE 1A</span></span>|<span data-ttu-id="c1087-3673">重新擲回</span><span class="sxs-lookup"><span data-stu-id="c1087-3673">rethrow</span></span>|<span data-ttu-id="c1087-3674">會重新擲回目前例外狀況</span><span class="sxs-lookup"><span data-stu-id="c1087-3674">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="c1087-3675">這個指示不定義任何堆疊轉換行為。</span><span class="sxs-lookup"><span data-stu-id="c1087-3675">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-3676">`rethrow`指示只允許的主體內`catch`處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1087-3676">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="c1087-3677">它會擲回相同這個處理常式所攔截的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-3677">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="c1087-3678">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`rethrow`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3678">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3679">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3679">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3680">將整數值向左移 (使用零) 指定的位元數，將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3680">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3681">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3681">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3682">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3682">Format</span></span>|<span data-ttu-id="c1087-3683">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3683">Assembly Format</span></span>|<span data-ttu-id="c1087-3684">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3684">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3685">62</span><span class="sxs-lookup"><span data-stu-id="c1087-3685">62</span></span>|<span data-ttu-id="c1087-3686">shl</span><span class="sxs-lookup"><span data-stu-id="c1087-3686">shl</span></span>|<span data-ttu-id="c1087-3687">將左側 （移位零） 的整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3687">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="c1087-3688">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3688">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3689">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3689">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3690">要移位的位元數量會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3690">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3691">要移位的位元數和值會彈出從堆疊;值是向左移位指定的位元數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3691">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="c1087-3692">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3692">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3693">`shl`指示移位值 (型別`int32`，`int64`或`native int`) 所指定的位元數留下。</span><span class="sxs-lookup"><span data-stu-id="c1087-3693">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="c1087-3694">位元數是類型的值`int32`或`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3694">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="c1087-3695">要移位的位元數字是否大於或等於所提供的值的寬度 （以位元為單位），會指定傳回的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3695">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="c1087-3696">`Shl` 在每個排班上最低的位置插入零值的位元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3696">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="c1087-3697">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`shl`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3699">將整數值 (使用正負號) 向右移指定的位元數，將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3699">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3700">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3701">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3701">Format</span></span>|<span data-ttu-id="c1087-3702">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3702">Assembly Format</span></span>|<span data-ttu-id="c1087-3703">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3704">63</span><span class="sxs-lookup"><span data-stu-id="c1087-3704">63</span></span>|<span data-ttu-id="c1087-3705">shr</span><span class="sxs-lookup"><span data-stu-id="c1087-3705">shr</span></span>|<span data-ttu-id="c1087-3706">整數，會向右位移 （移位正負號）。</span><span class="sxs-lookup"><span data-stu-id="c1087-3706">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="c1087-3707">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3708">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3708">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3709">要移位的位元數量會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3709">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3710">要移位的位元數和值會彈出從堆疊;值是向右移位指定的位元數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3710">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="c1087-3711">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3711">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3712">`shr.un`指示移位值 (型別`int32`，`int64`或`native int`) 權限所指定的位元數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3712">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="c1087-3713">位元數是類型的值`int32`或`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3713">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="c1087-3714">要移位的位元數字是否大於或等於所提供的值的寬度 （以位元為單位），會指定傳回的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3714">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="c1087-3715">`Shr` 複寫在每個排班，保留原始值的正負號位元的高序位`result`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3715">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="c1087-3716">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`shr`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3716">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3717">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3717">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3718">將不帶正負號的整數值 (使用零) 向右移指定的位元數，將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3718">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3719">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3719">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3720">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3720">Format</span></span>|<span data-ttu-id="c1087-3721">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3721">Assembly Format</span></span>|<span data-ttu-id="c1087-3722">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3722">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3723">64</span><span class="sxs-lookup"><span data-stu-id="c1087-3723">64</span></span>|<span data-ttu-id="c1087-3724">shr.un</span><span class="sxs-lookup"><span data-stu-id="c1087-3724">shr.un</span></span>|<span data-ttu-id="c1087-3725">整數，會向右位移 （移位零）。</span><span class="sxs-lookup"><span data-stu-id="c1087-3725">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="c1087-3726">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3726">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3727">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3727">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3728">要移位的位元數量會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3728">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3729">要移位的位元數和值會彈出從堆疊;值是向右移位指定的位元數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3729">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="c1087-3730">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3730">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3731">`shr.un`指示移位值 (型別`int32`，`int64`或`native int`) 權限所指定的位元數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3731">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="c1087-3732">位元數是類型的值`int32`，`int64`或`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3732">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="c1087-3733">要移位的位元數字是否大於或等於所提供的值的寬度 （以位元為單位），會指定傳回的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3733">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="c1087-3734">`Shr.un` 將零位元插入每個排班的最高位置。</span><span class="sxs-lookup"><span data-stu-id="c1087-3734">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="c1087-3735">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`shr.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3735">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3736">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3736">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3737">將所提供實值類型的大小推送至評估堆疊 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3737">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3738">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3738">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3739">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3739">Format</span></span>|<span data-ttu-id="c1087-3740">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3740">Assembly Format</span></span>|<span data-ttu-id="c1087-3741">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3741">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3742">FE 1C < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3742">FE 1C < `T` ></span></span>|<span data-ttu-id="c1087-3743">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="c1087-3743">sizeof `valType`</span></span>|<span data-ttu-id="c1087-3744">推送大小，以位元組為單位為實值型別`unsigned int32`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3744">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="c1087-3745">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3745">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3746">提供的值類型的大小 （以位元組為單位） (`valType`) 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3746">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3747">`valType` 必須是中繼資料語彙基元 (`typeref`或`typedef`)，在指定實值型別、 參考類型或泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3747">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="c1087-3748">對於參考類型，傳回的大小會是對應的參考值的大小類型 （32 位元系統上的 4 位元組），不是參考值所參考之物件中儲存之資料的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-3748">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="c1087-3749">泛型類型參數僅用於型別或其定義的方法主體中。</span><span class="sxs-lookup"><span data-stu-id="c1087-3749">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="c1087-3750">該類型或方法具現化時，由實值類型或參考類型取代泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3750">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="c1087-3751">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sizeof`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3751">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3752">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3752">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3753">在指定索引的引數槽中將值存放在評估堆疊的頂端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3753">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3754">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3754">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3755">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3755">Format</span></span>|<span data-ttu-id="c1087-3756">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3756">Assembly Format</span></span>|<span data-ttu-id="c1087-3757">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3757">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3758">FE 0B &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3758">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="c1087-3759">starg `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-3759">starg `num`</span></span>|<span data-ttu-id="c1087-3760">取出從堆疊頂端的值，並將它儲存在引數位置`num`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3760">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="c1087-3761">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3761">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3762">取出目前堆疊頂端值，並放在引數位置`num`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3762">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="c1087-3763">`starg`指令從堆疊取出值，並將它放在引數位置`num`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3763">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="c1087-3764">值的類型必須符合目前的方法簽章中指定的引數的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3764">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-3765">使用變數引數清單的程序`starg`指示可以僅用於初始的固定引數，不是這些簽章的變動部分。</span><span class="sxs-lookup"><span data-stu-id="c1087-3765">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="c1087-3766">執行成存放小於 4 個位元組的整數值的引數的存放區會截斷值，從堆疊移到引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3766">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="c1087-3767">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-3767">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-3768">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`starg`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3768">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3769">ILGenerator.Emit (OpCode，short)</span><span class="sxs-lookup"><span data-stu-id="c1087-3769">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3770">在指定索引 (簡短形式) 的引數位置中將值儲存於評估堆疊的頂端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3770">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3771">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3771">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3772">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3772">Format</span></span>|<span data-ttu-id="c1087-3773">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3773">Assembly Format</span></span>|<span data-ttu-id="c1087-3774">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3774">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3775">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3775">10 < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-3776">starg.s `num`</span><span class="sxs-lookup"><span data-stu-id="c1087-3776">starg.s `num`</span></span>|<span data-ttu-id="c1087-3777">取出從堆疊頂端的值，並將它儲存在引數位置`num`，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-3777">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="c1087-3778">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3778">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3779">取出目前堆疊頂端值，並放在引數位置`num`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3779">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="c1087-3780">`starg.s`指令從堆疊取出值，並將它放在引數位置`num`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3780">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="c1087-3781">值的類型必須符合目前的方法簽章中指定的引數的類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-3781">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="c1087-3782">`starg.s`指令可讓您提供有效的編碼方式，與前 256 個引數搭配使用。</span><span class="sxs-lookup"><span data-stu-id="c1087-3782">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="c1087-3783">使用變數引數清單的程序`starg.s`指示可以僅用於初始的固定引數，不是這些簽章的變動部分。</span><span class="sxs-lookup"><span data-stu-id="c1087-3783">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="c1087-3784">執行成存放小於 4 個位元組的整數值的引數的存放區會截斷值，從堆疊移到引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-3784">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="c1087-3785">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-3785">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-3786">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`starg.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3786">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3787">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-3787">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3788">使用評估堆疊上的值 (其類型在指令中指定)，取代在指定之索引處的陣列項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3788">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3789">下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3789">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3790">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3790">Format</span></span>|<span data-ttu-id="c1087-3791">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3791">Assembly Format</span></span>|<span data-ttu-id="c1087-3792">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3792">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3793">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3793">A4 < `T` ></span></span>|<span data-ttu-id="c1087-3794">stelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="c1087-3794">stelem `typeTok`</span></span>|<span data-ttu-id="c1087-3795">取代類型的值中提供的索引處的陣列項目`typeTok`堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3795">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3796">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3796">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3797">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3797">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3798">索引值時，`index`中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3798">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3799">在指令中指定之型別的值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3799">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3800">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3800">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3801">`stelem`指示取代的一維陣列中提供之以零起始的索引處的項目值`array`的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3801">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="c1087-3802">此值有語彙基元所指定的型別`typeTok`指令中。</span><span class="sxs-lookup"><span data-stu-id="c1087-3802">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="c1087-3803">陣列也是物件，表示型別的值`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3803">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3804">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3804">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3805"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3805"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3806"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3806"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3807"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3807"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3808">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3808">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3809">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-3809">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3810">取代具有指定索引處的陣列元素<see langword="native int" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3810">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3811">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3811">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3812">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3812">Format</span></span>|<span data-ttu-id="c1087-3813">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3813">Assembly Format</span></span>|<span data-ttu-id="c1087-3814">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3814">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3815">9B</span><span class="sxs-lookup"><span data-stu-id="c1087-3815">9B</span></span>|<span data-ttu-id="c1087-3816">stelem.i</span><span class="sxs-lookup"><span data-stu-id="c1087-3816">stelem.i</span></span>|<span data-ttu-id="c1087-3817">在使用提供的索引陣列項目取代`native int`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3817">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3818">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3818">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3819">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3819">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3820">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3820">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3821">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3821">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3822">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3822">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3823">`stelem.i`指令會取代項目的值`index`中的一維陣列`array`使用`native int`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3823">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3824">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3824">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3825">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3825">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3826"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3826"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3827"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3827"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3828"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3828"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3829">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3829">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3830">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3830">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3831">取代具有指定索引處的陣列元素<see langword="int8" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3831">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3832">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3832">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3833">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3833">Format</span></span>|<span data-ttu-id="c1087-3834">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3834">Assembly Format</span></span>|<span data-ttu-id="c1087-3835">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3835">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3836">9C</span><span class="sxs-lookup"><span data-stu-id="c1087-3836">9C</span></span>|<span data-ttu-id="c1087-3837">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="c1087-3837">stelem.i1</span></span>|<span data-ttu-id="c1087-3838">在使用提供的索引陣列項目取代`int8`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3838">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3839">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3839">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3840">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3840">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3841">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3841">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3842">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3842">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3843">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3843">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3844">`stelem.i1`指令會取代項目的值`index`中的一維陣列`array`使用`int8`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3844">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3845">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3845">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3846">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3846">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3847"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3847"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3848"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3848"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3849"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3849"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3850">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3850">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3851">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3851">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3852">取代具有指定索引處的陣列元素<see langword="int16" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3852">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3853">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3853">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3854">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3854">Format</span></span>|<span data-ttu-id="c1087-3855">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3855">Assembly Format</span></span>|<span data-ttu-id="c1087-3856">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3856">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3857">9D</span><span class="sxs-lookup"><span data-stu-id="c1087-3857">9D</span></span>|<span data-ttu-id="c1087-3858">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="c1087-3858">stelem.i2</span></span>|<span data-ttu-id="c1087-3859">在使用提供的索引陣列項目取代`int16`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3859">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3860">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3860">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3861">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3861">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3862">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3862">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3863">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3863">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3864">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3864">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3865">`stelem.i2`指令會取代項目的值`index`中的一維陣列`array`使用`int16`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3865">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3866">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3866">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3867">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3867">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3868"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3868"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3869"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3869"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3870"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3870"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3871">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3871">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3872">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3872">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3873">取代具有指定索引處的陣列元素<see langword="int32" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3873">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3874">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3874">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3875">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3875">Format</span></span>|<span data-ttu-id="c1087-3876">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3876">Assembly Format</span></span>|<span data-ttu-id="c1087-3877">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3877">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3878">9E</span><span class="sxs-lookup"><span data-stu-id="c1087-3878">9E</span></span>|<span data-ttu-id="c1087-3879">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="c1087-3879">stelem.i4</span></span>|<span data-ttu-id="c1087-3880">在使用提供的索引陣列項目取代`int32`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3880">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3881">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3881">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3882">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3882">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3883">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3883">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3884">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3884">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3885">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3885">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3886">`stelem.i4`指令會取代項目的值`index`中的一維陣列`array`使用`int32`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3886">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3887">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3887">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3888">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3888">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3889"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3889"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3890"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3890"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3891"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3891"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3892">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3892">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3893">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3893">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3894">取代具有指定索引處的陣列元素<see langword="int64" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3894">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3895">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3895">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3896">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3896">Format</span></span>|<span data-ttu-id="c1087-3897">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3897">Assembly Format</span></span>|<span data-ttu-id="c1087-3898">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3898">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3899">9F</span><span class="sxs-lookup"><span data-stu-id="c1087-3899">9F</span></span>|<span data-ttu-id="c1087-3900">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="c1087-3900">stelem.i8</span></span>|<span data-ttu-id="c1087-3901">在使用提供的索引陣列項目取代`int64`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3901">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3902">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3902">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3903">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3903">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3904">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3904">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3905">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3905">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3906">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3906">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3907">`stelem.i8`指令會取代項目的值`index`中的一維陣列`array`使用`int64`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3907">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3908">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3908">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3909">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3909">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3910"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3910"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3911"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3911"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3912"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3912"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3913">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3915">取代具有指定索引處的陣列元素<see langword="float32" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3915">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3916">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3917">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3917">Format</span></span>|<span data-ttu-id="c1087-3918">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3918">Assembly Format</span></span>|<span data-ttu-id="c1087-3919">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3920">A0</span><span class="sxs-lookup"><span data-stu-id="c1087-3920">A0</span></span>|<span data-ttu-id="c1087-3921">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="c1087-3921">stelem.r4</span></span>|<span data-ttu-id="c1087-3922">在使用提供的索引陣列項目取代`float32`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3922">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3923">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3924">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3924">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3925">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3925">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3926">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3926">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3927">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3927">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3928">`stelem.r4`指令會取代項目的值`index`中的一維陣列`array`使用`float32`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3928">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3929">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3929">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3930">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3930">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3931"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3931"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3932"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3932"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3933"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3933"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3934">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.r4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3934">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3935">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3935">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3936">取代具有指定索引處的陣列元素<see langword="float64" />評估堆疊上的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3936">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3937">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3937">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3938">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3938">Format</span></span>|<span data-ttu-id="c1087-3939">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3939">Assembly Format</span></span>|<span data-ttu-id="c1087-3940">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3940">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3941">A1</span><span class="sxs-lookup"><span data-stu-id="c1087-3941">A1</span></span>|<span data-ttu-id="c1087-3942">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="c1087-3942">stelem.r8</span></span>|<span data-ttu-id="c1087-3943">在使用提供的索引陣列項目取代`float64`堆疊上的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3943">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3944">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3944">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3945">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3945">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3946">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3946">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3947">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3947">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3948">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3948">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3949">`stelem.r8`指令會取代項目的值`index`中的一維陣列`array`使用`float64`值推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3949">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3950">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3950">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3951">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3951">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3952"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3952"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3953"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3953"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3954"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3954"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3955">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.r8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3955">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3956">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3956">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3957">陣列項目取代位於指定索引處的物件參考值 (類型<see langword="O" />) 評估堆疊上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3957">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3958">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3958">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3959">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3959">Format</span></span>|<span data-ttu-id="c1087-3960">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3960">Assembly Format</span></span>|<span data-ttu-id="c1087-3961">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3961">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3962">A2</span><span class="sxs-lookup"><span data-stu-id="c1087-3962">A2</span></span>|<span data-ttu-id="c1087-3963">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="c1087-3963">stelem.ref</span></span>|<span data-ttu-id="c1087-3964">在使用提供的索引陣列項目取代`ref`值 (類型`O`) 堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-3964">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="c1087-3965">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3965">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3966">陣列，物件參考`array`，推送到堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3966">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3967">有效的索引中的項目`array`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3967">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3968">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3968">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="c1087-3969">值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3969">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="c1087-3970">`stelem.ref`指示取代的一維陣列中提供的索引處的項目值`array`具有`ref`(型別`O`) 推送至堆疊的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3970">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-3971">陣列也是物件，表示類型的值由`O`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3971">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="c1087-3972">索引是型別`native int`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3972">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="c1087-3973">請注意，`stelem.ref`隱含轉換的項目型別所提供的值`array`指派值的陣列項目之前。</span><span class="sxs-lookup"><span data-stu-id="c1087-3973">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="c1087-3974">此轉換可能會失敗，即使針對已驗證的程式碼。</span><span class="sxs-lookup"><span data-stu-id="c1087-3974">This cast can fail, even for verified code.</span></span> <span data-ttu-id="c1087-3975">因此`stelem.ref`指令可以擲回<xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="c1087-3975">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="c1087-3976">多維陣列，以及不以零為起始的一維陣列<xref:System.Array>類別提供<xref:System.Array.SetValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="c1087-3976">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="c1087-3977"><xref:System.NullReferenceException> 如果擲回`array`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-3977"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-3978"><xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。</span><span class="sxs-lookup"><span data-stu-id="c1087-3978"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="c1087-3979"><xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。</span><span class="sxs-lookup"><span data-stu-id="c1087-3979"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="c1087-3980">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.ref`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-3980">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-3981">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-3981">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-3982">以新值取代儲存在物件參考或指標的欄位中的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-3982">Replaces the value stored in the field of an object reference or pointer with a new value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-3983">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-3983">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-3984">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3984">Format</span></span>|<span data-ttu-id="c1087-3985">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-3985">Assembly Format</span></span>|<span data-ttu-id="c1087-3986">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-3986">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-3987">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-3987">7D < `T` ></span></span>|<span data-ttu-id="c1087-3988">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="c1087-3988">stfld `field`</span></span>|<span data-ttu-id="c1087-3989">取代的值`field`具有新值的物件。</span><span class="sxs-lookup"><span data-stu-id="c1087-3989">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="c1087-3990">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-3990">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-3991">物件參考或指標會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3991">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-3992">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-3992">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-3993">值，而且物件參考/指標會彈出從堆疊;值`field`在該物件會取代所提供的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3993">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="c1087-3994">`stfld`指示取代物件的欄位的值 (型別`O`) 或透過指標 (型別`native int`， `&`，或`*`) 具有給定值。</span><span class="sxs-lookup"><span data-stu-id="c1087-3994">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="c1087-3995">`Field` 是指欄位成員參考中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-3995">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="c1087-3996">`stfld`指令可以有一個或兩個前置詞<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>。</span><span class="sxs-lookup"><span data-stu-id="c1087-3996">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="c1087-3997"><xref:System.NullReferenceException> 如果物件參考或指標為 null 參考，而欄位並非靜態，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-3997"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="c1087-3998"><xref:System.MissingFieldException> 如果擲回`field`中繼資料中找不到。</span><span class="sxs-lookup"><span data-stu-id="c1087-3998"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="c1087-3999">這通常會檢查 Microsoft Intermediate Language (MSIL) 指令被轉換成原生程式碼，不在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-3999">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="c1087-4000">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stfld`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4000">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4001">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-4001">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4002">儲存值的型別<see langword="native int" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4002">Stores a value of type <see langword="native int" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4003">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4003">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4004">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4004">Format</span></span>|<span data-ttu-id="c1087-4005">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4005">Assembly Format</span></span>|<span data-ttu-id="c1087-4006">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4006">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4007">DF</span><span class="sxs-lookup"><span data-stu-id="c1087-4007">DF</span></span>|<span data-ttu-id="c1087-4008">stind.i</span><span class="sxs-lookup"><span data-stu-id="c1087-4008">stind.i</span></span>|<span data-ttu-id="c1087-4009">存放區`native int`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4009">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4010">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4010">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4011">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4011">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4012">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4012">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4013">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4013">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4014">`stind.i`指示存放區`native int`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4014">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4015">類型安全的作業需要`stind.i`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4015">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4016">營運`stind.i`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4016">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4017"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4017"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4018">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4019">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4019">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4020">儲存值的型別<see langword="int8" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4020">Stores a value of type <see langword="int8" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4021">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4022">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4022">Format</span></span>|<span data-ttu-id="c1087-4023">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4023">Assembly Format</span></span>|<span data-ttu-id="c1087-4024">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4025">52</span><span class="sxs-lookup"><span data-stu-id="c1087-4025">52</span></span>|<span data-ttu-id="c1087-4026">stind.i1</span><span class="sxs-lookup"><span data-stu-id="c1087-4026">stind.i1</span></span>|<span data-ttu-id="c1087-4027">存放區`int8`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4027">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4028">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4029">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4029">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4030">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4030">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4031">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4031">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4032">`stind.i1`指示存放區`int8`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4032">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4033">類型安全的作業需要`stind.i1`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4033">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4034">營運`stind.i1`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4034">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4035"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4035"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4036">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4037">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4037">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4038">儲存值的型別<see langword="int16" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4038">Stores a value of type <see langword="int16" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4039">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4040">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4040">Format</span></span>|<span data-ttu-id="c1087-4041">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4041">Assembly Format</span></span>|<span data-ttu-id="c1087-4042">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4043">53</span><span class="sxs-lookup"><span data-stu-id="c1087-4043">53</span></span>|<span data-ttu-id="c1087-4044">stind.i2</span><span class="sxs-lookup"><span data-stu-id="c1087-4044">stind.i2</span></span>|<span data-ttu-id="c1087-4045">存放區`int16`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4045">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4046">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4047">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4047">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4048">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4048">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4049">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4049">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4050">`stind.i2`指示存放區`int16`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4050">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4051">類型安全的作業需要`stind.2i`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4051">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4052">營運`stind.i2`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4052">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4053"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4053"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4054">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4056">儲存值的型別<see langword="int32" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4056">Stores a value of type <see langword="int32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4057">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4058">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4058">Format</span></span>|<span data-ttu-id="c1087-4059">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4059">Assembly Format</span></span>|<span data-ttu-id="c1087-4060">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4061">54</span><span class="sxs-lookup"><span data-stu-id="c1087-4061">54</span></span>|<span data-ttu-id="c1087-4062">stind.i4</span><span class="sxs-lookup"><span data-stu-id="c1087-4062">stind.i4</span></span>|<span data-ttu-id="c1087-4063">存放區`int32`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4063">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4064">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4065">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4065">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4066">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4066">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4067">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4067">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4068">`stind.i4`指示存放區`int32`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4068">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4069">類型安全的作業需要`stind.i4`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4069">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4070">營運`stind.i4`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4070">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4071"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4071"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4072">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4074">儲存值的型別<see langword="int64" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4074">Stores a value of type <see langword="int64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4075">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4076">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4076">Format</span></span>|<span data-ttu-id="c1087-4077">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4077">Assembly Format</span></span>|<span data-ttu-id="c1087-4078">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4079">55</span><span class="sxs-lookup"><span data-stu-id="c1087-4079">55</span></span>|<span data-ttu-id="c1087-4080">stind.i8</span><span class="sxs-lookup"><span data-stu-id="c1087-4080">stind.i8</span></span>|<span data-ttu-id="c1087-4081">存放區`int64`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4081">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4082">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4083">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4083">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4084">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4084">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4085">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4085">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4086">`stind.i8`指示存放區`int64`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4086">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4087">類型安全的作業需要`stind.i8`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4087">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4088">營運`stind.i`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4088">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4089"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4089"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4090">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4092">儲存值的型別<see langword="float32" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4092">Stores a value of type <see langword="float32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4093">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4094">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4094">Format</span></span>|<span data-ttu-id="c1087-4095">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4095">Assembly Format</span></span>|<span data-ttu-id="c1087-4096">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4097">56</span><span class="sxs-lookup"><span data-stu-id="c1087-4097">56</span></span>|<span data-ttu-id="c1087-4098">stind.r4</span><span class="sxs-lookup"><span data-stu-id="c1087-4098">stind.r4</span></span>|<span data-ttu-id="c1087-4099">存放區`float32`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4099">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4100">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4101">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4101">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4102">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4102">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4103">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4103">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4104">`stind.r4`指示存放區`float32`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4104">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4105">類型安全的作業需要`stind.r4`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4105">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4106">營運`stind.r4`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4106">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4107"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4107"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4108">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.r4`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4110">儲存值的型別<see langword="float64" />在所提供的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4110">Stores a value of type <see langword="float64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4111">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4112">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4112">Format</span></span>|<span data-ttu-id="c1087-4113">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4113">Assembly Format</span></span>|<span data-ttu-id="c1087-4114">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4115">57</span><span class="sxs-lookup"><span data-stu-id="c1087-4115">57</span></span>|<span data-ttu-id="c1087-4116">stind.r8</span><span class="sxs-lookup"><span data-stu-id="c1087-4116">stind.r8</span></span>|<span data-ttu-id="c1087-4117">存放區`float64`值在指定的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4117">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4118">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4119">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4119">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4120">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4120">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4121">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4121">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4122">`stind.r8`指示存放區`float64`值所提供的位址 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4122">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4123">類型安全的作業需要`stind.r8`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4123">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4124">營運`stind.r8`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4124">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4125"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4125"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4126">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.r8`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4127">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4127">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4128">在所提供的位址儲存物件參考值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4128">Stores a object reference value at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4129">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4130">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4130">Format</span></span>|<span data-ttu-id="c1087-4131">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4131">Assembly Format</span></span>|<span data-ttu-id="c1087-4132">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4133">51</span><span class="sxs-lookup"><span data-stu-id="c1087-4133">51</span></span>|<span data-ttu-id="c1087-4134">stind.ref</span><span class="sxs-lookup"><span data-stu-id="c1087-4134">stind.ref</span></span>|<span data-ttu-id="c1087-4135">儲存物件參考 (型別`O`) 在指定位址的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-4135">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="c1087-4136">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4137">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4137">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4138">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4138">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4139">值和位址快顯從堆疊;值會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4139">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4140">`stind.ref`指令會儲存在所提供位址的物件參考值 (型別`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4140">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="c1087-4141">類型安全的作業需要`stind.ref`指示用於指標的類型與一致的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4141">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="c1087-4142">營運`stind.ref`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4142">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4143"><xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。</span><span class="sxs-lookup"><span data-stu-id="c1087-4143"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="c1087-4144">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.ref`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4145">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4145">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4146">從評估堆疊的頂端取出目前值，並將它存放在指定索引的區域變數清單中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4146">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4147">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4148">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4148">Format</span></span>|<span data-ttu-id="c1087-4149">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4149">Assembly Format</span></span>|<span data-ttu-id="c1087-4150">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4151">FE 0E &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4151">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="c1087-4152">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-4152">stloc `index`</span></span>|<span data-ttu-id="c1087-4153">從堆疊取出值，並將它儲存在區域變數中`index`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4153">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="c1087-4154">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4155">從堆疊取出值，並放在區域變數`index`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4155">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="c1087-4156">`stloc`指令會取出評估堆疊頂端的值，並將它移至本機變數數目`index`，其中的本機變數是及更新版本編號為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-4156">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="c1087-4157">值的類型必須符合目前方法的本機簽章中指定本機變數的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4157">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="c1087-4158">儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。</span><span class="sxs-lookup"><span data-stu-id="c1087-4158">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="c1087-4159">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-4159">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-4160">正確的 Microsoft Intermediate Language (MSIL) 指示要求`index`是有效的本機索引。</span><span class="sxs-lookup"><span data-stu-id="c1087-4160">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="c1087-4161">針對`stloc`的指示，`index`必須介於範圍 0 到 65534 （含） （具體而言，65535 無效）。</span><span class="sxs-lookup"><span data-stu-id="c1087-4161">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="c1087-4162">65535 排除在外的原因是務實： 可能的實作會使用 2 位元組的整數，來追蹤區域的索引，以及指定方法的區域變數的總數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4162">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="c1087-4163">如果 65535 的索引已經變成有效，它將需要更多的整數，用來追蹤這類方法中的區域變數的數目。</span><span class="sxs-lookup"><span data-stu-id="c1087-4163">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="c1087-4164">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4164">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4165">ILGenerator.Emit （OpCode、 LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="c1087-4165">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="c1087-4166">ILGenerator.Emit (OpCode，short)</span><span class="sxs-lookup"><span data-stu-id="c1087-4166">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4167">從評估堆疊的頂端取出目前值，並將它存放在索引 0 的區域變數清單中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4167">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4168">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4168">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4169">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4169">Format</span></span>|<span data-ttu-id="c1087-4170">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4170">Assembly Format</span></span>|<span data-ttu-id="c1087-4171">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4171">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4172">0A</span><span class="sxs-lookup"><span data-stu-id="c1087-4172">0A</span></span>|<span data-ttu-id="c1087-4173">stloc.0</span><span class="sxs-lookup"><span data-stu-id="c1087-4173">stloc.0</span></span>|<span data-ttu-id="c1087-4174">從堆疊中的值為 0 的區域變數中取出。</span><span class="sxs-lookup"><span data-stu-id="c1087-4174">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="c1087-4175">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4175">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4176">從堆疊取出值，並放在索引為 0 的本機變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4176">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="c1087-4177">`stloc.0`指令取出評估堆疊頂端的值，並將它移至索引為 0 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4177">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="c1087-4178">值的類型必須符合目前方法的本機簽章中指定本機變數的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4178">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="c1087-4179">`stloc.0` 是有效的編碼方式，將值儲存在本機變數 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-4179">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="c1087-4180">儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。</span><span class="sxs-lookup"><span data-stu-id="c1087-4180">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="c1087-4181">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-4181">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-4182">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.0`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4182">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4183">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4183">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4184">從評估堆疊的頂端取出目前值，並將它存放在索引 1 的區域變數清單中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4184">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4185">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4185">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4186">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4186">Format</span></span>|<span data-ttu-id="c1087-4187">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4187">Assembly Format</span></span>|<span data-ttu-id="c1087-4188">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4188">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4189">0B</span><span class="sxs-lookup"><span data-stu-id="c1087-4189">0B</span></span>|<span data-ttu-id="c1087-4190">stloc.1</span><span class="sxs-lookup"><span data-stu-id="c1087-4190">stloc.1</span></span>|<span data-ttu-id="c1087-4191">從值從堆疊取出到 1 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4191">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="c1087-4192">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4192">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4193">從堆疊取出值，並放在索引 1 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4193">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="c1087-4194">`stloc.1`指令取出評估堆疊頂端的值，並將它移至索引 1 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4194">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="c1087-4195">值的類型必須符合目前方法的本機簽章中指定本機變數的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4195">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="c1087-4196">`stloc.1` 是有效的編碼方式，將值儲存在區域變數 1。</span><span class="sxs-lookup"><span data-stu-id="c1087-4196">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="c1087-4197">儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。</span><span class="sxs-lookup"><span data-stu-id="c1087-4197">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="c1087-4198">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-4198">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-4199">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.1`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4201">從評估堆疊的頂端取出目前值，並將它存放在索引 2 的區域變數清單中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4201">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4202">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4203">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4203">Format</span></span>|<span data-ttu-id="c1087-4204">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4204">Assembly Format</span></span>|<span data-ttu-id="c1087-4205">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4206">0C</span><span class="sxs-lookup"><span data-stu-id="c1087-4206">0C</span></span>|<span data-ttu-id="c1087-4207">stloc.2</span><span class="sxs-lookup"><span data-stu-id="c1087-4207">stloc.2</span></span>|<span data-ttu-id="c1087-4208">顯示堆疊中的值放入本機變數 2</span><span class="sxs-lookup"><span data-stu-id="c1087-4208">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="c1087-4209">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4210">從堆疊取出值，並放在索引 2 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4210">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="c1087-4211">`stloc.2`指令取出評估堆疊頂端的值，並將它移至索引為 2 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4211">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="c1087-4212">值的類型必須符合目前方法的本機簽章中指定本機變數的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4212">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="c1087-4213">`stloc.2` 是有效的編碼方式，將值儲存在本機變數 2。</span><span class="sxs-lookup"><span data-stu-id="c1087-4213">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="c1087-4214">儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。</span><span class="sxs-lookup"><span data-stu-id="c1087-4214">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="c1087-4215">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-4215">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-4216">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.2`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4216">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4217">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4217">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4218">從評估堆疊的頂端取出目前值，並將它存放在索引 3 的區域變數清單中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4218">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4219">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4219">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4220">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4220">Format</span></span>|<span data-ttu-id="c1087-4221">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4221">Assembly Format</span></span>|<span data-ttu-id="c1087-4222">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4222">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4223">0D</span><span class="sxs-lookup"><span data-stu-id="c1087-4223">0D</span></span>|<span data-ttu-id="c1087-4224">stloc.3</span><span class="sxs-lookup"><span data-stu-id="c1087-4224">stloc.3</span></span>|<span data-ttu-id="c1087-4225">從值從堆疊取出到 3 的區域變數</span><span class="sxs-lookup"><span data-stu-id="c1087-4225">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="c1087-4226">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4226">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4227">從堆疊取出值，並放在索引 3 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4227">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="c1087-4228">`stloc.3`指令取出評估堆疊頂端的值，並將它移至索引為 3 的區域變數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4228">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="c1087-4229">值的類型必須符合目前方法的本機簽章中指定本機變數的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4229">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="c1087-4230">`stloc.3` 是有效的編碼方式，將值儲存在區域變數 3。</span><span class="sxs-lookup"><span data-stu-id="c1087-4230">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="c1087-4231">儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。</span><span class="sxs-lookup"><span data-stu-id="c1087-4231">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="c1087-4232">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-4232">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-4233">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.3`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4233">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4234">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4234">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4235">取出目前值從評估堆疊的頂端，並將其儲存在本機變數清單，在<paramref name="index" />（簡短形式）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4235">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4236">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4236">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4237">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4237">Format</span></span>|<span data-ttu-id="c1087-4238">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4238">Assembly Format</span></span>|<span data-ttu-id="c1087-4239">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4239">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4240">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4240">13 < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-4241">stloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="c1087-4241">stloc.s `index`</span></span>|<span data-ttu-id="c1087-4242">從堆疊取出值，並將它儲存在區域變數中`index`，簡短形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4242">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="c1087-4243">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4243">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4244">從堆疊取出值，並放在區域變數`index`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4244">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="c1087-4245">`stloc.s`指令會取出評估堆疊頂端的值，並將它移至本機變數數目`index`，其中的本機變數是及更新版本編號為 0。</span><span class="sxs-lookup"><span data-stu-id="c1087-4245">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="c1087-4246">值的類型必須符合目前方法的本機簽章中指定本機變數的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4246">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="c1087-4247">`stloc.s`指令可讓您提供有效的編碼方式，區域變數的 0 到 255 之間。</span><span class="sxs-lookup"><span data-stu-id="c1087-4247">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="c1087-4248">儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。</span><span class="sxs-lookup"><span data-stu-id="c1087-4248">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="c1087-4249">從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。</span><span class="sxs-lookup"><span data-stu-id="c1087-4249">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="c1087-4250">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.s`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4251">ILGenerator.Emit （OpCode、 LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="c1087-4251">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="c1087-4252">ILGenerator.Emit （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-4252">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4253">從評估堆疊複製指定類型的值到所提供的記憶體位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4253">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4254">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4255">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4255">Format</span></span>|<span data-ttu-id="c1087-4256">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4256">Assembly Format</span></span>|<span data-ttu-id="c1087-4257">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4258">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4258">81 < `T` ></span></span>|<span data-ttu-id="c1087-4259">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="c1087-4259">stobj `class`</span></span>|<span data-ttu-id="c1087-4260">儲存值的型別`class`從堆疊載入記憶體。</span><span class="sxs-lookup"><span data-stu-id="c1087-4260">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="c1087-4261">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4262">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4262">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4263">類型的值型別物件`class`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4263">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4264">物件和位址快顯從堆疊;實值類型物件會儲存在位址中。</span><span class="sxs-lookup"><span data-stu-id="c1087-4264">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="c1087-4265">`stobj`指令會將實值類型物件複製到指定位址的位址 (類型的指標`native int`， `*`，或`&`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4265">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="c1087-4266">已複製的位元組數目取決於所表示之類別的大小`class`、 表示實值型別中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-4266">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="c1087-4267">營運`stobj`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4267">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="c1087-4268"><xref:System.TypeLoadException> 如果找不到類別，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-4268"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="c1087-4269">這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-4269">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="c1087-4270">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stobj`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4271">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-4271">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4272">以來自評估堆疊的值取代靜態欄位的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4272">Replaces the value of a static field with a value from the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4273">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4274">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4274">Format</span></span>|<span data-ttu-id="c1087-4275">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4275">Assembly Format</span></span>|<span data-ttu-id="c1087-4276">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4277">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4277">80 < `T` ></span></span>|<span data-ttu-id="c1087-4278">這個前置 `field`</span><span class="sxs-lookup"><span data-stu-id="c1087-4278">stsfld `field`</span></span>|<span data-ttu-id="c1087-4279">中的值取代`field`與提供的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-4279">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="c1087-4280">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4281">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4281">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4282">從堆疊取出值，並儲存在`field`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4282">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="c1087-4283">`stsfld`指令會從堆疊以值取代靜態欄位的值。</span><span class="sxs-lookup"><span data-stu-id="c1087-4283">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="c1087-4284">`field` 為靜態欄位成員必須參考中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="c1087-4284">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="c1087-4285">`stsfld`可能會加上指令<xref:System.Reflection.Emit.OpCodes.Volatile>。</span><span class="sxs-lookup"><span data-stu-id="c1087-4285">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="c1087-4286"><xref:System.MissingFieldException> 如果在中繼資料中找不到欄位，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-4286"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="c1087-4287">這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-4287">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="c1087-4288">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stsfld`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4288">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4289">ILGenerator.Emit （OpCode、 FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="c1087-4289">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4290">將另一個值減去某一個值，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4290">Subtracts one value from another and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4291">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4291">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4292">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4292">Format</span></span>|<span data-ttu-id="c1087-4293">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4293">Assembly Format</span></span>|<span data-ttu-id="c1087-4294">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4294">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4295">59</span><span class="sxs-lookup"><span data-stu-id="c1087-4295">59</span></span>|<span data-ttu-id="c1087-4296">sub</span><span class="sxs-lookup"><span data-stu-id="c1087-4296">sub</span></span>|<span data-ttu-id="c1087-4297">一個值減去另一個，傳回新的數值。</span><span class="sxs-lookup"><span data-stu-id="c1087-4297">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="c1087-4298">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4298">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4299">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4299">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4300">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4300">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4301">`value2` 和`value1`會彈出從堆疊;`value2`會減去`value1`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4301">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="c1087-4302">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4302">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4303">整數運算溢位都沒有偵測到 (處理適當的溢位，請參閱<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4303">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="c1087-4304">整數減法包裝，而不是飽和。</span><span class="sxs-lookup"><span data-stu-id="c1087-4304">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="c1087-4305">例如： 假設 8 位元整數，其中`value1`設定為 0 和`value2`設為 1 時，「 包裝的 」 的結果會是 255。</span><span class="sxs-lookup"><span data-stu-id="c1087-4305">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="c1087-4306">傳回浮點溢位`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4306">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="c1087-4307">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sub`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4309">將另一個值減去某一個值、執行溢位檢查，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4309">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4310">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4311">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4311">Format</span></span>|<span data-ttu-id="c1087-4312">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4312">Assembly Format</span></span>|<span data-ttu-id="c1087-4313">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4314">DA</span><span class="sxs-lookup"><span data-stu-id="c1087-4314">DA</span></span>|<span data-ttu-id="c1087-4315">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="c1087-4315">sub.ovf</span></span>|<span data-ttu-id="c1087-4316">一個整數值減去另一個具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-4316">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="c1087-4317">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4318">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4318">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4319">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4319">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4320">`value2` 和`value1`會彈出從堆疊;`value2`會減去`value1`具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-4320">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="c1087-4321">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4321">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4322"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-4322"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-4323">帶正負號的整數; 上執行這項作業浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Sub>。</span><span class="sxs-lookup"><span data-stu-id="c1087-4323">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="c1087-4324">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sub.ovf`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4324">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4325">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4325">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4326">將另一個不帶正負號的值減去某一個不帶正負號的值、執行溢位檢查，並將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4326">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4327">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4327">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4328">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4328">Format</span></span>|<span data-ttu-id="c1087-4329">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4329">Assembly Format</span></span>|<span data-ttu-id="c1087-4330">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4330">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4331">DB</span><span class="sxs-lookup"><span data-stu-id="c1087-4331">DB</span></span>|<span data-ttu-id="c1087-4332">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="c1087-4332">sub.ovf.un</span></span>|<span data-ttu-id="c1087-4333">一個不帶正負號的整數值減去另一個具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-4333">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="c1087-4334">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4334">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4335">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4335">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4336">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4336">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4337">`value2` 和`value1`會彈出從堆疊;`value2`會減去`value1`具有溢位檢查。</span><span class="sxs-lookup"><span data-stu-id="c1087-4337">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="c1087-4338">結果會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4338">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4339"><xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-4339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="c1087-4340">帶正負號的整數; 上執行這項作業浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Sub>。</span><span class="sxs-lookup"><span data-stu-id="c1087-4340">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="c1087-4341">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sub.ovf.un`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4341">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4342">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4342">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4343">實作跳躍表格。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4343">Implements a jump table.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4344">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4344">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4345">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4345">Format</span></span>|<span data-ttu-id="c1087-4346">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4346">Assembly Format</span></span>|<span data-ttu-id="c1087-4347">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4347">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4348">45 < `unsigned int32` >< `int32` >...< `int32` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="c1087-4349">切換 (`N`， `t1`， `t2`...`tN`)</span><span class="sxs-lookup"><span data-stu-id="c1087-4349">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="c1087-4350">跳至其中一個`N`值。</span><span class="sxs-lookup"><span data-stu-id="c1087-4350">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="c1087-4351">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4351">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4352">的值會推入至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4352">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4353">值從堆疊取出並將執行轉移至編製索引的值，位移指示其中的值是小於`N`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4353">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="c1087-4354">`switch`指令實作跳躍表格。</span><span class="sxs-lookup"><span data-stu-id="c1087-4354">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="c1087-4355">指示的格式`unsigned int32`表示的目標數目`N`，後面接著`N`int32 值，指定跳躍目標。</span><span class="sxs-lookup"><span data-stu-id="c1087-4355">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="c1087-4356">這些目標時，會表示為位移 （正或負） 上，從一開始遵循此指示的`switch`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4356">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="c1087-4357">`switch`指令從堆疊取出值，並比較其項目，做為不帶正負號的整數， `N`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4357">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="c1087-4358">如果值是小於`N`，執行會傳輸至目標值，編製索引從 0 開始編號的目標 （例如，值為 0 會採用第一個目標，1 的值會採用第二個目標，並依此類推）。</span><span class="sxs-lookup"><span data-stu-id="c1087-4358">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="c1087-4359">如果值是大於或等於`N`，繼續執行下一個指令 （正常執行）。</span><span class="sxs-lookup"><span data-stu-id="c1087-4359">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="c1087-4360">如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-4360">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="c1087-4361">控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-4361">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="c1087-4362">（這類傳輸嚴重限制而必須改用）。</span><span class="sxs-lookup"><span data-stu-id="c1087-4362">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="c1087-4363">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`switch`opcode。</span><span class="sxs-lookup"><span data-stu-id="c1087-4363">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="c1087-4364">`Label[]`引數是標籤代表 32 位元位移的陣列。</span><span class="sxs-lookup"><span data-stu-id="c1087-4364">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="c1087-4365">ILGenerator.Emit （OpCode、 Label[])</span><span class="sxs-lookup"><span data-stu-id="c1087-4365">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c1087-4366">下列程式碼範例說明如何使用`Switch`產生跳躍表使用陣列的 opcode <xref:System.Reflection.Emit.Label>。</span><span class="sxs-lookup"><span data-stu-id="c1087-4366">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4367">執行後置的方法呼叫指令 (例如目前方法的堆疊框架) 會在執行實際的呼叫指令之前移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4367">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4368">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4368">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4369">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4369">Format</span></span>|<span data-ttu-id="c1087-4370">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4370">Assembly Format</span></span>|<span data-ttu-id="c1087-4371">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4371">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4372">FE 14</span><span class="sxs-lookup"><span data-stu-id="c1087-4372">FE 14</span></span>|<span data-ttu-id="c1087-4373">結尾。</span><span class="sxs-lookup"><span data-stu-id="c1087-4373">tail.</span></span>|<span data-ttu-id="c1087-4374">後續呼叫會終止目前的方法</span><span class="sxs-lookup"><span data-stu-id="c1087-4374">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="c1087-4375">不沒有定義這個指示任何堆疊轉換行為。</span><span class="sxs-lookup"><span data-stu-id="c1087-4375">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="c1087-4376">`tail`前置詞指令必須緊接著<xref:System.Reflection.Emit.OpCodes.Call>， <xref:System.Reflection.Emit.OpCodes.Calli>，或<xref:System.Reflection.Emit.OpCodes.Callvirt>指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4376">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="c1087-4377">指出呼叫指令執行之前，應該移除目前方法的堆疊框架。</span><span class="sxs-lookup"><span data-stu-id="c1087-4377">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="c1087-4378">這也表示從下列呼叫傳回的值也是目前的方法所傳回的值，並因此可以跨方法跳到轉換呼叫。</span><span class="sxs-lookup"><span data-stu-id="c1087-4378">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="c1087-4379">堆疊不得為空白，除了下列的呼叫所傳送的引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4379">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="c1087-4380">緊跟在呼叫指令必須是 ret。唯一有效的程式碼序列會因而`tail. call`(或`calli`或`callvirt`)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4380">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="c1087-4381">正確的 Microsoft Intermediate Language (MSIL) 指示不必須分支到`call`的指示，但它們可能會分支到後續<xref:System.Reflection.Emit.OpCodes.Ret>。</span><span class="sxs-lookup"><span data-stu-id="c1087-4381">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="c1087-4382">控制權會轉移不受信任的程式碼從信任的程式碼，因為這可能危及程式碼身分識別安全性時，就無法捨棄目前的框架。</span><span class="sxs-lookup"><span data-stu-id="c1087-4382">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="c1087-4383">.NET Framework 安全性檢查，因此可能會造成`tail`遭到忽略，離開標準<xref:System.Reflection.Emit.OpCodes.Call>指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4383">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="c1087-4384">同樣地，為了讓已同步處理的區域發生在呼叫傳回之後結束，則`tail`時用來結束標示為已同步處理的方法，會忽略前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-4384">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="c1087-4385">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`tail`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4386">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4386">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">
          <span data-ttu-id="c1087-4387">Opcode 物件的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4387">An instance of an Opcode object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c1087-4388">如果提供的作業碼採用單一位元組引數，則傳回 True 或 False。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4388">Returns true or false if the supplied opcode takes a single byte argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c1087-4389">
            <see langword="True" /> 或 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4389">
              <see langword="True" /> or <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4390">這個方法可用來找出哪些 MSIL 作業碼 「 簡短表單 」，用於最佳化程式碼中使用。</span><span class="sxs-lookup"><span data-stu-id="c1087-4390">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="c1087-4391">`TakesSingleByteArgument` 會傳回`true`如果<xref:System.Reflection.Emit.OpCode>執行個體使用單一位元組引數，在下列情況：</span><span class="sxs-lookup"><span data-stu-id="c1087-4391">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="c1087-4392">Opcode 會執行分支指令的位元組大小的位址 (例如<xref:System.Reflection.Emit.OpCodes.Br_S>和<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4392">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="c1087-4393">Opcode 會推送至堆疊的位元組值 (例如<xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4393">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="c1087-4394">Opcode 參考變數或引數，透過的位元組大小 」 簡短形式 」 (例如<xref:System.Reflection.Emit.OpCodes.Ldloc_S>和<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。</span><span class="sxs-lookup"><span data-stu-id="c1087-4394">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="c1087-4395">否則它會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4395">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="c1087-4396">下列範例示範如何使用`TakesSingleByteArgument`入反映`OpCodes`類別和測試以查看是否每個`OpCode`欄位採用單一位元組引數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4396">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4397">擲回目前位於評估堆疊的例外狀況物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4397">Throws the exception object currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4398">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4398">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4399">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4399">Format</span></span>|<span data-ttu-id="c1087-4400">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4400">Assembly Format</span></span>|<span data-ttu-id="c1087-4401">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4401">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4402">7A</span><span class="sxs-lookup"><span data-stu-id="c1087-4402">7A</span></span>|<span data-ttu-id="c1087-4403">throw</span><span class="sxs-lookup"><span data-stu-id="c1087-4403">throw</span></span>|<span data-ttu-id="c1087-4404">擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c1087-4404">Throws an exception.</span></span>|  
  
 <span data-ttu-id="c1087-4405">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4405">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4406">（將例外狀況） 的物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4406">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4407">物件參考會從堆疊並擲回的例外狀況中推出。</span><span class="sxs-lookup"><span data-stu-id="c1087-4407">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="c1087-4408">`throw`指令會擲回的例外狀況物件 (類型`O`) 目前在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-4408">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="c1087-4409"><xref:System.NullReferenceException> 如果物件參考為 null 參考，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-4409"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-4410">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`throw`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4411">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4412">表示目前位於評估堆疊頂端位置可能未對齊緊接的正常大小<see langword="ldind" />， <see langword="stind" />， <see langword="ldfld" />， <see langword="stfld" />， <see langword="ldobj" />， <see langword="stobj" />， <see langword="initblk" />，或<see langword="cpblk" />指令。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4412">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4413">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4414">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4414">Format</span></span>|<span data-ttu-id="c1087-4415">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4415">Assembly Format</span></span>|<span data-ttu-id="c1087-4416">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4417">FE 12 &LT; `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4417">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="c1087-4418">未對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4418">unaligned.</span></span> `alignment`|<span data-ttu-id="c1087-4419">表示後續指標指令可能未對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4419">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="c1087-4420">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4421">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4421">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4422">`Unaligned` 指定的位址 (的 unmanaged 的指標， `native int`) 在堆疊上可能未對齊緊接的正常大小`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`，`initblk`，或`cpblk`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4422">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="c1087-4423">也就是針對<xref:System.Reflection.Emit.OpCodes.Ldind_I4>指令位址的對齊方式可能無法與 4 位元組界限。</span><span class="sxs-lookup"><span data-stu-id="c1087-4423">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="c1087-4424">針對`initblk`和`cpblk`預設對齊方式是架構相依 （4 個 32 位元 cpu，在 64 位元 Cpu 上的 8 個位元組的位元組）。</span><span class="sxs-lookup"><span data-stu-id="c1087-4424">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="c1087-4425">未將其輸出限制為 32 位元字組大小的程式碼產生器必須使用`unaligned`如果對齊不在編譯時期已知為 8 個位元組。</span><span class="sxs-lookup"><span data-stu-id="c1087-4425">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="c1087-4426">對齊的值必須是 1、 2 或 4 和產生的程式碼應該採用的位址是雙位元組的位元組，或分別 4 位元組對齊的方式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4426">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="c1087-4427">請注意該暫時性指標 (型別`*`) 一律對齊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4427">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="c1087-4428">雖然的對齊方式`cpblk`指令會以邏輯方式需要兩個數字 （一個為來源），另一個用於目的地，則不會嚴重影響效能如果只指定較低的數字。</span><span class="sxs-lookup"><span data-stu-id="c1087-4428">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="c1087-4429">`unaligned`和`volatile`可以按照任何順序結合前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-4429">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="c1087-4430">後面必須緊接著`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4430">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="c1087-4431">只有<xref:System.Reflection.Emit.OpCodes.Volatile>允許前置詞<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-4431">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="c1087-4432">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unaligned`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4432">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4433">ILGenerator.Emit （OpCode、 標籤）</span><span class="sxs-lookup"><span data-stu-id="c1087-4433">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="c1087-4434">ILGenerator.Emit （Opcode，Byte）</span><span class="sxs-lookup"><span data-stu-id="c1087-4434">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4435">將實值類型的 boxed 表示轉換成它的 unboxed 形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4435">Converts the boxed representation of a value type to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4436">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4437">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4437">Format</span></span>|<span data-ttu-id="c1087-4438">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4438">Assembly Format</span></span>|<span data-ttu-id="c1087-4439">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4440">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4440">79 < `T` ></span></span>|<span data-ttu-id="c1087-4441">unbox `valType`</span><span class="sxs-lookup"><span data-stu-id="c1087-4441">unbox `valType`</span></span>|<span data-ttu-id="c1087-4442">擷取值的型別資料，從`obj`、 其表示法進行 boxed 處理。</span><span class="sxs-lookup"><span data-stu-id="c1087-4442">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="c1087-4443">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4444">物件參考推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4444">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4445">物件參考是從堆疊推出和 unboxed 實值類型指標至。</span><span class="sxs-lookup"><span data-stu-id="c1087-4445">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="c1087-4446">實值型別指標會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4446">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4447">實值型別有兩種不同的表示法在 Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="c1087-4447">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="c1087-4448">當實值型別內嵌在另一個物件時，使用 'raw' 格式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4448">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="c1087-4449">'Boxed' 格式，其中實值型別中的資料會包裝 （進行 boxed 處理） 到物件讓它可以當作獨立的實體存在。</span><span class="sxs-lookup"><span data-stu-id="c1087-4449">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="c1087-4450">`unbox`指令會將轉換的物件參考 (型別`O`)、 boxed 的實值類型，表示值的類型指標 (managed 的指標，類型`&`)、 其 unboxed 形式。</span><span class="sxs-lookup"><span data-stu-id="c1087-4450">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="c1087-4451">提供的實值型別 (`valType`) 為中繼資料語彙基元，表示類型的 boxed 物件內所包含的值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4451">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="c1087-4452">不同於<xref:System.Reflection.Emit.OpCodes.Box>，這必要項目在物件中，製作一份使用實值型別`unbox`不需要複製物件中的實值型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4452">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="c1087-4453">通常它只會計算已存在的 boxed 物件內的值類型的位址。</span><span class="sxs-lookup"><span data-stu-id="c1087-4453">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="c1087-4454"><xref:System.InvalidCastException> 如果物件不化為會擲回`valType`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4454"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="c1087-4455"><xref:System.NullReferenceException> 如果物件參考為 null 參考，會擲回。</span><span class="sxs-lookup"><span data-stu-id="c1087-4455"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-4456"><xref:System.TypeLoadException> 如果型別值，會擲回`valType`找不到。</span><span class="sxs-lookup"><span data-stu-id="c1087-4456"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="c1087-4457">這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。</span><span class="sxs-lookup"><span data-stu-id="c1087-4457">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="c1087-4458">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unbox`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4459">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-4459">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4460">將指令中指定之類型的 boxed 表示轉換成其 unboxed 形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4460">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4461">下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4461">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4462">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4462">Format</span></span>|<span data-ttu-id="c1087-4463">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4463">Assembly Format</span></span>|<span data-ttu-id="c1087-4464">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4465">A5 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="c1087-4465">A5 < `T` ></span></span>|<span data-ttu-id="c1087-4466">unbox.any `typeTok`</span><span class="sxs-lookup"><span data-stu-id="c1087-4466">unbox.any `typeTok`</span></span>|<span data-ttu-id="c1087-4467">擷取從資料`obj`、 其表示法進行 boxed 處理。</span><span class="sxs-lookup"><span data-stu-id="c1087-4467">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="c1087-4468">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4469">物件參考`obj`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4469">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4470">物件參考是從堆疊推出和 unboxed 指令中指定的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4470">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="c1087-4471">產生的物件參考或實值類型會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4471">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4472">套用至 boxed 實值型別時`unbox.any`指令會擷取內含值`obj`(型別的`O`)，而因此相當於`unbox`後面`ldobj`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4472">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="c1087-4473">當套用至參考型別`unbox.any`指令具有相同的效果`castclass` `typeTok`。</span><span class="sxs-lookup"><span data-stu-id="c1087-4473">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="c1087-4474">如果運算元`typeTok`是泛型類型參數，則執行階段行為取決於該泛型型別參數指定的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4474">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="c1087-4475"><xref:System.InvalidCastException> 如果擲回`obj`不經過 boxing 處理的型別。</span><span class="sxs-lookup"><span data-stu-id="c1087-4475"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="c1087-4476"><xref:System.NullReferenceException> 如果擲回`obj`為 null 參考。</span><span class="sxs-lookup"><span data-stu-id="c1087-4476"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="c1087-4477">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unbox.any`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4478">ILGenerator.Emit （OpCode、 型別）</span><span class="sxs-lookup"><span data-stu-id="c1087-4478">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4479">指定目前在評估堆疊頂端的位址可能是 volatile，並且無法快取讀取該位置的結果，或者無法隱藏存放該位置的多個存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4479">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4480">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4481">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4481">Format</span></span>|<span data-ttu-id="c1087-4482">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4482">Assembly Format</span></span>|<span data-ttu-id="c1087-4483">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4484">FE 13</span><span class="sxs-lookup"><span data-stu-id="c1087-4484">FE 13</span></span>|<span data-ttu-id="c1087-4485">變動性。</span><span class="sxs-lookup"><span data-stu-id="c1087-4485">volatile.</span></span>|<span data-ttu-id="c1087-4486">表示後續指標參考為 volatile。</span><span class="sxs-lookup"><span data-stu-id="c1087-4486">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="c1087-4487">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4488">位址會推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4488">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4489">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="c1087-4489">`volatile`.</span></span> <span data-ttu-id="c1087-4490">指定的位址是動態位址 （也就是可以從外部參考目前的執行緒） 和讀取位置無法快取，或發現無法隱藏多個門市，至該位置的結果。</span><span class="sxs-lookup"><span data-stu-id="c1087-4490">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="c1087-4491">標示為存取`volatile`只有該單一存取; 會影響其他存取相同的位置必須分別標示。</span><span class="sxs-lookup"><span data-stu-id="c1087-4491">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="c1087-4492">不需要以不可分割方式執行變動性的位置存取。</span><span class="sxs-lookup"><span data-stu-id="c1087-4492">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="c1087-4493"><xref:System.Reflection.Emit.OpCodes.Unaligned>和`volatile`可以按照任何順序結合前置詞。</span><span class="sxs-lookup"><span data-stu-id="c1087-4493">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="c1087-4494">後面必須緊接著`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。</span><span class="sxs-lookup"><span data-stu-id="c1087-4494">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="c1087-4495">只有`volatile`允許前置詞<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>指示。</span><span class="sxs-lookup"><span data-stu-id="c1087-4495">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="c1087-4496">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`volatile`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4496">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4497">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4497">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c1087-4498">計算評估堆疊頂端兩個值的位元 XOR，將結果推送至評估堆疊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c1087-4498">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c1087-4499">下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：</span><span class="sxs-lookup"><span data-stu-id="c1087-4499">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="c1087-4500">格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4500">Format</span></span>|<span data-ttu-id="c1087-4501">組件格式</span><span class="sxs-lookup"><span data-stu-id="c1087-4501">Assembly Format</span></span>|<span data-ttu-id="c1087-4502">描述</span><span class="sxs-lookup"><span data-stu-id="c1087-4502">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="c1087-4503">61</span><span class="sxs-lookup"><span data-stu-id="c1087-4503">61</span></span>|<span data-ttu-id="c1087-4504">xor</span><span class="sxs-lookup"><span data-stu-id="c1087-4504">xor</span></span>|<span data-ttu-id="c1087-4505">計算兩個整數值的位元 XOR 並傳回一個整數。</span><span class="sxs-lookup"><span data-stu-id="c1087-4505">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="c1087-4506">堆疊的轉換行為，依連續順序是：</span><span class="sxs-lookup"><span data-stu-id="c1087-4506">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="c1087-4507">`value1` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4507">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="c1087-4508">`value2` 推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4508">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="c1087-4509">`value2` 和`value1`會彈出從堆疊和其位元 XOR 計算。</span><span class="sxs-lookup"><span data-stu-id="c1087-4509">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="c1087-4510">位元 XOR`value2`和`value1`推送至堆疊。</span><span class="sxs-lookup"><span data-stu-id="c1087-4510">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="c1087-4511">`xor`指令會計算位元 XOR 的前兩個值在堆疊上，並將結果留在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="c1087-4511">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="c1087-4512">`Xor` 是整數特定作業。</span><span class="sxs-lookup"><span data-stu-id="c1087-4512">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="c1087-4513">下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`xor`opcode:</span><span class="sxs-lookup"><span data-stu-id="c1087-4513">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="c1087-4514">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="c1087-4514">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>