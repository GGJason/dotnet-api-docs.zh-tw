<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="922fb9597fe60f2fe290329ee8a5f430c0343e13" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36645506" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供 Microsoft Intermediate Language (MSIL) 指令的欄位表示，以用於 <see cref="T:System.Reflection.Emit.ILGenerator" /> 類別成員 (例如 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />) 的發出。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如成員 opcode 的詳細說明，請參閱 Common Language Infrastructure (CLI) 文件，尤其是 < 磁碟分割 III: CIL 指令集 > 和 < 資料分割第二部分： 中繼資料定義和語意 >。 您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。  
  
   
  
## Examples  
 下列範例會示範動態方法，使用的建構<xref:System.Reflection.Emit.ILGenerator>發出`OpCodes`到<xref:System.Reflection.Emit.MethodBuilder>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相加兩個值，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|58|加入|將兩個數值，傳回新的數值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`加入至`value2`。  
  
4.  結果會推送至堆疊。  
  
 溢位未偵測到適用於整數作業 (如適當溢位處理，請參閱<xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。  
  
 整數加法包裝，而不是飽和。 例如，假設 8 位元整數其中`value1`設為 255 和`value2`設為 1，已包裝的結果會是 0，而不是 256。  
  
 傳回浮點溢位`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 可接受的運算元類型和其對應的結果資料類型會在下表中列出。 如果沒有任何項目，針對特定類型組合 (例如，`int32`和`float`;`int32`和`int64`)，它是無效 Microsoft Intermediate Language (MSIL)，並產生錯誤。  
  
|運算元|value1 類型|value2 類型|結果型別|  
|-------------|-----------------|-----------------|-----------------|  
|加入|`int32`|`int32`|`int32`|  
|加入|`int32`|`native int`|`native int`|  
|加入|`int32`|`&`|`&`|  
|加入|`int32`|`*`|`*`|  
|加入|`int64`|`int64`|`int64`|  
|加入|`native int`|`int32`|`native int`|  
|加入|`native int`|`native int`|`native int`|  
|加入|`native int`|`&`|`&`|  
|加入|`native int`|`*`|`*`|  
|加入|`F`|`F`|`F`|  
|加入|`&`|`int32`|`&`|  
|加入|`&`|`native int`|`&`|  
|加入|`*`|`int32`|`*`|  
|加入|`*`|`native int`|`*`|  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`add`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相加兩個整數、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D6|add.ovf|將兩個溢位檢查的帶正負號的整數值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`加入至`value2`溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果不會出現在結果型別，會擲回。  
  
 您可以執行這項作業帶正負號的整數。 浮點值，使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 可接受的運算元類型和其對應的結果資料類型會在下表中列出。 如果沒有任何項目，針對特定類型組合 (例如，`int32`和`float`;`int32`和`int64`)，它是無效的 Microsoft Intermediate Language (MSIL) 指示並產生錯誤。  
  
|運算元|value1 類型|value2 類型|結果型別|  
|-------------|-----------------|-----------------|-----------------|  
|加入|`int32`|`int32`|`int32`|  
|加入|`int32`|`native int`|`native int`|  
|加入|`int32`|`&`|`&`|  
|加入|`int32`|`*`|`*`|  
|加入|`int64`|`int64`|`int64`|  
|加入|`native int`|`int32`|`native int`|  
|加入|`native int`|`native int`|`native int`|  
|加入|`native int`|`&`|`&`|  
|加入|`native int`|`*`|`*`|  
|加入|`F`|`F`|`F`|  
|加入|`&`|`int32`|`&`|  
|加入|`&`|`native int`|`&`|  
|加入|`*`|`int32`|`*`|  
|加入|`*`|`native int`|`*`|  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`add.ovf`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相加兩個不帶正負號的整數 (Unsigned Integer) 值、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|將兩個不帶正負號的整數值有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`加入至`value2`溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果不會出現在結果型別，會擲回。  
  
 您可以執行這項作業帶正負號的整數。 浮點值，使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 可接受的運算元類型和其對應的結果資料類型會在下表中列出。 如果沒有任何項目，針對特定類型組合 (例如，`int32`和`float`;`int32`和`int64`)，它是無效的 Microsoft Intermediate Language (MSIL) 指示並產生錯誤。  
  
|運算元|value1 類型|value2 類型|結果型別|  
|-------------|-----------------|-----------------|-----------------|  
|加入|`int32`|`int32`|`int32`|  
|加入|`int32`|`native int`|`native int`|  
|加入|`int32`|`&`|`&`|  
|加入|`int32`|`*`|`*`|  
|加入|`int64`|`int64`|`int64`|  
|加入|`native int`|`int32`|`native int`|  
|加入|`native int`|`native int`|`native int`|  
|加入|`native int`|`&`|`&`|  
|加入|`native int`|`*`|`*`|  
|加入|`F`|`F`|`F`|  
|加入|`&`|`int32`|`&`|  
|加入|`&`|`native int`|`&`|  
|加入|`*`|`int32`|`*`|  
|加入|`*`|`native int`|`*`|  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`add.ovf.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算兩個值的位元 AND 運算，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|指令|描述|  
|------------|-----------------|-----------------|  
|5F|和|判斷兩個整數值的位元 AND。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value1` 和`value2`會從堆疊; 推出計算兩個值的位元 AND。  
  
4.  結果會推送至堆疊。  
  
 `and`指令會在堆疊上的前兩個值的位元 AND 的計算，並將結果留在堆疊上。  
  
 `And` 是整數特定作業。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`and`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 Unmanaged 指標傳回目前方法的引數清單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 00|引數清單|傳回目前方法的引數清單控制代碼。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `arglist`指令傳回的不透明控制代碼 (類型的 unmanaged 的指標`native int`)，代表目前方法的引數清單。 這個控制代碼只有在目前方法的存留期間是有效的。 不過，您可以給其他方法傳遞控制代碼，只要是控制項的執行緒上的目前的方法。 您只能執行`arglist`接受可變數目的引數的方法中的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`arglist`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果兩個值相等，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|分支至目標指令，位移`target`兩個值是否相等。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`等於`value2`，執行分支作業。  
  
 `beq`指令將控制權傳輸至指定的目標指令如果`value1`等於`value2`。 其效果等同於執行`ceq`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 封裝可接受的運算元類型如下：  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。  
  
 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令 (這類傳輸有嚴格限制，而且必須使用<xref:System.Reflection.Emit.OpCodes.Leave>指令改為)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`beq`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果兩個值相等，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2E < `int8` >|後 `target`|分支至目標指令，位移`target`如果相等的簡短形式|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`等於`value2`，執行分支作業。  
  
 `beq.s`指令將控制權傳輸至指定的目標指令如果`value1`等於`value2`。 其效果等同於執行`ceq`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 封裝可接受的運算元類型如下：  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。  
  
 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令 (這類傳輸有嚴格限制，而且必須使用<xref:System.Reflection.Emit.OpCodes.Leave>指令改為)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`beq.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於或等於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge.s 使用 `target`|分支到指定之位移的第一個值是否大於或等於第二個值的目標指令。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於或等於`value2`，執行分支作業。  
  
 `bge`指令將控制權傳輸至指定的目標指令如果`value1`大於或等於`value2`。 其效果等同於執行`clt.un`指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bge`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2F `<int8>`|後 `target`|分支至目標指令，於指定位移的第一個值是否大於或等於第二個值，也就是簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於或等於`value2`，執行分支作業。  
  
 `bge.s`指令將控制權傳輸至指定的目標指令如果`value1`大於或等於`value2`。 其效果等同於執行`clt.un`指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bge.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|分支到指定之位移的第一個值是否大於或等於第二個值 （不帶正負號值） 的目標指令。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於或等於`value2`，執行分支作業。  
  
 `bge.un`指令將控制權傳輸至指定的目標指令如果`value1`大於或等於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`clt`指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bge.un`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|分支至目標指令，於指定位移的第一個值是否大於或等於第二個值 （不帶正負號值），簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於或等於`value2`，執行分支作業。  
  
 `bge.un.s`指令將控制權傳輸至指定的目標指令如果`value1`大於或等於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`clt`指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bge.un.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt.s 使用 `target`|分支到指定之位移的第一個值是否大於第二個值的目標指令。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於`value2`，執行分支作業。  
  
 `bgt`指令將控制權傳輸至指定的目標指令如果`value1`大於`value2`。 其效果等同於執行`cgt`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bgt`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|30 < `int8` >|後 `target`|分支至目標指令，於指定位移的第一個值是否大於第二個值，也就是簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於`value2`，執行分支作業。  
  
 `bgt.s`指令將控制權傳輸至指定的目標指令如果`value1`大於`value2`。 其效果等同於執行`cgt`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bgt.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|分支到指定之位移的第一個值是否大於第二個值 （不帶正負號值） 的目標指令。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於`value2`，執行分支作業。  
  
 `bgt.un`指令將控制權傳輸至指定的目標指令如果`value1`大於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`cgt.un`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bgt.un`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|分支至目標指令，於指定位移的第一個值是否大於第二個值 （不帶正負號值），簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`大於`value2`，執行分支作業。  
  
 `bgt.un.s`指令將控制權傳輸至指定的目標指令如果`value1`大於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`cgt.un`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bgt.un.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3E `<int32>`|b `target`|分支到指定之位移的第一個值是否小於或等於第二個值的目標指令。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`小於或等於`value2`，執行分支作業。  
  
 `ble`指令將控制權傳輸至指定的目標指令如果`value1`小於或等於`value2`。 其效果等同於執行`cgt`指令 (`cgt.un`為浮動) 後面接著`brfalse`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ble`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|31 `<int8>`|後 `target`|分支至目標指令，於指定位移的第一個值是否小於或等於第二個值，也就是簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`小於或等於`value2`，執行分支作業。  
  
 `ble.s`指令將控制權傳輸至指定的目標指令如果`value1`小於或等於`value2`。 其效果等同於執行`cgt`指令 (`cgt.un`為浮動) 指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ble.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|分支到指定之位移的第一個值是否小於或等於第二個值 （不帶正負號值） 的目標指令。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`小於或等於`value2`，執行分支作業。  
  
 `ble.un`指令將控制權傳輸至指定的目標指令如果`value1`小於或等於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`cgt.un`指令 (`cgt`為浮動) 後面接著`brfalse`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ble.un`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|分支至目標指令，於指定位移的第一個值是否小於或等於第二個值 （不帶正負號值），簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`小於或等於`value2`，執行分支作業。  
  
 `ble.un.s`指令將控制權傳輸至指定的目標指令如果`value1`小於或等於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`cgt.un`指令 (`cgt`為浮動) 後面接著`brfalse`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ble.un.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|若要在指定的位移的第一個值是否小於第二個值的目標指令的分支。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`是小於`value2`，執行分支作業。  
  
 `blt`指令將控制權傳輸至指定的目標指令如果`value1`小於或等於`value2`。 其效果等同於執行`clt`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`blt`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|32 < `int8` >|後 `target`|若要在指定的位移的第一個值是否小於第二個值，簡短形式的目標指令的分支。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`是小於`value2`，執行分支作業。  
  
 `blt.s`指令將控制權傳輸至指定的目標指令如果`value1`是小於`value2`。 其效果等同於執行`clt`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`blt.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|若要在指定的位移的第一個值是否小於第二個值 （不帶正負號值） 的目標指令的分支。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`是小於`value2`，執行分支作業。  
  
 `blt.un`指令將控制權傳輸至指定的目標指令如果`value1`是小於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`clt.un`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`blt.un`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|若要在指定的位移的第一個值是否小於第二個值 （不帶正負號值），簡短形式的目標指令的分支。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`是小於`value2`，執行分支作業。  
  
 `blt.un`指令將控制權傳輸至指定的目標指令如果`value1`是小於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`clt.un`指令，後面跟著`brtrue`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`blt.un.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當兩個不帶正負號的整數值或未按順序的浮點值不相等時，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|分支至目標指令於指定位移，如果兩個不帶正負號的整數值會等於 （不帶正負號的值）。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`不等於`value2`，執行分支作業。  
  
 `bne.un`指令將控制權傳輸至指定的目標指令如果`value1`不等於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`ceq`指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bne.un`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當兩個不帶正負號的整數值或未按順序的浮點值不相等時，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|分支至目標指令於指定位移，如果兩個不帶正負號的整數值是不相等的 （不帶正負號的值）、 簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊; 如果`value1`不等於`value2`，執行分支作業。  
  
 `bne.un`指令將控制權傳輸至指定的目標指令如果`value1`不等於`value2`，當使用不帶正負號的整數或未按順序的浮點值進行比較。 其效果等同於執行`ceq`指令，後面跟著`brfalse`分支到特定的目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`bne.un.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將實值型別 (Value Type) 轉換成物件參考 (型別 <see langword="O" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8C < `T` >|方塊 `valTypeToken`|轉換實值類型 (在指定之型別的`valTypeToken`) 為真正的物件參考。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  實值類型會推送至堆疊。  
  
2.  從堆疊，則會彈出實值型別，`box`執行作業。  
  
3.  產生的 「 boxed"的值類型的物件參考被推入堆疊。  
  
 實值類型有兩種不同的表示法中通用語言基礎結構 (CLI):  
  
-   「 原始 」 形式，當實值類型內嵌在另一個物件，或在堆疊上時。  
  
-   實值型別中的資料都包裝 （進行 boxed 處理） 成物件，它可以做為獨立的實體 'boxed' 格式。  
  
 `box`指令會將 「 原始 」 (unboxed) 的值類型轉換成物件參考 (類型`O`)。 這會透過建立新物件，並將資料複製到新配置的物件的值型別。 `valTypeToken` 這中繼資料語彙基元表示在堆疊上之值型別的型別。  
  
 <xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 轉換為原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`box`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無條件地將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|分支至目標指令指定的位移。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `br`指令無條件地將控制權傳輸至目標指令。 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`br`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無條件地將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|分支至目標指令指定的位移，簡短形式。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `br.s`指令無條件地將控制權傳輸至目標指令。 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`br.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以訊號指示 Common Language Infrastructure (CLI) 向偵錯工具告知已經過中斷點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|01|break|通知偵錯工具已到達中斷點。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `break`指示適用於偵錯支援。 它會通知來通知偵錯工具中斷點已跳脫 CLI。 它有沒有其他影響解譯器的狀態。  
  
 `break`指令具有最小可能的指令大小可讓程式碼中斷點修補和產生周圍的程式碼所造成的最小影響。  
  
 `break`指令落入偵錯工具，不執行任何動作，或引發安全性例外狀況。 確切的行為是由實作定義。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`break`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 為 <see langword="false" />、Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />) 或零，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|在指定的位移 if 的目標指令的分支`false`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 為推送至堆疊上前一項作業。  
  
2.  `value` 從堆疊; 推出如果`value`是`false`，分支到`target`。  
  
 `brfalse`指令 (和其別名`brnull`和`brzero`) 將控制權傳輸至指定的目標指令，如果`value`(型別`int32`， `int64`，物件參考`O`、 managed 指標`&`，暫時性指標`*`， `native int`) 為零 (`false`)。 如果`value`為非零 (`true`) 繼續執行下一個指令。  
  
 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`brfalse`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 為 <see langword="false" />、Null 參考或零，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|在指定的位移 if 的目標指令的分支`false`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 為推送至堆疊上前一項作業。  
  
2.  `value` 從堆疊; 推出如果`value`是`false`，分支到`target`。  
  
 `brfalse.s`指令 (和其別名`brnull`和`brzero`) 將控制權傳輸至指定的目標指令，如果`value`(型別`int32`， `int64`，物件參考`O`、 managed 指標`&`，暫時性指標`*`， `native int`) 為零 (`false`)。 如果`value`為非零 (`true`) 繼續執行下一個指令。  
  
 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`brfalse.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 為 <see langword="true" />、非 Null 或非零，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|如果不是零，分支至目標指令指定的位移 (`true`)。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 為推送至堆疊上前一項作業。  
  
2.  `value` 從堆疊; 推出如果`value`是`true`，分支到`target`。  
  
 `brtrue`指令將控制權傳輸至指定的目標指令如果`value`(型別`native int`) 為非零值 (`true`)。 如果`value`為零 (`false`) 繼續執行下一個指令。  
  
 如果`value`都是物件參考 (類型`O`) 然後`brinst`(別名`brtrue`) 將控制項傳送，如果它代表物件的執行個體 (例如，如果不是 null 物件的參考; 請參閱<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 目標指令以 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`brtrue`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 為 <see langword="true" />、非 Null 或非零，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|如果不是零，分支至目標指令指定的位移 (`true`)，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 為推送至堆疊上前一項作業。  
  
2.  `value` 從堆疊; 推出如果`value`是`true`，分支到`target`。  
  
 `brtrue.s`指令將控制權傳輸至指定的目標指令如果`value`(型別`native int`) 為非零值 (`true`)。 如果`value`為零 (`false`) 繼續執行下一個指令。  
  
 如果`value`都是物件參考 (類型`O`) 然後`brinst`(別名`brtrue`) 將控制項傳送，如果它代表物件的執行個體 (例如，如果不是 null 物件的參考; 請參閱<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 目標指令被以 1 個位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`brtrue.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼叫傳遞的方法描述項所指示的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|28 < `T` >|呼叫 `methodDesc`|呼叫所描述的方法`methodDesc`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  方法引數`arg1`透過`argN`推送至堆疊。  
  
2.  方法引數`arg1`透過`argN`會從堆疊; 推出方法呼叫會使用這些引數來執行，控制權會轉移到方法描述元所參考的方法。 完成時，傳回值是由被呼叫端方法所產生並傳送至呼叫端。  
  
3.  傳回值推送至堆疊。  
  
 `call`指令呼叫指令與傳遞方法描述項所指示的方法。 方法描述元是中繼資料語彙基元，指出呼叫的數目、 類型及放置在堆疊傳遞至該方法，以及要使用的呼叫慣例，引數順序的方法。 `call`指示可以立即加`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前置詞來指定應在之前將控制權傳輸釋出目前的方法狀態的指令。 如果呼叫會將控制權傳輸至較高的信任，比原始方法的方法，才會釋放堆疊框架。 相反地，繼續執行無訊息方式如同`tail`尚未提供。 中繼資料語彙基元會有足夠的資訊來判斷是否呼叫的是靜態方法、 執行個體方法，虛擬方法或全域函式。 在這些情況下的所有目的地位址由都決定完全從方法描述元 (與<xref:System.Reflection.Emit.OpCodes.Callvirt>指令呼叫虛擬方法，其中的目的地位址也會根據執行個體的執行階段類型參考推入之前<xref:System.Reflection.Emit.OpCodes.Callvirt>)。  
  
 引數會放置在堆疊上，在左到右的順序。 也就是第一個引數是計算並放置在堆疊中，第二個引數，然後第三個，直到所有必要的引數以遞減順序堆疊的頂端。 有三個重要的特殊情況：  
  
 1. 呼叫執行個體 （或虛擬） 方法必須將推入執行個體參考之前的任何使用者可見的引數。 執行個體參考不能為 null 參考。 執行中繼資料中的簽章不包含在參數清單中的項目`this`指標; 相反地，它使用位元來表示方法是否必須傳遞`this`指標。  
  
 2. 它是有效的虛擬方法，使用呼叫`call`(而非`callvirt`); 這表示，方法是使用指定的方法，而不是以動態方式叫用的物件中指定的類別來解析。  
  
 3. 請注意，委派的`Invoke`方法可以呼叫其中一種`call`或`callvirt`指令。  
  
 <xref:System.Security.SecurityException> 可能會擲回，如果系統安全性不授與被呼叫的方法的呼叫端存取。 原生程式碼，而不是在執行階段轉換的 Microsoft Intermediate Language (MSIL) 指示時，可能會發生安全性檢查。  
  
> [!NOTE]
>  當呼叫的 System.Object 方法，實值型別，請考慮使用`constrained`加上前置詞`callvirt`指令，而不是發出`call`指令。 這會移除需要發出避免潛在的版本控制問題實值型別會覆寫方法，根據不同的 IL。 請考慮使用`constrained`可以使用變更時叫用介面方法實值型別，因為實作介面方法的值類型方法的前置詞`MethodImpl`。 更詳細地描述這些問題<xref:System.Reflection.Emit.OpCodes.Constrained>opcode。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`call`作業碼：  
  
-   ILGenerator.Emit （OpCode，MethodInfo）  
  
-   ILGenerator.EmitCall (OpCode，MethodInfo Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法會提供給`varargs`呼叫。 使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>一般呼叫的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以呼叫慣例所描述的引數，呼叫在評估堆疊上指示的方法 (做為進入點的指標)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|呼叫的呼叫慣例所描述的引數指向的方法。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  方法引數`arg1`透過`argN`推送至堆疊。  
  
2.  方法進入點指標會推送至堆疊。  
  
3.  方法引數`arg1`透過`argN`方法進入點指標會從堆疊推出之後，執行方法呼叫。 完成時，傳回值是由被呼叫端方法所產生並傳送至呼叫端。  
  
4.  傳回值推送至堆疊。  
  
 `calli`指令呼叫方法的輸入指標，以引數`arg1`透過`argN`。 這些引數類型會描述特定的呼叫慣例 (`callSiteDesc`)。 `calli`指示可能立即加`tail`前置詞 (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 以指定目前的方法狀態的應該釋放之前將控制權傳輸。 如果呼叫，就會傳輸將不會釋放控制項的較高的信任，比原始方法的堆疊框架的方法;相反地，將會繼續執行無訊息方式如同`tail`尚未提供。  
  
 方法的項目指標會假設為特定原生程式碼 （的目標電腦） 可以合法呼叫 （獨立簽章的中繼資料語彙基元） 的呼叫慣例所描述的引數的指標。 您可以使用建立這類指標<xref:System.Reflection.Emit.OpCodes.Ldftn>或<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>指示，或從原生程式碼中傳遞。  
  
 呼叫慣例，不會檢查動態，因此程式碼，它使用`calli`指令無法正常運作如果目的地不會實際使用指定的呼叫慣例。  
  
 引數會放置在堆疊上，在左到右的順序。 也就是第一個引數是計算並放置在堆疊中，第二個引數，然後第三個，直到所有必要的引數以遞減順序堆疊的頂端。 在執行個體或虛擬方法的引數建置程式碼序列必須將該執行個體參考 （即不得為 null 參考） 推入之前的任何使用者可見的引數。  
  
 <xref:System.Security.SecurityException> 可能會擲回，如果系統安全性不授與被呼叫的方法的呼叫端存取。 Microsoft Intermediate Language (MSIL) 指示會轉換為原生程式碼，而不是在執行階段，就會發生安全性檢查。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法可以用來執行`calli`堆疊上的指示。 請注意，`calli`應該透過呼叫方法，而不是使用以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>類別，以指示將直接放在堆疊。  
  
-   ILGenerator.EmitCalli (Opcode、 CallingConventions、 型別，Type []，Type[]) 呼叫使用 managed 呼叫慣例。  
  
-   ILGenerator.EmitCalli (Opcode，CallingConvention，型別，Type[]) 呼叫使用 unmanaged 呼叫慣例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在物件上呼叫晚期繫結方法，將傳回值推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|呼叫相關聯的特定方法`obj`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`obj`推入至堆疊。  
  
2.  方法引數`arg1`透過`argN`推送至堆疊。  
  
3.  方法引數`arg1`透過`argN`和物件參考`obj`會從堆疊; 推出方法呼叫會使用這些引數來執行，控制權會轉移到中的方法`obj`方法參考中繼資料語彙基元。 完成時，傳回值是由被呼叫端方法所產生並傳送至呼叫端。  
  
4.  傳回值推送至堆疊。  
  
 `callvirt`指令的物件上呼叫晚期繫結方法。 亦即，方法將根據選擇的執行階段類型`obj`而不是編譯時間類別顯示在方法指標。 `Callvirt` 可用虛擬呼叫和執行個體方法。 `callvirt`指示可能立即加`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 來指定應該釋放目前的堆疊框架，才能將控制權傳輸的前置詞。 如果呼叫，就會傳輸將不會釋放控制項的較高的信任，比原始方法的堆疊框架的方法。  
  
 方法的中繼資料語彙基元提供名稱、 類別和要呼叫之方法的簽章。 與相關聯的類別`obj`是它的執行個體的類別。 如果類別定義與指定的方法名稱和簽章相符的非靜態方法，會呼叫這個方法。 否則順序會檢查這個類別的基底類別鏈結中的所有類別。 如果找不到任何方法，它會發生錯誤。  
  
 `Callvirt` 呼叫方法之前，會顯示物件和相關聯的引數評估堆疊。 如果方法具有傳回值，則會將它推入方法完成時的堆疊。 在被呼叫端，`obj`參數會做為引數為 0，存取`arg1`做為引數 1，依此類推。  
  
 引數會放置在堆疊上，在左到右的順序。 也就是第一個引數是計算並放置在堆疊中，第二個引數，然後第三個，直到所有必要的引數以遞減順序堆疊的頂端。 執行個體參考`obj`(一律需`callvirt`) 之前的任何使用者可見的引數都必須推送。 簽章 （中繼資料語彙基元攜帶） 不需要這個包含參數清單中的項目指標。  
  
 請注意，虛擬方法也可以呼叫使用<xref:System.Reflection.Emit.OpCodes.Call>指令。  
  
 <xref:System.MissingMethodException> 如果相關聯的類別中找不到具有指定的名稱和簽章的非靜態方法會擲回`obj`或任何基底類別。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 <xref:System.NullReferenceException> 如果 obj 為 null，會擲回。  
  
 <xref:System.Security.SecurityException> 如果系統安全性不授與被呼叫的方法的呼叫端存取，會擲回。 CIL 轉換為原生程式碼，而不是在執行階段時，可能會發生安全性檢查。  
  
> [!NOTE]
>  當呼叫的 System.Object 方法，實值型別，請考慮使用`constrained`加上前置詞`callvirt`指令。 這會移除需要發出避免潛在的版本控制問題實值型別會覆寫方法，根據不同的 IL。 請考慮使用`constrained`可以使用變更時叫用介面方法實值型別，因為實作介面方法的值類型方法的前置詞`MethodImpl`。 更詳細地描述這些問題<xref:System.Reflection.Emit.OpCodes.Constrained>opcode。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`callvirt`作業碼：  
  
-   ILGenerator.Emit （OpCode，MethodInfo）  
  
-   ILGenerator.EmitCall (OpCode，MethodInfo Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>嘗試將參考所傳遞的物件轉型為指定的類別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|將新物件型別的物件轉換`class`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考推送至堆疊。  
  
2.  從堆疊，則會彈出物件參考，參考的物件轉換為指定`class`。  
  
3.  如果成功，新的物件參考被推入堆疊。  
  
 `castclass`指令嘗試轉換成物件參考 (類型`O`) 至指定的類別堆疊的頂端。 指出所需的類別中繼資料語彙基元指定新的類別。 如果在堆疊的頂端物件的類別未實作 （假設新的類別一種介面） 的新類別，而且不是在衍生的類別的新類別則<xref:System.InvalidCastException>就會擲回。 如果物件參考為 null 參考，`castclass`成功並傳回新的物件為 null 參考。  
  
 <xref:System.InvalidCastException> 如果 obj 無法轉換成類別，會擲回。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指令轉換為原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`castclass`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個值。 如果相等，則將整數值 1 (<see langword="(int32" />) 推入至評估堆疊，否則將 0 (<see langword="int32" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 01|ceq|如果將推送 1`value1`等於`value2`，否則推播通知 0。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`相較於`value2`。  
  
4.  如果`value1`等於`value2`，1 會推送到堆疊; 否則為 0 會推送到堆疊。  
  
 `ceq`指令比較`value1`和`value2`。 如果`value1`等於`value2`、 然後 1 (型別`int32`) 推送到堆疊上。 否則為 0 (型別`int32`) 推送到堆疊上。  
  
 浮點數，如`ceq`的數字為未排序，則會傳回 0 （或兩者皆是 NaN）。 無限的值會等於其本身。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ceq`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個值。 如果第一個值大於第二個值，則將整數值 1 (<see langword="(int32" />) 推入至評估堆疊，否則，將 0 (<see langword="int32" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 02|cgt|如果將推送 1`value1`大於`value2`，否則推播通知 0。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`cgt`測試`value1`大於`value2`。  
  
4.  如果`value1`大於`value2`，1 會推送到堆疊; 否則為 0 會推送到堆疊。  
  
 `cgt`指令比較`value1`和`value2`。 如果`value1`必定大於`value2`，則`int32`1 的值推入堆疊。 否則，`int32`值為 0 推送到堆疊上。  
  
-   浮點數，如`cgt`如果 （亦即，如果一或兩個引數是 NaN） 的數字為未排序，則傳回 0。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`cgt`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個沒有正負號或未排序的值。 如果第一個值大於第二個值，則將整數值 1 (<see langword="(int32" />) 推入至評估堆疊，否則，將 0 (<see langword="int32" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|如果將推送 1`value1`大於`value2`，否則推播通知 0 （不帶正負號值）。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`cgt.un`測試`value1`大於`value2`。  
  
4.  如果`value1`大於`value2`，1 會推送到堆疊; 否則為 0 會推送到堆疊。  
  
 `int32`值 1 會推送到堆疊上，如果下列任一`true`:  
  
 浮點數，如`value1`相對於未經過排序`value2`。  
  
 對於整數值`value1`必定大於`value2`時被視為與不帶正負號的數字。  
  
 否則`int32`值為 0 推送到堆疊上。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`cgt.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果值非有限數值，則擲回 <see cref="T:System.ArithmeticException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|C3|ckfinite|擲回<xref:System.ArithmeticException>如果值不是有限的數字。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 已推送至堆疊...  
  
2.  `value` 從堆疊推出和`ckfinite`指令會在其上執行。  
  
3.  `value` 被推回堆疊如果擲不回任何例外狀況。  
  
 `ckfinite instruction`會擲回<xref:System.ArithmeticException>如果`value`（浮點數） 是 「 不是數字 」 值 (NaN) 或`+-`無限大值。 `Ckfinite` 如果擲不回任何例外狀況，讓值在堆疊上。 如果是未指定執行`value`不是浮點數。  
  
 <xref:System.ArithmeticException> 如果擲回`value`不是 'normal' 的數字。  
  
 請注意，特殊的例外狀況或衍生的類別的<xref:System.ArithmeticException>可能會更加適合，將不正確的值傳遞至例外狀況處理常式。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ckfinite`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個值。 如果第一個值小於第二個值，則將整數值 1 (<see langword="(int32" />) 推入至評估堆疊，否則，將 0 (<see langword="int32" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 04|clt|如果將推送 1`value1`是小於`value2`，否則推播通知 0。|  
  
 堆疊的轉換行為，依連續順序為：`value1`推入至堆疊。  
  
1.  `value2` 推入至堆疊。  
  
2.  `value2` 和`value1`取出從堆疊。`clt`測試`value1`是小於`value2`。  
  
3.  如果`value1`是小於`value2`，1 會推送到堆疊; 否則為 0 會推送到堆疊。  
  
 `clt`指令比較`value1`和`value2`。 如果`value1`是嚴格小於`value2`，則`int32`1 的值推入堆疊。 否則，`int32`值為 0 推送到堆疊上。  
  
-   浮點數，如`clt`如果 （亦即，如果一或兩個引數是 NaN） 的數字為未排序，則傳回 0。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`clt`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較不帶正負號或未按順序的值 <paramref name="value1" /> 和 <paramref name="value2" />。 如果 <paramref name="value1" /> 小於 <paramref name="value2" />，則將整數值 1 (<see langword="(int32" />) 推入至評估堆疊，否則將 0 (<see langword="int32" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|如果將推送 1`value1`是小於`value2`，否則推播通知 0 （不帶正負號值）。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`clt.un`測試`value1`是小於`value2`。  
  
4.  如果`value1`是小於`value2`，1 會推送到堆疊; 否則為 0 會推送到堆疊。  
  
 `clt.un`指令比較`value1`和`value2`。 `int32`值 1 會推送到堆疊上，如果下列任一項為真：  
  
-   `value1` 是嚴格小於`value2`(與`clt`)。  
  
-   浮點數，如`value1`相對於未經過排序`value2`。  
  
-   對於整數值`value1`是嚴格小於`value2`時被視為與不帶正負號的數字。  
  
 否則，`int32`值為 0 推送到堆疊上。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`clt.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>限制其上可進行虛擬方法呼叫的類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|受到條件約束。 `thisType`|呼叫虛擬方法的型別上限制類型`T`。|  
  
 `constrained`前置詞僅允許`callvirt`指令。  
  
 此時 MSIL 堆疊的狀態必須如下所示：  
  
1.  受管理的指標， `ptr`，推入至堆疊。 型別`ptr`必須是 managed 的指標 (`&`) 至`thisType`。 請注意，這不同於無前置詞的大小寫`callvirt`指令，需要的參考`thisType`。  
  
2.  方法引數`arg1`透過`argN`推入至堆疊，就像處理未加前置詞`callvirt`指令。  
  
 `constrained`前置詞的設計可讓`callvirt`指示中進行一致的方式獨立是否`thisType`是實值類型或參考型別。  
  
 當`callvirt``method`指令加`constrained` `thisType`，指示執行，如下所示：  
  
-   如果`thisType`是參考類型 （而不是實值類型），則`ptr`已取值，而且傳遞 'this' 指標`callvirt`的`method`。  
  
-   如果`thisType`是實值類型和`thisType`實作`method`然後`ptr`傳遞未修改與 'this' 指標`call``method`指示，用於實作的`method`由`thisType`.  
  
-   如果`thisType`是實值類型和`thisType`未實作`method`然後`ptr`是取值，會進行 boxed 處理，以及傳遞做為 'this' 指標`callvirt``method`指令。  
  
 最後一個案例中可能會發生時，才`method`上已定義<xref:System.Object>， <xref:System.ValueType>，或<xref:System.Enum>不覆寫`thisType`。 在此情況下，boxing 會設為原始物件的複本。 不過，因為沒有任何方法的<xref:System.Object>， <xref:System.ValueType>，和<xref:System.Enum>修改狀態的物件，無法偵測出此事實。  
  
 `constrained`前置詞支援建立泛型程式碼的 IL 產生器。 通常`callvirt`指令實值型別無效。 而是它需要 IL 編譯器有效地執行以上所述，在編譯時期，根據類型的 'this' 的轉換`ptr`和被呼叫的方法。 不過，當`ptr`不明在編譯時期為泛型型別不可能執行這項轉換在編譯時間。  
  
 `constrained` Opcode 允許進行統一的虛擬函式的呼叫是否方式無關的 IL 編譯器`ptr`是實值類型或參考型別。 雖然本指南適用於大小寫，但其中`thisType`是泛型型別變數，`constrained`首碼也適用於非泛型型別，而且可以減少虛擬呼叫產生的隱藏實值型別之間的差別語言的複雜性和參考型別。  
  
 使用`constrained`前置詞也可避免潛在的版本控制問題實值類型。 如果`constrained`不使用前置詞，根據實值類型是否會覆寫 System.Object 的方法必須發出不同的 IL。 例如，如果實值類型`V`覆寫 object.tostring （） 方法， `call` `V.ToString()`指令，就會發出; 如果沒有出現，請`box`指令和`callvirt``Object.ToString()`指令會發出。 版本控制問題可能會發生在先前的情況下，如果稍後移除覆寫，並在後者的情況下如果稍後加入覆寫。  
  
 `constrained`前置詞也可用在實值類型上的介面方法引動過程因為實作介面方法的值類型方法可以使用變更`MethodImpl`。 如果`constrained`不使用前置詞時，編譯器會強制選擇其中一個值在編譯時期繫結至類型的方法。 使用`constrained`前置詞可讓繫結至的方法，在執行階段，而不是在編譯時期實作介面方法的 MSIL。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`constrained`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D3|conv.i|將轉換成`native int`、 推送`native int`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.i` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.i`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="int8" />，然後將它擴充 (填補) 到 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|67|conv.i1|將轉換成`int8`、 推送`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.i1` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.i1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="int16" />，然後將它擴充 (填補) 到 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|68|conv.i2|將轉換成`int16`、 推送`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.i2` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.i2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|69|conv.i4|將轉換成`int32`、 推送`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.i4` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.i4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6A|conv.i8|將轉換成`int64`、 推送`int64`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.i8` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.i8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成帶正負號的 <see langword="native int" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|將轉換成`native int`(做為在堆疊上`native int`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成帶正負號的 <see langword="native int" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|將不帶正負號的值轉換`native int`(做為在堆疊上`native int`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成帶正負號 <see langword="int8" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|將轉換成`int8`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i1` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成帶正負號的 <see langword="int8" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|將不帶正負號的值轉換`int8`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i1.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i1.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成帶正負號的 <see langword="int16" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|將轉換成`int16`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i2` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成帶正負號的 <see langword="int16" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|將不帶正負號的值轉換`int16`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i2.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i2.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成帶正負號的 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|將轉換成`int32`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i4` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成帶正負號的 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|將不帶正負號的值轉換`int32`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i4.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i4.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成帶正負號的 <see langword="int64" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|將轉換成`int64`(做為在堆疊上`int64`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i8` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成帶正負號的 <see langword="int64" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|將不帶正負號的值轉換`int64`(做為在堆疊上`int64`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.i8.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.i8.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成 <see langword="unsigned native int" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|將轉換成`unsigned native int`(做為在堆疊上`native int`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成 <see langword="unsigned native int" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|將取消不帶正負號的值`unsigned native int`(做為在堆疊上`native int`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.uvf.u.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成 <see langword="unsigned int8" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|將轉換成`unsigned int8`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u1` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成 <see langword="unsigned int8" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|將不帶正負號的值轉換`unsigned int8`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u1.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u1.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成 <see langword="unsigned int16" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|將轉換成`unsigned int16`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u2` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成 <see langword="unsigned int16" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|將不帶正負號的值轉換`unsigned int16`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u2.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u2.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成 <see langword="unsigned int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|將轉換成`unsigned int32`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u4` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成 <see langword="unsigned int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|將不帶正負號的值轉換`unsigned int32`(做為在堆疊上`int32`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u4.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u4.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成 <see langword="unsigned int64" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|將轉換成`unsigned int64`(做為在堆疊上`int64`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u8` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換成 <see langword="unsigned int64" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|將不帶正負號的值轉換`unsigned int64`(做為在堆疊上`int64`) 和溢位時擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.ovf.u8.un` Opcode 轉換`value`opcode 及轉換值的堆疊頂端的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示由目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值會擴充以`int32`載入至評估堆疊 (除非`conv.ovf.i`或`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.ovf.u8.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的整數 (Unsigned Integer) 值轉換成 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|76|conv.r.un|轉換不帶正負號的整數到浮點數，推入`F`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.r.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數`result`傳回未指定。 `conv.r.un`作業接受整數堆疊、 將它解譯為不帶正負號，並取代浮點數，表示整數： 任一`float32`，如果這是寬度不足以表示不會遺失有效位數的整數或其他`float64`。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.r.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6B|conv.r4|將轉換成`float32`、 推送`F`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.r4` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.r4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="float64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6C|conv.r8|將轉換成`float64`、 推送`F`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.r8` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.r8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="unsigned native int" />，並將它擴充到 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|E0|conv.u|將轉換成`unsigned native int`、 推送`native int`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.u` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.u`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="unsigned int8" />，並將它擴充到 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D2|conv.u1|將轉換成`int8`、 推送`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.u1` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.u1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="unsigned int16" />，並將它擴充到 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D1|conv.u2|將轉換成`int16`、 推送`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.u2` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.u2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="unsigned int32" />，並將它擴充到 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6D|conv.u4|將轉換成`unsigned int32`、 推送`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.u4` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.u4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端的值轉換成 <see langword="unsigned int64" />，並將它擴充到 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6E|conv.u8|將轉換成`int64`、 推送`int64`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，會產生的值推入至堆疊。  
  
 `conv.u8` Opcode 轉換`value`opcode 及轉換的堆疊頂端的值保持在指定的型別堆疊的頂端。 小於 4 個位元組的整數值已擴充來`int32`載入至評估堆疊 (除非`conv.i`或`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 將浮點數轉換為整數值會截斷趨近於零的數字。 當轉換從`float64`至`float32`，有效位數，可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`為正值) 或負的無限值 (如果`value`為負) 會傳回。 如果轉換一個整數類型之間發生溢位，則會截斷高序位位元。 如果結果為小於`int32`，值是帶正負號擴充以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數傳回的值是 unspecified。  
  
 使用此欄位時，曾經會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>為對應的結果型別不可以正確地表示的結果值時將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`conv.u8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將指定的數值位元組數從來源位址複製到目的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|將資料從一個記憶體區塊複製到另一個。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  目的地位址會推送至堆疊。  
  
2.  來源位址會推送至堆疊。  
  
3.  要複製的位元組數會推送至堆疊。  
  
4.  從堆疊; 所推出的位元組、 來源位址，以及目的地位址數目指定的位元組數目會從來源位址複製到目的地位址。  
  
 `cpblk`指示複製數目 (類型`unsigned int32`) 來源位址中的位元組 (型別`*`， `native int`，或`&`) 目的地位址 (型別`*`， `native int`，或`&`)。 行為`cpblk`是未指定，如果來源和目的區域重疊。  
  
 `cpblk` 假設，會將來源和目的位址對齊自然機器的大小。 `cpblk`指示可以立即加`unaligned.<prefix>`指令，以便指出未配置的來源或目的地。  
  
 作業`cpblk`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`cpblk`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於物件位址上的實值型別 (型別 <see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" />) 複製到目的物件的位址 (型別 <see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|目的地物件類型從來源物件複製的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  目的地物件參考推送至堆疊。  
  
2.  來源物件參考推送至堆疊。  
  
3.  兩個物件參考是從堆疊; 推出實值型別在位址的來源物件會複製到目的地物件的位址。  
  
 行為`cpobj`未指定來源和目的地物件的參考不是類別語彙基元所代表的類別執行個體的指標是否`classTok`(`typeref`或`typedef`)，或如果`classTok`不代表實值型別。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`cpobj`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>除兩個值，並將做為浮點 (型別 <see langword="F" />) 或商 (型別 <see langword="int32" />) 的結果推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5B|div|兩個值相除並傳回商數或浮點結果。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`除以`value2`。  
  
4.  結果會推送至堆疊。  
  
 `result` = `value1` div value2 滿足以下條件：  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;，和：  
  
 符號 (`result`) = +，如果登入 (`value1`) = 號 (`value2`)，或-，如果登 (`value1`) ~ = 號 (`value2`)  
  
 `div`指令計算結果，並將它推送至堆疊。  
  
 整數除法截斷推向零。  
  
 除以零的有限數目的分割產生正確帶正負號的無限值。  
  
 除以零的零個或無限大的無限值，便會產生 NaN （Not A-數字） 值。 任何數字除以無限大，會產生零值。  
  
 整數類資料的作業會擲回<xref:System.ArithmeticException>如果結果無法表示的結果型別中。 這種情況`value1`為最大負數的值，和`value2`為-1。  
  
 整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。  
  
 請注意，在 Intel 平台上<xref:System.OverflowException>計算 (minint div-1) 時，就會擲回。 浮點運算絕不會擲回例外狀況 （會產生 Nan 或無限大，為了改為）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`div`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>除以兩個不帶正負號的整數值，並將結果 (<see langword="int32" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5C|div.un|兩個值相除，不帶正負號，並傳回商數。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`除以`value2`。  
  
4.  結果會推送至堆疊。  
  
 `div.un`指令計算`value1`除以`value2`，兩者都被視為不帶正負號的整數和推播通知`result`堆疊上。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`div.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複製評估堆疊上目前最頂端的值，然後將複製推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|25|dup|重複項目在堆疊的頂端的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 是從重複的堆疊中取出。  
  
3.  `value` 為推回堆疊。  
  
4.  重複的值會推送至堆疊。  
  
 `dup`指令重複項目堆疊頂端的項目，並將留在它之上的兩個相同的值。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`dup`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將控制權從例外狀況的 <see langword="filter" /> 子句傳回 Common Language Infrastructure (CLI) 例外處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|結束 SEH 例外狀況處理的篩選子句。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 從堆疊; 推出`endfilter`執行，控制權會轉移到例外狀況處理常式。  
  
 `Value` (這必須是型別`int32`是其中一組特定值的一項) 傳回篩選子句。 它應為其中一個：  
  
-   `exception_continue_search` (`value` = 0) 繼續搜尋例外狀況處理常式  
  
-   `exception_execute_handler` (`value` = 1) 啟動第二個階段例外狀況處理 finally 區塊會執行之前使用此篩選子句相關聯的處理常式的所在。 發現時，會執行此處理常式。  
  
 其他整數值會產生未指定的結果。  
  
 篩選器的進入點方法的例外狀況資料表中所示必須在篩選條件的程式碼區塊的第一個指令。 `endfilter`指令必須是在篩選條件的程式碼區塊的最後一個指令 (因此只能有一個`endfilter`任何單一篩選條件區塊)。 在執行之後`endfilter`指示控制項邏輯流動回到 CLI 例外狀況處理機制。  
  
 控制項無法傳輸到篩選區塊以外，透過例外狀況機制。 控制項無法流出除了透過使用的篩選條件區塊`throw`指令或藉由執行最終`endfilter`指令。 無法內嵌`try`區塊內`filter`區塊。 如果內部擲回例外狀況`filter`區塊，遭到攔截，值為 0 (`exception_continue_search`) 會傳回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`endfilter`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將控制權從例外狀況區塊的 <see langword="fault" /> 或 <see langword="finally" /> 子句傳回 Common Language Infrastructure (CLI) 例外處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|結束`finally`或`fault`例外狀況區塊的子句。|  
  
 此指示的轉換行為沒有任何堆疊。  
  
 `Endfinally` 和`endfault`表示結束`finally`或`fault`子句，因此堆疊回溯之前叫用例外狀況處理常式可以繼續。 `endfinally`或`endfault`指令將控制權傳輸至 CLI 例外狀況機制。 機制，則下一個搜尋`finally`如果受保護的區塊已結束與 leave 鏈結中的子句。 如果受保護的區塊結束並發生例外狀況，CLI 會搜尋下一個`finally`或`fault`，或輸入第一個階段中的例外狀況處理期間所選擇的例外狀況處理常式。  
  
 `endfinally`指令可能只會出現在語彙上應`finally`區塊。 不同於`endfilter`指令，在區塊的結尾不需要`endfinally`指令，並沒有可以是許多`endfinally`視需要在區塊中的指示。 這些相同的限制適用於`endfault`指令和`fault`區塊。  
  
 控制項無法轉移至`finally`(或`fault`) 除了封鎖透過例外狀況機制。 控制項無法轉移出`finally`(或`fault`) 除了封鎖使用`throw`指令或執行`endfinally`(或`endfault`) 指令。 特別是，您無法"切換 」 的`finally`(或`fault`) 區塊，或執行<xref:System.Reflection.Emit.OpCodes.Ret>或<xref:System.Reflection.Emit.OpCodes.Leave>內指令`finally`(或`fault`) 區塊。  
  
 請注意，`endfault`和`endfinally`指示別名-它們對應於相同的作業碼。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`endfinally`(`endfault`) 作業碼，並將`ILGenerator`方法<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將指定位址上的指定記憶體區塊初始化為指定的大小和初始值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 18|initblk|設定每個位置中的指定值的記憶體區塊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  起始位址會推送至堆疊。  
  
2.  初始化值推入至堆疊。  
  
3.  要初始化的位元組數會推送到堆疊。  
  
4.  從堆疊取出位元組、 初始化值，以及起始位址的數目，並根據它們的值執行初始化。  
  
 `initblk`指令會將數字 (`unsigned int32`) 的指定位址開頭的位元組 (型別`native int`， `&`，或`*`) 初始化值 (類型的`unsigned int8`)。 `initblk` 假設的起始位址的對齊自然機器的大小。  
  
 作業`initblk`可以更改指示前置<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`initblk`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定位址之值類型的各個欄位，初始化為適當之基本類型的 null 參考或 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|初始化實值類型。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  初始化實值類型的位址被推入堆疊。  
  
2.  從堆疊，則會彈出位址，實值型別，在指定的位址初始化型別為`typeTok`。  
  
 `initobj`指令初始化推入位址所指定之值型別的每個欄位 (型別`native int`， `&`，或`*`) 為 null 參考或 0，以適當的基本類型。 呼叫這個方法之後，就有一個執行個體可供要呼叫的建構函式方法。 如果`typeTok`是參考型別，這個指令會有相同的效果`ldnull`後面`stind.ref`。  
  
 不同於<xref:System.Reflection.Emit.OpCodes.Newobj>，`initobj`不呼叫建構函式方法。 `Initobj` 是要用於初始化實值類型，而`newobj`用來配置及初始化物件。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`initobj`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>測試物件參考 (型別 <see langword="O" />) 是否為特定類別的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|測試的執行個體的物件參考是否`class`，傳回 null 參考或該類別的執行個體或介面。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考推送至堆疊。  
  
2.  物件參考是從堆疊取出並測試以查看它是否在傳遞類別的執行個體`class`。  
  
3.  將結果 （物件參考或 null 參考） 被推入堆疊。  
  
 `Class` 中繼資料語彙基元，代表所需的類別。 在堆疊的頂端物件的類別會實作`class`(如果`class`是一種介面) 的衍生的類別或`class`(如果`class`是一般類別) 然後它會轉換為輸入`class`和結果推入堆疊，完全一樣<xref:System.Reflection.Emit.OpCodes.Castclass>如同呼叫。 否則，為 null 參考是推送至堆疊。 如果物件參考本身為 null 參考，則`isinst`同樣會傳回 null 參考。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換為原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`isinst`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>結束目前方法，並跳至指定的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|結束目前的方法，並跳至指定的方法。|  
  
 此指示的轉換行為沒有任何堆疊。  
  
 `jmp` （跳躍） 指示將控制權傳輸至指定的方法`method`，這是方法參考的中繼資料語彙基元。 目前的引數會傳輸至目標方法。  
  
 執行這個指令時，評估堆疊必須空白。 呼叫慣例、 數字和目的地位址位於引數的型別必須符合目前的方法。  
  
 `jmp`指令無法用來傳送出的控制`try`， `filter`， `catch`，或`finally`區塊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`jmp`作業碼：  
  
-   ILGenerator.Emit （OpCode，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入引數 (為指定的索引值所參考) 至堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|載入引數在`index`至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  在引數值`index`推入至堆疊。  
  
 `ldarg`指令位於索引的引數會推入`index`，其中引數則是從 0 開始，至評估堆疊。 `ldarg`指令可用於實值類型或基本值載入至堆疊藉由複製從傳入的引數。 引數值的類型是型別引數，目前方法的簽章所指定的相同。  
  
 程序，使用可變長度引數清單，如`ldarg`指令只能用於初始的固定引數，無法用簽章的變動的部分 (請參閱<xref:System.Reflection.Emit.OpCodes.Arglist>指令，如需詳細資訊)。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarg`作業碼：  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 0 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|02|ldarg.0|載入引數 0 至堆疊|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 0 的引數值推入至堆疊。  
  
 `ldarg.0`指令都是有效的編碼方式，用於載入位於索引 0 的引數值。  
  
 `ldarg.0`指令會推入引數，位於索引 0 至評估堆疊。 `ldarg.0`指令可用於實值類型或基本值載入至堆疊藉由複製從傳入的引數。 引數值的類型是型別引數，目前方法的簽章所指定的相同。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarg.0`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 1 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|03|ldarg.1|載入引數 1 至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 1 的引數值推入至堆疊。  
  
 `ldarg.1`指令都是有效的編碼方式，用於載入位於索引 1 的引數值。  
  
 `ldarg.1`指令將推送至評估堆疊的 1 編製索引的引數。 `ldarg.1`指令可用於實值類型或基本值載入至堆疊藉由複製從傳入的引數。 引數值的類型是型別引數，目前方法的簽章所指定的相同。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarg.1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 2 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|04|ldarg.2|載入引數 2 至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 2 的引數值推入至堆疊。  
  
 `ldarg.2`指令都是有效的編碼方式，用於載入位於索引 2 的引數值。  
  
 `ldarg.2`指令將推送至評估堆疊的 2 編製索引的引數。 `ldarg.2`指令可用於實值類型或基本值載入至堆疊藉由複製從傳入的引數。 引數值的類型是型別引數，目前方法的簽章所指定的相同。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarg.2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 3 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|05|ldarg.3|載入引數 3 至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 3 的引數值推入至堆疊。  
  
 `ldarg.3`指令都是有效的編碼方式，用於載入位於索引 3 的引數值。  
  
 `ldarg.3`指令將推送至評估堆疊的 3 編製索引的引數。 `ldarg.3`指令可用於實值類型或基本值載入至堆疊藉由複製從傳入的引數。 引數值的類型是型別引數，目前方法的簽章所指定的相同。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarg.3`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入引數 (為指定的簡短形式索引所參考) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|載入引數在`index`至堆疊，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  在引數值`index`推入至堆疊。  
  
 `ldarg.s`指令都是有效的編碼方式為載入引數從 4 到 255 的編製索引。  
  
 `ldarg.s`指令位於索引的引數會推入`index`，其中引數則是從 0 開始，至評估堆疊。 `ldarg.s`指令可用於實值類型或基本值載入至堆疊藉由複製從傳入的引數。 引數值的類型是型別引數，目前方法的簽章所指定的相同。  
  
 程序，使用可變長度引數清單，如`ldarg.s`指令只能用於初始的固定引數，無法用簽章的變動的部分 (請參閱<xref:System.Reflection.Emit.OpCodes.Arglist>指令，如需詳細資訊)。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarg.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入引數位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0A &LT; `unsigned int16` >|ldarga `index`|擷取以編製索引的引數位址`index`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址`addr`以編製索引的引數的`index`推入至堆疊。  
  
 `ldarga`指令會擷取地址 (類型的`*`) 以編製索引的引數的`index`、 引數則是從 0 開始的位置。 位址`addr`一律會在目標電腦上的自然界限對齊。  
  
 程序，使用可變長度引數清單，如`ldarga`指令只能用於初始的固定引數不是那些在簽章的變數。  
  
 `ldarga` 適用於由 ref 參數傳遞。 針對其他情況下，<xref:System.Reflection.Emit.OpCodes.Ldarg>和<xref:System.Reflection.Emit.OpCodes.Starg>應使用。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarga`作業碼：  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以簡短形式，載入引數位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|擷取以編製索引的引數位址`index`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址`addr`以編製索引的引數的`index`推入至堆疊。  
  
 `ldarga.s` (簡短形式`ldarga`) 應該使用引數的數字 0 到 255，，而且是更有效率的編碼方式。  
  
 `ldarga.s`指令會擷取地址 (類型的`*`) 以編製索引的引數的`index`、 引數則是從 0 開始的位置。 位址`addr`一律會在目標電腦上的自然界限對齊。  
  
 程序，使用可變長度引數清單，如`ldarga.s`指令只能用於初始的固定引數不是那些在簽章的變數。  
  
 `ldarga.s` 適用於由 ref 參數傳遞。 針對其他情況下，<xref:System.Reflection.Emit.OpCodes.Ldarg_S>和<xref:System.Reflection.Emit.OpCodes.Starg_S>應使用。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldarga.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入型別 <see langword="int32" /> 的提供值至評估堆疊做為 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|將值推入`num`至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值`num`推入至堆疊。  
  
 請注意，有特殊的 （也因此更有效率） 編碼的整數-128 到 127，或特別是短編碼方式-1 到 8。 所有較短的編碼推入堆疊的 4 位元組的整數。 較長的編碼用於 8 位元組整數和 4 和 8 位元組浮點數值，以及 4 個位元組的值不適合簡短形式。 有三種方式將推入至堆疊的 8 位元組整數常數  
  
 1. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I8>指示您必須以多個 32 位元的常數。  
  
 2. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I4>指令，後面跟著<xref:System.Reflection.Emit.OpCodes.Conv_I8>需要 9 到 32 位元的常數。  
  
 3. 使用簡短形式指令，後面跟著<xref:System.Reflection.Emit.OpCodes.Conv_I8>可以用來表示 8 或更少的位元的常數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4`作業碼：  
  
-   ILGenerator.Emit (OpCode，int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 0 推入至評估堆疊做為 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|推送至堆疊的 0。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值 0 會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.0`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 1 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|推送至堆疊的 1。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值 1 會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 2 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|推送至堆疊的 2。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值 2 會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 3 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|推送至堆疊上的 3。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  3 這個值會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.3`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 4 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|將 4 推入至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  4 這個值會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 5 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|推送至堆疊的 5。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值是 5 會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.5`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 6 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|推送至堆疊的 6。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  6 的值會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.6`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 7 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|推送至堆疊的 7。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值 7 會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.7`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 8 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|將 8 推入至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值為 8 推入至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 -1 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|推送至堆疊的-1。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值-1 會推送至堆疊。  
  
 這是特殊短編碼方式的整數值 0 推入。 所有特殊較短的編碼推入堆疊的 4 位元組的整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.m1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入提供的 <see langword="int8" /> 值至評估堆疊做為 <see langword="int32" /> (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1F &LT; `int8` >|ldc.i4.s `num`|推播通知`num`至做為堆疊`int32`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值`num`推入至堆疊。  
  
 `ldc.i4.s` 是更有效率的編碼方式的推入整數從-128 到 127 評估堆疊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i4.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入型別 <see langword="int64" /> 的提供值至評估堆疊做為 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|推播通知`num`至做為堆疊`int64`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值`num`推入至堆疊。  
  
 這種編碼方式將推入`int64`至堆疊的值。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.i8`作業碼：  
  
-   ILGenerator.Emit (OpCode，long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入型別 <see langword="float32" /> 的提供值至評估堆疊做為型別 <see langword="F" /> (浮點數)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|推播通知`num`至做為堆疊`F`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值`num`推入至堆疊。  
  
 這種編碼方式將推入`float32`至堆疊的值。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.r4`作業碼：  
  
-   ILGenerator.Emit (OpCode，單一)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入型別 <see langword="float64" /> 的提供值至評估堆疊做為型別 <see langword="F" /> (浮點數)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|推播通知`num`至做為堆疊`F`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值`num`推入至堆疊。  
  
 這種編碼方式將推入`float64`至堆疊的值。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldc.r8`作業碼：  
  
-   ILGenerator.Emit (OpCode，double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定之陣列索引處的項目當做指令中指定的類型載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|載入處的項目`index`類型堆疊的頂端`typeTok`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列是物件，並由類型的值表示`O`。  
  
 語彙基元所指定的傳回值類型`typeTok`指令中。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於上限`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="native int" /> 的元素當做 <see langword="native int" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|97|ldelem.i|載入項目類型`native int`在`index`作為堆疊的頂端`native int`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.i`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i`是`native int`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.i`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="int8" /> 的元素當做 <see langword="int32" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|載入項目類型`int8`在`index`作為堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.i1`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i1`是`int8`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.i1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="int16" /> 的元素當做 <see langword="int32" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|載入項目類型`int16`在`index`作為堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.i2`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i2`是`int16`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.i2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="int32" /> 的元素當做 <see langword="int32" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|載入項目類型`int32`在`index`作為堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.i4`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i4`是`int32`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.i4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="int64" /> 的元素當做 <see langword="int64" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|載入項目類型`int64`在`index`作為堆疊的頂端`int64`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.i8`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i8`是`int64`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.i8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="float32" /> 的元素當做型別 <see langword="F" /> (浮點數) 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|載入項目類型`float32`在`index`做為類型堆疊的頂端`F`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.r4`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.r4`是`float32`。  
  
 浮點數的值會轉換成輸入`F`時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.r4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="float64" /> 的元素當做型別 <see langword="F" /> (浮點數) 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|載入項目類型`float64`在`index`類型堆疊的頂端`F`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.r8`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.r8`是`float64`。  
  
 浮點數的值會轉換成輸入`F`時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.r8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入包含位於指定的陣列索引中的物件參考元素至評估堆疊的頂端，做為型別 <see langword="O" /> (物件參考)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|載入具有物件參考的項目`index`類型堆疊的頂端`O`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.ref`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.ref`是型別`O`（物件參考）。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.ref`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="unsigned int8" /> 的元素當做 <see langword="int32" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|載入項目類型`unsigned int8`在`index`作為堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.u1`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.u1`是`int8`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.u1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="unsigned int16" /> 的元素當做 <see langword="int32" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|載入項目類型`unsigned int16`為堆疊頂端的索引處`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.u2`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.u2`是`int16`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.u2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定陣列索引處型別為 <see langword="unsigned int32" /> 的元素當做 <see langword="int32" /> 載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|載入項目類型`unsigned int32`為堆疊頂端的索引處`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的值`index`中`array`查閱。  
  
4.  值會推送至堆疊。  
  
 `ldelem.u4`指令載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。  
  
 傳回值`ldelem.u4`是`int32`。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果陣列未包含必要的型別項目，會擲回。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelem.u4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定陣列索引中的陣列元素位址至評估堆疊的頂端，做為型別 <see langword="&amp;" /> (Managed 指標)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|在陣列元素的位址載入`index`類型評估堆疊的頂端`&`（managed 的指標）。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`array`推入至堆疊。  
  
2.  索引值`index`推入至堆疊。  
  
3.  `index` 和`array`取出堆疊，從儲存位置的位址`index`中`array`查閱。  
  
4.  位址會推送至堆疊。  
  
 `ldelema`用來擷取物件的陣列中的特定索引處物件的位址 (型別`class`)。 `ldelema`指令載入索引處的值的位址`index`(型別`native int`) 中以零為起始的一維陣列`array`，並將它放在堆疊的頂端。 陣列物件，表示類型的值由`O`。 值必須是型別`class`傳遞與指示。  
  
 傳回值`ldelema`是 managed 的指標 (類型`&`)。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldelema`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尋找物件中的欄位值，該值的參考目前位於評估堆疊中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|推送至堆疊上指定之物件中欄位的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考 （或指標） 會推送至堆疊。  
  
2.  物件參考 （或指標） 是從堆疊推出。位於物件中指定之欄位的值。  
  
3.  欄位中儲存的值會推送至堆疊。  
  
 `ldfld`指令將推送至堆疊物件中欄位的值。 物件必須是在堆疊做為物件參考 (類型`O`)，managed 的指標 (類型`&`)，unmanaged 的指標 (類型`native int`)，暫時性指標 (類型`*`)，或實值類型的執行個體。 可驗證的程式碼中不允許使用的 unmanaged 指標。 必須參考欄位成員的中繼資料語彙基元所指定物件的欄位。 傳回型別是欄位相關聯的一個相同。 此欄位可能是 （在此情況下的物件不得為 null 參考） 的執行個體欄位或靜態欄位。  
  
 `ldfld`指令前面可以有一個或兩個<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 <xref:System.NullReferenceException> 如果物件為 null，且不是靜態欄位，會擲回。  
  
 <xref:System.MissingFieldException> 中繼資料中找不到指定的欄位時，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldfld`作業碼：  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尋找物件中的欄位位址，該位址的參考目前位於評估堆疊中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|推送的位址`field`至堆疊上指定之物件中。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考 （或指標） 會推送至堆疊。  
  
2.  物件參考 （或指標） 是從堆疊推出。找到的物件中指定之欄位的位址。  
  
3.  指定欄位的位址被推入堆疊。  
  
 `ldflda`指令將推送至堆疊物件中欄位的位址。 物件必須是在堆疊做為物件參考 (類型`O`)，managed 的指標 (類型`&`)，unmanaged 的指標 (類型`native int`)，暫時性指標 (類型`*`)，或實值類型的執行個體。 可驗證的程式碼中不允許使用的 unmanaged 指標。 必須參考欄位成員的中繼資料語彙基元所指定物件的欄位。  
  
 所傳回的值`ldflda`是 managed 的指標 (類型`&`) 除非物件已推送至堆疊當做 unmanaged 指標，在此情況下傳回位址也就是將 unmanaged 的指標 (類型`native int`)。  
  
 `ldflda`指令前面可以有一個或兩個<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 <xref:System.InvalidOperationException> 如果物件不是從它正在存取的應用程式定義域中，會擲回。 無法載入內部存取應用程式定義域不是欄位的位址。  
  
 <xref:System.NullReferenceException> 如果物件為 null，且不是靜態欄位，會擲回。  
  
 <xref:System.MissingFieldException> 中繼資料中找不到指定的欄位時，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldflda`作業碼：  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入實作特定方法之機器碼的 Unmanaged 指標 (型別 <see langword="native int" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|將指標所參考的方法推入`method`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  Unmanaged 的指標的特定方法推入至堆疊。  
  
 特定的方法 (`method`) 可以使用呼叫<xref:System.Reflection.Emit.OpCodes.Calli>如果參考的 managed 的方法 （或從 managed 轉換到 unmanaged 程式碼 stub） 的指示。  
  
 傳回點使用 CLR 的呼叫慣例的原生程式碼的值。 這個方法的指標不應該傳遞至未受管理的原生程式碼中，但會當做回呼常式。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldftn`作業碼：  
  
-   ILGenerator.Emit （OpCode，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將型別 <see langword="native int" /> 的值做為 <see langword="native int" />，間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4D|ldind.i|載入`native int`值在位址`addr`至做為堆疊`native int`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.i`指令間接載入`native int`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`native int`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.i`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="int8" /> 型別的值做為 <see langword="int32" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|46|ldind.i1|載入`int8`值在位址`addr`至做為堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送到堆疊中...  
  
 `ldind.i1`指令間接載入`int8`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int32`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.i1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="int16" /> 型別的值做為 <see langword="int32" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|48|ldind.i2|載入`int16`值在位址`addr`至做為堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.i2`指令間接載入`int16`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int32`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.i2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="int32" /> 型別的值做為 <see langword="int32" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|載入`int32`值在位址`addr`至做為堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.i4`指令間接載入`int32`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int32`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.i4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="int64" /> 型別的值做為 <see langword="int64" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|載入`int64`值在位址`addr`至做為堆疊`int64`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.i8`指令間接載入`int64`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int64`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.i8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將型別 <see langword="float32" /> 的值做為型別 <see langword="F" /> (浮點數)，間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|載入`float32`值在位址`addr`至做為類型堆疊`F`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.r4`指令間接載入`float32`從指定的位址值 (類型的`native int`， `&`，或 *) 做為類型堆疊`F`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.r4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將型別 <see langword="float64" /> 的值做為型別 <see langword="F" /> (浮點數)，間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|載入`float64`值在位址`addr`至做為類型堆疊`F`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.r8`指令間接載入`float64`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`float64`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.r8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將物件參考做為型別 <see langword="O" /> (物件參考)，間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|50|ldind.ref|在位址的物件參考載入`addr`堆疊為型別 `O`|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，擷取位於位址的物件參考。  
  
3.  將擷取的參考會推送至堆疊。  
  
 `ldind.ref`指令間接載入的物件參考指定的位址 (型別`native int`， `&`，或 *) 做為類型堆疊`O`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.ref`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="unsigned int8" /> 型別的值做為 <see langword="int32" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|47|ldind.u1|載入`unsigned int8`值在位址`addr`至做為堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.u1`指令間接載入`unsigned int8`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int32`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.u1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="unsigned int16" /> 型別的值做為 <see langword="int32" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|49|ldind.u2|載入`unsigned int16`值在位址`addr`至做為堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.u2`指令間接載入`unsigned int16`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int32`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.u2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 <see langword="unsigned int32" /> 型別的值做為 <see langword="int32" /> 間接載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|載入`unsigned int32`值在位址`addr`至做為堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  從堆疊，則會彈出位址，位於位址的值會不提取。  
  
3.  將擷取的值會推送至堆疊。  
  
 `ldind.u4`指令間接載入`unsigned int32`從指定的位址值 (類型的`native int`， `&`，或 *) 做為堆疊`int32`。  
  
 所有的`ldind`指示都快速鍵<xref:System.Reflection.Emit.OpCodes.Ldobj>指定對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值會擴充以`int32`(不`native int`) 載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 格式正確的 Microsoft Intermediate Language (MSIL)，確保`ldind`指示用於指標類型與一致的方式。  
  
 一開始推入堆疊的位址必須對齊自然的電腦上的物件大小或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令的預防措施)。 傳回位址的所有 MSIL 指令的結果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 大於 1 個位元組的資料類型，如位元組順序會相依於目標 CPU。 所有平台上，可能無法執行程式碼所依賴位元組順序。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldind.u4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送以零為起始的一維陣列的項目數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8E|ldlen|推播通知長度 (型別`natural unsigned int`) 的堆疊上的陣列。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  陣列的物件參考推送至堆疊。  
  
2.  從堆疊取出陣列參考，並計算長度。  
  
3.  長度會推送至堆疊。  
  
 陣列物件，表示類型的值由`O`。 則會傳回長度為`natural unsigned int`。  
  
 <xref:System.NullReferenceException> 如果陣列參考為 null 參考，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldlen`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|載入位於索引的區域變數`index`至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  指定索引處的區域變數值推入至堆疊。  
  
 `ldloc`指令推播通知的區域變數編號內容在傳遞的索引至評估堆疊，區域變數是從的 0 開始的位置。 在方法上的初始化旗標為 true 時，才進入方法之前，本機變數會初始化為 0。 有 65535 (2 ^16-1） 區域變數可能 (0-65534)。 索引 65,535 無效，因為可能的實作會使用 2 位元組整數來追蹤兩個區域的索引，以及指定方法的區域變數的總數。 如果 65535 的索引已經變成有效，它將需要更多的整數，來追蹤在這種方法中區域變數的數目。  
  
 `ldloc.0`， `ldloc.1`， `ldloc.2`，和`ldloc.3`指示提供有效的編碼方式，來存取前四個本機變數。  
  
 值的類型是方法標頭中指定的本機變數的類型相同。 請參閱小於 4 個位元組會展開成輸入的資料分割 I.本機變數`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc`作業碼：  
  
-   ILGenerator.Emit （OpCode，LocalBuilder）  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 0 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|06|ldloc.0|將位於索引 0 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 0 的區域變數值推入至堆疊。  
  
 `ldloc.0` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 0 的本機變數的存取權。  
  
 值的類型是方法標頭中指定的本機變數的類型相同。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldloc.0`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 1 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|07|ldloc.1|將位於索引 1 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 1 的區域變數值推入至堆疊。  
  
 `ldloc.1` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，位於索引 1 允許本機變數的存取權。  
  
 值的類型是方法標頭中指定的本機變數的類型相同。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldloc.1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 2 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|08|ldloc.2|將位於索引 2 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 2 的區域變數值推入至堆疊。  
  
 `ldloc.2` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，位於索引 2 允許本機變數的存取權。  
  
 值的類型是方法標頭中指定的本機變數的類型相同。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldloc.2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 3 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|09|ldloc.3|將位於索引 3 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位於索引 3 的區域變數值推入至堆疊。  
  
 `ldloc.3` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，位於索引 3 允許本機變數的存取權。  
  
 值的類型是方法標頭中指定的本機變數的類型相同。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldloc.3`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數至評估堆疊 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|載入位於索引的區域變數`index`至堆疊，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  指定索引處的區域變數值推入至堆疊。  
  
 `ldloc.s`指令推播通知的區域變數編號內容在傳遞的索引至評估堆疊，區域變數是從的 0 開始的位置。 之前輸入的方法，如果在方法上的初始化旗標為 true，本機變數會初始化為 0。 有 256 (2 ^8) 中的區域變數可能 (0-255) 的簡短形式，這是更有效率的編碼方式與`ldloc`。  
  
 值的類型是方法標頭中指定的本機變數的類型相同。 請參閱小於 4 個位元組會展開成輸入的資料分割 I.本機變數`int32`時載入至堆疊。 浮點數值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，LocalBuilder）  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|載入位於區域變數的位址`index`至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  儲存在位於指定索引的區域變數的位址被推送至堆疊。  
  
 `ldloca`指令會推入數目的本機變數的位址位於傳遞至堆疊中，索引其中區域變數會從的 0 開始。 推入堆疊的值已正確對齊用於指示像<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 結果是暫時性的指標 (類型`*`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldloca`作業碼：  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數位址至評估堆疊 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|載入位於區域變數的位址`index`至評估堆疊，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  儲存在位於指定索引的區域變數的位址被推送至堆疊。  
  
 `ldloca.s`指令會推入數目的本機變數的位址位於傳遞至堆疊中，索引其中區域變數會從的 0 開始。 推入堆疊的值已正確對齊用於指示像<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 結果是暫時性的指標 (類型`*`)。  
  
 `ldloca.s`指令提供有效的編碼方式，使用以 0 到 255 的本機變數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldloca.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入 Null 參考 (型別 <see langword="O" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|14|ldnull|推送至堆疊的 null 參考|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  Null 物件的參考會推送至堆疊。  
  
 `ldnull` 推播通知為 null 參考 (類型`O`) 堆疊上。 這用來初始化之前會填入資料，或在它們被取代的位置。  
  
 `ldnull` 提供與大小無關的 null 參考。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldnull`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複製位址所指向的實值類型物件到評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|實值類型的複本執行個體`class`的堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  實值類型物件的位址被推送至堆疊。  
  
2.  從堆疊推出位址，並在該特定位址的執行個體查閱。  
  
3.  儲存在該位址之物件的值會推送至堆疊。  
  
 `ldobj`指示用來做為參數傳遞實值類型。  
  
 `ldobj`指令會將指向的值複製`addrOfValObj`(型別`&`， `*`，或`native int`) 至堆疊的頂端。 複製的位元組數目取決於類別的大小 (依指定`class`參數)。 `class`參數是代表實值型別中繼資料語彙基元。  
  
 作業`ldobj`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指令轉換為原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldobj`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送靜態欄位的值至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|推入的值`field`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  特定欄位的值會推送至堆疊。  
  
 `ldsfld`指令會推入靜態 （在類別的所有執行個體之間共用） 的值在堆疊上的欄位。 傳遞的中繼資料語彙基元相關聯的傳回型別是`field`。  
  
 `ldsfld`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldsfld`作業碼：  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送靜態欄位的位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|推送的位址`field`堆疊上|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  特定欄位的位址被推入堆疊。  
  
 `ldsflda`指令會推入靜態 （在類別的所有執行個體之間共用） 的地址欄位在堆疊上。 位址可表示為暫時性指標 (類型`*`) 如果中繼資料語彙基元`field`參考管理其記憶體的型別。 否則，它會對應至 unmanaged 指標 (類型`native int`)。 請注意，`field`可能是靜態指派的相對虛擬位址 （基底位址，其包含的 PE 檔載入記憶體中的欄位位移） 與全域所在 unmanaged 記憶體。  
  
 `ldsflda`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 <xref:System.MissingFieldException> 如果在中繼資料中找不到欄位，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldsflda`作業碼：  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送新的物件參考至儲存於中繼資料的字串常值 (String Literal)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|推播通知的中繼資料字串語彙基元的字串物件`mdToken`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  字串物件參考推送至堆疊。  
  
 `ldstr`指令的物件參考推送 (型別`O`) 成新的字串物件，代表特定字串常值儲存在中繼資料。 `ldstr`指令會配置必要的記憶體量，並進行任何必要轉換在執行階段所需的字串格式檔案中所使用的形式的字串常值的格式轉換。  
  
 通用語言基礎結構 (CLI) 可確保兩個結果`ldstr`兩個具有相同的字元序列的中繼資料語彙基元所參考的指示會傳回精確的說相同的字串物件 （稱為 「 字串拘留 」 的程序）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldstr`作業碼：  
  
-   ILGenerator.Emit (OpCode，字串)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將中繼資料語彙基元轉換成它的執行階段表示，並將它推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|將中繼資料語彙基元轉換成它的執行階段表示。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  傳遞的語彙基元會轉換成`RuntimeHandle`和推入堆疊。  
  
 `ldtoken`指令推播通知`RuntimeHandle`指定的中繼資料語彙基元。 A`RuntimeHandle`可以`fieldref/fielddef`、 `methodref/methoddef`，或`typeref/typedef`。  
  
 推入堆疊的值可用於呼叫`Reflection`系統類別庫中的方法。  
  
 在執行階段控制代碼上的資訊，請參閱下列類別： <xref:System.RuntimeFieldHandle>， <xref:System.RuntimeTypeHandle>，和<xref:System.RuntimeMethodHandle>。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldtoken`作業碼：  
  
-   ILGenerator.Emit （OpCode，MethodInfo）  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推入實作與指定的物件相關聯的特定虛擬方法之機器碼的 Unmanaged 指標 (型別 <see langword="native int" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|將指標物件的虛擬方法推入`method`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考推送至堆疊。  
  
2.  從堆疊] 和 [進入點位址推出物件參考給方法 (依中繼資料語彙基元的指定`method`) 查詢。  
  
3.  將指標`method`推入至堆疊。  
  
 產生 unmanaged 的指標推入至堆疊方式`ldvirtftn`指令可以使用呼叫<xref:System.Reflection.Emit.OpCodes.Calli>如果參考的 managed 的方法 （或從 managed 轉換到 unmanaged 程式碼 stub） 的指示。  
  
 Unmanaged 的指標會指向使用 CLR 的呼叫慣例的原生程式碼。 這個方法的指標不應該傳遞至未受管理的原生程式碼中，但會當做回呼常式。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ldvirtftn`作業碼：  
  
-   ILGenerator.Emit （OpCode，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>結束程式碼的保護區，無條件地將控制權傳輸至特定的目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DD < `int32` >|保留 `target`|受保護的區域的程式碼就會結束。|  
  
 不沒有指定此指示任何堆疊轉換行為。  
  
 `leave`指令無條件地將控制權傳輸至特定目標指令，表示成 4 位元組帶正負號位移從緊跟在目前指令的開頭。  
  
 `leave`指示是類似於`br`指令，但它可以用來結束`try`， `filter`，或`catch`封鎖而一般分支指示僅能在這類區塊傳輸中的控制項它。 `leave`指令會清空評估堆疊，並確保適當的周圍`finally`區塊會執行。  
  
 您無法使用`leave`指令，以便結束`finally`區塊。 為了簡化從 catch 區塊內使用有效的例外狀況處理常式的程式碼產生`leave`指令，以便將控制權轉移至中相關聯的任何指令`try`區塊。  
  
 指令會有一或多個前置詞程式碼，如果控制項只傳送到第一個一個前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`leave`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>結束程式碼的保護區，無條件地將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|結束受保護的區域，程式碼，簡短形式。|  
  
 不沒有指定此指示任何堆疊轉換行為。  
  
 `leave.s`指令無條件地將控制權傳輸至傳遞的目標指令，表示為 1 個位元組帶正負號的位移，從開頭緊跟在目前的指令。  
  
 `leave.s`指示是類似於`br`指令，但它可以用來結束`try`， `filter`，或`catch`封鎖而一般分支指示僅能在這類區塊傳輸中的控制項它。 `leave.s`指令會清空評估堆疊，並確保適當的周圍`finally`區塊會執行。  
  
 您無法使用`leave.s`指令，以便結束`finally`區塊。 為了簡化從 catch 區塊內使用有效的例外狀況處理常式的程式碼產生`leave.s`指令，以便將控制權轉移至中相關聯的任何指令`try`區塊。  
  
 指令會有一或多個前置詞程式碼，如果控制項只傳送到第一個一個前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`leave.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從區域動態記憶體集區中配置某些數量的位元組，並將第一個配置的位元組的位址 (暫時性指標，型別 <see langword="*" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|從本機堆積中配置空間。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  要配置的位元組數會推送到堆疊。  
  
2.  從堆疊，則會彈出的位元組數目，從本機堆積配置大小相對應的記憶體數量。  
  
3.  配置的記憶體中的第一個位元組的指標會推送至堆疊。  
  
 `localloc`指令配置`size`(型別`natural unsigned int`) 位元組從區域的動態記憶體集區，並將位址傳回 (暫時性指標、 型別`*`) 配置的第一個位元組。 只有在方法上的初始化旗標是初始化為 0 的記憶體區塊傳回`true`。 當目前的方法執行<xref:System.Reflection.Emit.OpCodes.Ret>，本機記憶體集區可供重複使用。  
  
 產生的位址對齊使任何基本資料類型可以儲存在該處使用`stind`指示 (例如<xref:System.Reflection.Emit.OpCodes.Stind_I4>) 和使用載入`ldind`指示 (例如<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。  
  
 `localloc`指令不能出現在`filter`， `catch`， `finally`，或`fault`區塊。  
  
 <xref:System.StackOverflowException> 如果記憶體不足，無法服務此要求，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`localloc`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將特定類型的執行個體之類型參考推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany 使用 `class`|具類型的參考類型的推播通知`class`至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  指標的資料推送至堆疊。  
  
2.  取出並轉換成具類型的參考類型的指標`class`。  
  
3.  具類型的參考會推送至堆疊。  
  
 `mkrefany`指令支援動態具型別的參考傳遞。 滑鼠指標必須是型別`&`， `*`，或`native int`，並保留一段資料的有效位址。 `Class` 類別語彙基元描述資料指標所參考的類型。 `Mkrefany` 將具類型的參考推送至堆疊，並提供指標和類型的不透明的描述元`class`。  
  
 允許在具類型的參考時唯一有效的作業是將它傳遞到要求做為參數的型別的參考的方法。 被呼叫端可以使用<xref:System.Reflection.Emit.OpCodes.Refanytype>和<xref:System.Reflection.Emit.OpCodes.Refanyval>分別擷取的型別 （類別） 與位址的指示。  
  
 <xref:System.TypeLoadException> 如果擲回`class`找不到。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換為原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`mkrefany`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個值相乘，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5A|mul|將在堆疊上的兩個值相乘。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`乘以`value2`。  
  
4.  結果會推送至堆疊。  
  
 `mul`指令乘以`value1`由`value2`並將結果推至堆疊上。 整數運算以無訊息模式截斷發生溢位較高的位元。  
  
 請參閱<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整數特定乘溢位處理作業。  
  
 浮點類型，0 * 無限大 = NaN。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`mul`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個整數值相乘、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|將具有溢位檢查的堆疊上的兩個整數值相乘。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`乘以`value2`，有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 `mul.ovf`指令乘以整數`value1`由整數`value2`並將結果推至堆疊上。 如果結果不符合的結果型別，則會擲回例外狀況。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`mul.ovf`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個不帶正負號的整數值相乘、執行溢位檢查，再將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|乘上兩個不帶正負號的值有溢位檢查堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value1`乘以`value2`，有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 `mul.ovf.un`指示將不帶正負號的整數`value1`的不帶正負號的整數`value2`並將結果推至堆疊上。 如果結果不符合的結果型別，則會擲回例外狀況。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`mul.ovf.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將值變成相反值，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|65|協商|堆疊頂端的目前值的否定運算。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會推送至堆疊。  
  
2.  值，從堆疊取出並相反值。  
  
3.  結果會推送至堆疊。  
  
 `neg`指令變換正負號的值，並將結果的堆疊的頂端。 傳回類型是運算元類型相同。  
  
 整數值的否定是標準二補數否定。 特別是，否定最大負數數字 （沒有對應的正數） 會產生最大負數的數字。 若要偵測此溢位，請使用<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>指令改用 （也就是從 0 減）。  
  
 將浮點數值不能溢位，並取消 NaN 傳回 NaN。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`neg`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將新的以零為起始一維陣列 (其項目屬於特定類型) 的物件參考推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|建立新的陣列型別的項目與`etype`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  陣列中的項目數會推送至堆疊。  
  
2.  從堆疊推出的項目數，並在建立陣列。  
  
3.  新陣列的物件參考推送至堆疊。  
  
 `newarr`指令的物件參考推送 (型別`O`) 到新以零為起始的一維陣列的元素屬於類型`etype`（描述類型的中繼資料語彙基元）。 新陣列中的項目數目應該指定為`native int`。 陣列的有效索引範圍是從零到最大項目數減一。  
  
 陣列的項目可以是任何類型，包括實值類型。  
  
 數字的以零為起始的一維陣列會建立使用參考適當的值類型的中繼資料語彙基元 (<xref:System.Int32>等等)。 陣列的元素會初始化為 0 的適當類型。  
  
 Nonzero-根據一維陣列和多維度陣列則會使用建立<xref:System.Reflection.Emit.OpCodes.Newobj>而不是`newarr`。 通常，它們會建立使用的方法<xref:System.Array>.NET Framework 中的類別。  
  
 <xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。  
  
 <xref:System.OverflowException> 如果擲回`numElems`小於 0。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`newarr`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>建立實值型別的新物件或新執行個體，將物件參考 (型別 <see langword="O" />) 推入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|配置未初始化的物件或實值類型，並呼叫建構函式方法`ctor`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  引數`arg1`透過`argn`順序推入堆疊。  
  
2.  引數`argn`透過`arg1`會從堆疊取出並傳遞給`ctor`建立物件。  
  
3.  新物件的參考會推送至堆疊。  
  
 `newobj`指示建立新的物件或實值類型的新執行個體。 `Ctor` 為中繼資料語彙基元 (`methodref`或`methoddef`，必須標示為建構函式)，表示名稱、 類別和簽章的建構函式呼叫。  
  
 `newobj`指令會配置與相關聯之類別的新執行個體`ctor`並初始化 0 （或適當的型別） 或 null 參考，適當地將新執行個體中的所有欄位。 然後它會呼叫建構函式`ctor`與指定的引數，以及新建立的執行個體。 呼叫建構函式之後，立即初始化物件參考 (類型`O`) 推送到堆疊上。  
  
 從建構函式的觀點來看，未初始化的物件是引數 0，而其他引數傳遞至 newobj 順序。  
  
 使用建立所有的以零為起始的一維陣列<xref:System.Reflection.Emit.OpCodes.Newarr>，而非`newobj`。 相反地，所有其他陣列 （一個維度，或一維但未以零為起始） 會建立使用`newobj`。  
  
 實值類型不通常會建立使用`newobj`。 它們通常會配置做為引數或本機變數，使用`newarr`（適用於以零為起始的一維陣列），或做為欄位的物件。 配置之後，它們會使用初始化<xref:System.Reflection.Emit.OpCodes.Initobj>。 不過，`newobj`指令可以用來建立實值類型的新執行個體上的堆疊，接著可以傳遞做為引數，儲存在區域變數中等等。  
  
 <xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。  
  
 <xref:System.MissingMethodException> 如果建構函式方法會擲回`ctor`使用指定的名稱、 類別和簽章找不到。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`newobj`作業碼：  
  
-   ILGenerator.Emit （OpCode，ConstructorInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果已完成修補作業碼，則填滿空間。 雖然會耗用處理循環，卻不會執行任何有意義的運算。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|00|nop|執行無行為的運算。|  
  
 不沒有定義此指示任何堆疊過渡期行為。  
  
 `nop`作業不做任何動作。 它被要填滿空間中，如果已完成修補 opcode。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`nop`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算堆疊頂端的整數值的位元補數 (Complement)，並將結果當做相同類型來推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|66|not|計算值的位元補數。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value` 推入至堆疊。  
  
2.  `value` 從堆疊，而且其位元推出計算的補數。  
  
3.  結果會推送至堆疊。  
  
 `not`指令會計算整數值的位元補數，並將推送至堆疊的結果。 傳回類型是運算元類型相同。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`not`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算堆疊頂端兩個整數值的位元補數，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|60|或|計算位元或兩個整數值，傳回一個整數。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`自堆疊，而且其位元 OR 取出計算。  
  
4.  結果會推送至堆疊。  
  
 `or`指令會計算推送至堆疊的結果位元 OR 堆疊頂端兩個值。  
  
 `Or` 是整數特定作業。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`or`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>目前在評估堆疊頂端移除值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|26|pop|會顯示從堆疊頂端的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  在最高值會從堆疊推出。  
  
 `pop`指令從堆疊移除最上層元素。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`pop`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定後續陣列位址作業在執行階段不執行任何類型檢查，且會傳回限制其變動性的 Managed 指標。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1E|readonly。|指定後續陣列位址作業會執行任何類型檢查，在執行階段，以及它在具有限制變動性傳回 managed 的指標。|  
  
 此前置詞只能出現之前`ldelema`指令和呼叫特殊`Address`陣列上的方法。 其會影響後續的作業有兩個：  
  
1.  執行階段類型檢查會不執行任何作業。 請注意，通常隱含型別檢查`ldelema`和`stelem`參考上使用時的指示輸入陣列。 都不會實值類別的執行階段類型檢查因此`readonly`在此情況下沒有任何作業。  
  
2.  檢查器視為 managed 指標具有限制變動性的地址的作業結果。  
  
 指標就稱為具有限制變動，因為定義的類型可讓您控制是否可以變更值。 實值類別沒有公用欄位或更新的位置中的值的方法公開 （expose） 的指標是唯讀的 (因此前置詞的名稱)。 特別是，表示基本類型 (例如，System.Int32) 的類別會公開 mutator，因此對於是唯讀。  
  
 這種方式在受限制的 managed 的指標只能用於透過下列方式：  
  
-   做為`object`參數`ldfld`， `ldflda`， `stfld`， `call`，或`constrained callvirt`指示。  
  
-   做為`pointer`參數`ldobj`指令或其中一個`ldind`指示。  
  
-   做為`source`參數`cpobj`指令。  
  
 所有其他作業，包括`stobj`， `initobj`，或`mkrefany`作業，或任何`stind`指示。  
  
 目的`readonly`前置詞是以泛型程式碼中的陣列中擷取元素時，避免型別檢查。 例如，運算式`arr[i].m()`，其中的陣列型別`arr`是已被限於必須有一個介面，方法是泛型類型`m`，可能會編譯成下列 MSIL。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 不含`readonly`前置詞，`ldelema`指令案例中會執行類型檢查其中 ！ 0 是參考型別。 不僅沒有效率，此類型檢查，但卻語意不正確。 類型檢查`ldelema`完全相符，也就是太強式。 如果陣列類型的子類別 ！ 0，上述程式碼會失敗類型檢查。  
  
 陣列元素的位址會擷取，而不是項目本身，以獲得的控制代碼`arr[i]`適用於同時實值類型和參考型別，並因此可傳遞至`constrained callvirt`指令。  
  
 一般情況下將不安全，如果陣列是參考類型的項目，跳過執行階段檢查。 為了安全起見，就必須確定對陣列進行任何修改都會經過這個指標。 驗證器規則可確保這。 受限制的 managed 的指標可以傳遞物件的執行個體方法呼叫，因此它沒有嚴格唯讀，對於實值類型，但是是實值型別沒有型別安全問題。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`readonly`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>擷取內嵌於類型參考中的類型語彙基元。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|推播通知儲存在具類型參考的類型語彙基元。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  實值類型參考推送至堆疊。  
  
2.  具類型的參考從堆疊取出並擷取其對應的類型語彙基元。  
  
3.  類型語彙基元會推送至堆疊。  
  
 具類型的參考包含類型的語彙基元和物件執行個體的位址。  
  
 `refanytype`指令會擷取內嵌在型別參考的類型語彙基元。 請參閱<xref:System.Reflection.Emit.OpCodes.Mkrefany>如需有關建立詳細的指示輸入參考。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`refanytype`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>擷取內嵌於型別參考中的位址 (型別 <see langword="&amp;" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|推送位址儲存在具類型的參考。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  實值類型參考推送至堆疊。  
  
2.  從堆疊取出具類型的參考，並擷取對應的位址。  
  
3.  位址會推送至堆疊。  
  
 具類型的參考包含類型的語彙基元和物件執行個體的位址。  
  
 `refanyval`指令會擷取內嵌於位址具類型的參考。 內嵌在堆疊上提供的型別參考的類型必須符合所指定之類型`type`(中繼資料語彙基元，是`typedef`或`typeref`)。 請參閱<xref:System.Reflection.Emit.OpCodes.Mkrefany>相關內容的指示。  
  
 <xref:System.InvalidCastException> 如果擲回`type`不相同的型別參考類型 (在此情況下，`type`類別提供給<xref:System.Reflection.Emit.OpCodes.Mkrefany>建構指令稱為具類型的參考)。  
  
 <xref:System.TypeLoadException> 如果擲回`type`找不到。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`refanyval`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個值相除，並將餘數推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5D|rem|將餘數推送`value1`由`value2`至堆疊。|  
  
> [!NOTE]
>  ReplaceThisText  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  A`value1`推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`從堆疊，而且的其餘部分會推出`value1` `div` `value2`計算。  
  
4.  結果會推送至堆疊。  
  
 `result` = `value1` `rem` `value2` 符合下列條件：  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`)，以及：  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;，標誌 (`result`) = 號 (`value1`)，其中`div`為除法指令會截斷推向零。  
  
 如果`value2`為零或`value1`是的無限大的結果為 NaN。 如果`value2`是無限大，結果是`value1`(否定的`-infinity`)。  
  
 整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。  
  
 請注意，在 Intel 平台上<xref:System.OverflowException>計算時，就會擲回 (minint `rem` -1)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`rem`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個不帶正負號的值相除，並將餘數推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5E|rem.un|將餘數推送不帶正負號`value1`的不帶正負號`value2`至堆疊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`從堆疊，而且的其餘部分會推出`value1` `div` `value2`計算。  
  
4.  結果會推送至堆疊。  
  
 `result` = `value1` `rem.un` `value2` 符合下列條件：  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`)，以及：  
  
 0 = `result`  <  `value2`，其中`div.un`為不帶正負號的除法指令。  
  
 `rem.un`指令計算`result`並將它推入堆疊上。 `Rem.un` 它的引數視為不帶正負號的整數，而<xref:System.Reflection.Emit.OpCodes.Rem>將它們視為為帶正負號的整數。  
  
 `Rem.un` 未指定為浮點數值。  
  
 整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`rem.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從目前方法傳回，將被呼叫端評估堆疊的傳回值 (如果有) 推送至呼叫端的評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2A|ret|從方法傳回，可能傳回值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  傳回值是從被呼叫端評估堆疊中取出。  
  
2.  步驟 1 中取得的傳回值推送至呼叫端評估堆疊。  
  
 如果傳回的值不存在，被呼叫端評估堆疊上，會傳回任何值 （沒有堆疊轉換行為在被呼叫端或呼叫端的方法）。  
  
 類型的傳回值，如果有的話，目前方法的決定從堆疊頂端和複製到堆疊呼叫目前方法的方法擷取值的類型。 目前方法的評估堆疊必須是空的除了要傳回的值。  
  
 `ret`指令無法用來傳送出的控制`try`， `filter`， `catch`，或`finally`區塊。 從`try`或`catch`，使用<xref:System.Reflection.Emit.OpCodes.Leave>指示目的地`ret`之外所有封入的例外狀況區塊的指示。 因為`filter`和`finally`區塊在邏輯上是例外狀況處理和非內嵌程式碼方法的一部分，正確地產生的 Microsoft Intermediate Language (MSIL) 指示不會執行傳回從方法`filter`或`finally`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`ret`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>重新擲回目前的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1A|重新擲回|會重新擲回目前例外狀況|  
  
 這個指令會不定義任何堆疊轉換行為。  
  
 `rethrow`指令只允許的主體內`catch`處理常式。 它會擲回相同這個處理常式所攔截的例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`rethrow`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值向左移 (使用零) 指定的位元數，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|62|shl|將左側 （移位零） 的整數。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會推送至堆疊。  
  
2.  要移位的位元數量會推送到堆疊。  
  
3.  要移位的位元數字和值會從堆疊推出;值是向左移位指定的位元數。  
  
4.  結果會推送至堆疊。  
  
 `shl`指令移位值 (類型`int32`，`int64`或`native int`) 保留指定的位元數。 位元數是型別值`int32`或`native int`。 要移位的位元數字是否大於或等於所提供的寬度 （以位元），則傳回值會是值的 unspecified。  
  
 `Shl` 在每個排班上最低的位置插入零的位元。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`shl`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 (使用正負號) 向右移指定的位元數，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|63|shr|您可以將整數向右移 （符號都會移位）。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會推送至堆疊。  
  
2.  要移位的位元數量會推送到堆疊。  
  
3.  要移位的位元數字和值會從堆疊推出;值是向右移位指定的位元數。  
  
4.  結果會推送至堆疊。  
  
 `shr.un`指令移位值 (類型`int32`，`int64`或`native int`) 向右旋轉指定的位元數。 位元數是型別值`int32`或`native int`。 要移位的位元數字是否大於或等於所提供的寬度 （以位元），則傳回值會是值的 unspecified。  
  
 `Shr` 複寫高序位位元上每個排班，保留原始值的正負號`result`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`shr`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將不帶正負號的整數值 (使用零) 向右移指定的位元數，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|64|shr.un|您可以將整數向右移 （移位零）。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會推送至堆疊。  
  
2.  要移位的位元數量會推送到堆疊。  
  
3.  要移位的位元數字和值會從堆疊推出;值是向右移位指定的位元數。  
  
4.  結果會推送至堆疊。  
  
 `shr.un`指令移位值 (類型`int32`，`int64`或`native int`) 向右旋轉指定的位元數。 位元數是型別值`int32`，`int64`或`native int`。 要移位的位元數字是否大於或等於所提供的寬度 （以位元），則傳回值會是值的 unspecified。  
  
 `Shr.un` 將插入每個排班的最高位置零的位元。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`shr.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將所提供實值類型的大小推送至評估堆疊 (以位元組為單位)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|Push 大小，以位元組為單位為實值類型`unsigned int32`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  提供的值類型的大小 （以位元組為單位） (`valType`) 推送至堆疊。  
  
 `valType` 必須是中繼資料語彙基元 (`typeref`或`typedef`)，在指定實值類型、 參考類型或泛型型別參數。  
  
 對於參考類型，傳回的大小會是對應的參考值的大小 （32 位元系統上的 4 位元組），輸入不參考值所參考之物件中儲存之資料的大小。 泛型型別參數僅用於型別或其定義的方法主體。 該類型或方法具現化時，泛型型別參數取代為實值類型或參考型別。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`sizeof`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指定索引的引數槽中將值存放在評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0B &LT; `unsigned int16` >|starg `num`|取出從堆疊頂端的值，並將它儲存在引數槽`num`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  取出堆疊頂端的目前值，並放在引數槽中`num`。  
  
 `starg`指令從堆疊取出值，並將它放在引數槽`num`。 值的類型必須符合的引數，目前方法的簽章中指定的類型。  
  
 變數引數清單中，程序`starg`指令只能用於初始的固定引數不是那些在簽章的變數。  
  
 執行存放區保存小於 4 個位元組的整數值的引數會截斷值，從堆疊移動的引數。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`starg`作業碼：  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指定索引 (簡短形式) 的引數位置中將值儲存於評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|取出從堆疊頂端的值，並將它儲存在引數槽`num`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  取出堆疊頂端的目前值，並放在引數槽中`num`。  
  
 `starg.s`指令從堆疊取出值，並將它放在引數槽`num`。 值的類型必須符合的引數，目前方法的簽章中指定的類型。  
  
 `starg.s`指令提供有效的編碼方式的前 256 個引數搭配使用。  
  
 變數引數清單中，程序`starg.s`指令只能用於初始的固定引數不是那些在簽章的變數。  
  
 執行存放區保存小於 4 個位元組的整數值的引數會截斷值，從堆疊移動的引數。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`starg.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用評估堆疊上的值 (其類型在指令中指定)，取代在指定之索引處的陣列項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|取代類型值的陣列索引處的元素提供`typeTok`堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  索引值，`index`中的項目`array`推入至堆疊。  
  
3.  在指示中所指定型別的值推入至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem`指令取代的一維陣列中提供的以零為起始索引處的項目值`array`的值。 值有語彙基元所指定的型別`typeTok`指令中。  
  
 陣列是物件，並由類型的值表示`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="native int" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9B|stelem.i|在提供的索引與陣列項目取代`native int`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.i`指令取代項目的值`index`一維陣列中`array`與`native int`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.i`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="int8" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|在提供的索引與陣列項目取代`int8`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.i1`指令取代項目的值`index`一維陣列中`array`與`int8`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.i1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="int16" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|在提供的索引與陣列項目取代`int16`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.i2`指令取代項目的值`index`一維陣列中`array`與`int16`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.i2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="int32" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|在提供的索引與陣列項目取代`int32`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.i4`指令取代項目的值`index`一維陣列中`array`與`int32`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.i4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="int64" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|在提供的索引與陣列項目取代`int64`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.i8`指令取代項目的值`index`一維陣列中`array`與`int64`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.i8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="float32" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|在提供的索引與陣列項目取代`float32`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.r4`指令取代項目的值`index`一維陣列中`array`與`float32`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.r4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的 <see langword="float64" /> 值來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|在提供的索引與陣列項目取代`float64`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.r8`指令取代項目的值`index`一維陣列中`array`與`float64`值推入堆疊。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.r8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以在評估堆疊上的物件參考值 (型別 <see langword="O" />) 來取代在指定索引的陣列元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|在提供的索引與陣列項目取代`ref`值 (類型`O`) 堆疊上。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考陣列， `array`，推入至堆疊。  
  
2.  有效的索引中的項目`array`推入至堆疊。  
  
3.  值，會推送至堆疊。  
  
4.  值、 索引及陣列參考是從堆疊推出。值會放入指定的索引處的陣列項目。  
  
 `stelem.ref`指令取代的一維陣列中提供的索引處的項目值`array`與`ref`(型別`O`) 推送至堆疊的值。  
  
 陣列物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 請注意，`stelem.ref`隱含地將轉換的項目類型所提供的值`array`指派值的陣列項目之前。 此轉換可能會失敗，即使的已驗證的程式碼。 因此`stelem.ref`指令可以擲回<xref:System.InvalidCastException>。 多維陣列，以及針對不是以零為起始的一維陣列<xref:System.Array>類別提供<xref:System.Array.SetValue%2A>方法。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未包含必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stelem.ref`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以新值取代儲存在物件參考或指標的欄位中的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|取代的值`field`具有新值的物件。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考或指標會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和物件參考/指標會從堆疊推出。值`field`物件中會取代所提供的值。  
  
 `stfld`指令取代的物件中的欄位值 (類型`O`) 或透過指標 (類型`native int`， `&`，或`*`) 具有給定值。 `Field` 是指欄位成員參考中繼資料語彙基元。 `stfld`指令可以包含一個或兩個前置詞<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.NullReferenceException> 如果物件參考或指標為 null 參考，且欄位並非靜態，會擲回。  
  
 <xref:System.MissingFieldException> 如果擲回`field`中繼資料中找不到。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指令被轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stfld`作業碼：  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="native int" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DF|stind.i|存放區`native int`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.i`指令存放區`native int`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i`指令的使用方式與指標類型一致。 作業`stind.i`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.i`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="int8" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|52|stind.i1|存放區`int8`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.i1`指令存放區`int8`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i1`指令的使用方式與指標類型一致。 作業`stind.i1`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.i1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="int16" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|53|stind.i2|存放區`int16`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.i2`指令存放區`int16`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.2i`指令的使用方式與指標類型一致。 作業`stind.i2`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.i2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="int32" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|54|stind.i4|存放區`int32`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.i4`指令存放區`int32`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i4`指令的使用方式與指標類型一致。 作業`stind.i4`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.i4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="int64" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|55|stind.i8|存放區`int64`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.i8`指令存放區`int64`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i8`指令的使用方式與指標類型一致。 作業`stind.i`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.i8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="float32" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|56|stind.r4|存放區`float32`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.r4`指令存放區`float32`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.r4`指令的使用方式與指標類型一致。 作業`stind.r4`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.r4`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>於所提供的位址儲存 <see langword="float64" /> 型別的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|57|stind.r8|存放區`float64`位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.r8`指令存放區`float64`提供的位址值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.r8`指令的使用方式與指標類型一致。 作業`stind.r8`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.r8`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的位址儲存物件參考值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|51|stind.ref|儲存物件參考 (類型`O`) 位於指定的位址值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  值，會推送至堆疊。  
  
3.  值和位址會從堆疊推出。值會儲存在位址。  
  
 `stind.ref`指令會儲存在所提供位址的物件參考值 (類型`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.ref`指令的使用方式與指標類型一致。 作業`stind.ref`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stind.ref`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在指定索引的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|從堆疊取出值，並將它儲存在區域變數中`index`。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會從堆疊取出並放置於本機變數`index`。  
  
 `stloc`指令取出評估堆疊頂端的值，並將它移動至區域變數編號`index`，其中的本機變數是從的 0 開始。 值的類型必須符合目前方法的本機簽章中指定本機變數的類型。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 正確的 Microsoft Intermediate Language (MSIL) 指示需要`index`是有效的本機索引。 如`stloc`指示`index`必須介於範圍 0 到 65534 內含 （具體而言，65535 不是有效）。 65535 排除在外的原因是 14k： 類似的實作會使用 2 位元組整數來追蹤區域的索引，以及指定方法的區域變數的總數。 如果 65535 的索引已經變成有效，它將需要更多的整數，來追蹤在這種方法中區域變數的數目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc`作業碼：  
  
-   ILGenerator.Emit （OpCode，LocalBuilder）  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 0 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0A|stloc.0|從堆疊中的值為 0 的區域變數中取出。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，從堆疊取出並放在本機變數索引為 0。  
  
 `stloc.0`指令取出評估堆疊頂端的值，並將它移至索引為 0 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的類型。  
  
 `stloc.0` 是有效的編碼方式，將值儲存在本機變數 0。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stloc.0`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 1 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0B|stloc.1|從堆疊中的值放入本機變數 1 中取出。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，從堆疊取出並放在索引 1 的區域變數。  
  
 `stloc.1`指令取出評估堆疊頂端的值，並將它移至索引 1 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的類型。  
  
 `stloc.1` 是有效的編碼方式，將值儲存在區域變數 1。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stloc.1`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 2 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0C|stloc.2|取出堆疊中的值置入區域變數 2|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，從堆疊取出並放在本機變數索引為 2。  
  
 `stloc.2`指令取出評估堆疊頂端的值，並將它移至索引為 2 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的類型。  
  
 `stloc.2` 是有效的編碼方式，將值儲存在本機變數 2。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stloc.2`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 3 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0D|stloc.3|取出堆疊中的值置入區域變數 3|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，從堆疊取出並放在索引 3 的區域變數。  
  
 `stloc.3`指令取出評估堆疊頂端的值，並將它移至索引 3 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的類型。  
  
 `stloc.3` 是有效的編碼方式，將值儲存在區域變數 3。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stloc.3`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在 <paramref name="index" /> (簡短形式) 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|從堆疊取出值，並將它儲存在區域變數中`index`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會從堆疊取出並放置於本機變數`index`。  
  
 `stloc.s`指令取出評估堆疊頂端的值，並將它移動至區域變數編號`index`，其中的本機變數是從的 0 開始。 值的類型必須符合目前方法的本機簽章中指定本機變數的類型。  
  
 `stloc.s`指令提供區域變數 0 到 255 之間的有效編碼方式。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小會四捨五入的浮點值 (類型`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.s`作業碼：  
  
-   ILGenerator.Emit （OpCode，LocalBuilder）  
  
-   ILGenerator.Emit （OpCode，byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊複製指定類型的值到所提供的記憶體位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|儲存類型的值`class`從堆疊記憶體。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
2.  類型的實值類型物件`class`推入至堆疊。  
  
3.  物件和位址會從堆疊推出。實值類型物件會儲存在位址。  
  
 `stobj`指令將實值類型物件複製到該位址所指定的地址 (類型的指標`native int`， `*`，或`&`)。 複製的位元組數目取決於所表示之類別的大小`class`、 代表實值類型的中繼資料語彙基元。  
  
 作業`stobj`可以更改指令前面<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>指令的前置詞。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換為原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stobj`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以來自評估堆疊的值取代靜態欄位的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|80 < `T` >|這個前置 `field`|中的值會取代`field`與提供的值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會推送至堆疊。  
  
2.  值，會從堆疊取出並儲存在`field`。  
  
 `stsfld`指令以堆疊中的值取代靜態欄位的值。 `field` 是靜態欄位成員必須參考中繼資料語彙基元。  
  
 `stsfld`指示可能加<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.MissingFieldException> 如果在中繼資料中找不到欄位，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`stsfld`作業碼：  
  
-   ILGenerator.Emit （OpCode，FieldInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將另一個值減去某一個值，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|59|sub|將一個值減去另一個，傳回新的數值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value2`會減去`value1`。  
  
4.  結果會推送至堆疊。  
  
 溢位未偵測到適用於整數作業 (如適當溢位處理，請參閱<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。  
  
 整數減法會包裝，而不是飽和。 例如： 假設 8 位元整數，其中`value1`設為 0 和`value2`設為 1 時，「 包裝 」 的結果會是 255。  
  
 傳回浮點溢位`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`sub`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將另一個值減去某一個值、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|將一個整數值減去另一個具有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value2`會減去`value1`有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 帶正負號的整數; 上執行這項作業浮點值，使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`sub.ovf`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將另一個不帶正負號的值減去某一個不帶正負號的值、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|將一個不帶正負號的整數值減去另一個具有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊。`value2`會減去`value1`有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果不會顯示結果型別，會擲回。  
  
 帶正負號的整數; 上執行這項作業浮點值，使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`sub.ovf.un`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>實作跳躍表格。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >...< `int32` >|切換 (`N`， `t1`， `t2`...`tN`)|跳到其中一個`N`值。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  值，會推送至堆疊。  
  
2.  值從堆疊取出並將執行轉移至在位移值編製索引指令其中的值是小於`N`。  
  
 `switch`指令實作跳躍表格。 指示的格式是`unsigned int32`代表目標數目`N`，後面接著`N`int32 值，指定跳躍的目標。 這些目標以位移 （正數或負數） 表示接下來的指示從頭`switch`指令。  
  
 `switch`指令從堆疊取出值，並可將其比較的不帶正負號的整數， `N`。 如果值為小於`N`，執行會傳輸至目標值，索引會從 0 開始編號目標 （例如，值為 0 會採用第一個目標，1 的值會採用第二個目標，依此類推）。 如果值大於或等於`N`，繼續執行下一個指令 （失敗）。  
  
 目標指令有一或多個前置詞程式碼，如果控制項只傳送到第一個前置詞。  
  
 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這個指令。 （這類傳輸嚴重限制而必須改用）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`switch`opcode。 `Label[]`引數是標籤代表 32 位元位移的陣列。  
  
-   ILGenerator.Emit （OpCode，Label[])  
  
   
  
## Examples  
 下列程式碼範例說明如何使用`Switch`opcode 來產生使用陣列的跳躍點表格<xref:System.Reflection.Emit.Label>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>執行後置的方法呼叫指令 (例如目前方法的堆疊框架) 會在執行實際的呼叫指令之前移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 14|結尾。|後續呼叫會終止目前的方法|  
  
 不沒有定義此指示任何堆疊轉換行為。  
  
 `tail`前置詞指令必須緊接著<xref:System.Reflection.Emit.OpCodes.Call>， <xref:System.Reflection.Emit.OpCodes.Calli>，或<xref:System.Reflection.Emit.OpCodes.Callvirt>指令。 表示呼叫指令執行之前，應該移除目前方法的堆疊框架。 它也表示從下列呼叫傳回的值也是目前的方法所傳回的值，因此可以呼叫轉換成交叉方法跳躍。  
  
 堆疊必須是空的除了正在傳送下列呼叫的引數。 緊跟在呼叫指令必須是 ret。因此在唯一有效的程式碼序列是`tail. call`(或`calli`或`callvirt`)。 正確的 Microsoft Intermediate Language (MSIL) 指示不必須分支到`call`指令，但是它們可能分支到後續<xref:System.Reflection.Emit.OpCodes.Ret>。  
  
 控制權會轉移信任的程式碼從信任的程式碼，因為這可能危及程式碼識別安全性時，無法捨棄目前的框架。 .NET Framework 安全性檢查，因此可能會導致`tail`被忽略，離開標準<xref:System.Reflection.Emit.OpCodes.Call>指令。 同樣地，為了讓同步區域就會發生在呼叫傳回的結束，`tail`時用來結束標記為同步的方法，會忽略前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`tail`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Opcode 物件的執行個體。</param>
        <summary>如果提供的作業碼採用單一位元組引數，則傳回 True 或 False。</summary>
        <returns>
          <see langword="True" /> 或 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可以用來找出哪些 MSIL opcode [簡短表單]，用於最佳化程式碼中。  
  
 `TakesSingleByteArgument` 傳回`true`如果<xref:System.Reflection.Emit.OpCode>執行個體使用單一位元組引數，在下列情況：  
  
-   作業碼執行的分支指令，位元組大小的位址 (例如，<xref:System.Reflection.Emit.OpCodes.Br_S>和<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   作業碼推送至堆疊的位元組值 (例如， <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   Opcode 參考變數或引數的位元組大小 」 簡短形式 」 透過 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloc_S>和<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。  
  
 否則它會傳回 `false`。  
  
 下列範例示範如何使用`TakesSingleByteArgument`透過反映入`OpCodes`類別和測試以查看是否每個`OpCode`欄位採用單一位元組引數。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>擲回目前位於評估堆疊的例外狀況物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7A|throw|擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  （將例外狀況） 的物件參考推送至堆疊。  
  
2.  物件參考是從取出堆疊並擲回的例外狀況。  
  
 `throw`指令會擲回的例外狀況物件 (類型`O`) 目前的堆疊。  
  
 <xref:System.NullReferenceException> 如果物件參考為 null 參考，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`throw`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示目前位於評估堆疊頂端的位置可能未對齊緊接 <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> 或 <see langword="cpblk" /> 指令的正常大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|未對齊。 `alignment`|表示後續的指標指令可能未對齊。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
 `Unaligned` 指定的位址 (unmanaged 的指標， `native int`) 堆疊上可能不會對齊，以自然的後置大小`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`，`initblk`，或`cpblk`指令。 也就是針對<xref:System.Reflection.Emit.OpCodes.Ldind_I4>指令位址的對齊方式可能無法與 4 位元組界限。 如`initblk`和`cpblk`預設對齊是架構相依 （4 位元組 32 位元 cpu，64 位元 Cpu 上的 8 位元組）。 未將其輸出限制為 32 位元字組大小的程式碼產生器必須使用`unaligned`如果對齊方式不在編譯時期已知為 8 個位元組。  
  
 對齊的值必須是 1、 2 或 4 和產生的程式碼應該假設的位址是 byte、 雙位元組或 4 位元組對齊，分別表示。 請注意該暫時性指標 (類型`*`) 永遠對齊。  
  
 雖然的對齊方式`cpblk`指令會以邏輯方式需要兩個數字 （一個為來源），另一個用於目的地，所以不會嚴重影響效能如果只在指定的較低的數字。  
  
 `unaligned`和`volatile`可以按照任何順序結合前置詞。 它們必須緊接著`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 只有<xref:System.Reflection.Emit.OpCodes.Volatile>允許前置詞<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unaligned`作業碼：  
  
-   ILGenerator.Emit （OpCode，標籤）  
  
-   ILGenerator.Emit （Opcode，Byte）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將實值類型的 boxed 表示轉換成它的 unboxed 形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|79 < `T` >|unbox `valType`|擷取值的類型資料，從`obj`、 其表示法會進行 boxed 處理。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考推送至堆疊。  
  
2.  物件參考是從堆疊取出並實值類型指標來進行 unboxed 處理。  
  
3.  實值類型指標會推送至堆疊。  
  
 實值類型有兩種不同的表示法中通用語言基礎結構 (CLI):  
  
-   「 原始 」 形式，實值類型內嵌在另一個物件時使用。  
  
-   實值型別中的資料都包裝 （進行 boxed 處理） 成物件，它可以做為獨立的實體 'boxed' 格式。  
  
 `unbox`指令將轉換的物件參考 (類型`O`)、 實值類型指標至 boxed 實值類型，表示法 (的 managed 的指標類型`&`)、 其進行 unboxed 處理表單。 提供的值類型 (`valType`) 會指出類型的 boxed 物件內所包含的實值型別中繼資料語彙基元。  
  
 不同於<xref:System.Reflection.Emit.OpCodes.Box>，所需物件中建立一份使用實值類型`unbox`不需要複製物件中的實值型別。 通常它只會計算的位址已存在於 boxed 物件內的值類型。  
  
 <xref:System.InvalidCastException> 如果物件不會進行 boxed 處理做為擲回`valType`。  
  
 <xref:System.NullReferenceException> 如果物件參考為 null 參考，會擲回。  
  
 <xref:System.TypeLoadException> 如果類型值會擲回`valType`找不到。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`unbox`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將指令中指定之類型的 boxed 表示轉換成其 unboxed 形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A5 &LT; `T` >|unbox.any `typeTok`|擷取從資料`obj`、 其表示法會進行 boxed 處理。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  物件參考`obj`推入至堆疊。  
  
2.  物件參考是從堆疊取出並指令中指定的型別進行 unboxed 處理。  
  
3.  產生的物件參考或值類型會推送至堆疊。  
  
 當套用至 boxed 實值類型，`unbox.any`指令會擷取內含值`obj`(型別的`O`)，而且因此相當於`unbox`後面`ldobj`。  
  
 當套用至參考類型，`unbox.any`指令具有相同的效果`castclass` `typeTok`。  
  
 如果運算元`typeTok`是泛型類型參數，則執行階段行為取決於指定給該泛型類型參數的類型。  
  
 <xref:System.InvalidCastException> 如果擲回`obj`不 boxed 型別。  
  
 <xref:System.NullReferenceException> 如果擲回`obj`為 null 參考。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`unbox.any`作業碼：  
  
-   ILGenerator.Emit （OpCode，Type）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定目前在評估堆疊頂端的位址可能是 volatile，並且無法快取讀取該位置的結果，或者無法隱藏存放該位置的多個存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 13|變動性。|表示後續指標參考是暫時性。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  位址會推送至堆疊。  
  
 `volatile`。 指定的位址是動態位址 （也就是可以從外部參考目前的執行緒） 和讀取無法快取位置，或該位置的多個存放區不隱藏的結果。 標示為存取`volatile`會影響只有單一存取; 必須分別標示其他存取相同的位置。 不需要以不可分割方式執行變動性的位置。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned>和`volatile`可以按照任何順序結合前置詞。 它們必須緊接著`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 只有`volatile`允許前置詞<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`volatile`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算評估堆疊頂端兩個值的位元 XOR，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|61|xor|計算兩個整數值的位元 XOR 並傳回一個整數。|  
  
 堆疊的轉換行為，依連續順序為：  
  
1.  `value1` 推入至堆疊。  
  
2.  `value2` 推入至堆疊。  
  
3.  `value2` 和`value1`取出從堆疊，而且其位元 XOR 計算。  
  
4.  位元 XOR`value2`和`value1`推入至堆疊。  
  
 `xor`指令會計算前兩個的位元 XOR 值在堆疊上，並將結果留在堆疊上。  
  
 `Xor` 是整數特定作業。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載，可以使用`xor`作業碼：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>