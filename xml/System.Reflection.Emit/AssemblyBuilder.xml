<Type Name="AssemblyBuilder" FullName="System.Reflection.Emit.AssemblyBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8042d4d2a7c7a54f8532813c480f8abdd84ee332" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30470762" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AssemblyBuilder : System.Reflection.Assembly, System.Runtime.InteropServices._AssemblyBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AssemblyBuilder extends System.Reflection.Assembly implements class System.Runtime.InteropServices._AssemblyBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.AssemblyBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AssemblyBuilder&#xA;Inherits Assembly&#xA;Implements _AssemblyBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyBuilder sealed : System::Reflection::Assembly, System::Runtime::InteropServices::_AssemblyBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Assembly</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義及表示動態組件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態組件是使用反映發出 Api 建立組件。 使用儲存動態組件時，會儲存組件中的動態模組<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>方法。 若要產生可執行檔<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>必須呼叫方法，來識別組件的進入點的方法。 組件會儲存為 Dll 根據預設，除非<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>方法會要求在產生的主控台應用程式或 Windows 應用程式。  
  
 如果是動態組件包含一個以上的動態模組，組件的資訊清單檔案名稱應該符合模組的名稱指定為第一個引數<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>方法。  
  
 有些方法在基底<xref:System.Reflection.Assembly>類別，例如`GetModules`和`GetLoadedModules`，將無法正常運作時從呼叫<xref:System.Reflection.Emit.AssemblyBuilder>物件。 您可以載入定義動態組件，並載入的組件上呼叫方法。 例如，若要確保傳回的模組清單中，包含資源模組，呼叫`GetModules`上載入<xref:System.Reflection.Assembly>物件。  
  
 使用的動態組件的簽章<xref:System.Reflection.AssemblyName.KeyPair%2A>沒有作用，直到組件儲存至磁碟。 因此，強式名稱不適用於暫時性動態組件。  
  
 若要取得<xref:System.Reflection.Emit.AssemblyBuilder>物件，請使用<xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>方法。  
  
## <a name="reflection-emit-dynamic-assembly-scenarios"></a>反映發出動態組件的案例  
 下列是使用時要考慮的事項<xref:System.Reflection.Emit.AssemblyBuilder>類別來建立動態組件。  
  
### <a name="dynamic-modules"></a>動態模組  
 反映發出支援建立動態組件中定義的動態模組。 建立動態組件中的動態模組可以是暫時性或永久性。  
  
### <a name="restrictions-on-type-references"></a>型別參考的限制  
 組件可以參考另一個組件中定義的型別。 暫時性動態組件可以安全地參考另一個暫時性動態組件、 永久性的動態組件或靜態組件中定義的型別。 不過，common language runtime 不允許參考類型的暫時性動態模組中定義永久性動態模組。 這是因為當之後要儲存到磁碟，執行階段載入保存的動態模組無法解析的參考至暫時性動態模組中定義的類型。  
  
### <a name="restrictions-on-emitting-to-remote-application-domains"></a>發出遠端應用程式定義域的限制  
 某些情況下會需要建立與遠端應用程式定義域中執行的動態組件。 反映發出不允許直接與遠端應用程式定義域發出動態組件。 解決方案是發出動態組件目前的應用程式定義域中，發出動態組件儲存至磁碟，然後載入遠端應用程式定義域中的動態組件。  
  
### <a name="dynamic-assembly-access-modes"></a>動態組件存取模式  
 您可以使用下列存取模式的其中一種建立動態組件：  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess.Run?displayProperty=nameWithType>  
  
     表示的動態組件<xref:System.Reflection.Emit.AssemblyBuilder>物件是暫時性。 動態組件只可用來執行發出程式碼。  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess.Save?displayProperty=nameWithType>  
  
     表示的動態組件<xref:System.Reflection.Emit.AssemblyBuilder>物件是否為永續性，但無法執行，直到已經從磁碟載入已儲存的可攜式執行檔 (PE) 檔案。  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType>  
  
     表示的動態組件<xref:System.Reflection.Emit.AssemblyBuilder>物件是永久性的但也可以執行之前和/或之後的組件儲存至磁碟。  
  
 必須指定的存取模式，藉由提供適當<xref:System.Reflection.Emit.AssemblyBuilderAccess>的呼叫中的值<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly%2A?displayProperty=nameWithType>方法時的動態組件定義和稍後無法變更。 執行階段使用的動態組件的存取模式，來最佳化組件的內部表示法。  
  
   
  
## Examples  
 下列程式碼範例示範如何定義使用一個模組的動態組件。 範例組件中的模組包含一種類型， `MyDynamicType`，其中包含私用欄位、 取得和設定私用欄位的屬性、 建構函式會初始化私用欄位和將私用欄位的使用者提供數字相乘的方法值，並傳回結果。  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> 建立組件時指定的。 立即使用組件程式碼和組件也會儲存至磁碟，以便可以檢查與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)或用於另一個程式。  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
    <altmember cref="Overload:System.AppDomain.DefineDynamicAssembly" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AssemblyBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddResourceFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將現有的資源檔加入這個組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddResourceFile">
      <MemberSignature Language="C#" Value="public void AddResourceFile (string name, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddResourceFile(string name, string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddResourceFile (name As String, fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddResourceFile(System::String ^ name, System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">資源的邏輯名稱。</param>
        <param name="fileName">邏輯名稱對應到實體檔案名稱 (.resources 檔案)。 這不應該包含路徑；該檔案必須與要加入該檔案的組件位於相同目錄中。</param>
        <summary>將現有的資源檔加入這個組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` 不能與任何其他永久性模組、 獨立受管理資源或獨立的資訊清單檔案的相同。  
  
 Managed 的資源檔中會假設為公用。  
  
 指定的資源檔必須儲存組件的目錄中。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例示範如何將資源檔附加至使用動態建立組件`AddResourceFile`。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          之前已定義過 <paramref name="name" />。  
  
 -或-  
  
 組件中另有一個檔案名為 <paramref name="fileName" />。  
  
 -或-  
  
 <paramref name="name" /> 的長度為零。  
  
 -或-  
  
 <paramref name="fileName" /> 的長度為零，或者如果 <paramref name="fileName" /> 包含路徑。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要存取的資源檔需要的 FileIOPermissionAccess.Read 權<paramref name="resourceFileName" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="AddResourceFile">
      <MemberSignature Language="C#" Value="public void AddResourceFile (string name, string fileName, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddResourceFile(string name, string fileName, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddResourceFile (name As String, fileName As String, attribute As ResourceAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddResourceFile(System::String ^ name, System::String ^ fileName, System::Reflection::ResourceAttributes attribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">資源的邏輯名稱。</param>
        <param name="fileName">邏輯名稱對應到實體檔案名稱 (.resources 檔案)。 這不應該包含路徑；該檔案必須與要加入該檔案的組件位於相同目錄中。</param>
        <param name="attribute">資源屬性。</param>
        <summary>將現有的資源檔加入這個組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` 不能與任何其他永久性模組、 獨立受管理資源或獨立的資訊清單檔案的相同。  
  
 Managed 資源可指定屬性。  
  
 指定的資源檔必須儲存組件的目錄中。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例示範如何將資源檔附加至使用動態建立組件`AddResourceFile`。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.AddResourceFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          之前已定義過 <paramref name="name" />。  
  
 -或-  
  
 組件中另有一個檔案名為 <paramref name="fileName" />。  
  
 -或-  
  
 <paramref name="name" /> 長度為零，或如果 <paramref name="fileName" /> 長度為零。  
  
 -或-  
  
 <paramref name="fileName" /> 包含路徑。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="fileName" /> 檔案。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要存取的資源檔需要的 FileIOPermissionAccess.Read 權<paramref name="resourceFileName" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public override string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得原先指定的組件位置 (例如在 <see cref="T:System.Reflection.AssemblyName" /> 物件中指定的位置)。</summary>
        <value>原先指定的組件位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得之資訊清單包含已載入檔案的絕對路徑，請使用<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義動態組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">組件的名稱。</param>
        <param name="access">組件的存取權限。</param>
        <summary>定義具有指定名稱和存取模式的動態組件。</summary>
        <returns>代表新組件的物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">組件的名稱。</param>
        <param name="access">組件的存取權限。</param>
        <param name="assemblyAttributes">包含此組件屬性的集合。</param>
        <summary>定義具有指定名稱、存取權和屬性的新組件。</summary>
        <returns>代表新組件的物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicModule">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在此組件中定義動態模組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicModule (name As String) As ModuleBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ModuleBuilder ^ DefineDynamicModule(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動態模組的名稱。 長度必須小於 260 個字元。</param>
        <summary>在此組件中定義具名的暫時性動態模組。</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.ModuleBuilder" />，代表定義的動態模組。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它是組件中定義多個具有相同名稱的動態模組的錯誤。  
  
 定義的動態模組是暫時性的。 無法儲存動態模組，即使父動態組件以建立<xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave>。  
  
> [!NOTE]
>  若要偵錯動態模組時隱藏最佳化，套用<xref:System.Diagnostics.DebuggableAttribute>屬性設定為動態組件，然後再呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>。 建立的執行個體<xref:System.Diagnostics.DebuggableAttribute>與<xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations>旗標，並將它使用套用<xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A>方法。 屬性必須套用至動態組件。 如果套用至模組，它沒有任何作用。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 [Visual Basic、 C#]  
  
 下列程式碼範例示範如何建立暫時性動態模組，使用`DefineDynamicModule`。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的開頭為空白字元。  
  
 -或-  
  
 <paramref name="name" /> 的長度為零。  
  
 -或-  
  
 <paramref name="name" /> 的長度大於或等於 260。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ExecutionEngineException">無法載入預設符號寫入器的組件。  
  
 -或-  
  
 找不到實作預設符號寫入器介面的類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, bool emitSymbolInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicModule (name As String, emitSymbolInfo As Boolean) As ModuleBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ModuleBuilder ^ DefineDynamicModule(System::String ^ name, bool emitSymbolInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="emitSymbolInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態模組的名稱。 長度必須小於 260 個字元。</param>
        <param name="emitSymbolInfo">
          如果要發出符號資訊，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>定義這個組件中的具名暫時性動態模組，並指定是否應該發出符號資訊。</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.ModuleBuilder" />，代表定義的動態模組。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它是組件中定義多個具有相同名稱的動態模組的錯誤。  
  
 無法儲存動態模組，即使父動態組件以建立<xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave>。  
  
> [!NOTE]
>  若要偵錯動態模組時隱藏最佳化，套用<xref:System.Diagnostics.DebuggableAttribute>屬性設定為動態組件，然後再呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>。 建立的執行個體<xref:System.Diagnostics.DebuggableAttribute>與<xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations>旗標，並將它使用套用<xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A>方法。 屬性必須套用至動態組件。 如果套用至模組，它沒有任何作用。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 [Visual Basic、 C#]  
  
 下列程式碼範例示範如何建立暫時性動態模組，使用`DefineDynamicModule`，隱藏符號資訊。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#2)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#2)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的開頭為空白字元。  
  
 -或-  
  
 <paramref name="name" /> 的長度為零。  
  
 -或-  
  
 <paramref name="name" /> 的長度大於或等於 260。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ExecutionEngineException">無法載入預設符號寫入器的組件。  
  
 -或-  
  
 找不到實作預設符號寫入器介面的類型。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicModule (name As String, fileName As String) As ModuleBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ModuleBuilder ^ DefineDynamicModule(System::String ^ name, System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動態模組的名稱。 長度必須小於 260 個字元。</param>
        <param name="fileName">應該儲存動態模組的檔案名稱。</param>
        <summary>以會儲存在指定檔案的指定名稱定義永久性動態模組。 沒有發出任何符號資訊。</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 物件代表定義的動態模組。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要定義永久性動態模組，這個組件必須具有建立<xref:System.Reflection.Emit.AssemblyBuilderAccess.Save>或<xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave>屬性。  
  
 如果您想要包含的組件資訊清單模組`name`應該是相同的組件名稱 (也就是<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性<xref:System.Reflection.AssemblyName>用來建立動態組件) 和`fileName`應該相同您指定當您將儲存組件檔名。  
  
 只有一個模組的組件，在該模組應該包含組件資訊清單。  
  
> [!NOTE]
>  若要偵錯動態模組時隱藏最佳化，套用<xref:System.Diagnostics.DebuggableAttribute>屬性設定為動態組件，然後再呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>。 建立的執行個體<xref:System.Diagnostics.DebuggableAttribute>與<xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations>旗標，並將它使用套用<xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A>方法。 屬性必須套用至動態組件。 如果套用至模組，它沒有任何作用。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 [Visual Basic、 C#]  
  
 下列程式碼範例示範如何建立持續性的動態模組，使用`DefineDynamicModule`。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#3)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#3)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 的長度為零。  
  
 -或-  
  
 <paramref name="name" /> 的長度大於或等於 260。  
  
 -或-  
  
 <paramref name="fileName" /> 包含路徑規格 (例如目錄元件)。  
  
 -或-  
  
 和屬於這個組件的另一個檔案名稱發生衝突。</exception>
        <exception cref="T:System.InvalidOperationException">這個組件之前已儲存過。</exception>
        <exception cref="T:System.NotSupportedException">這個組件在具有 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /> 屬性的動態組件上呼叫過。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ExecutionEngineException">無法載入預設符號寫入器的組件。  
  
 -或-  
  
 找不到實作預設符號寫入器介面的類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">寫入 = true，或附加 = true 才能儲存模組</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, string fileName, bool emitSymbolInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicModule (name As String, fileName As String, emitSymbolInfo As Boolean) As ModuleBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ModuleBuilder ^ DefineDynamicModule(System::String ^ name, System::String ^ fileName, bool emitSymbolInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="emitSymbolInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態模組的名稱。 長度必須小於 260 個字元。</param>
        <param name="fileName">應該儲存動態模組的檔案名稱。</param>
        <param name="emitSymbolInfo">若為 <see langword="true" />，符號資訊會使用預設符號寫入器寫入。</param>
        <summary>定義永久性動態模組，指定模組名稱、要儲存該模組的檔案名稱，以及是否應使用預設符號寫入器發出符號資訊。</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 物件代表定義的動態模組。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要定義永久性動態模組，這個組件必須具有建立<xref:System.Reflection.Emit.AssemblyBuilderAccess.Save>或<xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave>屬性。  
  
 如果您想要包含的組件資訊清單模組`name`應該是相同的組件名稱 (也就是<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性<xref:System.Reflection.AssemblyName>用來建立動態組件) 和`fileName`應該相同您指定當您將儲存組件檔名。  
  
 只有一個模組的組件，在該模組應該包含組件資訊清單。  
  
> [!NOTE]
>  若要偵錯動態模組時隱藏最佳化，套用<xref:System.Diagnostics.DebuggableAttribute>屬性設定為動態組件，然後再呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>。 建立的執行個體<xref:System.Diagnostics.DebuggableAttribute>與<xref:System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations>旗標，並將它使用套用<xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A>方法。 屬性必須套用至動態組件。 如果套用至模組，它沒有任何作用。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 [Visual Basic、 C#]  
  
 下列程式碼範例示範如何建立的永續性的動態模組，符號發出使用`DefineDynamicModule`。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CPP/source.cpp#4)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/CS/source.cs#4)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 的長度為零。  
  
 -或-  
  
 <paramref name="name" /> 的長度大於或等於 260。  
  
 -或-  
  
 <paramref name="fileName" /> 包含路徑規格 (例如目錄元件)。  
  
 -或-  
  
 和屬於這個組件的另一個檔案名稱發生衝突。</exception>
        <exception cref="T:System.InvalidOperationException">這個組件之前已儲存過。</exception>
        <exception cref="T:System.NotSupportedException">這個組件在具有 <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Run" /> 屬性的動態組件上呼叫過。</exception>
        <exception cref="T:System.ExecutionEngineException">無法載入預設符號寫入器的組件。  
  
 -或-  
  
 找不到實作預設符號寫入器介面的類型。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">寫入 = true，或附加 = true 才能儲存這個模組</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義這個組件的獨立受管理資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String, fileName As String) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description, System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">資源的邏輯名稱。</param>
        <param name="description">資源的文字描述。</param>
        <param name="fileName">邏輯名稱對應到實體檔案名稱 (.resources 檔案)。 這應該不包含路徑。</param>
        <summary>使用預設公用資源屬性定義這個組件的獨立受管理資源。</summary>
        <returns>所指定資源的 <see cref="T:System.Resources.ResourceWriter" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新增細部的資源，可以使用所傳回<xref:System.Resources.ResourceWriter>藉由呼叫<xref:System.Resources.ResourceWriter.AddResource%2A>。  
  
 `fileName` 不能與任何其他永久性模組、 獨立受管理的資源或獨立的資訊清單檔案的相同。  
  
 執行階段呼叫<xref:System.Resources.ResourceWriter.Close%2A>方法儲存動態組件時。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>方法來取得資源寫入器。 此範例會使用資源寫入器將三個資源字串。  
  
 [!code-cpp[AssemblyBuilder.DefineResource Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder.DefineResource Example 2/CPP/assemblybuilder_defineresource.cpp#1)]
 [!code-csharp[AssemblyBuilder.DefineResource Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder.DefineResource Example 2/CS/assemblybuilder_defineresource.cs#1)]
 [!code-vb[AssemblyBuilder.DefineResource Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder.DefineResource Example 2/VB/assemblybuilder_defineresource.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          之前已定義過 <paramref name="name" />。  
  
 -或-  
  
 組件中另有一個檔案名為 <paramref name="fileName" />。  
  
 -或-  
  
 <paramref name="name" /> 的長度為零。  
  
 -或-  
  
 <paramref name="fileName" /> 的長度為零。  
  
 -或-  
  
 <paramref name="fileName" /> 包含路徑。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">寫入 = true，或附加 = true</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, string fileName, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, string fileName, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String, fileName As String, attribute As ResourceAttributes) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description, System::String ^ fileName, System::Reflection::ResourceAttributes attribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">資源的邏輯名稱。</param>
        <param name="description">資源的文字描述。</param>
        <param name="fileName">邏輯名稱對應到實體檔案名稱 (.resources 檔案)。 這應該不包含路徑。</param>
        <param name="attribute">資源屬性。</param>
        <summary>定義這個組件的獨立受管理資源。 Managed 資源可指定屬性。</summary>
        <returns>所指定資源的 <see cref="T:System.Resources.ResourceWriter" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新增細部的資源，可以使用所傳回<xref:System.Resources.ResourceWriter>藉由呼叫<xref:System.Resources.ResourceWriter.AddResource%2A>。  
  
 `fileName` 不能與任何其他永久性模組、 獨立受管理資源或獨立的資訊清單檔案的相同。  
  
 執行階段呼叫<xref:System.Resources.ResourceWriter.Close%2A>方法儲存動態組件時。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          先前已定義過 <paramref name="name" />，或組件中是否另有一個檔案名為 <paramref name="fileName" />。  
  
 -或-  
  
 <paramref name="name" /> 的長度為零。  
  
 -或-  
  
 <paramref name="fileName" /> 的長度為零。  
  
 -或-  
  
 <paramref name="fileName" /> 包含路徑。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="fileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">寫入 = true，或附加 = true</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineUnmanagedResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義這個組件的 Unmanaged 資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resource As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(cli::array &lt;System::Byte&gt; ^ resource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">表示 Unmanaged 資源的不透明 Blob (位元組)。</param>
        <summary>將這個組件的 Unmanaged 資源定義為不透明的 Blob (位元組)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以只有一個 unmanaged 資源相關聯的組件。 這表示，呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A>或<xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A>之後呼叫其中一個方法之前將會擲回所擲回 System.ArgumentException。 需要 Microsoft ResMerge 公用程式 （未提供與 common language runtime） 之類的工具與合併多個未受管理的資源。  
  
   
  
## Examples  
 下列程式碼範例會建立並附加表示動態組件，使用的 unmanaged 的資源的位元組陣列`DefineUnmanagedResource`。  
  
 [!code-cpp[AssemblyBuilder_DefineUnmanagedResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource2/CPP/assemblybuilder_defineunmanagedresource2.cpp#1)]
 [!code-csharp[AssemblyBuilder_DefineUnmanagedResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource2/CS/assemblybuilder_defineunmanagedresource2.cs#1)]
 [!code-vb[AssemblyBuilder_DefineUnmanagedResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource2/VB/assemblybuilder_defineunmanagedresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">先前定義的 Unmanaged 資源。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resourceFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(System::String ^ resourceFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">資源檔名稱。</param>
        <summary>定義指定資源檔名稱的這個組件之 Unmanaged 資源檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以只有一個 unmanaged 資源相關聯的組件。 這表示，呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A>或<xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A>之後呼叫其中一個方法之前將會擲回 System.ArgumentException。 需要 Microsoft ResMerge 公用程式 （未提供與 common language runtime） 之類的工具與合併多個未受管理的資源。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範呼叫`DefineUnmanagedResource`，傳遞至外部的資源檔。  
  
 [!code-cpp[AssemblyBuilder_DefineUnmanagedResource#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource/CPP/assemblybuilder_defineunmanagedresource.cpp#3)]
 [!code-csharp[AssemblyBuilder_DefineUnmanagedResource#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource/CS/assemblybuilder_defineunmanagedresource.cs#3)]
 [!code-vb[AssemblyBuilder_DefineUnmanagedResource#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineUnmanagedResource/VB/assemblybuilder_defineunmanagedresource.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">先前定義的 Unmanaged 資源。  
  
 -或-  
  
 檔案 <paramref name="resourceFileName" /> 不可讀取。  
  
 -或-  
  
 <paramref name="resourceFileName" /> 為空字串 ("")。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="resourceFileName" />。  
  
 -或-  
  
 <paramref name="resourceFileName" /> 是目錄。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要存取的資源檔需要的 FileIOPermissionAccess.Read 權<paramref name="resourceFileName" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineVersionInfoResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義這個組件的 Unmanaged Version 資訊資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineVersionInfoResource">
      <MemberSignature Language="C#" Value="public void DefineVersionInfoResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineVersionInfoResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineVersionInfoResource ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineVersionInfoResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用組件 AssemblyName 物件和組件自訂屬性中指定的資訊，定義 Unmanaged Version 資訊資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以只有一個 unmanaged 資源相關聯的組件。 這表示，呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A>或<xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A>之後呼叫其中一個方法之前將會擲回 System.ArgumentException。 需要 Microsoft ResMerge 公用程式 （未提供與 common language runtime SDK） 之類的工具與合併多個未受管理的資源。  
  
 空白的引數的字串寫入為單一空格。 空格會取代的引數字串中的 null 字元。  
  
 資訊會從推斷`AssemblyName`用來定義這個動態組件的物件。 這個組件的自訂屬性會覆寫資訊中指定`AssemblyName`物件。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例所示的使用方式`DefineVersionInfoResource`。  
  
 [!code-cpp[AssemblyBuilder_DefineVersionInfoResource#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CPP/assemblybuilder_defineversioninforesource.cpp#1)]
 [!code-csharp[AssemblyBuilder_DefineVersionInfoResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CS/assemblybuilder_defineversioninforesource.cs#1)]
 [!code-vb[AssemblyBuilder_DefineVersionInfoResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/VB/assemblybuilder_defineversioninforesource.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Unmanaged Version 資訊資源之前已定義過。  
  
 -或-  
  
 Unmanaged Version 資訊太大以致於無法保存。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineVersionInfoResource">
      <MemberSignature Language="C#" Value="public void DefineVersionInfoResource (string product, string productVersion, string company, string copyright, string trademark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineVersionInfoResource (product As String, productVersion As String, company As String, copyright As String, trademark As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineVersionInfoResource(System::String ^ product, System::String ^ productVersion, System::String ^ company, System::String ^ copyright, System::String ^ trademark);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="product" Type="System.String" />
        <Parameter Name="productVersion" Type="System.String" />
        <Parameter Name="company" Type="System.String" />
        <Parameter Name="copyright" Type="System.String" />
        <Parameter Name="trademark" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="product">散發這個組件的產品名稱。</param>
        <param name="productVersion">散發這個組件的產品版本。</param>
        <param name="company">生產這個組件的公司名稱。</param>
        <param name="copyright">描述所有適用這個組件的著作權標示、商標及註冊商標。 這應包括所有注意事項全文、法律符號、版權日期、商標登錄編號等等。 此段文字的英文格式應為 "Copyright Microsoft Corp.1990-2001".</param>
        <param name="trademark">描述所有適用這個組件的商標及註冊商標。 這應包括所有注意事項全文、法律符號、商標登錄編號等等。 此段文字的英文格式應為 "Windows is a trademark of Microsoft Corporation"。</param>
        <summary>請使用指定的規格定義這個組件的 Unmanaged Version 資訊資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以只有一個 unmanaged 資源相關聯的組件。 這表示，呼叫<xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A>或<xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A>之後呼叫其中一個方法之前將會擲回 System.ArgumentException。 多個未受管理的資源需要 Microsoft 之類的工具與合併`ResMerge`公用程式 （不是與 common language runtime SDK 提供）。  
  
 空白的引數的字串寫入為單一空格。 空格會取代的引數字串中的 null 字元。  
  
 版本資源的結構包含可識別版本、 語言和檔案的發佈資料。 安裝程式檔案安裝文件庫 （版本中使用函式DLL) 來擷取檔案版本資訊資源，並為從資源擷取版本資訊區塊。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例所示的使用方式`DefineVersionInfoResource`。  
  
 [!code-cpp[AssemblyBuilder_DefineVersionInfoResource#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CPP/assemblybuilder_defineversioninforesource.cpp#1)]
 [!code-csharp[AssemblyBuilder_DefineVersionInfoResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/CS/assemblybuilder_defineversioninforesource.cs#1)]
 [!code-vb[AssemblyBuilder_DefineVersionInfoResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_DefineVersionInfoResource/VB/assemblybuilder_defineversioninforesource.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Unmanaged Version 資訊資源之前已定義過。  
  
 -或-  
  
 Unmanaged Version 資訊太大以致於無法保存。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回這個組件的進入點。</summary>
        <value>這個組件的進入點。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">與這個執行個體相比較的物件，或 <see langword="null" />。</param>
        <summary>傳回值，這個值表示這個執行個體是否等於指定的物件。</summary>
        <returns>
          如果 <see langword="true" /> 和這個執行個體具有相同的類型和值，則為 <paramref name="obj" />否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個組件的辨識碼。</summary>
        <value>這個組件的辨識項。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前動態組件的顯示名稱。</summary>
        <value>目前動態組件的顯示名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>的組件的顯示名稱格式的描述。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 的自訂屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 的所有自訂屬性。</summary>
        <returns>陣列，其中包含自訂屬性；如果沒有屬性，則陣列是空的。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">從中衍生屬性的基底類型。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 且衍生自指定之屬性型別的所有自訂屬性。</summary>
        <returns>陣列，包含衍生自 <paramref name="attributeType" /> 任何層級的自訂屬性，如果沒有這類屬性則為空陣列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 不是由執行階段提供的 <see cref="T:System.Type" /> 物件。 例如，<paramref name="attributeType" /> 是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Reflection.CustomAttributeData" /> 物件，這些物件包含已套用至目前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 之屬性的相關資訊。</summary>
        <returns>
          <see cref="T:System.Reflection.CustomAttributeData" /> 物件的泛型清單，表示已套用至目前模組之屬性 (Attribute) 的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要檢查之自訂屬性的程式碼，在僅限反映的內容中，在其中已載入僅限反映之內容的程式碼中定義的自訂屬性本身的情況下使用這個方法。 這類方法<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>不能在這種情況下，因為它們可以建立屬性的執行個體。 無法執行僅限反映的內容中的程式碼。 如需詳細資訊和如需範例程式碼，請參閱<xref:System.Reflection.CustomAttributeData>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder GetDynamicModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder GetDynamicModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicModule (name As String) As ModuleBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ModuleBuilder ^ GetDynamicModule(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求之動態模組的名稱。</param>
        <summary>傳回具有指定名稱的動態模組。</summary>
        <returns>代表要求之動態模組的 ModuleBuilder 物件。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度為零。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得這個組件中定義的匯出類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 陣列，包含在這個組件中定義的匯出型別。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">這個方法尚未實作。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public override System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定檔案的名稱。</param>
        <summary>取得指定之檔案的 <see cref="T:System.IO.FileStream" />，這個指定之檔案位於這個組件的資訊清單檔案表中。</summary>
        <returns>指定檔案的 <see cref="T:System.IO.FileStream" /> 或 <see langword="null" /> (如果找不到檔案)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` 不應該包含檔案的路徑。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public override System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>取得組件資訊清單檔案表中的檔案，指定是否要包含資源模組。</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> 物件的陣列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>傳回所有屬於這個組件的載入模組，並選擇性地包含資源模組。</summary>
        <returns>屬於這個組件的載入模組。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public override System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">資源名稱。</param>
        <summary>傳回指定資源已保存方式的資訊。</summary>
        <returns>
          填入此資源拓撲相關資訊的 <see cref="T:System.Reflection.ManifestResourceInfo" />，如果找不到資源，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public override string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>載入來自這個組件的指定資訊清單資源。</summary>
        <returns>類型 <see langword="String" /> 的陣列，包含所有資源的名稱。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">動態組件不支援這個方法。 若要取得資訊清單資源名稱，請使用 <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入來自這個組件的指定資訊清單資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所要求的資訊清單資源名稱。</param>
        <summary>載入來自這個組件的指定資訊清單資源。</summary>
        <returns>
          <see cref="T:System.IO.Stream" /> 代表這個資訊清單資源。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">類型，其命名空間是用來限定資訊清單資源名稱的範圍。</param>
        <param name="name">所要求的資訊清單資源名稱。</param>
        <summary>從這個組件載入指定資訊清單資源，由指定類型的命名空間限定範圍。</summary>
        <returns>
          <see cref="T:System.IO.Stream" /> 代表這個資訊清單資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.IO.Stream>其設定為在資源開頭的檔案指標。  
  
   
  
## Examples  
 如果完整名稱`type`是 「 MyNameSpace.MyClasses"和`name`是 「 點 」，`GetManifestResourceStream`會搜尋名為 MyNameSpace.Dot 的資源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求模組的名稱。</param>
        <summary>取得這個組件中的指定模組。</summary>
        <returns>正在接受要求的模組，如果找不到模組，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>取得所有屬於這個組件的模組，並選擇性地包含資源模組。</summary>
        <returns>屬於這個組件的模組。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> 表示將程式碼基底設定為組件陰影複製以後的位置，<see langword="false" /> 表示將程式碼基底設定為原始位置。</param>
        <summary>取得目前動態組件建立時所指定的 <see cref="T:System.Reflection.AssemblyName" />，並且依指定設定程式碼基底。</summary>
        <returns>動態組件的名稱。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public override System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得這個 <see cref="T:System.Reflection.AssemblyName" /> 所參考組件之 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 物件的不完整清單。</summary>
        <returns>受參考組件的組件名稱陣列。 這個陣列不是完整的清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回參考的組件的完整清單。 例如，如果您套用自訂屬性以<xref:System.Reflection.Emit.AssemblyBuilder>，定義屬性的組件包含在這個方法所傳回的清單。 不過，如果您使用<xref:System.Type>以指定的方法參數，類型不是包含類型的物件。  
  
 若要取得參考的組件的完整清單，請儲存組件，請將其載入至另一個應用程式定義域，並呼叫<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得指定的附屬組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定的文化特性。</param>
        <summary>取得指定文化特性的附屬組件。</summary>
        <returns>指定的附屬組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附屬組件包含不同一個主應用程式組件，其中包含不可當地語系化的可執行程式碼和單一文化的資源，用以做為預設或中性文化特性的當地語系化的資源。  
  
 呼叫此方法以使用目前的組件版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到具有相符檔名的附屬組件，但 <see langword="CultureInfo" /> 與所指定者不符。</exception>
        <exception cref="T:System.BadImageFormatException">此附屬組件不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定的文化特性。</param>
        <param name="version">附屬組件的版本。</param>
        <summary>取得指定文化特性的附屬組件指定版本。</summary>
        <returns>指定的附屬組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附屬組件包含不同一個主應用程式組件，其中包含不可當地語系化的可執行程式碼和單一文化的資源，用以做為預設或中性文化特性的當地語系化的資源。  
  
 呼叫<xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>多載，以便使用目前的組件版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">找到具有相符檔名的附屬組件，但 <see langword="CultureInfo" /> 或版本與所指定者不符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到組件。</exception>
        <exception cref="T:System.BadImageFormatException">此附屬組件不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要搜尋的類型名稱。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該型別時擲回例外狀況，否則為 <see langword="false" />。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示搜尋時忽略型別名稱的大小寫，否則為 <see langword="false" />。</param>
        <summary>從目前 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 中已定義及建立的型別，取得指定的型別。</summary>
        <returns>指定的型別，如果找不到或尚未建立該型別，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型別找不到之前建立藉由呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public override bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示組件是否從全域組件快取載入。</summary>
        <value>一定是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.AssemblyBuilder> 物件一律代表對動態組件，因此永遠不會載入及從全域組件快取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public override long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得建立動態組件所在的主機內容。</summary>
        <value>指出建立動態組件所在之主機內容的值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public override string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得將要儲存在含有資訊清單之檔案中的 Common Language Runtime 版本。</summary>
        <value>代表 Common Language Runtime 版本的字串。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">要測試的屬性類型。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回值，這個值表示指定屬性類型的一或多個執行個體是否套用至這個成員。</summary>
        <returns>
          如果一個或多個 <paramref name="attributeType" /> 的執行個體套用至這個動態組件，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public override bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前的組件是動態組件。</summary>
        <value>一定是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.AssemblyBuilder>物件一律代表動態組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public override string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果不是陰影複製，則取得包含資訊清單之已載入檔案的位置 (程式碼基底格式)。</summary>
        <value>包含資訊清單之載入檔的位置。 如果載入檔是已經陰影複製的，則 <see langword="Location" /> 是陰影複製前檔案的位置。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">目前不支援這個方法。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在目前的 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 中取得模組，其中包含組件資訊清單。</summary>
        <value>資訊清單模組。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public override System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前動態組件的授權集。</summary>
        <value>目前動態組件的授權集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 物件可以包含機密資訊，例如路徑。 因此，完全信任，才能存取這些物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public override bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，其會表示此動態組件是否位於僅限反射內容中。</summary>
        <value>
          如果動態組件位於僅反映的內容中，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要發出動態組件的僅限反映的內容中，指定<xref:System.Reflection.Emit.AssemblyBuilderAccess.ReflectionOnly?displayProperty=nameWithType>當您建立<xref:System.Reflection.Emit.AssemblyBuilder>。 如果在僅限反映的內容中，就會發出動態組件，則無法執行其程式碼。  
  
> [!NOTE]
>  動態組件儲存至磁碟之後，您可以使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法完成的組件載入僅限反映的內容。 不過，無法再修改組件。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Reflection.Emit.AssemblyBuilderAccess.ReflectionOnly" />
        <altmember cref="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將此動態組件儲存到磁碟。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string assemblyFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string assemblyFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (assemblyFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ assemblyFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFileName">組件的檔案名稱。</param>
        <summary>將此動態組件儲存到磁碟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會儲存在這個動態組件中定義的所有非暫時性動態模組。 不會儲存暫時性動態模組。 組件檔案名稱可以是下列其中一個模組的名稱相同。 若是如此，組件資訊清單會儲存在該模組中。 `assemblyFileName` 可以是不同的所有組件內所包含之模組的名稱。 若是如此，組件檔案包含組件資訊清單。  
  
 每個<xref:System.Resources.ResourceWriter>使用取得<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>，.resources 檔案，並在呼叫這個方法會寫入<xref:System.Resources.ResourceWriter.Close%2A>關閉資料流。  
  
 `assemblyFileName`必須是簡單的檔案名稱沒有磁碟機或目錄的元件。 若要建立組件的特定目錄中，使用其中一種<xref:System.AppDomain.DefineDynamicAssembly%2A>使用目標目錄引數的方法。  
  
 在.NET Framework 2.0 版中，這個多載的<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>方法相當於呼叫<xref:System.Reflection.Emit.AssemblyBuilder.Save%28System.String%2CSystem.Reflection.PortableExecutableKinds%2CSystem.Reflection.ImageFileMachine%29>方法多載<xref:System.Reflection.PortableExecutableKinds.ILOnly>如`portableExecutableKind`參數和<xref:System.Reflection.ImageFileMachine.I386>如`imageFileMachine`參數。  
  
   
  
## Examples  
 下列程式碼範例會建立動態組件，然後將它保存到本機磁碟使用`Save`。  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.Save Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.Save Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.AssemblyBuilder.Save Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.Save Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.AssemblyBuilder.Save Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFileName" /> 的長度為零。  
  
 -或-  
  
 組件中有兩個或多個模組資源檔案具有相同名稱。  
  
 -或-  
  
 組件的目標目錄無效。  
  
 -或-  
  
 <paramref name="assemblyFileName" /> 不是簡單檔名 (例如具有目錄或磁碟機元件)，或者在這個組件中定義了一個以上的 Unmanaged 資源 (包括版本資訊資源)。  
  
 -或-  
  
 <see cref="T:System.Reflection.AssemblyCultureAttribute" /> 中的 <see langword="CultureInfo" /> 字串不是有效的字串，並且 <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /> 是在呼叫這個方法之前呼叫的。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已儲存了這個組件。  
  
 -或-  
  
 這個組件具有存取權 <see langword="Run" /><see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /></exception>
        <exception cref="T:System.IO.IOException">儲存期間發生輸出錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          尚未為組件之模組中的任何型別呼叫 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 以寫入磁碟。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">寫入 = true，或附加 = true 才能將這個組件儲存至指定的檔案名稱。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string assemblyFileName, System.Reflection.PortableExecutableKinds portableExecutableKind, System.Reflection.ImageFileMachine imageFileMachine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string assemblyFileName, valuetype System.Reflection.PortableExecutableKinds portableExecutableKind, valuetype System.Reflection.ImageFileMachine imageFileMachine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.Save(System.String,System.Reflection.PortableExecutableKinds,System.Reflection.ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ assemblyFileName, System::Reflection::PortableExecutableKinds portableExecutableKind, System::Reflection::ImageFileMachine imageFileMachine);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFileName" Type="System.String" />
        <Parameter Name="portableExecutableKind" Type="System.Reflection.PortableExecutableKinds" />
        <Parameter Name="imageFileMachine" Type="System.Reflection.ImageFileMachine" />
      </Parameters>
      <Docs>
        <param name="assemblyFileName">組件的檔案名稱。</param>
        <param name="portableExecutableKind">
          <see cref="T:System.Reflection.PortableExecutableKinds" /> 值的 Bitwise 組合，用來指定程式碼的性質。</param>
        <param name="imageFileMachine">其中一個 <see cref="T:System.Reflection.ImageFileMachine" /> 值，用來指定目標平台。</param>
        <summary>將這個動態組件儲存至磁碟，指定在組件的可執行檔和目標平台的程式碼本質。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`imageFileMachine`和`portableExecutableKind`不相容，`imageFileMachine`優先於`portableExecutableKind`。 不會有例外狀況擲回。 例如，如果您指定<xref:System.Reflection.ImageFileMachine.I386?displayProperty=nameWithType>與<xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=nameWithType>，<xref:System.Reflection.PortableExecutableKinds.PE32Plus?displayProperty=nameWithType>會被忽略。  
  
 這個方法會儲存在這個動態組件中定義的所有非暫時性動態模組。 不會儲存暫時性動態模組。 組件檔案名稱可以是下列其中一個模組的名稱相同。 若是如此，組件資訊清單會儲存在該模組中。 `assemblyFileName` 可以是不同的所有組件內所包含之模組的名稱。 若是如此，組件檔案包含組件資訊清單。  
  
 每個<xref:System.Resources.ResourceWriter>使用取得<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>，.resources 檔案，並在呼叫這個方法會寫入<xref:System.Resources.ResourceWriter.Close%2A>關閉資料流。  
  
 `assemblyFileName`必須是簡單的檔案名稱沒有磁碟機或目錄的元件。 若要建立組件的特定目錄中，使用其中一種<xref:System.AppDomain.DefineDynamicAssembly%2A>使用目標目錄引數的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFileName" /> 的長度為零。  
  
 -或-  
  
 組件中有兩個或多個模組資源檔案具有相同名稱。  
  
 -或-  
  
 組件的目標目錄無效。  
  
 -或-  
  
 <paramref name="assemblyFileName" /> 不是簡單檔名 (例如具有目錄或磁碟機元件)，或者在這個組件中定義了一個以上的 Unmanaged 資源 (包括版本資訊資源)。  
  
 -或-  
  
 <see cref="T:System.Reflection.AssemblyCultureAttribute" /> 中的 <see langword="CultureInfo" /> 字串不是有效的字串，並且 <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource(System.String,System.String,System.String,System.String,System.String)" /> 是在呼叫這個方法之前呼叫的。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已儲存了這個組件。  
  
 -或-  
  
 這個組件具有存取權 <see langword="Run" /><see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /></exception>
        <exception cref="T:System.IO.IOException">儲存期間發生輸出錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          尚未為組件之模組中的任何型別呼叫 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 以寫入磁碟。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">寫入 = true，或附加 = true 才能將這個組件儲存至指定的檔案名稱。</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.AssemblyBuilder.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值指出應針對此組件強制執行的 Common Language Runtime (CLR) 安全性規則組合。</summary>
        <value>CLR 對這個動態組件強制執行的安全性規則組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]一律會強制執行層級 2 透明度 (<xref:System.Security.SecurityRuleSet.Level2?displayProperty=nameWithType>) 就會產生動態組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定此組件的自訂屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">定義自訂屬性的協助程式類別執行個體。</param>
        <summary>使用自訂屬性產生器來設定這個組件上的自訂屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> 不能設定的宣告式安全性屬性。 使用其中一個多載的<xref:System.AppDomain.DefineDynamicAssembly%2A>採用所需，選擇性的並拒絕權限。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例說明如何使用`SetCustomAttribute`內<xref:System.Reflection.Emit.AssemblyBuilder>，並使用<xref:System.Reflection.Emit.CustomAttributeBuilder>。  
  
 [!code-cpp[AssemblyBuilder_SetCustomAttribute1#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute1/CPP/assemblybuilder_setcustomattribute1.cpp#1)]
 [!code-csharp[AssemblyBuilder_SetCustomAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute1/CS/assemblybuilder_setcustomattribute1.cs#1)]
 [!code-vb[AssemblyBuilder_SetCustomAttribute1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute1/VB/assemblybuilder_setcustomattribute1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">自訂屬性的建構函式。</param>
        <param name="binaryAttribute">代表屬性的位元組 Blob。</param>
        <summary>使用指定的自訂屬性 Blob 來設定這個組件上的自訂屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有關如何格式化，請參閱 ECMA 第二篇文件以取得詳細資料中的中繼資料規格`binaryAttribute`。 您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 `RuntimeConstructorInfo` 由系統產生的一種特殊類型。 它衍生自<xref:System.Reflection.ConstructorInfo>類別，以及任何<xref:System.Reflection.ConstructorInfo>您透過反映來取得的物件是實際的執行個體`RuntimeConstructorInfo`。  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> 不能設定的宣告式安全性屬性。 使用其中一個多載的<xref:System.AppDomain.DefineDynamicAssembly%2A>採用所需，選擇性的並拒絕權限。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例說明如何使用`SetCustomAttribute`来附加自訂屬性至動態產生的組件。  
  
 [!code-cpp[AssemblyBuilder_SetCustomAttribute2#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute2/CPP/assemblybuilder_setcustomattribute2.cpp#1)]
 [!code-csharp[AssemblyBuilder_SetCustomAttribute2#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute2/CS/assemblybuilder_setcustomattribute2.cs#1)]
 [!code-vb[AssemblyBuilder_SetCustomAttribute2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilder_SetCustomAttribute2/VB/assemblybuilder_setcustomattribute2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="con" /> 不是 <see langword="RuntimeConstructorInfo" /> 物件。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEntryPoint">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定這個動態組件的進入點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEntryPoint">
      <MemberSignature Language="C#" Value="public void SetEntryPoint (System.Reflection.MethodInfo entryMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEntryPoint(class System.Reflection.MethodInfo entryMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetEntryPoint (entryMethod As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetEntryPoint(System::Reflection::MethodInfo ^ entryMethod);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryMethod">方法的參考，代表這個動態組件的進入點。</param>
        <summary>設定這個動態組件的進入點，並假設正在建立主控台應用程式。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryMethod" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entryMethod" /> 不包含在這個組件中。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetEntryPoint">
      <MemberSignature Language="C#" Value="public void SetEntryPoint (System.Reflection.MethodInfo entryMethod, System.Reflection.Emit.PEFileKinds fileKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEntryPoint(class System.Reflection.MethodInfo entryMethod, valuetype System.Reflection.Emit.PEFileKinds fileKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint(System.Reflection.MethodInfo,System.Reflection.Emit.PEFileKinds)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetEntryPoint (entryMethod As MethodInfo, fileKind As PEFileKinds)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetEntryPoint(System::Reflection::MethodInfo ^ entryMethod, System::Reflection::Emit::PEFileKinds fileKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="fileKind" Type="System.Reflection.Emit.PEFileKinds" />
      </Parameters>
      <Docs>
        <param name="entryMethod">方法的參考，代表這個動態組件的進入點。</param>
        <param name="fileKind">正在建置之組件可執行檔的類型。</param>
        <summary>設定這個組件的進入點和定義正在建置之可攜式執行檔 (PE 檔) 的類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryMethod" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entryMethod" /> 不包含在這個組件中。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AssemblyBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_AssemblyBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AssemblyBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_AssemblyBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">接收要求的類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AssemblyBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_AssemblyBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的類型資訊介面數目的位置。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.AssemblyBuilder.System#Runtime#InteropServices#_AssemblyBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AssemblyBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_AssemblyBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
  </Members>
</Type>