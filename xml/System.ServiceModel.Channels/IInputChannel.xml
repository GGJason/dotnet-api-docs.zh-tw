<Type Name="IInputChannel" FullName="System.ServiceModel.Channels.IInputChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="73371f76db2d9423c8ff9eb31a980d7e95096d7b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37621694" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IInputChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IInputChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IInputChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IInputChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IInputChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IInputChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>定義通道必須實作以接收訊息的介面。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IInputChannel> 合約包括接收、嘗試接收 (try-to-receive) 和等候訊息 (wait-for-a-message) 功能的同步和非同步等變體。  
  
 提取模型一般是配合 <xref:System.ServiceModel.Channels.IInputChannel> 使用來接收訊息：您要呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (從通道「提取」訊息) 然後等候訊息到達。 另一個替代的使用模式是呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 或者 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>，然後呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>。 對於在 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> 和 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 呼叫之間開始交易的交易用法而言，這是很常見的方法。  
  
 <xref:System.ServiceModel.Channels.IInputChannel> 不一定要繫結到單一寄件人。 其他的通道和通道介面可以提供特定寄件人和 <xref:System.ServiceModel.Channels.IInputChannel>之間的相互關聯，但是基底合約並未提供這類限制。 實作 (Implementation) 可以為每個訊息建立新的 <xref:System.ServiceModel.Channels.IInputChannel>，或者為多個訊息和寄件人重複使用相同的 <xref:System.ServiceModel.Channels.IInputChannel>。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始非同步的接收作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。 當可接受目前的執行緒要進行封鎖直到接收到要求訊息或者已超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。 不管有沒有明確的逾時，都可以使用非同步的作業。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</param>
        <param name="state">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</param>
        <summary>開始非同步的作業，接收具有與該作業關聯之狀態物件的訊息。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，參考非同步訊息接收。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。 當可接受目前的執行緒要進行封鎖直到接收到要求訊息或者已超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。 不管有沒有明確的逾時，都可以使用非同步的作業。  
  
 這個方法會透過回呼 (Callback)，接收有關作業之事件處理常式身分識別的通知。 作業要等到訊息可以在通道中使用之後才算完成。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指定等候訊息變成可以使用的時間間隔。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</param>
        <param name="state">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</param>
        <summary>開始非同步的作業，接收具有已指定逾時以及與該作業關聯之狀態物件的訊息。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，參考非同步的接收作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。 當可接受目前的執行緒要進行封鎖直到接收到要求訊息或者已超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。 不管有沒有明確的逾時，都可以使用非同步的作業。  
  
 在訊息可以於通道中使用或發生逾時之後，作業才會完成。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">在完成作業之前超出了指定的 <paramref name="timeout" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的逾時小於零。</exception>
        <block subset="none" type="overrides">
          <para>作業會擲回<see cref="T:System.TimeoutException" />如果指定<paramref name="timeout" />超出之前完成。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginTryReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指定等候訊息變成可以使用的時間間隔。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</param>
        <param name="state">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</param>
        <summary>開始非同步的作業，接收具有已指定逾時以及與該作業關聯之狀態物件的訊息。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，參考非同步的接收作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您希望應用程式繼續執行而不要等候時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。 當目前的執行緒可接受進行封鎖並同時回覆要求訊息，或是直到已超過逾時間隔時，請使用同步的 <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> 方法。  
  
 在訊息可以於通道中使用或發生逾時之後，作業才會完成。  
  
 如果您要處理逾時，而不只是重新擲回或者包裝 <xref:System.TimeoutException>，則您應該呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>，而不是呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>。  
  
 如果您不要特別去處理逾時，則只需要呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>，否則您將遺失錯誤資訊。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">在完成作業之前超出了指定的 <paramref name="timeout" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的逾時小於零。</exception>
        <block subset="none" type="overrides">
          <para>此作業會傳回<see langword="false" />從<see cref="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />如果指定<paramref name="timeout" />超過。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForMessage">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForMessage (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForMessage(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForMessage (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForMessage(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForMessage : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginWaitForMessage (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指定等候訊息變成可以使用的時間間隔。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</param>
        <param name="state">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</param>
        <summary>開始非同步的「等候訊息到達」(wait-for-a-message-to-arrive) 作業，這個作業具有指定的逾時以及與該作業關聯之狀態物件。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，參考非同步作業以等候訊息到達。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要應用程式繼續執行而不要等候訊息到達，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用同步的 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> 方法。 執行緒會持續封鎖，直到指定的 `timeout` 為止。  
  
 這個方法會透過回呼 (Callback)，接收有關作業之事件處理常式身分識別的通知。 在訊息可以於通道中使用或發生逾時之後，作業才會完成。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">在完成作業之前超出了指定的 <paramref name="timeout" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的逾時小於零。</exception>
        <block subset="none" type="overrides">
          <para>此作業會傳回<see langword="false" />如果指定<paramref name="timeout" />超過時，不逾時例外狀況。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ EndReceive(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceive : IAsyncResult -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，呼叫其中一種 <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> 方法時傳回。</param>
        <summary>完成非同步作業，以便接收訊息。</summary>
        <returns>所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceive">
      <MemberSignature Language="C#" Value="public bool EndTryReceive (IAsyncResult result, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceive(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceive (result As IAsyncResult, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceive(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceive : IAsyncResult *  -&gt; bool" Usage="iInputChannel.EndTryReceive (result, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">由 <see cref="T:System.IAsyncResult" /> 方法的呼叫所傳回的 <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />。</param>
        <param name="message">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</param>
        <summary>完成指定的非同步作業，以便接收訊息。</summary>
        <returns>如果在超過指定時間間隔之前接收到訊息，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForMessage">
      <MemberSignature Language="C#" Value="public bool EndWaitForMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForMessage (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForMessage : IAsyncResult -&gt; bool" Usage="iInputChannel.EndWaitForMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，識別要完成並從其中擷取最終結果的 <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" /> 作業。</param>
        <summary>完成指定的非同步「等候訊息」(wait-for-a-message) 作業。</summary>
        <returns>如果訊息是在超過 <see langword="true" /> 之前到達，則為 <paramref name="timeout" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得輸入通道接收訊息的位址。</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" />，輸入通道在上面接收訊息的位址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個輸入通道沒有獨立位址 (例如，它是用戶端初始化之 TCP 通道的輸入端)，則這個屬性為 `null`。  
  
 這個屬性可以由較高層通道使用於關聯目的。 例如，當較高層級的通道在 <xref:System.ServiceModel.Channels.IDuplexChannel> 的上方實作要求-回覆，此通道便可以使用 WS-Addressing ReplyTo 標頭的 <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> 屬性。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個屬性：  
  
 [!code-csharp[S_UE_MessageInterceptor#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.ServiceProcess.TimeoutException">作業並未在逾時間隔期間完成。</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">輸入通道失敗。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectAbortedException">輸入通道已經中止。</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">輸入通道發生錯誤。</exception>
        <summary>如果輸入通道在明確或隱含定義的時間間隔內有收到訊息，則將此訊息傳回。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當目前的執行緒可接受進行封鎖直到其接收到要求訊息或者超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。 當您需要應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。  
  
 不管有沒有明確的逾時，都可以使用同步 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 作業。  
  
 如果沒有收到訊息，執行緒就會加以封鎖，直到有訊息可使用或超過逾時為止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="abstract member Receive : unit -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果有收到訊息，則將該訊息傳回。 如果沒有收到訊息，執行緒就會封鎖一段預設間隔時間。</summary>
        <returns>所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當目前的執行緒可接受進行封鎖直到其接收到要求訊息或者超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。 當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。  
  
 不管有沒有明確的逾時，都可以使用同步 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 作業。  
  
 如果沒有收到訊息，執行緒就會加以封鎖，直到有訊息可使用或超過逾時為止。  
  
 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 可以多次呼叫或同時呼叫。 每個已收到的訊息只能完成一次 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 呼叫。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Receive : TimeSpan -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指定必須在逾時和擲回 <see cref="T:System.TimeoutException" /> 多久之前完成接收作業。</param>
        <summary>如果有收到訊息，則將該訊息傳回。 如果沒有收到訊息，執行緒就會封鎖一段指定的間隔時間。</summary>
        <returns>所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當目前的執行緒可接受進行封鎖直到其接收到要求訊息或者超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。 當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。  
  
 不管有沒有明確的逾時，都可以使用同步 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 作業。  
  
 如果沒有收到訊息，執行緒就會加以封鎖，直到有訊息可使用或超過逾時為止。  
  
 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 可以多次呼叫或同時呼叫。 每個已收到的訊息只能完成一次 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 呼叫。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">在完成作業之前超出了指定的 <paramref name="timeout" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的逾時小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (TimeSpan timeout, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (timeout As TimeSpan, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceive(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : TimeSpan *  -&gt; bool" Usage="iInputChannel.TryReceive (timeout, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.IAsyncResult" />，呼叫其中一種 <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> 方法時傳回。</param>
        <param name="message">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</param>
        <summary>嘗試在指定的時間間隔內接收訊息。</summary>
        <returns>如果在超過 <paramref name="timeout" /> 之前接收到訊息，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您要處理逾時，而不只是重新擲回或者包裝 <xref:System.TimeoutException>，則您應該呼叫 <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29>，而不是呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>。  
  
 如果您不要特別去處理逾時，則只需要呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，否則您將遺失錯誤資訊。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">在完成作業之前超出了指定的 <paramref name="timeout" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的逾時小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForMessage">
      <MemberSignature Language="C#" Value="public bool WaitForMessage (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForMessage(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForMessage (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForMessage(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForMessage : TimeSpan -&gt; bool" Usage="iInputChannel.WaitForMessage timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指定在逾時之前等候訊息到達的最長時間間隔。</param>
        <summary>傳回值，這個值會表示訊息是否是在指定的時間間隔內到達。</summary>
        <returns>如果訊息是在超過 <see langword="true" /> 之前到達，則為 <paramref name="timeout" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29>，並不會導致訊息以任何其他方式進行接收或處理。  
  
 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> 方法的存在目的，主要是針對使用者希望接收到使用交易之訊息的交易狀況。 一般針對這種狀況會只有使用 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，此時使用者必須建立交易並接著呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，然後期待訊息會在交息逾時之前到達，但是訊息可能不會如預期般到達。  
  
 相反的，使用者可以配合任何需要的逾時 (甚至無限時) 來呼叫 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29>，接著在訊息到達時開啟交易並呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，然後深信自己可以在交易逾時之前取回訊息。  
  
 這是同步的方法，因此它會封鎖目前的執行緒，直到收到訊息或是發生逾時為止。 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29>。 執行緒會持續封鎖，直到指定的 `timeout` 為止。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。  
  
   
  
## Examples  
 下列程式碼說明如何實作這個方法：  
  
 [!code-csharp[S_UE_MessageInterceptor#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">在完成作業之前超出了指定的 <paramref name="timeout" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的逾時小於零。</exception>
        <block subset="none" type="overrides">
          <para>此作業會傳回<see langword="false" />如果指定<paramref name="timeout" />超過時，不逾時例外狀況。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>