<Type Name="IInputChannel" FullName="System.ServiceModel.Channels.IInputChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="73371f76db2d9423c8ff9eb31a980d7e95096d7b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37621694" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IInputChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IInputChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IInputChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IInputChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IInputChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IInputChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="96939-101">定義通道必須實作以接收訊息的介面。</span>
      <span class="sxs-lookup">
        <span data-stu-id="96939-101">Defines the interface that a channel must implement to receive a message.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-102"><xref:System.ServiceModel.Channels.IInputChannel> 合約包括接收、嘗試接收 (try-to-receive) 和等候訊息 (wait-for-a-message) 功能的同步和非同步等變體。</span><span class="sxs-lookup"><span data-stu-id="96939-102">The <xref:System.ServiceModel.Channels.IInputChannel> contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.</span></span>  
  
 <span data-ttu-id="96939-103">提取模型一般是配合 <xref:System.ServiceModel.Channels.IInputChannel> 使用來接收訊息：您要呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (從通道「提取」訊息) 然後等候訊息到達。</span><span class="sxs-lookup"><span data-stu-id="96939-103">The pull model is used typically with an <xref:System.ServiceModel.Channels.IInputChannel> to receive messages: you call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (to "pull" a message out of the channel) and then wait for a message to arrive.</span></span> <span data-ttu-id="96939-104">另一個替代的使用模式是呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 或者 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>，然後呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>。</span><span class="sxs-lookup"><span data-stu-id="96939-104">An alternative usage pattern is to call <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> or <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>.</span></span> <span data-ttu-id="96939-105">對於在 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> 和 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 呼叫之間開始交易的交易用法而言，這是很常見的方法。</span><span class="sxs-lookup"><span data-stu-id="96939-105">This approach is common for transactional usages where you start the transaction between the calls to <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> and <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.</span></span>  
  
 <span data-ttu-id="96939-106"><xref:System.ServiceModel.Channels.IInputChannel> 不一定要繫結到單一寄件人。</span><span class="sxs-lookup"><span data-stu-id="96939-106">An <xref:System.ServiceModel.Channels.IInputChannel> is not necessarily bound to a single sender.</span></span> <span data-ttu-id="96939-107">其他的通道和通道介面可以提供特定寄件人和 <xref:System.ServiceModel.Channels.IInputChannel>之間的相互關聯，但是基底合約並未提供這類限制。</span><span class="sxs-lookup"><span data-stu-id="96939-107">Other channels and channel interfaces can provide a correlation between particular senders and an <xref:System.ServiceModel.Channels.IInputChannel>, but the base contract makes no such restriction.</span></span> <span data-ttu-id="96939-108">實作 (Implementation) 可以為每個訊息建立新的 <xref:System.ServiceModel.Channels.IInputChannel>，或者為多個訊息和寄件人重複使用相同的 <xref:System.ServiceModel.Channels.IInputChannel>。</span><span class="sxs-lookup"><span data-stu-id="96939-108">An implementation can create a new <xref:System.ServiceModel.Channels.IInputChannel> for each message or reuse the same <xref:System.ServiceModel.Channels.IInputChannel> for multiple messages and senders.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="96939-109">開始非同步的接收作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-109">Begins an asynchronous receive operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-110">當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-110">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.</span></span> <span data-ttu-id="96939-111">當可接受目前的執行緒要進行封鎖直到接收到要求訊息或者已超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-111">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded.</span></span> <span data-ttu-id="96939-112">不管有沒有明確的逾時，都可以使用非同步的作業。</span><span class="sxs-lookup"><span data-stu-id="96939-112">The asynchronous operation is available with or without an explicit timeout.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="96939-113">
            <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-113">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous operation completion.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="96939-114">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-114">An object, specified by the application, that contains state information associated with the asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-115">開始非同步的作業，接收具有與該作業關聯之狀態物件的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-115">Begins an asynchronous operation to receive a message that has a state object associated with it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-116">
            <see cref="T:System.IAsyncResult" />，參考非同步訊息接收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-116">The <see cref="T:System.IAsyncResult" /> that references the asynchronous message reception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-117">當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-117">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.</span></span> <span data-ttu-id="96939-118">當可接受目前的執行緒要進行封鎖直到接收到要求訊息或者已超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-118">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded.</span></span> <span data-ttu-id="96939-119">不管有沒有明確的逾時，都可以使用非同步的作業。</span><span class="sxs-lookup"><span data-stu-id="96939-119">The asynchronous operation is available with or without an explicit timeout.</span></span>  
  
 <span data-ttu-id="96939-120">這個方法會透過回呼 (Callback)，接收有關作業之事件處理常式身分識別的通知。</span><span class="sxs-lookup"><span data-stu-id="96939-120">This method receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="96939-121">作業要等到訊息可以在通道中使用之後才算完成。</span><span class="sxs-lookup"><span data-stu-id="96939-121">The operation is not complete until a message becomes available in the channel.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-122">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-122">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="96939-123">
            <see cref="T:System.TimeSpan" />，指定等候訊息變成可以使用的時間間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-123">The <see cref="T:System.TimeSpan" /> that specifies the interval of time to wait for a message to become available.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="96939-124">
            <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-124">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous operation completion.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="96939-125">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-125">An object, specified by the application, that contains state information associated with the asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-126">開始非同步的作業，接收具有已指定逾時以及與該作業關聯之狀態物件的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-126">Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-127">
            <see cref="T:System.IAsyncResult" />，參考非同步的接收作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-127">The <see cref="T:System.IAsyncResult" /> that references the asynchronous receive operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-128">當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-128">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.</span></span> <span data-ttu-id="96939-129">當可接受目前的執行緒要進行封鎖直到接收到要求訊息或者已超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-129">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded.</span></span> <span data-ttu-id="96939-130">不管有沒有明確的逾時，都可以使用非同步的作業。</span><span class="sxs-lookup"><span data-stu-id="96939-130">The asynchronous operation is available with or without an explicit timeout.</span></span>  
  
 <span data-ttu-id="96939-131">在訊息可以於通道中使用或發生逾時之後，作業才會完成。</span><span class="sxs-lookup"><span data-stu-id="96939-131">The operation is not complete until either a message becomes available in the channel or the time out occurs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-132">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-132">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">
          <span data-ttu-id="96939-133">在完成作業之前超出了指定的 <paramref name="timeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-133">The specified <paramref name="timeout" /> is exceeded before the operation is completed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="96939-134">指定的逾時小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-134">The timeout specified is less than zero.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="96939-135">
            <para>作業會擲回<see cref="T:System.TimeoutException" />如果指定<paramref name="timeout" />超出之前完成。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-135">
              <para>The operation throws a <see cref="T:System.TimeoutException" /> if the specified <paramref name="timeout" /> is exceeded before it completes.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginTryReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="96939-136">
            <see cref="T:System.TimeSpan" />，指定等候訊息變成可以使用的時間間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-136">The <see cref="T:System.TimeSpan" /> that specifies the interval of time to wait for a message to become available.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="96939-137">
            <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-137">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous operation completion.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="96939-138">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-138">An object, specified by the application, that contains state information associated with the asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-139">開始非同步的作業，接收具有已指定逾時以及與該作業關聯之狀態物件的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-139">Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-140">
            <see cref="T:System.IAsyncResult" />，參考非同步的接收作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-140">The <see cref="T:System.IAsyncResult" /> that references the asynchronous receive operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-141">當您希望應用程式繼續執行而不要等候時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-141">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you want the application processing to continue without waiting.</span></span> <span data-ttu-id="96939-142">當目前的執行緒可接受進行封鎖並同時回覆要求訊息，或是直到已超過逾時間隔時，請使用同步的 <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-142">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.</span></span>  
  
 <span data-ttu-id="96939-143">在訊息可以於通道中使用或發生逾時之後，作業才會完成。</span><span class="sxs-lookup"><span data-stu-id="96939-143">The operation is not complete until either a message becomes available in the channel or the timeout occurs.</span></span>  
  
 <span data-ttu-id="96939-144">如果您要處理逾時，而不只是重新擲回或者包裝 <xref:System.TimeoutException>，則您應該呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>，而不是呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>。</span><span class="sxs-lookup"><span data-stu-id="96939-144">If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.</span></span>  
  
 <span data-ttu-id="96939-145">如果您不要特別去處理逾時，則只需要呼叫 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>，否則您將遺失錯誤資訊。</span><span class="sxs-lookup"><span data-stu-id="96939-145">If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, otherwise you lose error information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-146">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-146">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">
          <span data-ttu-id="96939-147">在完成作業之前超出了指定的 <paramref name="timeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-147">The specified <paramref name="timeout" /> is exceeded before the operation is completed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="96939-148">指定的逾時小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-148">The timeout specified is less than zero.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="96939-149">
            <para>此作業會傳回<see langword="false" />從<see cref="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />如果指定<paramref name="timeout" />超過。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-149">
              <para>The operation returns <see langword="false" /> from <see cref="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" /> if the specified <paramref name="timeout" /> is exceeded.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForMessage">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForMessage (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForMessage(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForMessage (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForMessage(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForMessage : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginWaitForMessage (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="96939-150">
            <see cref="T:System.TimeSpan" />，指定等候訊息變成可以使用的時間間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-150">The <see cref="T:System.TimeSpan" /> that specifies the interval of time to wait for a message to become available.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="96939-151">
            <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收非同步作業完成的通知。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-151">The <see cref="T:System.AsyncCallback" /> delegate that receives the notification of the asynchronous operation completion.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="96939-152">應用程式所指定的物件，其中包含與非同步作業相關聯的狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-152">An object, specified by the application, that contains state information associated with the asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-153">開始非同步的「等候訊息到達」(wait-for-a-message-to-arrive) 作業，這個作業具有指定的逾時以及與該作業關聯之狀態物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-153">Begins an asynchronous wait-for-a-message-to-arrive operation that has a specified time out and state object associated with it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-154">
            <see cref="T:System.IAsyncResult" />，參考非同步作業以等候訊息到達。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-154">The <see cref="T:System.IAsyncResult" /> that references the asynchronous operation to wait for a message to arrive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-155">如果需要應用程式繼續執行而不要等候訊息到達，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-155">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method if you need the application processing to continue without waiting for the message to arrive.</span></span> <span data-ttu-id="96939-156">當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用同步的 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-156">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="96939-157">執行緒會持續封鎖，直到指定的 `timeout` 為止。</span><span class="sxs-lookup"><span data-stu-id="96939-157">The thread is blocked up to the specified `timeout`.</span></span>  
  
 <span data-ttu-id="96939-158">這個方法會透過回呼 (Callback)，接收有關作業之事件處理常式身分識別的通知。</span><span class="sxs-lookup"><span data-stu-id="96939-158">This method receives notification, through a callback, of the identity of the event handler for the operation.</span></span> <span data-ttu-id="96939-159">在訊息可以於通道中使用或發生逾時之後，作業才會完成。</span><span class="sxs-lookup"><span data-stu-id="96939-159">The operation is not complete until either a message becomes available in the channel or the time out occurs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-160">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-160">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">
          <span data-ttu-id="96939-161">在完成作業之前超出了指定的 <paramref name="timeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-161">The specified <paramref name="timeout" /> is exceeded before the operation is completed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="96939-162">指定的逾時小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-162">The timeout specified is less than zero.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="96939-163">
            <para>此作業會傳回<see langword="false" />如果指定<paramref name="timeout" />超過時，不逾時例外狀況。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-163">
              <para>The operation returns <see langword="false" /> if the specified <paramref name="timeout" /> is exceeded, not a timeout exception.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ EndReceive(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceive : IAsyncResult -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="96939-164">
            <see cref="T:System.IAsyncResult" />，呼叫其中一種 <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> 方法時傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-164">The <see cref="T:System.IAsyncResult" /> returned by a call to one of the <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-165">完成非同步作業，以便接收訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-165">Completes an asynchronous operation to receive a message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-166">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-166">The <see cref="T:System.ServiceModel.Channels.Message" /> received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="96939-167">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-167">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceive">
      <MemberSignature Language="C#" Value="public bool EndTryReceive (IAsyncResult result, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceive(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceive (result As IAsyncResult, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceive(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceive : IAsyncResult *  -&gt; bool" Usage="iInputChannel.EndTryReceive (result, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="96939-168">由 <see cref="T:System.IAsyncResult" /> 方法的呼叫所傳回的 <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-168">The <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </param>
        <param name="message">
          <span data-ttu-id="96939-169">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-169">The <see cref="T:System.ServiceModel.Channels.Message" /> received.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-170">完成指定的非同步作業，以便接收訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-170">Completes the specified asynchronous operation to receive a message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-171">如果在超過指定時間間隔之前接收到訊息，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-171">
              <see langword="true" /> if a message is received before the specified interval of time elapses; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="96939-172">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-172">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForMessage">
      <MemberSignature Language="C#" Value="public bool EndWaitForMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForMessage (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForMessage : IAsyncResult -&gt; bool" Usage="iInputChannel.EndWaitForMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="96939-173">
            <see cref="T:System.IAsyncResult" />，識別要完成並從其中擷取最終結果的 <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" /> 作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-173">The <see cref="T:System.IAsyncResult" /> that identifies the <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" /> operation to finish, and from which to retrieve an end result.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-174">完成指定的非同步「等候訊息」(wait-for-a-message) 作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-174">Completes the specified asynchronous wait-for-a-message operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-175">如果訊息是在超過 <see langword="true" /> 之前到達，則為 <paramref name="timeout" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-175">
              <see langword="true" /> if a message has arrived before the <paramref name="timeout" /> has been exceeded; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="96939-176">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-176">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="96939-177">取得輸入通道接收訊息的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-177">Gets the address on which the input channel receives messages.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="96939-178">
            <see cref="T:System.ServiceModel.EndpointAddress" />，輸入通道在上面接收訊息的位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-178">The <see cref="T:System.ServiceModel.EndpointAddress" /> on which the input channel receives messages.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-179">如果這個輸入通道沒有獨立位址 (例如，它是用戶端初始化之 TCP 通道的輸入端)，則這個屬性為 `null`。</span><span class="sxs-lookup"><span data-stu-id="96939-179">If this input channel does not have a standalone address (for example, it is the input-side of a client-initiated TCP channel), then this property is `null`.</span></span>  
  
 <span data-ttu-id="96939-180">這個屬性可以由較高層通道使用於關聯目的。</span><span class="sxs-lookup"><span data-stu-id="96939-180">This property can be used by higher-level channels for correlation purposes.</span></span> <span data-ttu-id="96939-181">例如，當較高層級的通道在 <xref:System.ServiceModel.Channels.IDuplexChannel> 的上方實作要求-回覆，此通道便可以使用 WS-Addressing ReplyTo 標頭的 <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="96939-181">For example, if a higher-level channel implements request-reply on top of a <xref:System.ServiceModel.Channels.IDuplexChannel>, it can use the <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> property in the WS-Addressing ReplyTo header.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-182">下列程式碼說明如何實作這個屬性：</span><span class="sxs-lookup"><span data-stu-id="96939-182">The following code illustrates how to implement this property:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.ServiceProcess.TimeoutException">
          <span data-ttu-id="96939-183">作業並未在逾時間隔期間完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-183">The operation did not complete with the timeout interval.</span>
          </span>
        </exception>
        <exception cref="T:System.ServiceModel.CommunicationException">
          <span data-ttu-id="96939-184">輸入通道失敗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-184">The input channel failed.</span>
          </span>
        </exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectAbortedException">
          <span data-ttu-id="96939-185">輸入通道已經中止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-185">The input channel has been aborted.</span>
          </span>
        </exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">
          <span data-ttu-id="96939-186">輸入通道發生錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-186">The input channel faulted.</span>
          </span>
        </exception>
        <summary>
          <span data-ttu-id="96939-187">如果輸入通道在明確或隱含定義的時間間隔內有收到訊息，則將此訊息傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-187">Returns a message received by the input channel, if one is available with an interval of time that is explicitly or implicitly defined.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-188">當目前的執行緒可接受進行封鎖直到其接收到要求訊息或者超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-188">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`.</span></span> <span data-ttu-id="96939-189">當您需要應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-189">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you need the application processing to continue without waiting for the request to be received.</span></span>  
  
 <span data-ttu-id="96939-190">不管有沒有明確的逾時，都可以使用同步 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 作業。</span><span class="sxs-lookup"><span data-stu-id="96939-190">The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.</span></span>  
  
 <span data-ttu-id="96939-191">如果沒有收到訊息，執行緒就會加以封鎖，直到有訊息可使用或超過逾時為止。</span><span class="sxs-lookup"><span data-stu-id="96939-191">If a message is not available, it blocks until one is available or until the timeout is exceeded.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="abstract member Receive : unit -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="96939-192">如果有收到訊息，則將該訊息傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-192">Returns the message received, if one is available.</span>
          </span>
          <span data-ttu-id="96939-193">如果沒有收到訊息，執行緒就會封鎖一段預設間隔時間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-193">If a message is not available, blocks for a default interval of time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-194">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-194">The <see cref="T:System.ServiceModel.Channels.Message" /> received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-195">當目前的執行緒可接受進行封鎖直到其接收到要求訊息或者超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-195">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`.</span></span> <span data-ttu-id="96939-196">當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-196">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.</span></span>  
  
 <span data-ttu-id="96939-197">不管有沒有明確的逾時，都可以使用同步 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 作業。</span><span class="sxs-lookup"><span data-stu-id="96939-197">The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.</span></span>  
  
 <span data-ttu-id="96939-198">如果沒有收到訊息，執行緒就會加以封鎖，直到有訊息可使用或超過逾時為止。</span><span class="sxs-lookup"><span data-stu-id="96939-198">If a message is not available, it blocks until one is available or until the timeout is exceeded.</span></span>  
  
 <span data-ttu-id="96939-199"><xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 可以多次呼叫或同時呼叫。</span><span class="sxs-lookup"><span data-stu-id="96939-199"><xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently.</span></span> <span data-ttu-id="96939-200">每個已收到的訊息只能完成一次 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 呼叫。</span><span class="sxs-lookup"><span data-stu-id="96939-200">Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-201">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-201">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Receive : TimeSpan -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="96939-202">
            <see cref="T:System.TimeSpan" />，指定必須在逾時和擲回 <see cref="T:System.TimeoutException" /> 多久之前完成接收作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-202">The <see cref="T:System.TimeSpan" /> that specifies how long the receive operation has to complete before timing out and throwing a <see cref="T:System.TimeoutException" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-203">如果有收到訊息，則將該訊息傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-203">Returns the message received, if one is available.</span>
          </span>
          <span data-ttu-id="96939-204">如果沒有收到訊息，執行緒就會封鎖一段指定的間隔時間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-204">If a message is not available, blocks for a specified interval of time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-205">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-205">The <see cref="T:System.ServiceModel.Channels.Message" /> received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-206">當目前的執行緒可接受進行封鎖直到其接收到要求訊息或者超過由 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 指定的時間間隔，請使用同步的 `timeout` 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-206">Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`.</span></span> <span data-ttu-id="96939-207">當您希望應用程式繼續執行，而不要等候接收到要求時，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-207">Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.</span></span>  
  
 <span data-ttu-id="96939-208">不管有沒有明確的逾時，都可以使用同步 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 作業。</span><span class="sxs-lookup"><span data-stu-id="96939-208">The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.</span></span>  
  
 <span data-ttu-id="96939-209">如果沒有收到訊息，執行緒就會加以封鎖，直到有訊息可使用或超過逾時為止。</span><span class="sxs-lookup"><span data-stu-id="96939-209">If a message is not available, it blocks until one is available or until the timeout is exceeded.</span></span>  
  
 <span data-ttu-id="96939-210"><xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 可以多次呼叫或同時呼叫。</span><span class="sxs-lookup"><span data-stu-id="96939-210"><xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently.</span></span> <span data-ttu-id="96939-211">每個已收到的訊息只能完成一次 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> 呼叫。</span><span class="sxs-lookup"><span data-stu-id="96939-211">Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-212">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-212">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">
          <span data-ttu-id="96939-213">在完成作業之前超出了指定的 <paramref name="timeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-213">The specified <paramref name="timeout" /> is exceeded before the operation is completed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="96939-214">指定的逾時小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-214">The timeout specified is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (TimeSpan timeout, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (timeout As TimeSpan, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceive(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : TimeSpan *  -&gt; bool" Usage="iInputChannel.TryReceive (timeout, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="96939-215">
            <see cref="T:System.IAsyncResult" />，呼叫其中一種 <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> 方法時傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-215">The <see cref="T:System.IAsyncResult" /> returned by a call to one of the <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" /> methods.</span>
          </span>
        </param>
        <param name="message">
          <span data-ttu-id="96939-216">所接收的 <see cref="T:System.ServiceModel.Channels.Message" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-216">The <see cref="T:System.ServiceModel.Channels.Message" /> received.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-217">嘗試在指定的時間間隔內接收訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-217">Tries to receive a message within a specified interval of time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-218">如果在超過 <paramref name="timeout" /> 之前接收到訊息，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-218">
              <see langword="true" /> if a message is received before the <paramref name="timeout" /> has been exceeded; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-219">如果您要處理逾時，而不只是重新擲回或者包裝 <xref:System.TimeoutException>，則您應該呼叫 <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29>，而不是呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="96939-219">If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.</span></span>  
  
 <span data-ttu-id="96939-220">如果您不要特別去處理逾時，則只需要呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，否則您將遺失錯誤資訊。</span><span class="sxs-lookup"><span data-stu-id="96939-220">If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, otherwise you will lose error information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-221">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-221">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">
          <span data-ttu-id="96939-222">在完成作業之前超出了指定的 <paramref name="timeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-222">The specified <paramref name="timeout" /> is exceeded before the operation is completed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="96939-223">指定的逾時小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-223">The timeout specified is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForMessage">
      <MemberSignature Language="C#" Value="public bool WaitForMessage (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForMessage(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForMessage (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForMessage(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForMessage : TimeSpan -&gt; bool" Usage="iInputChannel.WaitForMessage timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="96939-224">
            <see cref="T:System.TimeSpan" />，指定在逾時之前等候訊息到達的最長時間間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-224">The <see cref="T:System.TimeSpan" /> specifies the maximum interval of time to wait for a message to arrive before timing out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="96939-225">傳回值，這個值會表示訊息是否是在指定的時間間隔內到達。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-225">Returns a value that indicates whether a message has arrived within a specified interval of time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="96939-226">如果訊息是在超過 <see langword="true" /> 之前到達，則為 <paramref name="timeout" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-226">
              <see langword="true" /> if a message has arrived before the <paramref name="timeout" /> has been exceeded; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="96939-227">呼叫 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29>，並不會導致訊息以任何其他方式進行接收或處理。</span><span class="sxs-lookup"><span data-stu-id="96939-227">Calling <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> does not result in a message being received or processed in any other way.</span></span>  
  
 <span data-ttu-id="96939-228"><xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> 方法的存在目的，主要是針對使用者希望接收到使用交易之訊息的交易狀況。</span><span class="sxs-lookup"><span data-stu-id="96939-228">The <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction.</span></span> <span data-ttu-id="96939-229">一般針對這種狀況會只有使用 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，此時使用者必須建立交易並接著呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，然後期待訊息會在交息逾時之前到達，但是訊息可能不會如預期般到達。</span><span class="sxs-lookup"><span data-stu-id="96939-229">When using just <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normally for this, the user must create the transaction and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and hope the message arrives before the transaction times out, which may not be possible.</span></span>  
  
 <span data-ttu-id="96939-230">相反的，使用者可以配合任何需要的逾時 (甚至無限時) 來呼叫 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29>，接著在訊息到達時開啟交易並呼叫 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>，然後深信自己可以在交易逾時之前取回訊息。</span><span class="sxs-lookup"><span data-stu-id="96939-230">Instead, the user can call <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> with whatever time out they want (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and be confident that they can get the message back before the transaction expires.</span></span>  
  
 <span data-ttu-id="96939-231">這是同步的方法，因此它會封鎖目前的執行緒，直到收到訊息或是發生逾時為止。</span><span class="sxs-lookup"><span data-stu-id="96939-231">This method is synchronous, so it blocks the current thread until a message is available or the time out occurs.</span></span> <span data-ttu-id="96939-232">當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29>。</span><span class="sxs-lookup"><span data-stu-id="96939-232">Use <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</span></span> <span data-ttu-id="96939-233">執行緒會持續封鎖，直到指定的 `timeout` 為止。</span><span class="sxs-lookup"><span data-stu-id="96939-233">The thread is blocked up to the specified `timeout`.</span></span> <span data-ttu-id="96939-234">當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="96939-234">If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="96939-235">下列程式碼說明如何實作這個方法：</span><span class="sxs-lookup"><span data-stu-id="96939-235">The following code illustrates how to implement this method:</span></span>  
  
 [!code-csharp[S_UE_MessageInterceptor#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">
          <span data-ttu-id="96939-236">在完成作業之前超出了指定的 <paramref name="timeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-236">The specified <paramref name="timeout" /> is exceeded before the operation is completed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="96939-237">指定的逾時小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-237">The timeout specified is less than zero.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="96939-238">
            <para>此作業會傳回<see langword="false" />如果指定<paramref name="timeout" />超過時，不逾時例外狀況。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="96939-238">
              <para>The operation returns <see langword="false" /> if the specified <paramref name="timeout" /> is exceeded, not a timeout exception.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>