<Type Name="MsmqBindingElementBase" FullName="System.ServiceModel.Channels.MsmqBindingElementBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1b610f2bca30cb09c03c5512b442e872ec2ac896" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694141" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MsmqBindingElementBase : System.ServiceModel.Channels.TransportBindingElement, System.ServiceModel.Channels.ITransactedBindingElement, System.ServiceModel.Description.IPolicyExportExtension, System.ServiceModel.Description.IWsdlExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MsmqBindingElementBase extends System.ServiceModel.Channels.TransportBindingElement implements class System.ServiceModel.Channels.ITransactedBindingElement, class System.ServiceModel.Description.IPolicyExportExtension, class System.ServiceModel.Description.IWsdlExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.MsmqBindingElementBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MsmqBindingElementBase&#xA;Inherits TransportBindingElement&#xA;Implements IPolicyExportExtension, ITransactedBindingElement, IWsdlExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqBindingElementBase abstract : System::ServiceModel::Channels::TransportBindingElement, System::ServiceModel::Channels::ITransactedBindingElement, System::ServiceModel::Description::IPolicyExportExtension, System::ServiceModel::Description::IWsdlExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.TransportBindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.ITransactedBindingElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IWsdlExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <see cref="T:System.ServiceModel.MsmqIntegration.MsmqIntegrationBindingElement" /> 與 <see cref="T:System.ServiceModel.Channels.MsmqTransportBindingElement" /> 的基底類別。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CustomDeadLetterQueue">
      <MemberSignature Language="C#" Value="public Uri CustomDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CustomDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomDeadLetterQueue As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CustomDeadLetterQueue { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Uri" />，這個項目會識別自訂的寄不出信件佇列，其中將會傳送無法傳遞的逾期訊息。</summary>
        <value>自訂寄不出的信件佇列的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 寄不出的信件佇列是由傳送應用程式的佇列管理員來管理的佇列，這個佇列會儲存無法傳遞或逾期的訊息。 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 屬性可讓您指定自訂的寄不出信件佇列，而非使用整個系統的預設寄不出信件佇列。  
  
 由 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 指定的 URI 必須使用 `net.msmq scheme`。  
  
 如果 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.DeadLetterQueue%2A> 設定為 <xref:System.ServiceModel.DeadLetterQueue.None> 或 <xref:System.ServiceModel.DeadLetterQueue.System>，則 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 必須設定為 `null`。 如果 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 不是 `null`，則 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.DeadLetterQueue%2A> 必須設定為 <xref:System.ServiceModel.DeadLetterQueue.Custom>。  
  
 從 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.CustomDeadLetterQueue%2A> 之後的作業系統上才能設定 [!INCLUDE[wv](~/includes/wv-md.md)] 屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeadLetterQueue">
      <MemberSignature Language="C#" Value="public System.ServiceModel.DeadLetterQueue DeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.DeadLetterQueue DeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property DeadLetterQueue As DeadLetterQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::DeadLetterQueue DeadLetterQueue { System::ServiceModel::DeadLetterQueue get(); void set(System::ServiceModel::DeadLetterQueue value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.DeadLetterQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個繫結的 <see cref="T:System.ServiceModel.DeadLetterQueue" /> 設定。</summary>
        <value>要使用的寄不出的信件佇列型別 (如果有的話)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 寄不出的信件佇列是由傳送應用程式的佇列管理員來管理的佇列，這個佇列會儲存無法傳遞或逾期的訊息。 訊息可能會因為下列任何一個原因而無法到達接收應用程式：  
  
-   異動式訊息已傳送至非異動式佇列。  
  
-   非交易式訊息已傳送至交易式佇列。  
  
-   未經驗證的訊息已傳送至僅接受經過驗證之訊息的佇列。  
  
-   未經加密的訊息已傳送至僅接受經過加密之訊息的佇列。  
  
-   訊息在傳送給接收者之前就已逾期。  
  
-   已超出目標電腦的訊息儲存配額或是目的佇列的儲存配額，或者是當訊息送達時，目標電腦上沒有可用的儲存空間。  
  
-   寄件者沒有[存取權限](http://go.microsoft.com/fwlink/?LinkId=96167)才能將訊息放在目的端佇列。  
  
-   附加到訊息的數位簽章無效。  
  
-   加密的訊息無法由目的佇列管理員進行解密。  
  
-   擷取訊息前，會清除或刪除目的佇列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個值不在 <see cref="T:System.ServiceModel.DeadLetterQueue" /> 定義的值範圍內。</exception>
      </Docs>
    </Member>
    <Member MemberName="Durable">
      <MemberSignature Language="C#" Value="public bool Durable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Durable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.Durable" />
      <MemberSignature Language="VB.NET" Value="Public Property Durable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Durable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定使用這個繫結傳送的訊息是否具有永久性或變動性。</summary>
        <value>
          如果這個繫結處理的訊息是永久性的，則為 <see langword="true" />，如果為變動性的則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為 `true`，訊息會是永久性的，否則會是變動性的。 如果佇列管理員毀損，永久性訊息不會遺失。 這個屬性的預設值為 `true`。 如果需要正好一次的保證 (<xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 設定為 `true`)，這個屬性必須設定為 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOnce">
      <MemberSignature Language="C#" Value="public bool ExactlyOnce { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExactlyOnce" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce" />
      <MemberSignature Language="VB.NET" Value="Public Property ExactlyOnce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExactlyOnce { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定使用這個繫結傳送的訊息是否將具有正好一次的保證。</summary>
        <value>
          如果與此繫結一起傳送的訊息有「正好一次」的保證，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 設定為 `true` 時，表示訊息佇列 (MSMQ) 將確保傳送的訊息只會傳遞到接收訊息佇列一次，如果傳遞失敗，訊息會根據 `DeadLetterQueue` 屬性設定傳送到寄不出的信件佇列。 將 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> 設定為 `true` 需要交易式的佇列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">屬性的型別。</typeparam>
        <param name="context">繫結項目的 <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>在衍生類別中覆寫時，為提供的繫結內容擷取指定型別的物件。</summary>
        <returns>
          <paramref name="T" /> 型別的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供從項目擷取能力和保護需求的功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">內容為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCycles">
      <MemberSignature Language="C#" Value="public int MaxRetryCycles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCycles" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCycles As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCycles { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定嘗試傳遞訊息至接收應用程式的重試循環次數上限。</summary>
        <value>指定在傳送訊息至有害訊息佇列之前要嘗試之重試循環次數的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 「重試循環」(Retry Cycle) 是指訊息從重試佇列傳送至應用程式佇列以嘗試傳遞至應用程式的時間。 在立即重試達到 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount%2A> 的指定次數後，就會將訊息置於重試佇列。 `MaxRetryCycles` 會指定重試循環次數，且不會包含最初的傳送訊息嘗試。 嘗試傳遞訊息的次數上限為 (1 + MaxRetryCycles) * (ReceiveRetryCount + 1) 次。 例如，如果 ReceiveRetryCount = 0 且 MaxRetryCycles 為 1，則嘗試傳遞訊息的次數上限為 2。 從 [!INCLUDE[wv](~/includes/wv-md.md)] 之後的作業系統上才能使用這個屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="MsmqTransportSecurity">
      <MemberSignature Language="C#" Value="public System.ServiceModel.MsmqTransportSecurity MsmqTransportSecurity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.MsmqTransportSecurity MsmqTransportSecurity" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.MsmqTransportSecurity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MsmqTransportSecurity As MsmqTransportSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::MsmqTransportSecurity ^ MsmqTransportSecurity { System::ServiceModel::MsmqTransportSecurity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.MsmqTransportSecurity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與此繫結項目相關聯的 <see cref="T:System.ServiceModel.MsmqTransportSecurity" />。</summary>
        <value>與這個繫結項目關聯的 <see cref="T:System.ServiceModel.MsmqTransportSecurity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.MsmqTransportSecurity> 會封裝 MSMQ 整合傳輸的安全性設定。 這些設定對 MSMQ 整合和已佇列傳輸都是相同的。 <xref:System.ServiceModel.MsmqTransportSecurity> 可讓您設定驗證模式、加密演算法、安全的雜湊演算法和保護層級。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否已要求接收內容行為。</summary>
        <value>
          如果繫結支援接收內容行為，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveErrorHandling">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveErrorHandling As ReceiveErrorHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReceiveErrorHandling ReceiveErrorHandling { System::ServiceModel::ReceiveErrorHandling get(); void set(System::ServiceModel::ReceiveErrorHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReceiveErrorHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定列舉值，這個值會指定如何處理有害和其他不可分派的訊息。</summary>
        <value>
          <see cref="T:System.ServiceModel.ReceiveErrorHandling" /> 值，指定如何處理有害和其他不可分派的訊息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 時，通道接聽程式會發生錯誤，並且會追蹤和擲回 <xref:System.ServiceModel.ProtocolException> (內含一個 <xref:System.ServiceModel.MsmqPoisonMessageException>)。 訊息會留在佇列中，並且必須由某種手動方法來移除。 <xref:System.ServiceModel.MsmqPoisonMessageException> 包含 <xref:System.ServiceModel.MsmqPoisonMessageException.MessageLookupId%2A>，後者可用於從有害訊息佇列中識別並手動移除有問題的訊息。  
  
 當這個屬性設定為 <xref:System.ServiceModel.ReceiveErrorHandling.Drop> 時，即會捨棄訊息。  
  
 當這個屬性設定為 <xref:System.ServiceModel.ReceiveErrorHandling.Reject> 時，負認可會傳送至用戶端，並從有害訊息佇列中移除訊息。 只有在 Message Queuing 4.0 上才能使用這個選項。  
  
 當設定為 <xref:System.ServiceModel.ReceiveErrorHandling.Move> 時，訊息會移到最後一個有害子佇列。 只有在 Message Queuing 4.0 上才能使用這個選項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個值不在 <see cref="T:System.ServiceModel.ReceiveErrorHandling" /> 定義的值範圍內。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRetryCount">
      <MemberSignature Language="C#" Value="public int ReceiveRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveRetryCount { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列管理員在傳送訊息至重試佇列之前，應嘗試傳送的次數上限。</summary>
        <value>指定佇列管理員在傳送訊息至重試佇列之前，應嘗試傳送之次數上限的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果達到傳遞嘗試的次數上限，且應用程式未存取訊息，訊息便會傳送到重試佇列，以便日後再次傳遞。 在訊息傳回傳送佇列之前的時間長度是由 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A> 控制。 如果重試循環達到 MaxRetryCycles 值，便會根據 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ReceiveErrorHandling%2A> 屬性值而分派訊息。  
  
 如需詳細資訊，請參閱<xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A>和<xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryCycleDelay">
      <MemberSignature Language="C#" Value="public TimeSpan RetryCycleDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan RetryCycleDelay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryCycleDelay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan RetryCycleDelay { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定當嘗試傳遞無法傳遞的訊息時，在嘗試另一次重試循環之前要等待的時間長度。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，指定開始下一輪嘗試傳遞至接收應用程式的循環前，要等候的時間間隔。 預設值為 30 (分鐘)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 單一重試循環會重複嘗試將訊息傳遞至接收應用程式 (由 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A> 屬性指定)。 如果所有嘗試都失敗，便會將訊息放回重試佇列中。 這個屬性會指定訊息在傳輸至應用程式佇列以進行另一次重試循環之前，要保留在重試佇列中的時間長度。 從 [!INCLUDE[wv](~/includes/wv-md.md)] 之後的作業系統上才能使用這個屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個值不是無限的，而且會大於 Int32.MaxValue 毫秒。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">您可以用來修改匯出程序的 <see cref="T:System.ServiceModel.Description.MetadataExporter" />。</param>
        <param name="context">您可以用來插入自訂原則判斷提示的 <see cref="T:System.ServiceModel.Description.PolicyConversionContext" />。</param>
        <summary>匯出關於繫結的自訂原則判斷提示。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱<xref:System.ServiceModel.Description.IPolicyExportExtension>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IWsdlExportExtension.ExportContract">
      <MemberSignature Language="C#" Value="void IWsdlExportExtension.ExportContract (System.ServiceModel.Description.WsdlExporter exporter, System.ServiceModel.Description.WsdlContractConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(class System.ServiceModel.Description.WsdlExporter exporter, class System.ServiceModel.Description.WsdlContractConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.System#ServiceModel#Description#IWsdlExportExtension#ExportContract(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlContractConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportContract (exporter As WsdlExporter, context As WsdlContractConversionContext) Implements IWsdlExportExtension.ExportContract" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IWsdlExportExtension.ExportContract(System::ServiceModel::Description::WsdlExporter ^ exporter, System::ServiceModel::Description::WsdlContractConversionContext ^ context) = System::ServiceModel::Description::IWsdlExportExtension::ExportContract;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IWsdlExportExtension.ExportContract(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlContractConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.WsdlExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.WsdlContractConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.WsdlExporter" />，可匯出合約資訊。</param>
        <param name="context">提供從匯出的 WSDL 項目到合約描述之間的對應。</param>
        <summary>將自訂的 Web 服務描述語言 (WSDL) 項目寫入為合約產生的 WSDL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱<xref:System.ServiceModel.Description.IWsdlExportExtension>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint">
      <MemberSignature Language="C#" Value="void IWsdlExportExtension.ExportEndpoint (System.ServiceModel.Description.WsdlExporter exporter, System.ServiceModel.Description.WsdlEndpointConversionContext endpointContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(class System.ServiceModel.Description.WsdlExporter exporter, class System.ServiceModel.Description.WsdlEndpointConversionContext endpointContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqBindingElementBase.System#ServiceModel#Description#IWsdlExportExtension#ExportEndpoint(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlEndpointConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportEndpoint (exporter As WsdlExporter, endpointContext As WsdlEndpointConversionContext) Implements IWsdlExportExtension.ExportEndpoint" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(System::ServiceModel::Description::WsdlExporter ^ exporter, System::ServiceModel::Description::WsdlEndpointConversionContext ^ endpointContext) = System::ServiceModel::Description::IWsdlExportExtension::ExportEndpoint;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IWsdlExportExtension.ExportEndpoint(System.ServiceModel.Description.WsdlExporter,System.ServiceModel.Description.WsdlEndpointConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.WsdlExporter" />
        <Parameter Name="endpointContext" Type="System.ServiceModel.Description.WsdlEndpointConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.WsdlExporter" />，可匯出端點資訊。</param>
        <param name="endpointContext">提供從匯出的 WSDL 項目到端點描述之間的對應。</param>
        <summary>將自訂的 Web 服務描述語言 (WSDL) 項目寫入為端點產生的 WSDL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱<xref:System.ServiceModel.Description.IWsdlExportExtension>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeToLive">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToLive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToLive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.TimeToLive" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToLive As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToLive { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定指定訊息有效時間長度的值。 經過這個時間之後，訊息就會根據 <see langword="DeadLetterQueue" /> 設定放在寄不出的信件佇列中。</summary>
        <value>指定訊息有效時間長度的 <see cref="T:System.TimeSpan" /> 值。 預設值為 24 小時。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 佇列應用程式是以中斷連線的方式運作， 這表示傳送和接收應用程式可能不會同時執行；因此，由傳送應用程式傳送的訊息可能不會由接收應用程式立即處理。 有些訊息包含的資訊只在特定期間內有效。 如果這類訊息沒有在該期間內傳遞，就不再包含有用的資訊且會被捨棄。 這個屬性可讓您指定訊息在傳遞至應用程式佇列之前要保留的時限。 如果在將訊息傳遞至應用程式佇列之前就超過這個時間限制，而且有寄不出的信件佇列可用，則會將訊息放在其中 (由 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> 屬性判斷)；否則，就會捨棄訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個值不是無限的，而且會大於 Int32.MaxValue 毫秒。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactedReceiveEnabled">
      <MemberSignature Language="C#" Value="public bool TransactedReceiveEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactedReceiveEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.TransactedReceiveEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactedReceiveEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactedReceiveEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.ITransactedBindingElement.TransactedReceiveEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值指定這個繫結是否需要交易來接收訊息。</summary>
        <value>
          如果繫結需要接收作業的交易則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 發送器會存取這個屬性，以判斷接收作業是否需要異動。  
  
 在 WCF 中的佇列的傳輸會傳回`true`這個屬性，如果且只有<xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A>設`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseMsmqTracing">
      <MemberSignature Language="C#" Value="public bool UseMsmqTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseMsmqTracing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseMsmqTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseMsmqTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會啟用或停用訊息佇列 (MSMQ) 內建訊息追蹤工具。</summary>
        <value>
          如果應啟用訊息佇列 (MSMQ) 內建訊息追蹤則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing%2A> 設定為 `true` 時，佇列通道會使用訊息佇列內建訊息追蹤工具。 透過這項工具，每次訊息進入及離開佇列管理員時，都會傳送報告訊息至指定的報告佇列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSourceJournal">
      <MemberSignature Language="C#" Value="public bool UseSourceJournal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSourceJournal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.UseSourceJournal" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSourceJournal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSourceJournal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要將此繫結處理之訊息的複本儲存在來源日誌佇列。</summary>
        <value>
          如果要將此繫結處理的訊息複製到來源日誌佇列，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要記錄已離開來源電腦輸出佇列之訊息的佇列應用程式可以將訊息複製到日誌佇列。 訊息一離開輸出佇列之後，而且收到目的端電腦已收到訊息的認可，訊息的複本就會保留在傳送端電腦的系統日誌佇列中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidityDuration">
      <MemberSignature Language="C#" Value="public TimeSpan ValidityDuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ValidityDuration" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqBindingElementBase.ValidityDuration" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidityDuration As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ValidityDuration { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定接收內容功能鎖定訊息的持續期間。</summary>
        <value>接收內容功能鎖定訊息的持續期間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設值是 5 分鐘。 接收內容會鎖定訊息以進行檢查，直到此訊息已使用或釋回佇列為止。 有效持續期間屬性會指定訊息在自動釋回佇列之前，要由接收內容保持鎖定的時間長度。  
  
> [!IMPORTANT]
>  如果訊息的 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ValidityDuration%2A> 過期，任何可用於處理訊息的交易都將中止，而且如果過期是在交易期間發生，工作流程執行個體也會一併中止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於零或大於 Int32.MaxValue。</exception>
      </Docs>
    </Member>
  </Members>
</Type>