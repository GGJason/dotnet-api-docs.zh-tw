<Type Name="ExportAttribute" FullName="System.Composition.ExportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a91004943ffb63ad3d55c06e870517fe965ae22d" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52906120" /></Metadata><TypeSignature Language="C#" Value="public class ExportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ExportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Composition.ExportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class ExportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class ExportAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type ExportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Composition.AttributedModel</AssemblyName>
    <AssemblyVersion>1.0.31.0</AssemblyVersion>
    <AssemblyVersion>1.0.32.0</AssemblyVersion>
    <AssemblyVersion>1.0.33.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.1;netcore-2.0;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Property, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>指定型別、屬性、欄位或方法可提供特定匯出。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
在屬性化程式設計模型中，exportattribute 標記屬性宣告，就會匯出組件，或提供組合容器，可滿足特定合約的物件。 在組合期間使用匯入具有相符合約的組件會有填入的匯出物件的這些相依性。

Exportattribute 標記屬性可以套用至整個類別或屬性，欄位或類別的方法。 如果它套用至整個類別，類別的執行個體是所匯出的物件。 如果它套用至類別的成員，匯出的物件將會是該成員的值。

主要是由合約名稱和合約型別，決定使用的合約符合。 如需詳細資訊，請參閱<xref:System.Composition.ImportAttribute>參考。 



## Examples  
 下列範例示範套用至三個類別，並進行比對的三個匯入的 exportattribute 標記。  

```csharp
//Default export infers type and contract name from the
//exported type.  This is the preferred method.
[Export]
public class MyExport1
{
    public String data = "Test Data 1.";
}

public class MyImporter1
{
    [Import]
    public MyExport1 importedMember { get; set; }
}

public interface MyInterface
{

}

//Specifying the contract type may be important if
//you want to export a type other then the base type,
//such as an interface.
[Export(typeof(MyInterface))]
public class MyExport2 : MyInterface
{
    public String data = "Test Data 2.";
}

public class MyImporter2
{
    //The import must match the contract type!
    [Import(typeof(MyInterface))]
    public MyExport2 importedMember { get; set; }
}

//Specifying a contract name should only be 
//needed in rare caes. Usually, using metadata
//is a better approach.
[Export("MyContractName", typeof(MyInterface))]
public class MyExport3 : MyInterface
{
    public String data = "Test Data 3.";
}

public class MyImporter3
{
    //Both contract name and type must match!
    [Import("MyContractName", typeof(MyInterface))]
    public MyExport3 importedMember { get; set; }
}

class Program
{      

    static void Main(string[] args)
    {
        AggregateCatalog catalog = new AggregateCatalog();
        catalog.Catalogs.Add(new AssemblyCatalog(typeof(MyExport1).Assembly));
        CompositionContainer _container = new CompositionContainer(catalog);
        MyImporter1 test1 = new MyImporter1();
        MyImporter2 test2 = new MyImporter2();
        MyImporter3 test3 = new MyImporter3();
        _container.SatisfyImportsOnce(test1);
        _container.SatisfyImportsOnce(test2);
        _container.SatisfyImportsOnce(test3);
        Console.WriteLine(test1.importedMember.data);
        Console.WriteLine(test2.importedMember.data);
        Console.WriteLine(test3.importedMember.data);
        Console.ReadLine();

    }
}
```

```vb
'Default export infers type and contract name from the
'exported type.  This is the preferred method.
<Export()>
Public Class MyExport1
    Public ReadOnly Property data As String
        Get
            Return "Test Data 1."
        End Get
    End Property
End Class

Public Class MyImporter1

    <Import()>
    Public Property ImportedMember As MyExport1

End Class

Public Interface MyInterface

End Interface

'Specifying the contract type may be important if
'you want to export a type other then the base type,
'such as an interface.
<Export(GetType(MyInterface))>
Public Class MyExport2
    Implements MyInterface
    Public ReadOnly Property data As String
        Get
            Return "Test Data 2."
        End Get
    End Property
End Class

Public Class MyImporter2
    'The import must match the contract type!
    <Import(GetType(MyInterface))>
    Public Property ImportedMember As MyExport2
End Class

'Specifying a contract name should only be 
'needed in rare caes. Usually, using metadata
'is a better approach.
<Export("MyContractName", GetType(MyInterface))>
Public Class MyExport3
    Implements MyInterface
    Public ReadOnly Property data As String
        Get
            Return "Test Data 3."
        End Get
    End Property
End Class

Public Class MyImporter3
    'Both contract name and type must match!
    <Import("MyContractName", GetType(MyInterface))>
    Public Property ImportedMember As MyExport3
End Class



Sub Main()
    Dim catalog As AggregateCatalog = New AggregateCatalog()
    catalog.Catalogs.Add(New AssemblyCatalog(GetType(MyExport1).Assembly))
    Dim container As CompositionContainer = New CompositionContainer(catalog)
    Dim test1 As MyImporter1 = New MyImporter1()
    Dim test2 As MyImporter2 = New MyImporter2()
    Dim test3 As MyImporter3 = New MyImporter3()
    container.SatisfyImportsOnce(test1)
    container.SatisfyImportsOnce(test2)
    container.SatisfyImportsOnce(test3)
    Console.WriteLine(test1.ImportedMember.data)
    Console.WriteLine(test2.ImportedMember.data)
    Console.WriteLine(test3.ImportedMember.data)
    Console.ReadLine()
End Sub
```

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ExportAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
        <AssemblyVersion>1.0.33.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用預設合約名稱來匯出標記有這個屬性的型別或成員，初始化 <see cref="T:System.Composition.ExportAttribute" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
標記有這個屬性的方法必須使用指定的合約名稱或型別<xref:System.ComponentModel.Composition.ExportAttribute.%23ctor(System.String)>或<xref:System.ComponentModel.Composition.ExportAttribute.%23ctor(System.Type)>方法。

合約名稱會比較使用<xref:System.StringComparer.Ordinal>執行區分大小寫、 非語言比較的屬性。 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ExportAttribute(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="new System.Composition.ExportAttribute : string -&gt; System.Composition.ExportAttribute" Usage="new System.Composition.ExportAttribute contractName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
        <AssemblyVersion>1.0.33.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contractName">用來匯出標記有這個屬性之型別或成員的合約名稱，否則為使用預設合約名稱的 <see langword="null" /> 或空字串 ("")。</param>
        <summary>使用指定合約名稱來匯出標記有這個屬性的型別或成員，初始化 <see cref="T:System.Composition.ExportAttribute" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

標記有這個屬性的方法必須使用指定的合約名稱或型別<xref:System.ComponentModel.Composition.ExportAttribute.%23ctor(System.String)>或<xref:System.ComponentModel.Composition.ExportAttribute.%23ctor(System.Type)>方法。

合約名稱會比較使用<xref:System.StringComparer.Ordinal>執行區分大小寫、 非語言比較的屬性。 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute (Type contractType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type contractType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ExportAttribute(Type ^ contractType);" />
      <MemberSignature Language="F#" Value="new System.Composition.ExportAttribute : Type -&gt; System.Composition.ExportAttribute" Usage="new System.Composition.ExportAttribute contractType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
        <AssemblyVersion>1.0.33.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="contractType">從其中衍生合約名稱的型別，而該合約名稱會用來匯出標記有這個屬性的型別或成員，否則為使用預設合約名稱的 <see langword="null" />。</param>
        <summary>使用衍生自指定型別之合約名稱來匯出標記有這個屬性的型別或成員，初始化 <see cref="T:System.Composition.ExportAttribute" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
標記有這個屬性的方法必須使用指定的合約名稱或型別<xref:System.ComponentModel.Composition.ExportAttribute.%23ctor(System.String)>或<xref:System.ComponentModel.Composition.ExportAttribute.%23ctor(System.Type)>方法。

合約名稱會比較使用<xref:System.StringComparer.Ordinal>執行區分大小寫、 非語言比較的屬性。 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ExportAttribute (string contractName, Type contractType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName, class System.Type contractType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Composition.ExportAttribute.#ctor(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractName As String, contractType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ExportAttribute(System::String ^ contractName, Type ^ contractType);" />
      <MemberSignature Language="F#" Value="new System.Composition.ExportAttribute : string * Type -&gt; System.Composition.ExportAttribute" Usage="new System.Composition.ExportAttribute (contractName, contractType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
        <AssemblyVersion>1.0.33.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
        <Parameter Name="contractType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="contractName">用來匯出標記有這個屬性之型別或成員的合約名稱，否則為使用預設合約名稱的 <see langword="null" /> 或空字串 ("")。</param>
        <param name="contractType">要匯出的型別。</param>
        <summary>使用指定的合約名稱來匯出指定的型別，初始化 <see cref="T:System.Composition.ExportAttribute" /> 類別的新執行個體。</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractName">
      <MemberSignature Language="C#" Value="public string ContractName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContractName" />
      <MemberSignature Language="DocId" Value="P:System.Composition.ExportAttribute.ContractName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContractName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContractName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContractName : string" Usage="System.Composition.ExportAttribute.ContractName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
        <AssemblyVersion>1.0.33.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得合約名稱，此名稱會用來匯出標記有這個屬性的類型或成員。</summary>
        <value>合約名稱，用來匯出標記有這個屬性的類型或成員。 預設值為空字串 ("")。</value>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractType">
      <MemberSignature Language="C#" Value="public Type ContractType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ContractType" />
      <MemberSignature Language="DocId" Value="P:System.Composition.ExportAttribute.ContractType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContractType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ ContractType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContractType : Type" Usage="System.Composition.ExportAttribute.ContractType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Composition.AttributedModel</AssemblyName>
        <AssemblyVersion>1.0.31.0</AssemblyVersion>
        <AssemblyVersion>1.0.32.0</AssemblyVersion>
        <AssemblyVersion>1.0.33.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得合約類型，這個類型是由這個屬性標示的成員所匯出。</summary>
        <value>要提供之匯出的類型。 預設值為 <see langword="null" />，表示將透過在附加此匯出之成員上查看型別的方式取得型別。</value>
        <remarks></remarks>
      </Docs>
    </Member>
  </Members>
</Type>