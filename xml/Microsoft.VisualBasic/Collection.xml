<Type Name="Collection" FullName="Microsoft.VisualBasic.Collection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a6ec4e5e4ce807927ed04f1338017c31c0fdf473" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37710118" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Collection : System.Collections.IList, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed Collection extends System.Object implements class System.Collections.ICollection, class System.Collections.IList, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Collection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Collection&#xA;Implements IDeserializationCallback, IList, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Collection sealed : System::Collections::IList, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Collection = class&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(Microsoft.VisualBasic.Collection/CollectionDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Visual Basic <see langword="Collection" /> 是一組已排序的項目，可以稱為一個單位。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  可能的話，您應該使用中的泛型集合<xref:System.Collections.Generic?displayProperty=nameWithType>命名空間或<xref:System.Collections.Concurrent>命名空間，而不是 Visual Basic `Collection`。 如需詳細資訊，請參閱 <<c0> [ 集合](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b)。  
  
 Visual Basic`Collection`物件提供便利的方式，來參考的項目為單一物件相關的群組。 項目，或*項目*中只需要它們存在於集合中的事實相關的集合。 集合的項目就不必共用相同的資料型別。  
  
 如下列範例說明您可以建立指定集合相同的方式建立其他物件。  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 當您建立集合之後時，您可以執行下列其中一項：  
  
-   新增項目<xref:Microsoft.VisualBasic.Collection.Add%2A>方法。  
  
-   移除具有的項目<xref:Microsoft.VisualBasic.Collection.Remove%2A>方法。  
  
-   移除所有項目與<xref:Microsoft.VisualBasic.Collection.Clear%2A>方法。  
  
-   了解集合包含具有的項目數目<xref:Microsoft.VisualBasic.Collection.Count%2A>屬性。  
  
-   檢查特定的項目是否有與<xref:Microsoft.VisualBasic.Collection.Contains%2A>方法。  
  
-   從集合傳回特定的項目<xref:Microsoft.VisualBasic.Collection.Item%2A>屬性。  
  
-   逐一查看整個集合與[每個...下一個陳述式](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)。  
  
    > [!NOTE]
    >  雖然 Visual Basic`Collection`物件具有相同的功能`Collection`物件在 Visual Basic 6.0 中，這兩個無法在 COM 環境交互操作。  
  
    > [!CAUTION]
    >  逐一查看 Visual Basic`Collection`不是安全執行緒程序。 即使集合經過同步化，其他執行緒仍然可以修改集合中，導致擲回例外狀況的列舉值。 若要保證列舉期間的執行緒安全，請鎖定集合，或攔截由其他執行緒變更所造成的例外狀況。 如需有關鎖定的程式設計元素的詳細資訊，請參閱[SyncLock 陳述式](~/docs/visual-basic/language-reference/statements/synclock-statement.md)。  
  
   
  
## Examples  
 下列範例會建立`Collection`物件`names`和對話方塊中，使用者可以將物件加入 （名稱） 集合。 它接著會在集合中的顯示名稱，以及最後會將集合清空不需處置的`Collection`物件本身。  
  
 若要查看其運作方式，請選擇**加入類別**命令**專案**功能表，並宣告一個名為的公用變數`instanceName`在模組層級`nameClass`(型別`Public instanceName`) 來保存每個執行個體名稱。 保留預設名稱為`nameClass`。 複製並貼上下列程式碼**一般**一節的另一個模組，然後將它啟動與陳述式`classNamer`中另一個程序。 （此範例僅適用於支援類別的裝載應用程式。）  
  
 [!code-vb[VbVbalrCollectionObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Collection ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Collection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>建立並傳回新的Visual Basic <see cref="T:Microsoft.VisualBasic.Collection" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回這個建構函式的 Visual Basic 集合是空的而且沒有任何已配置的初始容量。  
  
 Visual Basic 集合與不相容[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]集合中可用<xref:System.Collections?displayProperty=nameWithType>， <xref:System.Collections.Generic?displayProperty=nameWithType>，和<xref:System.Collections.Specialized?displayProperty=nameWithType>命名空間。  
  
   
  
## Examples  
 下列範例會建立新的 Visual Basic 集合，並將它指派給變數`coll`:  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 這`Collection`物件是一個為基礎，這表示，項目範圍是從 1 到的值的索引值`Count`屬性。 Visual Basic 集合保留類型的項目<xref:System.Object>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object Item, string Key = null, object Before = null, object After = null);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Add(object Item, string Key, object Before, object After) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Add(System.Object,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (Item As Object, Optional Key As String = null, Optional Before As Object = null, Optional After As Object = null)" />
      <MemberSignature Language="F#" Value="member this.Add : obj * string * obj * obj -&gt; unit" Usage="collection.Add (Item, Key, Before, After)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Before" Type="System.Object" />
        <Parameter Name="After" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Item">必要項。 任何型別的物件，可指定要加入到集合中的項目。</param>
        <param name="Key">選擇項。 唯一的 <see langword="String" /> 運算式，指定用來存取集合中這個新項目的索引鍵字串，藉以取代位置索引。</param>
        <param name="Before">選擇項。 運算式，可指定集合中的相對位置。 要加入的元素會放置在集合中由 <c>Before</c> 引數識別的元素之前。 如果 <c>Before</c> 為數值運算式，它必須是從 1 到集合之 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 屬性值的數字。 如果 <c>Before</c> 為 <see langword="String" /> 運算式，它必須對應到當所參考的元素加入到集合中時所指定的索引鍵字串。 您不能同時指定 <c>Before</c> 和 <c>After</c>。</param>
        <param name="After">選擇項。 運算式，可指定集合中的相對位置。 要加入的元素會放置在集合中由 <c>After</c> 引數識別的元素之後。 如果 <c>After</c> 為數值運算式，它必須是從 1 到集合之 <see langword="Count" /> 屬性值的數字。 如果 <c>After</c> 為 <see langword="String" /> 運算式，它必須對應到當所參考的元素加入集合中時所指定的索引鍵字串。 您不能同時指定 <c>Before</c> 和 <c>After</c>。</param>
        <summary>將項目加入至 <see langword="Collection" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Before`或`After`引數必須參考現有集合的項目; 否則會發生錯誤。  
  
 如果兩個`Before`和`After`省略引數時，新物件加入至集合結尾。  
  
 如果指定，也會發生錯誤`Key`值符合現有項目集合的索引鍵。  
  
   
  
## Examples  
 下列範例會使用`Add`方法來加入`child`物件，呼叫類別的執行個體`child`包含`Public`屬性`name`— 至集合，稱為`family`。 若要查看其運作方式，建立<xref:System.Windows.Forms.Form>具有兩個<xref:System.Windows.Forms.Button>控制項並設定其<xref:System.Windows.Forms.Control.Text%2A>屬性，以`Add`和`List`。 新增`child`類別定義和`family`表單程式碼的宣告。 修改`_Click`事件處理常式**新增**並**清單**按鈕所示。 **新增**按鈕可讓您新增子系。 **清單**按鈕會顯示所有子系的名稱。  
  
 [!code-vb[VbVbalrCollectionObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="collection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除 Visual Basic <see langword="Collection" /> 物件的所有項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Clear`方法會將集合清空，並重設其<xref:Microsoft.VisualBasic.Collection.Count%2A>屬性設為 0。  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool Contains(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (Key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ Key);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="collection.Contains Key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">必要項。 <see langword="String" /> 運算式，可指定要搜尋集合項目的索引鍵。</param>
        <summary>傳回 <see langword="Boolean" /> 值，指出 Visual Basic <see langword="Collection" /> 物件是否包含具有特定索引鍵的項目。</summary>
        <returns>傳回 <see langword="Boolean" /> 值，指出 Visual Basic <see langword="Collection" /> 物件是否包含具有特定索引鍵的項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Contains` 會傳回`True`如果集合包含具有完全相符的索引鍵的項目`Key`。 否則，請`Contains`傳回`False`。 比對索引鍵的值時，會忽略大小寫。  
  
 Visual Basic`Collection`可以保留某些項目具有索引鍵和其他項目不含索引鍵。 這取決於是否呼叫<xref:Microsoft.VisualBasic.Collection.Add%2A>方法會提供選擇性的引數`Key`參數。  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#4)]  
  
 如果您想要使用其索引鍵的項目在集合中搜尋，請記得提供`Key`每次呼叫的引數`Add`方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="Microsoft.VisualBasic.Collection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回 <see langword="Integer" />，其中包含集合中的項目數目。 唯讀。</summary>
        <value>傳回 <see langword="Integer" />，其中包含集合中的項目數目。 唯讀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Count`屬性來判斷中的項目數`Collection`物件。  
  
   
  
## Examples  
 此範例說明如何使用`Count`屬性來顯示中的項目數<xref:Microsoft.VisualBasic.Collection>變數中的物件`birthdays`。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#6)]  
  
 `Collection`物件是一個為基礎，這表示，項目範圍是從 1 到的值的索引值`Count`屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回對列舉值物件的參考，這個物件是用來反覆查看 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件。</summary>
        <returns>傳回對列舉值物件的參考，這個物件是用來反覆查看 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [每個...下一個陳述式](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)呼叫`GetEnumerator`來取得集合的項目支援反覆運算的列舉值物件。 通常，您使用`For Each`...`Next`迴圈來周遊集合或陣列，並不需要呼叫`GetEnumerator`明確。  
  
 如果您需要進一步控制反覆項目比`For Each`...`Next`陳述式提供，您可以使用`GetEnumerator`方法，以執行自訂的周遊。 以下是某些情況下，您可能需要執行這項操作。  
  
-   您可能想要傳回至集合的開頭和結束前，開始反覆項目一次。  
  
-   您可能想要跳過各種原因而一或多個項目。  
  
-   您可能需要變更中間周遊集合的元素。 在此情況下您必須取得新的列舉值物件，因為前一個無效。  
  
   
  
## Examples  
 下列範例示範如何使用`GetEnumerator`擷取的所有項目的`Collection`物件。  
  
 [!code-vb[VbVbalrCollectionObject#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#7)]  
  
 `GetEnumerator` 建構並傳回列舉值物件，它會實作<xref:System.Collections.IEnumerator>介面的<xref:System.Collections>命名空間。 列舉值物件會公開<xref:System.Collections.IEnumerator.Current%2A>屬性和<xref:System.Collections.IEnumerator.MoveNext%2A>和<xref:System.Collections.IEnumerator.Reset%2A>方法。 如需詳細資訊，請參閱[每個...下一個陳述式](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[int Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[int] { System::Object ^ get(int Index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">(A) 數值運算式，可指定集合中項目的位置。 <c>Index</c> 必須是從 1 到集合之 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 屬性值的數字。 或是 (B) <see langword="Object" /> 運算式，可指定集合中項目的位置或索引鍵字串。</param>
        <summary>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</summary>
        <value>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Index`屬於型別`Object`，則`Item`屬性會嘗試將它視為`String`， `Char`，`Char`陣列或整數值。 如果`Item`無法轉換`Index`要`String`或是`Integer`，就會擲回<xref:System.ArgumentException>例外狀況。  
  
 `Item`屬性是集合的預設屬性。 因此，下列程式碼行是相等的。  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 下列範例會使用`Item`屬性來擷取集合中物件的參考。 它會建立`birthdays`作為`Collection`物件，並接著會擷取物件，表示使用索引鍵的 Bill 的生日`"Bill"`做為`Index`引數。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 請注意，第一次呼叫明確指定`Item`屬性，但第二個則否。 這兩個呼叫運作，因為`Item`屬性是預設屬性，如`Collection`物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">(A) 數值運算式，可指定集合中項目的位置。 <c>Index</c> 必須是從 1 到集合之 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 屬性值的數字。 或是 (B) <see langword="Object" /> 運算式，可指定集合中項目的位置或索引鍵字串。</param>
        <summary>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</summary>
        <value>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Index`屬於型別`Object`，則`Item`屬性會嘗試將它視為`String`， `Char`，`Char`陣列或整數值。 如果`Item`無法轉換`Index`要`String`或是`Integer`，就會擲回<xref:System.ArgumentException>例外狀況。  
  
 `Item`屬性是集合的預設屬性。 因此，下列程式碼行是相等的。  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 下列範例會使用`Item`屬性來擷取集合中物件的參考。 它會建立`birthdays`作為`Collection`物件，並接著會擷取物件，表示使用索引鍵的 Bill 的生日`"Bill"`做為`Index`引數。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 請注意，第一次呼叫明確指定`Item`屬性，但第二個則否。 這兩個呼叫運作，因為`Item`屬性是預設屬性，如`Collection`物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[string Key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ Key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">唯一的 <see langword="String" /> 運算式，指定用來存取集合中項目的索引鍵字串，藉以取代位置索引。 <c>Key</c> 必須對應至在元素加入集合時所指定的 <c>Key</c> 引數。</param>
        <summary>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</summary>
        <value>依位置或索引鍵傳回 <see langword="Collection" /> 物件的特定項目。 唯讀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Index`屬於型別`Object`，則`Item`屬性會嘗試將它視為`String`， `Char`，`Char`陣列或整數值。 如果`Item`無法轉換`Index`要`String`或是`Integer`，就會擲回<xref:System.ArgumentException>例外狀況。  
  
 `Item`屬性是集合的預設屬性。 因此，下列程式碼行是相等的。  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 下列範例會使用`Item`屬性來擷取集合中物件的參考。 它會建立`birthdays`作為`Collection`物件，並接著會擷取物件，表示使用索引鍵的 Bill 的生日`"Bill"`做為`Index`引數。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 請注意，第一次呼叫明確指定`Item`屬性，但第二個則否。 這兩個呼叫運作，因為`Item`屬性是預設屬性，如`Collection`物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從 <see langword="Collection" /> 物件移除項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(int32 Index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; unit" Usage="collection.Remove Index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">數值運算式，可指定集合中項目的位置。 <c>Index</c> 必須是從 1 到集合之 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 屬性值的數字。</param>
        <summary>從 <see langword="Collection" /> 物件移除項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當`Remove`刪除的項目從集合取得，它遞減集合的<xref:Microsoft.VisualBasic.Collection.Count%2A>其中一個屬性。 它也會遞減`Index`之前遵循的已刪除的項目集合中每個元素的值。  
  
 如果項目加入至集合，而不需要`Key`，您必須使用其`Index`將它移除。  
  
   
  
## Examples  
 此範例說明如何使用`Remove`方法來移除的物件<xref:Microsoft.VisualBasic.Collection>變數中的物件`birthdays`。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 下列四個呼叫`Add`方法中，`Count`屬性包含 4，項目`"Bill"`具有索引值 1，且項目`"Pete"`索引值 4。  
  
 遵循第一次呼叫`Remove`，`Count`為 3，項目`"Bill"`遭到刪除，和項目`"Pete"`索引值 3。  
  
 遵循第二次呼叫`Remove`，`Count`為 2，項目`"Mike"`遭到刪除，和項目`"Pete"`索引值 2。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Key As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ Key);" />
      <MemberSignature Language="F#" Value="member this.Remove : string -&gt; unit" Usage="collection.Remove Key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">唯一的 <see langword="String" /> 運算式，指定用來存取集合中項目的索引鍵字串，藉以取代位置索引。 <c>Key</c> 必須對應至在元素加入集合時所指定的 <c>Key</c> 引數。</param>
        <summary>從 <see langword="Collection" /> 物件移除項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當`Remove`刪除的項目從集合取得，它遞減集合的<xref:Microsoft.VisualBasic.Collection.Count%2A>其中一個屬性。 它也會遞減`Index`之前遵循的已刪除的項目集合中每個元素的值。  
  
 如果項目加入至集合，而不需要`Key`，您必須使用其`Index`將它移除。  
  
   
  
## Examples  
 此範例說明如何使用`Remove`方法來移除的物件<xref:Microsoft.VisualBasic.Collection>變數中的物件`birthdays`。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 下列四個呼叫`Add`方法中，`Count`屬性包含 4，項目`"Bill"`具有索引值 1，且項目`"Pete"`索引值 4。  
  
 遵循第一次呼叫`Remove`，`Count`為 3，項目`"Bill"`遭到刪除，和項目`"Pete"`索引值 3。  
  
 遵循第二次呼叫`Remove`，`Count`為 2，項目`"Mike"`遭到刪除，和項目`"Pete"`索引值 2。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void ICollectionCopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionCopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void ICollectionCopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一維 <see cref="T:System.Array" />，是從 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件複製項目之目的位置。 <see cref="T:System.Array" /> 必須有以零起始的索引。</param>
        <param name="index">
          <c>array</c> 中以零起始的索引，複製作業從此處開始。</param>
        <summary>從特定的 <see cref="T:Microsoft.VisualBasic.Collection" /> 索引開始，將 <see cref="T:System.Array" /> 的項目複製至 <see cref="T:System.Array" />。 實作 <see cref="T:System.Collections.ICollection" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將元素複製到<xref:System.Array>所在的列舉值逐一查看的順序相同<xref:Microsoft.VisualBasic.Collection>物件。  
  
 這個方法是 O (`n`) 運算，其中`n`取自<xref:Microsoft.VisualBasic.Collection.System%23Collections%23ICollection%23Count>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 為多維。  -或-  來源 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中的項目數目，大於從 <paramref name="index" /> 到目的地 <paramref name="array" /> 結尾的可用空間。</exception>
        <exception cref="T:System.InvalidCastException">來源 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件的型別無法自動轉換為目的 <paramref name="array" /> 的型別</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.ICollectionCount">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.ICollectionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ICollectionCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionCount" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionCount As Integer Implements ICollection.ICollectionCount" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.ICollectionCount { int get(); };" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.ICollectionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.ICollectionIsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.ICollectionIsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ICollectionIsSynchronized" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionIsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionIsSynchronized As Boolean Implements ICollection.ICollectionIsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.ICollectionIsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.ICollectionIsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.ICollectionSyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.ICollectionSyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ICollectionSyncRoot" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionSyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionSyncRoot As Object Implements ICollection.ICollectionSyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.ICollectionSyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.ICollectionSyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance class System.Collections.IEnumerator ICollectionGetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionGetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function ICollectionGetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ ICollectionGetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回可逐一查看集合的列舉程式。 實作 <see cref="T:System.Collections.ICollection" /> 介面。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> 物件，用於逐一查看集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、 C#]  
  
 C# 語言的 `foreach` 陳述式 (在 Visual Basic 中為 `for each`) 會隱藏列舉值的複雜度。 因此，建議您使用 `foreach`，而不要直接使用列舉值。  
  
 列舉程式可以用來讀取集合中的資料，但是無法用來修改基礎集合。  
  
 一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A>方法也會列舉值帶回至這個位置。 在這個位置，<xref:System.Collections.IEnumerator.Current%2A>未定義屬性。 因此，您必須呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>列舉值前進到第一個項目，再讀取的值集合的方法<xref:System.Collections.IEnumerator.Current%2A>。  
  
 <xref:System.Collections.IEnumerator.Current%2A> 會傳回相同的物件直到呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A> 或 <xref:System.Collections.IEnumerator.Reset%2A>。 <xref:System.Collections.IEnumerator.MoveNext%2A> 會將 <xref:System.Collections.IEnumerator.Current%2A> 設定為下一個項目。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>集合，也就是列舉值的結尾是否位於集合中的最後一個元素之後的階段和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。 列舉值位於此位置，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。 如果上次呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>會傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。 若要再次將 <xref:System.Collections.IEnumerator.Current%2A> 設定為集合的第一個元素，您可以在呼叫 <xref:System.Collections.IEnumerator.Reset%2A> 之後，接著呼叫 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、修改或刪除項目，列舉程式會永久失效，且其行為未定義。  
  
 列舉程式沒有集合的獨佔存取權，因此，列舉集合內容本質上並不是安全的執行緒程序。 若要確保列舉期間的執行緒安全性，您可以在整個列舉期間鎖定集合。 若要讓多重執行緒能夠存取集合以便進行讀取和寫入，您必須實作自己的同步處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object Item);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object Item) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListAdd(System.Object)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (Item As Object) As Integer Implements IList.Add" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ Item) = System::Collections::IList::Add;" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="int IList.Add (object value);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListAdd(System.Object)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (value As Object) As Integer Implements IList.Add" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ value) = System::Collections::IList::Add;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      </Parameters>
      <Docs>
        <param name="value">要加入到 <see cref="T:System.Object" /> 物件中的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <param name="Item">To be added.</param>
        <summary>將項目新增至 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <returns>插入新項目的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您也可以使用<xref:Microsoft.VisualBasic.Collection.Item%2A>屬性來設定索引鍵的值加入新項目不存在於<xref:Microsoft.VisualBasic.Collection>物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 物件是唯讀的。  -或-  <see cref="T:Microsoft.VisualBasic.Collection" /> 物件具有固定的大小。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Add(System.Object)" />
        <altmember cref="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListClear" />
      <MemberSignature Language="VB.NET" Value="Sub IListClear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListClear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將所有項目從 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中移除。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會移除所有項目從<xref:Microsoft.VisualBasic.Collection>物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 是唯讀的。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.Hashtable.Clear" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance bool IListContains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListContains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListContains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool IListContains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 物件中尋找的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>判斷 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件是否包含特定的值。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <returns>如果在 <see cref="T:System.Object" /> 物件中找到 <see cref="T:Microsoft.VisualBasic.Collection" />，則傳回 <see langword="True" />，否則傳回 <see langword="False" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會判斷是否<xref:Microsoft.VisualBasic.Collection>物件包含特定值。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IListIsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IListIsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsFixedSize" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsFixedSize As Boolean Implements IList.IListIsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IListIsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListIsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IListIsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IListIsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsReadOnly As Boolean Implements IList.IListIsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IListIsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListIsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IListItem">
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int Index] { get; set; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".property instance object IListItem(int32)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListItem(System.Int32)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(Index As Integer) As Object Implements IList.IListItem" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int Index); void set(int Index, System::Object ^ value); };" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListItem" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int index] { get; set; }" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".property instance object IListItem(int32)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListItem(System.Int32)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(index As Integer) As Object Implements IList.IListItem" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListItem" FrameworkAlternate="netframework-2.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListIndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListIndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 物件中尋找的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>判斷 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中特定項目的索引。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <returns>如果可在集合中找到，即為 <paramref name="value" /> 的索引，否則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會判斷在特定項目的索引<xref:Microsoft.VisualBasic.Collection>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.IndexOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListInsert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListInsert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListInsert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListInsert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">應該插入 <c>value</c> 之以零啟始的索引。</param>
        <param name="value">要插入至 <see cref="T:System.Object" /> 物件的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>將項目插入至指定之索引的 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`index`等於中的項目數<xref:Microsoft.VisualBasic.Collection>物件，然後`value`附加至結尾。  
  
 在連續項目的集合 (例如清單) 中，後面接著插入點的項目會向下移動以容納新項目。 如果集合具有索引，則移動之項目的索引也會更新。 集合的項目若在概念上群組成 Bucket (例如雜湊資料表)，則不適用這項行為。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 物件是唯讀的。  -或-  <see cref="T:Microsoft.VisualBasic.Collection" /> 物件具有固定的大小。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> 是 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中的 null 參考</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要從 <see cref="T:System.Object" /> 物件中移除的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>從 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中移除第一次出現的特定物件。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在相鄰元素的集合中，例如清單，接在移除的元素之後的元素會向上移動以佔用空出的位置。 如果集合具有索引，則移動之項目的索引也會更新。 集合的項目若在概念上群組成 Bucket (例如雜湊資料表)，則不適用這項行為。 如果`value`中找不到<xref:Microsoft.VisualBasic.Collection>物件，<xref:Microsoft.VisualBasic.Collection>物件會維持不變，並擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 物件是唯讀的。  -或-  <see cref="T:Microsoft.VisualBasic.Collection" /> 物件具有固定的大小。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除項目之以零啟始的索引。</param>
        <summary>移除指定之索引的 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件項目。 實作 <see cref="T:System.Collections.IList" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在相鄰元素的集合中，例如清單，接在移除的元素之後的元素會向上移動以佔用空出的位置。 如果集合具有索引，則移動之項目的索引也會更新。 集合的項目若在概念上群組成 Bucket (例如雜湊資料表)，則不適用這項行為。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 物件是唯讀的。  -或-  <see cref="T:Microsoft.VisualBasic.Collection" /> 物件具有固定的大小。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">初始化回呼 (Callback) 的物件。</param>
        <summary>在整個 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件圖形還原序列化之後執行。 實作 <see cref="T:System.Runtime.Serialization.IDeserializationCallback" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會呼叫這個方法之後整個<xref:Microsoft.VisualBasic.Collection>已還原序列化物件圖形。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.IDeserializationCallback" />
        <altmember cref="M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件，含有要序列化 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件的必要資訊。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> 物件，包含與 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件相關之序列化資料流的來源與目的端。</param>
        <summary>傳回序列化 <see cref="T:Microsoft.VisualBasic.Collection" /> 物件所需的資料。 實作 <see cref="T:System.Runtime.Serialization.ISerializable" /> 介面。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回序列化所需的資料<xref:Microsoft.VisualBasic.Collection>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>