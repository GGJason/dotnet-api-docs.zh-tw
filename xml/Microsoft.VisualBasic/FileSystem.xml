<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="698d4c7779138119bfe452e95602b55a06711e5b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37712140" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個模組支援的 Visual Basic 語言關鍵字和存取檔案和資料夾的執行階段程式庫成員。  
  
   
  
## Examples  
 這個範例會使用`GetAttr`函式來判斷檔案和目錄或資料夾的屬性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder. <c>Path</c> may include the drive. If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</param>
        <summary>Changes the current directory or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函式會變更預設目錄，但不是在預設的磁碟機。 例如，如果預設磁碟機 C，下列陳述式會變更磁碟機 D 上的預設目錄，但 C 則保持預設的磁碟機：  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 您可以進行相對目錄變更，請輸入兩個句號，如下所示：  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函式需要 unmanaged 程式碼的權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和。  
  
   
  
## Examples  
 這個範例會使用`ChDir`函式來變更目前的目錄或資料夾。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is empty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Changes the current drive.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函式需要 unmanaged 程式碼的權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱 <<c0> <xref:System.Security.Permissions.SecurityPermission> 並[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 這個範例會使用`ChDrive`函式來變更目前的磁碟機。 如果磁碟機不存在，則此函式會擲回例外狀況。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函式需要 unmanaged 程式碼的權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱 <<c0> <xref:System.Security.Permissions.SecurityPermission> 並[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 這個範例會使用`ChDrive`函式來變更目前的磁碟機。 如果磁碟機不存在，則此函式會擲回例外狀況。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`CurDir`函式來傳回目前的路徑。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. <see langword="Char" /> expression that specifies an existing drive. If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</param>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`CurDir`函式來傳回目前的路徑。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 `VbVolume` 傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。  
  
 您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含參數的函式。  
  
> [!IMPORTANT]
>  若要正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>並<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>加上旗標的<xref:System.Security.Permissions.FileIOPermission>要授與執行的程式碼。 如需詳細資訊，請參閱 < <xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，並[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`引數的列舉值如下所示：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|預設值： 指定沒有屬性的檔案。|  
|`ReadOnly`|`vbReadOnly`|指定唯讀檔案，以及不需屬性的檔案。|  
|`Hidden`|`vbHidden`|指定隱藏的檔，以及不需屬性的檔案。|  
|`System`|`vbSystem`|指定系統檔案，以及不需屬性的檔案。|  
|`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。|  
|`Directory`|`vbDirectory`|指定目錄或資料夾，以及不需屬性的檔案。|  
|`Archive`|`vbArchive`|上次備份之後變更檔案。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉由 Visual Basic 語言，並可用於您的程式碼，而不是實際值的任何位置。  
  
   
  
## Examples  
 這個範例會使用`Dir`函式來檢查特定的檔案和目錄是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</param>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 `VbVolume` 傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。  
  
 您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含任何參數的函式。  
  
> [!IMPORTANT]
>  若要正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>並<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>加上旗標的<xref:System.Security.Permissions.FileIOPermission>要授與執行的程式碼。 如需詳細資訊，請參閱 < <xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，並[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`引數的列舉值如下所示：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|預設值： 指定沒有屬性的檔案。|  
|`ReadOnly`|`vbReadOnly`|指定唯讀檔案，除了沒有屬性的檔案。|  
|`Hidden`|`vbHidden`|指定隱藏的檔，除了沒有屬性的檔案。|  
|`System`|`vbSystem`|指定系統檔案，除了沒有屬性的檔案。|  
|`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。|  
|`Directory`|`vbDirectory`|指定目錄或資料夾，以及沒有屬性的檔案。|  
|`Archive`|`vbArchive`|上次備份之後變更檔案。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉由 Visual Basic 語言，並可用於您的程式碼來取代實際值的任何位置。  
  
   
  
## Examples  
 這個範例會使用`Dir`函式來檢查特定的檔案和目錄是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains any valid file number.</param>
        <summary>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</summary>
        <returns>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`以避免嘗試取得輸入超過檔案結尾所產生的錯誤。  
  
 `EOF`函式會傳回`False`直到達到檔案結尾為止。 使用開啟的檔案`Random`或`Binary`存取`EOF`會傳回`False`直到最後一個執行`FileGet`函式是無法讀取整個記錄。  
  
 使用開啟的檔案`Binary`存取，請嘗試透過檔案使用讀取`Input`運作直到`EOF`傳回`True`會產生錯誤。 使用`LOF`並`Loc`函數，而`EOF`讀取二進位檔案時`Input`，或使用`Get`使用時`EOF`函式。 使用開啟的檔案`Output`，`EOF`一律會傳回`True`。  
  
   
  
## Examples  
 這個範例會使用`EOF`函式來偵測檔案的結尾。 這個範例假設`Testfile`是文字檔案，其中包含幾行文字。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. <see langword="Integer" />. Any valid file number.</param>
        <summary>Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</summary>
        <returns>The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函數會傳回代表使用開啟的檔案模式的列舉型別`FileOpen`函式。  
  
   
  
## Examples  
 這個範例會使用`FileAttr`函數來傳回已開啟之檔案的檔案模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameter array of 0 or more channels to be closed.</param>
        <summary>Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function. <see langword="My" /> gives you better productivity and performance in file I/O operations. See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 如何： StreamReader 從檔案讀取文字](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[如何： 將文字寫入檔案以 streamwriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[逐步解說： 中管理檔案和目錄Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。  
  
 如果您省略`FileNumbers`，開啟的所有作用中檔案`FileOpen`函式會關閉。  
  
 當您關閉已開啟的檔案時`Output`或`Append`，最後的緩衝區的輸出會寫入該檔案的作業系統緩衝區。 所有的緩衝區空間的封閉型相關聯檔案釋出。  
  
 當`FileClose`函式執行、 其檔案的檔案的關聯數字結尾。  
  
   
  
## Examples  
 這個範例會使用`FileClose`函式，以關閉 檔案開啟為`Input`。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Required. <see langword="String" /> expression that specifies the name of the file to be copied. <c>Source</c> may include the directory or folder, and drive, of the source file.</param>
        <param name="Destination">Required. <see langword="String" /> expression that specifies the destination file name. <c>Destination</c> may include the directory or folder, and drive, of the destination file.</param>
        <summary>Copies a file. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試使用`FileCopy`函式在目前開啟的檔案，則會發生錯誤。  
  
 `FileCopy` 需要完全信任才能在本機的磁碟機上運作。  
  
   
  
## Examples  
 這個範例會使用`FileCopy`函式複製到另一個檔案。 基於此範例的詳細資訊，假設`SrcFile`是包含資料的檔案。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</exception>
        <exception cref="T:System.IO.IOException">File is already open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Date" /> value that indicates the date and time a file was written to. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> value that indicates the date and time a file was created or last modified.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`FileDateTime`建立函式來判斷日期和時間的檔案或上次修改檔案。 格式的日期和時間顯示為基礎的系統地區設定。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果不使用描述項。 則的大小和陣列的界限傳遞到`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`而不是使用函式`FileGet`若要避免模稜兩可在編譯時期，如果型別`Object`傳回而不是另一個類型，例如`Integer`， `Long`， `Short`，依此類推。  
  
 如果您想要寫出`Variant`型別，`FileGetObject`需要。 有疑問，如果您使用物件來作為第二個參數，一律建議您改用`FilePutObject`和`FileGetObject`。  
  
 `FileGetObject` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGetObject`通常會使用寫入`FilePutObject`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`，`FileGetObject`讀取最後一個之後的資料錄或位元組`FileGetObject`或是`FilePutObject`函式 (或最後一個指向`Seek`函式)。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGetObject`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開頭之間的空間。 因為填補資料的數量無法精確地判斷，所以最好有符合所讀取的資料長度的資料錄長度。  
  
-   正在讀取到變數是否為字串，預設`FileGetObject`讀取雙位元組描述元包含字串的長度，然後再讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度字串和讀取檔案時，長度的描述項不會寫入。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，則所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目： 2 + 8 * NumberOfDimensions。  
  
     比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟：  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 個位元組會分散，如下所示： 18 位元組描述元 (2 + 8 * 2)，以及 100 個位元組 (5 * 10 * 4) 的資料。  
  
-   `FileGetObject` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePutObject`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元： 2 + 8 * NumberOfDimensions。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目，包括任何陣列和其描述項所需的所有位元組的總和。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>類別，可指出的大小字串寫入時的結構中的字串欄位套用至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，所有`Random`套用規則，但有下列例外：  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGetObject` 所有連續讀取變數，從磁碟，也就是記錄之間的不帶填補。  
  
-   在結構中，陣列以外的所有陣列`FileGetObject`讀取的資料。 不讀取任何描述項。  
  
 `FileGetObject` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不是 Visual Basic 來源檔案。  
  
   
  
## Examples  
 下列範例讀入測試檔案中的記錄，然後擷取它。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the length of a file in bytes. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> value that specifies the length of a file in bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的檔案時，開啟`FileLen`函式呼叫，傳回的值代表檔案的大小，在它已開啟的時間。  
  
> [!NOTE]
>  若要取得目前已開啟之檔案的長度，請使用`LOF`函式。  
  
   
  
## Examples  
 這個範例會使用`FileLen`函數來傳回檔案的長度，以位元組為單位。 基於此範例的詳細資訊，假設`TestFile`是包含某些資料的檔案。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number. Use the <see langword="FreeFile" /> function to obtain the next available file number.</param>
        <param name="FileName">Required. <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</param>
        <param name="Mode">Required. Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Optional. Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />. Defaults to <see langword="ReadWrite" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Optional. Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />. Defaults to <see langword="Lock Read Write" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.</param>
        <summary>Opens a file for input or output. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 您必須開啟檔案，才能在其上執行任何 I/O 作業。 `FileOpen` 會針對 I/O 配置緩衝區至檔案，並判斷權限與緩衝區使用的模式。  
  
> [!IMPORTANT]
>  寫入至檔案時，應用程式可能要建立檔案，如果嘗試寫入的檔案不存在。 若要這樣做，它會需要權限的 建立檔案的目錄。 不過，如果指定的檔案`FileName`存在，應用程式需求`Write`只對檔案本身的權限。 盡量，以協助改善安全性、 部署和授與期間建立檔案的任一處`Write`該檔案的權限唯一的而不是整個目錄。 若要改善安全性，請將資料寫入使用者目錄，而不是目錄的根目錄或 Program Files 目錄。  
  
 若要開啟的通道可使用`FreeFile()`函式。  
  
> [!IMPORTANT]
>  `FileOpen`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 此範例說明的各種用法`FileOpen`函式可讓輸入與輸出至檔案。  
  
 下列程式碼會開啟檔案`TestFile`在`Input`模式。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 此範例會開啟中的檔案`Binary`模式只允許寫入作業。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下列範例會開啟中的檔案`Random`模式。 檔案包含的結構記錄`Person`。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 此程式碼範例會開啟中的檔案`Output`模式; 任何程序可以讀取或寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 此程式碼範例會開啟中的檔案`Binary`模式進行讀取，其他處理序無法讀取檔案。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Record length is negative (and not equal to -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`而不是使用函式`FilePut`若要避免模稜兩可在編譯時期，如果型別`Object`傳遞，而另一個類型，例如`Integer`， `Long`， `Short`，依此類推。  
  
 `FilePutObject` 寫入，並讀取描述物件的描述元。 如果您想要寫出`Variant`型別，`FilePutObject`需要。 如有疑問，如果您使用物件來作為第二個參數，我們建議您一律使用`FilePutObject`和`FileGetObject`。  
  
 `FilePutObject` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePutObject` 寫入的資料，通常會透過使用 `FileGetObject` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`，`FilePutObject`寫入最後一個之後的下一步 的資料錄或位元組`FileGetObject`或是`FilePutObject`函式 (或資料錄或位元組所指的最後一個`Seek`函式)。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePutObject` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePutObject`，您必須執行相同的`FileGetObject`，和您也必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePutObject`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 填補資料的數量無法精確地判斷，因為它通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式擲回例外狀況。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePutObject`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePutObject`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePutObject`寫入雙位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，則所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，所有`Random`套用模式的規則，除了：  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePutObject` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
   
  
## Examples  
 這個範例會使用`FilePutObject`函式來將字串寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="RecordWidth">Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <c>RecordWidth</c> equals 0, there is no limit to the length of a line. The default value for <c>RecordWidth</c> is 0.</param>
        <summary>Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`FileWidth`函式來設定輸出行寬度的檔案。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</summary>
        <returns>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`提供尚未使用的檔案數字。  
  
   
  
## Examples  
 這個範例會使用`FreeFile`函式傳回下一個可用的檔案數目。 輸出，在迴圈內，開啟五個檔案和一些範例資料會寫入每一個。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">More than 255 files are in use.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file, directory, or folder name. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷設定了哪些屬性，請使用`And`運算子來執行所傳回的值的位元比較`GetAttr`函式和您想要個別的檔案屬性的值。 如果結果不是零，該屬性是設定具名的檔案。 例如，下列的傳回值`And`運算式是零，如果`Archive`未設定屬性：  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 會傳回非零值，如果`Archive`屬性設定。  
  
   
  
## Examples  
 這個範例會使用`GetAttr`函式來判斷檔案和目錄或資料夾的屬性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有一些使用寫入的資料行`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有一些使用寫入的資料行`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="CharCount">Required. Any valid numeric expression specifying the number of characters to read.</param>
        <summary>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`InputString`函式通常利用寫入至檔案`Print`或`FilePut`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
 不同於`Input`函式，`InputString`函式會傳回讀取的字元。 這包括逗號、 換行字元、 換行、 引號和前置空格。  
  
 使用開啟的檔案`Binary`存取，嘗試讀取檔案，使用`InputString`運作直到`EOF`傳回`True`會產生錯誤。 使用`LOF`並`Loc`函數，而`EOF`藉由讀取二進位檔案時`InputString`，或使用`FileGet`當您使用`EOF`函式。  
  
> [!NOTE]
>  從檔案讀取時，請勿依據副檔名的檔案內容的相關安全性決策。 例如，名為 Form1.vb 檔案可能不是 Visual Basic 來源檔案。  
  
   
  
## Examples  
 這個範例會使用`InputString`函式來從檔案一次讀取一個字元，並列印它`Output`視窗。 這個範例假設`MyFile`是具有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 or &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies one or more file names to be deleted. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Deletes files from a disk. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 **安全性注意事項**才能執行，請`Kill`函式需要`Read`並`PathDiscovery`加上旗標的<xref:System.Security.Permissions.FileIOPermission>要授與執行的程式碼。 如需詳細資訊，請參閱 < <xref:System.Security.SecurityException>[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 這個範例會使用`Kill`函式來從磁碟中刪除檔案。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Target file(s) open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file(s) not found.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</summary>
        <returns>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`LineInput`通常會先寫入至檔案使用`Print`。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
 `LineInput`函式會從檔案的一個字元讀取一次直到遇到歸位字元 (`Chr(13)`) 或歸位字元/換 (`Chr(13) + Chr(10)`) 順序。 歸位字元 return/line 摘要的序列會略過而不是附加的字元字串。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`LineInput`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`LineInput`從循序檔案讀取一行，並將它指派給變數的函式。 這個範例假設`TestFile`是具有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">End of file reached.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid <see langword="Integer" /> file number.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</summary>
        <returns>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`為以零為起始的函式，使用它來擷取檔案中的第一個位元組，則會傳回 0。  
  
 `Loc`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 以下說明每個檔案存取模式的傳回值：  
  
|模式|傳回值|  
|-|-|  
|`Random`|讀取或寫入檔案的最後一個記錄的數目。|  
|`Sequential`|除以 128 檔案中的目前位元組位置。 不過，資訊會由`Loc`的循序檔案不會使用或所需。|  
|`Binary`|讀取或寫入的最後一個位元組的位置。|  
  
   
  
## Examples  
 這個範例會使用`Loc`函式來傳回目前的讀取/寫入位置，在開啟的檔案。 這個範例假設`MyFile`是具有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FileLen`函式來取得未開啟檔案的長度。  
  
   
  
## Examples  
 這個範例會使用`LOF`函式來判斷已開啟之檔案的大小。 這個範例假設`TestFile`是文字檔案，其中包含範例資料。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory to be created. The <c>Path</c> may include the drive. If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</param>
        <summary>Creates a new directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函式會建立新的目錄。  
  
   
  
## Examples  
 這個範例會使用`MkDir`函式來建立目錄。 如果未指定磁碟機，在目前的磁碟機上建立新的目錄。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <exception cref="T:System.IO.IOException">Directory already exists.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包含換行字元結尾的行不過，`PrintLine`包含換行字元。  
  
 資料寫入`Print`通常從檔案讀取利用`LineInput`或`Input`。  
  
 如果您省略`Output`for `PrintLine`，列印一行空白行檔案; 如`Print`，沒有輸出。 多個以逗號分隔的運算式將會對齊索引標籤的界限，但混用逗號和`TAB`可能會導致不一致的結果。  
  
 針對`Boolean`資料，可以是`True`或`False`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
 日期資料寫入檔案中，使用您的系統可辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
 如果，則不寫入至檔案`Output`是空的資料。 不過，如果`Output`清單中的資料`DBNull`，`Null`寫入檔案。  
  
 針對`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定不會轉譯關鍵字。  
  
 寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的小數分隔符號。 如果使用者想要輸出多個地區設定中，供資料`Write`應該使用。  
  
 寫入檔案，使用`Print`或是`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Print`和`PrintLine`函式，將資料寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包含換行字元結尾的行不過，`PrintLine`包含換行字元。  
  
 資料寫入`Print`通常從檔案讀取利用`LineInput`或`Input`。  
  
 如果您省略`Output`for `PrintLine`，列印一行空白行檔案; 如`Print`，沒有輸出。 多個以逗號分隔的運算式將會對齊索引標籤的界限，但混用逗號和`TAB`可能會導致不一致的結果。  
  
 針對`Boolean`資料，可以是`True`或`False`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
 日期資料寫入檔案中，使用系統可辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
 如果，則不寫入至檔案`Output`是空的資料。 不過，如果`Output`清單中的資料`DBNull`，`Null`寫入檔案。  
  
 針對`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定不會轉譯關鍵字。  
  
 寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的小數分隔符號。 如果使用者想要輸出多個地區設定中，供資料`Write`應該使用。  
  
 寫入檔案，使用`Print`或是`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Print`和`PrintLine`函式，將資料寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Required. <see langword="String" /> expression that specifies the existing file name and location. <c>OldPath</c> may include the directory, and drive, of the file.</param>
        <param name="NewPath">Required. <see langword="String" /> expression that specifies the new file name and location. <c>NewPath</c> may include directory and drive of the destination location. The file name specified by <c>NewPath</c> cannot already exist.</param>
        <summary>Renames a disk file or directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`函式重新命名檔案，並將它移到另一個目錄，如有必要。 `Rename`函式可以將檔案移到磁碟機，但它只能重新命名現有的目錄時兩者`NewPath`和`OldPath`都位於相同的磁碟機。 `Rename` 無法建立新的檔案或目錄。  
  
 使用`Rename`函式開啟的檔案會產生錯誤。 您必須先關閉開啟的檔案，才能重新命名。 `Rename` 引數不能包含多個字元 （*） 和單一字元 （？） 的萬用字元。  
  
> [!IMPORTANT]
>  當使用`Rename`將來自未受保護位置的檔案複製到受保護的位置中，該檔案會保留的限制較少的權限。 請檢查以確定未造成可能的安全性風險。  
  
   
  
## Examples  
 這個範例會使用`Rename`函式來重新命名檔案。 基於此範例的詳細資訊，請假設已指定的目錄已經存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Path is invalid.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">Cannot rename to different device.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes all disk files opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`函式會關閉開啟的所有作用中檔案`FileOpen`函式，並具有相同的功能`FileClose()`不含任何參數。  
  
   
  
## Examples  
 這個範例會使用`Reset`函式來關閉所有開啟的檔案並寫入磁碟中的所有檔案緩衝區的內容。 請注意，使用`Object`變數`FileNumber`做為字串和數字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory or folder to be removed. <c>Path</c> can include the drive. If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</param>
        <summary>Removes an existing directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />. For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試使用，就會發生錯誤`RmDir`包含檔案的目錄。 使用`Kill`函式來刪除所有檔案，然後再移除目錄。  
  
   
  
## Examples  
 這個範例會使用`RmDir`函式以移除現有的目錄。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.IO.IOException">Target directory contains files.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Directory does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 傳回介於 1 到 2,147,483,647 之間的值 (相當於 2 ^31-1) 之間，內含。  
  
 以下說明每個檔案存取模式的傳回值：  
  
|模式|傳回值|  
|-|-|  
|`Random`|下一個記錄讀取或寫入的數目|  
|`Binary`、`Input`、`Output``Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。|  
  
   
  
## Examples  
 這個範例會使用`Seek`函數來傳回目前的檔案位置。 此範例假設`TestFile`是包含的結構記錄檔`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 在開啟的檔案`Random`模式中，`Seek`傳回下一筆記錄的數目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`傳回下一項作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 這個範例會使用`Seek`函式，以將位置設定下一個要讀取或寫入檔案。  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`設定下一個作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <param name="Position">Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 傳回介於 1 到 2,147,483,647 之間的值 (相當於 2 ^31-1) 之間，內含。  
  
 以下說明每個檔案存取模式的傳回值：  
  
|模式|傳回值|  
|-|-|  
|`Random`|下一個記錄讀取或寫入的數目|  
|`Binary`、`Input`、`Output``Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。|  
  
   
  
## Examples  
 這個範例會使用`Seek`函數來傳回目前的檔案位置。 此範例假設`TestFile`是包含的結構記錄檔`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 在開啟的檔案`Random`模式中，`Seek`傳回下一筆記錄的數目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`傳回下一項作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 這個範例會使用`Seek`函式，以將位置設定下一個要讀取或寫入檔案。  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`設定下一個作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> can include directory or folder, and drive.</param>
        <param name="Attributes">Required. Constant or numeric expression, whose sum specifies file attributes.</param>
        <summary>Sets attribute information for a file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試設定已開啟之檔案的屬性，就會發生執行階段錯誤。  
  
 `Attributes`引數的列舉值如下所示：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbNormal`|標準模式 （預設值）。|  
|`ReadOnly`|`vbReadOnly`|唯讀。|  
|`Hidden`|`vbHidden`|隱藏。|  
|`System`|`vbSystem`|系統檔案。|  
|`Volume`|`vbVolume`|磁碟區標籤|  
|`Directory`|`vbDirectory`|目錄或資料夾。|  
|`Archive`|`vbArchive`|上次備份之後變更檔案。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉 Visual Basic 語言所指定。 名稱可在您的程式碼，而不是實際的值中的任何地方使用。  
  
   
  
## Examples  
 這個範例會使用`SetAttr`函式來設定檔案的屬性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> type is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Required. The number of spaces to insert before displaying or printing the next expression in a list.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`少於輸出行寬度下, 一個列印位置立即遵循的列印的空格數目。 如果`Count`大於輸出行寬度，`SPC`計算中使用的公式的下一步 列印位置：  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 比方說，如果目前的列印位置為 24，輸出行寬度是 80，且您指定`SPC(90)`下, 一個列印時會啟動位置為 34 （目前的列印位置 + 90/80 的餘數）。 如果目前的列印位置與輸出行寬度之間的差異是小於`Count`(或`Count` `Mod` *寬度*)，則`SPC`函式就會跳到下一行的開頭，並產生空間等於`Count`– (*寬度*– *currentprintposition*)。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以容納寬字母。  
  
   
  
## Examples  
 這個範例會使用`SPC`函式用於定位輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的行上目前的列印位置大於`Column`，`TAB`就會跳到資料行值等於`Column`在下一步 的輸出行。 如果`Column`小於 1，`TAB`的列印位置移至 資料行 1。 如果`Column`大於輸出行寬度，`TAB`計算中使用的公式的下一步 列印位置：  
  
 資料行的 Mod 寬度  
  
 例如，如果*寬度*是 80，且您指定`TAB(90)`下, 一個列印會開始於行 10 （90/80 的餘數）。 如果`Column`小於目前的列印位置，在下一行中的導出的列印位置在列印開始。 如果導出的列印位置大於目前的列印位置，列印會在計算列印位置位於同一行上。  
  
 在輸出行上最左邊的列印位置一律為 1。 當您使用`Print`或是`PrintLine`函數來列印至檔案，最右邊的列印位置是輸出檔，您可以使用設定的目前寬度`FileWidth`函式。  
  
 `TAB`函式也會搭配`WriteLine`函式。 它不能搭配<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以包含廣泛的字母。  
  
   
  
## Examples  
 這個範例會使用`TAB`函式用於定位輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的行上目前的列印位置是否大於`Column`，`TAB`就會跳到資料行值等於`Column`在下一步 的輸出行。 如果`Column`小於 1，`TAB`的列印位置移至 資料行 1。 如果`Column`大於輸出行寬度，`TAB`計算中使用的公式的下一步 列印位置：  
  
 資料行的 Mod 寬度  
  
 例如，如果*寬度*是 80，且您指定`TAB(90)`下, 一個列印會開始於行 10 （90/80 的餘數）。 如果`Column`小於目前的列印位置，在下一行中的導出的列印位置在列印開始。 導出的列印位置是否大於目前的列印位置，列印會在計算列印位置位於同一行上。  
  
 在輸出行上最左邊的列印位置一律為 1。 當您使用`Print`或是`PrintLine`函數來列印至檔案，最右邊的列印位置是輸出檔，您可以使用設定的目前寬度`FileWidth`函式。  
  
 `TAB`函式也會搭配`WriteLine`函式。 它不能搭配<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以包含廣泛的字母。  
  
   
  
## Examples  
 這個範例會使用`TAB`函式用於定位輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。  
  
 不同於`Print`函式，`Write`函式會插入項目和字串的引號之間插入逗號會寫入至檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數字`Boolean`，日期、 null、 和`Error`支援的資料格式。 因此資料一律可以讀取並正確地解譯使用遵循下列通用假設`Input`，而不論地區設定：  
  
-   寫入的數值資料使用句點作為小數分隔符號。  
  
-   針對`Boolean`資料，可以是`#TRUE#`或`#FALSE#`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
-   日期資料會寫入至使用通用的日期格式的檔案。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
-   如果，則不寫入至檔案`Output`是空的資料。 不過，對於 null 資料，`#NULL#`寫入。  
  
-   針對`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。  
  
 `WriteLine` 插入新行字元 (也就是歸位字元/換，或是`Chr(13) + Chr(10)`)，撰寫最後一個字元之後`Output`檔案。  
  
 您也可以使用雙引號括住，在字串中內嵌引號或""。 例如，套用至物件的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 傳回字串，其值為`Double quotation marks aren't "difficult" to handle`。  
  
 寫入檔案，使用`Write`或是`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Write`函式，將原始資料寫入循序檔。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。  
  
 不同於`Print`函式，`Write`函式會插入項目和字串的引號之間插入逗號會寫入至檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數字`Boolean`，日期、 null、 和`Error`支援的資料格式。 因此資料一律可以讀取並正確地解譯使用遵循下列通用假設`Input`，而不論地區設定：  
  
-   寫入的數值資料使用句點作為小數分隔符號。  
  
-   針對`Boolean`資料，可以是`#TRUE#`或`#FALSE#`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
-   日期資料會寫入至使用通用的日期格式的檔案。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
-   如果，則不寫入至檔案`Output`是空的資料。 不過，對於 null 資料，`#NULL#`寫入。  
  
-   針對`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。  
  
 `WriteLine` 插入新行字元 (也就是歸位字元/換，或是`Chr(13) + Chr(10)`)，撰寫最後一個字元之後`Output`檔案。  
  
 您也可以使用雙引號括住，在字串中內嵌引號或""。 例如，套用至物件的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 傳回字串，其值為`Double quotation marks aren't "difficult" to handle`。  
  
 寫入檔案，使用`Write`或是`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Write`函式，將原始資料寫入循序檔。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>