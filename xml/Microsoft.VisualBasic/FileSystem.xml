<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac3ffad84738935580a11dd5acf01cdedc2192d2" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52742113" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="FileSystem" /> 模組包含用於執行檔案、目錄或資料夾及系統等作業的程序。 <see langword="My" /> 功能提供比使用 <see langword="FileSystem" /> 模組更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個模組支援的 Visual Basic 語言關鍵字和存取檔案和資料夾的執行階段程式庫成員。  
  
   
  
## Examples  
 這個範例會使用`GetAttr`函式來判斷檔案和目錄或資料夾的屬性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">目錄和檔案摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">輸入和輸出摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">關鍵字 (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 執行階段程式庫成員</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必要。 <see langword="String" /> 運算式，用來識別要成為新預設目錄或資料夾的目錄或資料夾。 <paramref name="Path" /> 可包括磁碟機。 如果未指定磁碟機，則 <see langword="ChDir" /> 會變更目前磁碟機上的預設目錄或資料夾。</param>
        <summary>變更目前的目錄或資料夾。 <see langword="My" /> 功能提供了比 <see langword="ChDir" /> 函式更強大的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函式會變更預設目錄，但不是在預設的磁碟機。 例如，如果預設磁碟機 C，下列陳述式會變更磁碟機 D 上的預設目錄，但 C 則保持預設的磁碟機：  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 您可以進行相對目錄變更，請輸入兩個句號，如下所示：  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函式需要 unmanaged 程式碼的權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和。  
  
   
  
## Examples  
 這個範例會使用`ChDir`函式來變更目前的目錄或資料夾。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 是空的。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定的磁碟無效，或磁碟無法使用。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">如何：在 Visual Basic 中剖析檔案路徑</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">在 Visual Basic 中建立、刪除和移動檔案和目錄</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>變更目前的磁碟機。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必要。 指定現有磁碟機的字串運算式。 如果您提供長度為零的字串 ("")，則目前的磁碟機將不會變更。 如果 <paramref name="Drive" /> 引數是多個字元的字串，則 <see langword="ChDrive" /> 僅會使用第一個字母。</param>
        <summary>變更目前的磁碟機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函式需要 unmanaged 程式碼的權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱 <<c0> <xref:System.Security.Permissions.SecurityPermission> 並[程式碼存取權限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 這個範例會使用`ChDrive`函式來變更目前的磁碟機。 如果磁碟機不存在，則此函式會擲回例外狀況。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的磁碟無效，或磁碟無法使用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必要。 指定現有磁碟機的字串運算式。 如果您提供長度為零的字串 ("")，則目前的磁碟機將不會變更。 如果 <paramref name="Drive" /> 引數是多個字元的字串，則 <see langword="ChDrive" /> 僅會使用第一個字母。</param>
        <summary>變更目前的磁碟機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函式需要 unmanaged 程式碼的權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱 <<c0> <xref:System.Security.Permissions.SecurityPermission> 並[程式碼存取權限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 這個範例會使用`ChDrive`函式來變更目前的磁碟機。 如果磁碟機不存在，則此函式會擲回例外狀況。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的磁碟無效，或磁碟無法使用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回表示目前路徑的字串。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="CurDir" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回表示目前路徑的字串。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="CurDir" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示目前路徑的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`CurDir`函式來傳回目前的路徑。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">選擇性。 指定現有磁碟機的 <see langword="Char" /> 運算式。 如果未指定磁碟機，或 <paramref name="Drive" /> 是長度為零的字串 ("")，則 <see langword="CurDir" /> 會傳回目前磁碟機的路徑。</param>
        <summary>傳回表示目前路徑的字串。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="CurDir" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示目前路徑的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`CurDir`函式來傳回目前的路徑。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回的字串表示符合指定模式或檔案屬性的檔案、目錄或資料夾的名稱，也可以是磁碟機的磁碟區標籤。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="Dir" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回的字串表示符合指定模式或檔案屬性的檔案、目錄或資料夾的名稱，也可以是磁碟機的磁碟區標籤。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="Dir" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>表示檔案、目錄或資料夾名稱的字串，該字串符合指定的模式或檔案屬性 (Attribute)，也可以是磁碟機的磁碟區標籤 (Label)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 `VbVolume` 傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。  
  
 您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含參數的函式。  
  
> [!IMPORTANT]
>  若要正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>並<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>加上旗標的<xref:System.Security.Permissions.FileIOPermission>要授與執行的程式碼。 如需詳細資訊，請參閱 < <xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，並[程式碼存取權限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`引數的列舉值如下所示：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|預設值： 指定沒有屬性的檔案。|  
|`ReadOnly`|`vbReadOnly`|指定唯讀檔案，以及不需屬性的檔案。|  
|`Hidden`|`vbHidden`|指定隱藏的檔，以及不需屬性的檔案。|  
|`System`|`vbSystem`|指定系統檔案，以及不需屬性的檔案。|  
|`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。|  
|`Directory`|`vbDirectory`|指定目錄或資料夾，以及不需屬性的檔案。|  
|`Archive`|`vbArchive`|前次備份之後，檔案已經有了變更。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉由 Visual Basic 語言，並可用於您的程式碼，而不是實際值的任何位置。  
  
   
  
## Examples  
 這個範例會使用`Dir`函式來檢查特定的檔案和目錄是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">選擇性。 <see langword="String" /> 運算式，可指定檔名、目錄或資料夾名稱或磁碟機的磁碟區標籤。 如果找不到 <paramref name="PathName" />，則會傳回長度為零的字串 (<see langword="&quot;&quot;" />)。</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">選擇性。 列舉類型或數值運算式，其值可指定檔案屬性。 如果省略，則 <see langword="Dir" /> 會傳回符合 <paramref name="PathName" /> 的檔案，但是沒有屬性。</param>
        <summary>傳回的字串表示符合指定模式或檔案屬性的檔案、目錄或資料夾的名稱，也可以是磁碟機的磁碟區標籤。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="Dir" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>表示檔案、目錄或資料夾名稱的字串，該字串符合指定的模式或檔案屬性 (Attribute)，也可以是磁碟機的磁碟區標籤 (Label)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 `VbVolume` 傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。  
  
 您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含任何參數的函式。  
  
> [!IMPORTANT]
>  若要正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>並<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>加上旗標的<xref:System.Security.Permissions.FileIOPermission>要授與執行的程式碼。 如需詳細資訊，請參閱 < <xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，並[程式碼存取權限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`引數的列舉值如下所示：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|預設值： 指定沒有屬性的檔案。|  
|`ReadOnly`|`vbReadOnly`|指定唯讀檔案，除了沒有屬性的檔案。|  
|`Hidden`|`vbHidden`|指定隱藏的檔，除了沒有屬性的檔案。|  
|`System`|`vbSystem`|指定系統檔案，除了沒有屬性的檔案。|  
|`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。|  
|`Directory`|`vbDirectory`|指定目錄或資料夾，以及沒有屬性的檔案。|  
|`Archive`|`vbArchive`|前次備份之後，檔案已經有了變更。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉由 Visual Basic 語言，並可用於您的程式碼來取代實際值的任何位置。  
  
   
  
## Examples  
 這個範例會使用`Dir`函式來檢查特定的檔案和目錄是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含任何有效檔案編號的 <see langword="Integer" />。</param>
        <summary>當已經到達為 <see langword="True" /> 或循序 <see langword="Random" /> 開啟的檔案之結尾時，傳回布林值 (Boolean) <see langword="Input" />。</summary>
        <returns>當已經到達為 <see langword="True" /> 或循序 <see langword="Random" /> 開啟的檔案之結尾時，傳回布林值 (Boolean) <see langword="Input" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`以避免嘗試取得輸入超過檔案結尾所產生的錯誤。  
  
 `EOF`函式會傳回`False`直到達到檔案結尾為止。 使用開啟的檔案`Random`或`Binary`存取`EOF`會傳回`False`直到最後一個執行`FileGet`函式是無法讀取整個記錄。  
  
 使用開啟的檔案`Binary`存取，請嘗試透過檔案使用讀取`Input`運作直到`EOF`傳回`True`會產生錯誤。 使用`LOF`並`Loc`函數，而`EOF`讀取二進位檔案時`Input`，或使用`Get`使用時`EOF`函式。 使用開啟的檔案`Output`，`EOF`一律會傳回`True`。  
  
   
  
## Examples  
 這個範例會使用`EOF`函式來偵測檔案的結尾。 這個範例假設`Testfile`是文字檔案，其中包含幾行文字。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 <see langword="Integer" />. 任何有效的檔案數目。</param>
        <summary>傳回列舉類型，表示使用 <see langword="FileOpen" /> 函式開啟的檔案之檔案模式。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="FileAttr" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>下列列舉類型值表示檔案存取模式： 
 <list type="table"><item><term> 值 
 </term><description> 模式 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函數會傳回代表使用開啟的檔案模式的列舉型別`FileOpen`函式。  
  
   
  
## Examples  
 這個範例會使用`FileAttr`函數來傳回已開啟之檔案的檔案模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">選擇性。 參數陣列，具有 0 個或更多要關閉的通道。</param>
        <summary>將輸入/輸出 (I/O) 結果導向使用 <see langword="FileOpen" /> 函式開啟的檔案。 <see langword="My" /> 提供更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 如何： StreamReader 從檔案讀取文字](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[如何： 將文字寫入檔案以 streamwriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[逐步解說： 中管理檔案和目錄Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。  
  
 如果您省略`FileNumbers`，開啟的所有作用中檔案`FileOpen`函式會關閉。  
  
 當您關閉已開啟的檔案時`Output`或`Append`，最後的緩衝區的輸出會寫入該檔案的作業系統緩衝區。 所有的緩衝區空間的封閉型相關聯檔案釋出。  
  
 當`FileClose`函式執行、 其檔案的檔案的關聯數字結尾。  
  
   
  
## Examples  
 這個範例會使用`FileClose`函式，以關閉 檔案開啟為`Input`。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End 陳述式</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop 陳述式 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必要。 <see langword="String" /> 運算式，指定要複製的檔案名稱。 <paramref name="Source" /> 可包括原始程式檔的目錄或資料夾及磁碟機。</param>
        <param name="Destination">必要。 <see langword="String" /> 運算式，指定目標檔案名稱。 <paramref name="Destination" /> 可包括目的檔案的目錄或資料夾及磁碟機。</param>
        <summary>複製檔案。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="FileCopy" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試使用`FileCopy`函式在目前開啟的檔案，則會發生錯誤。  
  
 `FileCopy` 需要完全信任才能在本機的磁碟機上運作。  
  
   
  
## Examples  
 這個範例會使用`FileCopy`函式複製到另一個檔案。 基於此範例的詳細資訊，假設`SrcFile`是包含資料的檔案。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> 或 <paramref name="Destination" /> 為無效值或尚未指定。</exception>
        <exception cref="T:System.IO.IOException">檔案已經開啟。</exception>
        <exception cref="T:System.IO.FileNotFoundException">檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">如何：在 Visual Basic 中於不同資料夾內建立檔案複本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">如何：在 Visual Basic 中於相同目錄內建立檔案複本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">如何：在 Visual Basic 中將目錄複製到另一個目錄</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔名的 <see langword="String" /> 運算式。 <paramref name="PathName" /> 可能包括目錄或資料夾及磁碟機。</param>
        <summary>傳回 <see langword="Date" /> 值，表示寫入檔案的日期和時間。 相較於 <see langword="FileDateTime" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Date" /> 值，表示建立檔案或上次修改檔案的日期和時間。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`FileDateTime`建立函式來判斷日期和時間的檔案或上次修改檔案。 格式的日期和時間顯示為基礎的系統地區設定。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> 無效或包含萬用字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目標檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果不使用描述項。 則的大小和陣列的界限傳遞到`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會寫入的檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要為字串寫入描述長度的雙位元組描述元。 預設值為 <see langword="False" />。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="ArrayIsDynamic">選擇性。 只有在編寫陣列時才適用。 指定是否將陣列視為動態 (Dynamic)，以及是否有必要指定描述陣列大小和界限的陣列描述元。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要為字串寫入描述長度的雙位元組描述元。 預設值為 <see langword="False" />。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一步 的資料錄或最後一個位元組`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGet`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，在讀入的變數是一個字串，如果`FileGet`讀取雙位元組描述元，其中包含字串的長度，並接著會讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度的字串;置入檔案時，不寫入的長度描述元。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，您可以選擇是否要讀取的大小和陣列的維度的描述元。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 當讀取陣列，您一定要相符寫入陣列的方式。 如果它具有描述元所撰寫，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`判斷要讀取的項目。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果被讀入到變數是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePut`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目所需的所有位元組的總和。 這包括任何陣列和其描述項。 `VBFixedString`屬性可以套用至字串欄位中指出的大小字串寫入時的結構至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGet` 從磁碟讀取所有的變數時，也將連續;也就不含之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 不讀取任何描述項。  
  
-   `FileGet` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  使用 從檔案讀取`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。  相較於 <see langword="FileGetObject" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`而不是使用函式`FileGet`若要避免模稜兩可在編譯時期，如果型別`Object`傳回而不是另一個類型，例如`Integer`， `Long`， `Short`，依此類推。  
  
 如果您想要寫出`Variant`型別，`FileGetObject`需要。 有疑問，如果您使用物件來作為第二個參數，一律建議您改用`FilePutObject`和`FileGetObject`。  
  
 `FileGetObject` 只有在有效`Random`和`Binary`模式。  
  
 讀取的資料`FileGetObject`通常會使用寫入`FilePutObject`。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`，`FileGetObject`讀取最後一個之後的資料錄或位元組`FileGetObject`或是`FilePutObject`函式 (或最後一個指向`Seek`函式)。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   正在讀取資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FileGetObject`讀取後續的記錄資料錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開頭之間的空間。 因為填補資料的數量無法精確地判斷，所以最好有符合所讀取的資料長度的資料錄長度。  
  
-   正在讀取到變數是否為字串，預設`FileGetObject`讀取雙位元組描述元包含字串的長度，然後再讀取變數的資料。 因此，所指定的記錄長度`RecordLength`子句`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 和更早版本支援固定長度字串和讀取檔案時，長度的描述項不會寫入。 如果您想要讀取描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果正在讀入的變數陣列，則所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目： 2 + 8 * NumberOfDimensions。  
  
     比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟：  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 個位元組會分散，如下所示： 18 位元組描述元 (2 + 8 * 2)，以及 100 個位元組 (5 * 10 * 4) 的資料。  
  
-   `FileGetObject` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (以`FilePutObject`) 加上其長度會等於 2 加上 8 倍的維度數目的描述元： 2 + 8 * NumberOfDimensions。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於讀取個別的項目，包括任何陣列和其描述項所需的所有位元組的總和。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>類別，可指出的大小字串寫入時的結構中的字串欄位套用至磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，所有`Random`套用規則，但有下列例外：  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FileGetObject` 所有連續讀取變數，從磁碟，也就是記錄之間的不帶填補。  
  
-   在結構中，陣列以外的所有陣列`FileGetObject`讀取的資料。 不讀取任何描述項。  
  
 `FileGetObject` 讀取可變長度的字串不是結構，而不需要雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不是 Visual Basic 來源檔案。  
  
   
  
## Examples  
 下列範例讀入測試檔案中的記錄，然後擷取它。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔案的 <see langword="String" /> 運算式。 <paramref name="PathName" /> 可能包括目錄或資料夾及磁碟機。</param>
        <summary>傳回 <see langword="Long" /> 值，指定檔案的長度 (以位元組為單位)。 相較於 <see langword="FileLen" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Long" /> 指定檔案長度的值 (以位元組為單位)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的檔案時，開啟`FileLen`函式呼叫，傳回的值代表檔案的大小，在它已開啟的時間。  
  
> [!NOTE]
>  若要取得目前已開啟之檔案的長度，請使用`LOF`函式。  
  
   
  
## Examples  
 這個範例會使用`FileLen`函數來傳回檔案的長度，以位元組為單位。 基於此範例的詳細資訊，假設`TestFile`是包含某些資料的檔案。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。 使用 <see langword="FreeFile" /> 函式取得下一個可用的檔案編號。</param>
        <param name="FileName">必要。 <see langword="String" /> 運算式，可指定檔名，也可能包括目錄或資料夾及磁碟機。</param>
        <param name="Mode">必要。 指定檔案模式的列舉類型：<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" /> 或 <see langword="Random" />  如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.OpenMode" />。</param>
        <param name="Access">選擇性。 指定開啟檔案上允許的作業之列舉類型：<see langword="Read" />、<see langword="Write" /> 或 <see langword="ReadWrite" />。 預設值為 <see langword="ReadWrite" />。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.OpenAccess" />。</param>
        <param name="Share">選擇性。 指定開啟的檔案上其他處理序不允許之作業的列舉類型：<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" /> 和 <see langword="Lock Read Write" />。 預設值為 <see langword="Lock Read Write" />。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.OpenShare" />。</param>
        <param name="RecordLength">選擇性。 數字小於或等於 32,767 (位元組)。 對於為隨機存取開啟的檔案而言，這個值是資料錄長度。 對於循序檔案而言，這個值是緩衝的字元數。</param>
        <summary>開啟要當做輸入或輸出的檔案。 相較於 <see langword="FileOpen" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 您必須開啟檔案，才能在其上執行任何 I/O 作業。 `FileOpen` 會針對 I/O 配置緩衝區至檔案，並判斷權限與緩衝區使用的模式。  
  
> [!IMPORTANT]
>  寫入至檔案時，應用程式可能要建立檔案，如果嘗試寫入的檔案不存在。 若要這樣做，它會需要權限的 建立檔案的目錄。 不過，如果指定的檔案`FileName`存在，應用程式需求`Write`只對檔案本身的權限。 盡量，以協助改善安全性、 部署和授與期間建立檔案的任一處`Write`該檔案的權限唯一的而不是整個目錄。 若要改善安全性，請將資料寫入使用者目錄，而不是目錄的根目錄或 Program Files 目錄。  
  
 若要開啟的通道可使用`FreeFile()`函式。  
  
> [!IMPORTANT]
>  `FileOpen`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 此範例說明的各種用法`FileOpen`函式可讓輸入與輸出至檔案。  
  
 下列程式碼會開啟檔案`TestFile`在`Input`模式。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 此範例會開啟中的檔案`Binary`模式只允許寫入作業。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下列範例會開啟中的檔案`Random`模式。 檔案包含的結構記錄`Person`。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 此程式碼範例會開啟中的檔案`Output`模式; 任何程序可以讀取或寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 此程式碼範例會開啟中的檔案`Binary`模式進行讀取，其他處理序無法讀取檔案。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">資料錄的長度為負數 (而且不等於 -1)。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> 已經開啟，或 <paramref name="FileName" /> 無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要針對檔案的字串編寫二位元組字串長度的描述元。 預設值為 <see langword="False" />。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="ArrayIsDynamic">選擇性。 只有在編寫陣列時才適用。 指定陣列是否要視為動態 (Dynamic)，以及是否要針對描述長度的字串編寫陣列描述元。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要針對檔案的字串編寫二位元組字串長度的描述元。 預設值為 <see langword="False" />。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`下, 一個資料錄或最後一個之後的位元組`FileGet`或是`FilePut`函式，或指向最後一個`Seek`撰寫函式時。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePut` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法任何確定地決定填補資料的數量，通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入雙位元組描述元包含字串的長度，並再寫入變數的資料。 因此，所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是至少在兩個位元組大於字串的實際長度。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePut`寫入兩個位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，您會有關於要寫入的大小和陣列維度的描述元的選擇。 Visual Basic 6.0 和更早版本撰寫的動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述項。 若要寫入的描述元，將`ArrayIsDynamic`參數來`True`。 在撰寫時的陣列，您必須比對會讀取陣列; 的方式它會讀取具有描述元，如果您有寫入描述項。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 比方說，下列陣列宣告需要 218 的位元組陣列寫入至磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果要寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於所寫入的資料長度。  
  
-   `FilePut` 如同寫入每個個別但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位中的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串已超過所指定位元組數目的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，大部分的`Random`模式規則的套用，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式與不同的規則`Random`模式︰  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入不是雙位元組長度描述項的結構元素的可變長度的字串。 寫入的位元組數目等於字串中的字元數目。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式，將資料寫入檔案。 結構的五筆記錄`Person`會寫入至檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。  相較於 <see langword="FilePutObject" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`而不是使用函式`FilePut`若要避免模稜兩可在編譯時期，如果型別`Object`傳遞，而另一個類型，例如`Integer`， `Long`， `Short`，依此類推。  
  
 `FilePutObject` 寫入，並讀取描述物件的描述元。 如果您想要寫出`Variant`型別，`FilePutObject`需要。 如有疑問，如果您使用物件來作為第二個參數，我們建議您一律使用`FilePutObject`和`FileGetObject`。  
  
 `FilePutObject` 只有在有效`Random`和`Binary`模式。  
  
 使用 `FilePutObject` 寫入的資料，通常會透過使用 `FileGetObject` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組在位置 1，第二個資料錄或位元組位於位置 2，依此類推。 如果您省略`RecordNumber`，`FilePutObject`寫入最後一個之後的下一步 的資料錄或位元組`FileGetObject`或是`FilePutObject`函式 (或資料錄或位元組所指的最後一個`Seek`函式)。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定的長度。 `FilePutObject` 引數時，會將寫入的長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`具有`FilePutObject`，您必須執行相同的`FileGetObject`，和您也必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機的模式  
 在開啟的檔案的`Random`模式中，適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePutObject`將後續的記錄寫入記錄長度界限上。 檔案緩衝區的現有內容填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 填補資料的數量無法精確地判斷，因為它通常是個不錯的主意，具有符合要寫入的資料長度的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式擲回例外狀況。  
  
-   如果要寫入的變數是物件，包含數值的型別，`FilePutObject`寫入兩個位元組，識別`VarType`物件的然後將寫入的變數。 比方說，撰寫物件時，包含整數`FilePutObject`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 和包含資料的四個位元組。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果寫入的變數是包含字串、 物件`FilePutObject`寫入雙位元組描述元，識別`VarType(8)`的物件，表示的字串，然後再寫入字串資料長度的雙位元組描述元。 所指定的記錄長度`RecordLength`中的參數`FileOpen`函式必須是至少在四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，而您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數陣列，則所指定的記錄長度`RecordLength`子句中的`FileOpen`函式必須是大於或等於要寫入的陣列資料和陣列描述元所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2，再加上 8 倍的維度數目: (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟的檔案`Binary`模式中，所有`Random`套用模式的規則，除了：  
  
-   `RecordLength`子句中的`FileOpen`函式沒有任何作用。 `FilePutObject` 將所有的變數，連續地寫入磁碟，也就是沒有記錄之間的填補。  
  
   
  
## Examples  
 這個範例會使用`FilePutObject`函式來將字串寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="RecordWidth">必要。 0–255 範圍內的數值運算式 (包含頭尾)，表示在開始新行之前，會有多少字元出現在一行上。 如果 <paramref name="RecordWidth" /> 等於 0，則一行的長度將沒有限制。 <paramref name="RecordWidth" /> 的預設值為 0。</param>
        <summary>為藉由使用 <see langword="FileOpen" /> 函式開啟的檔案指派輸出行寬度。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`FileWidth`函式來設定輸出行寬度的檔案。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see langword="Integer" /> 值，表示可供 <see langword="FileOpen" /> 函式使用的下一個可用的檔案編號。</summary>
        <returns>傳回 <see langword="Integer" /> 值，表示可供 <see langword="FileOpen" /> 函式使用的下一個可用的檔案編號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`提供尚未使用的檔案數字。  
  
   
  
## Examples  
 這個範例會使用`FreeFile`函式傳回下一個可用的檔案數目。 輸出，在迴圈內，開啟五個檔案和一些範例資料會寫入每一個。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">使用中的檔案超過 255 個。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔案、目錄或資料夾名稱的 <see langword="String" /> 運算式。 <paramref name="PathName" /> 可包含目錄或資料夾，以及磁碟機。</param>
        <summary>傳回 <see langword="FileAttribute" /> 值，表示檔案、目錄或資料夾的屬性。 相較於 <see langword="FileAttribute" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>
          <see langword="GetAttr" /> 傳回的值是以下列舉值的總和： 
 <list type="table"><item><term> 值 
 </term><description> 常數 
 </description><description> 描述 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 一般。  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 唯讀。  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 隱藏。  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> 系統檔案。  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> 目錄或資料夾。  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> 前次備份之後，檔案已經有了變更。  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> 檔案有不同的名稱。  
  
 </description></item></list><block subset="none" type="note"><para>  
 這些列舉類型 (Enumeration) 是由 Visual Basic 語言所指定。 您可在程式碼中的任何地方使用這些名稱來取代實際值。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷設定了哪些屬性，請使用`And`運算子來執行所傳回的值的位元比較`GetAttr`函式和您想要個別的檔案屬性的值。 如果結果不是零，該屬性是設定具名的檔案。 例如，下列的傳回值`And`運算式是零，如果`Archive`未設定屬性：  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 會傳回非零值，如果`Archive`屬性設定。  
  
   
  
## Examples  
 這個範例會使用`GetAttr`函式來判斷檔案和目錄或資料夾的屬性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> 無效或包含萬用字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目標檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And 運算子 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有一些使用寫入的資料行`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有一些使用寫入的資料行`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準的字串或數值資料會指派給變數，而不需修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所代表的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，停止輸入，而發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 比方說，在德文版中，如果您輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`置於兩個變數，從檔案讀取資料的函式。 這個範例假設`TestFile`是一個檔案，有數行的資料寫入至其中使用`Write`函式，每一行包含引號，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="CharCount">必要。 任何有效的數值運算式，指定要讀取的字元數。</param>
        <summary>傳回 <see langword="String" /> 值，其中包含於 <see langword="Input" /> 或 <see langword="Binary" /> 模式下開啟之檔案中的字元。 相較於 <see langword="InputString" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>傳回 <see langword="String" /> 值，其中包含於 <see langword="Input" /> 或 <see langword="Binary" /> 模式下開啟之檔案中的字元。 相較於 <see langword="InputString" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`InputString`函式通常利用寫入至檔案`Print`或`FilePut`。 此函式只適用於在開啟的檔案`Input`或`Binary`模式。  
  
 不同於`Input`函式，`InputString`函式會傳回讀取的字元。 這包括逗號、 換行字元、 換行、 引號和前置空格。  
  
 使用開啟的檔案`Binary`存取，嘗試讀取檔案，使用`InputString`運作直到`EOF`傳回`True`會產生錯誤。 使用`LOF`並`Loc`函數，而`EOF`藉由讀取二進位檔案時`InputString`，或使用`FileGet`當您使用`EOF`函式。  
  
> [!NOTE]
>  從檔案讀取時，請勿依據副檔名的檔案內容的相關安全性決策。 例如，名為 Form1.vb 檔案可能不是 Visual Basic 來源檔案。  
  
   
  
## Examples  
 這個範例會使用`InputString`函式來從檔案一次讀取一個字元，並列印它`Output`視窗。 這個範例假設`MyFile`是具有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 或 &gt; 214。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 <see langword="String" /> 運算式，指定要刪除的一個或多個檔案的名稱。 <paramref name="PathName" /> 可包含目錄或資料夾，以及磁碟機。</param>
        <summary>從磁碟中刪除檔案。 相較於 <see langword="Kill" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 **安全性注意事項**才能執行，請`Kill`函式需要`Read`並`PathDiscovery`加上旗標的<xref:System.Security.Permissions.FileIOPermission>要授與執行的程式碼。 如需詳細資訊，請參閱 < <xref:System.Security.SecurityException>[程式碼存取權限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 這個範例會使用`Kill`函式來從磁碟中刪除檔案。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目標檔案已開啟。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到目標檔案。</exception>
        <exception cref="T:System.Security.SecurityException">權限遭拒。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <summary>從開啟的循序檔案中讀取單一行，並將它指派給 <see langword="String" /> 變數。</summary>
        <returns>從開啟的循序檔案中讀取單一行，並將它指派給 <see langword="String" /> 變數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 讀取的資料`LineInput`通常會先寫入至檔案使用`Print`。  
  
> [!IMPORTANT]
>  從檔案讀取時，請勿根據檔案名稱副檔名的檔案內容的相關決策。 例如，名為 Form1.vb 檔案可能不會是 Visual Basic 來源檔案。  
  
 `LineInput`函式會從檔案的一個字元讀取一次直到遇到歸位字元 (`Chr(13)`) 或歸位字元/換 (`Chr(13) + Chr(10)`) 順序。 歸位字元 return/line 摘要的序列會略過而不是附加的字元字串。  
  
> [!IMPORTANT]
>  使用 從檔案讀取`LineInput`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`LineInput`從循序檔案讀取一行，並將它指派給變數的函式。 這個範例假設`TestFile`是具有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到達檔案結尾。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的 <see langword="Integer" /> 檔案編號。</param>
        <summary>傳回 <see langword="Long" /> 值，指定開啟檔案中目前的讀取/寫入位置。</summary>
        <returns>傳回 <see langword="Long" /> 值，指定開啟檔案中目前的讀取/寫入位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`為以零為起始的函式，使用它來擷取檔案中的第一個位元組，則會傳回 0。  
  
 `Loc`函式會提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 以下說明每個檔案存取模式的傳回值：  
  
|模式|傳回值|  
|-|-|  
|`Random`|讀取或寫入檔案的最後一個記錄的數目。|  
|`Sequential`|除以 128 檔案中的目前位元組位置。 不過，資訊會由`Loc`的循序檔案不會使用或所需。|  
|`Binary`|讀取或寫入的最後一個位元組的位置。|  
  
   
  
## Examples  
 這個範例會使用`Loc`函式來傳回目前的讀取/寫入位置，在開啟的檔案。 這個範例假設`MyFile`是具有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Record">選擇性。 要鎖定或解除鎖定的唯一資料錄或位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="FromRecord">選擇性。 要鎖定或解除鎖定的第一筆資料錄或第一個位元組的編號。</param>
        <param name="ToRecord">選擇性。 要鎖定或解除鎖定的最後一筆資料錄或最後一個位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含有效檔案編號的 <see langword="Integer" />。</param>
        <summary>傳回 <see langword="Long" />，表示使用 <see langword="FileOpen" /> 函式開啟之檔案之大小 (以位元組為單位)。 相較於 <see langword="LOF" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>傳回 <see langword="Long" />，表示使用 <see langword="FileOpen" /> 函式開啟之檔案之大小 (以位元組為單位)。 相較於 <see langword="LOF" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FileLen`函式來取得未開啟檔案的長度。  
  
   
  
## Examples  
 這個範例會使用`LOF`函式來判斷已開啟之檔案的大小。 這個範例假設`TestFile`是文字檔案，其中包含範例資料。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必要。 <see langword="String" /> 運算式，可識別要建立的目錄。 <paramref name="Path" /> 可包含磁碟機。 如果未指定磁碟機，則 <see langword="MkDir" /> 會在目前磁碟機上建立新目錄。</param>
        <summary>建立新目錄。 相較於 <see langword="MkDir" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函式會建立新的目錄。  
  
   
  
## Examples  
 這個範例會使用`MkDir`函式來建立目錄。 如果未指定磁碟機，在目前的磁碟機上建立新的目錄。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 尚未指定或是空的。</exception>
        <exception cref="T:System.Security.SecurityException">權限遭拒。</exception>
        <exception cref="T:System.IO.IOException">目錄已經存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">如何：在 Visual Basic 中建立目錄</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Output">選擇性。 要寫入檔案的零或多個逗點分隔運算式。  
  
<paramref name="Output" /> 引數設定為︰ 
 <see langword="T:System.IO.IOException" />︰檔案模式無效。  
  
 <see langword="T:System.IO.IOException" />：<paramref name="FileNumber" /> 不存在。</param>
        <summary>將顯示格式資料寫入循序檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包含換行字元結尾的行不過，`PrintLine`包含換行字元。  
  
 資料寫入`Print`通常從檔案讀取利用`LineInput`或`Input`。  
  
 如果您省略`Output`for `PrintLine`，列印一行空白行檔案; 如`Print`，沒有輸出。 多個以逗號分隔的運算式將會對齊索引標籤的界限，但混用逗號和`TAB`可能會導致不一致的結果。  
  
 針對`Boolean`資料，可以是`True`或`False`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
 日期資料寫入檔案中，使用您的系統可辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
 如果，則不寫入至檔案`Output`是空的資料。 不過，如果`Output`清單中的資料`DBNull`，`Null`寫入檔案。  
  
 針對`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定不會轉譯關鍵字。  
  
 寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的小數分隔符號。 如果使用者想要輸出多個地區設定中，供資料`Write`應該使用。  
  
 寫入檔案，使用`Print`或是`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Print`和`PrintLine`函式，將資料寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Output">選擇性。 要寫入檔案的零或多個逗點分隔運算式。  
  
<paramref name="Output" /> 引數設定為︰ 
 <see langword="T:System.IO.IOException" />︰檔案模式無效。  
  
 <see langword="T:System.IO.IOException" />：<paramref name="FileNumber" /> 不存在。</param>
        <summary>將顯示格式資料寫入循序檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包含換行字元結尾的行不過，`PrintLine`包含換行字元。  
  
 資料寫入`Print`通常從檔案讀取利用`LineInput`或`Input`。  
  
 如果您省略`Output`for `PrintLine`，列印一行空白行檔案; 如`Print`，沒有輸出。 多個以逗號分隔的運算式將會對齊索引標籤的界限，但混用逗號和`TAB`可能會導致不一致的結果。  
  
 針對`Boolean`資料，可以是`True`或`False`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
 日期資料寫入檔案中，使用系統可辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
 如果，則不寫入至檔案`Output`是空的資料。 不過，如果`Output`清單中的資料`DBNull`，`Null`寫入檔案。  
  
 針對`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定不會轉譯關鍵字。  
  
 寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的小數分隔符號。 如果使用者想要輸出多個地區設定中，供資料`Write`應該使用。  
  
 寫入檔案，使用`Print`或是`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Print`和`PrintLine`函式，將資料寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必要。 <see langword="String" /> 運算式，指定現有的檔案名稱和位置。 <paramref name="OldPath" /> 可包括檔案的目錄及磁碟機。</param>
        <param name="NewPath">必要。 <see langword="String" /> 運算式，指定新檔案的名稱和位置。 <paramref name="NewPath" /> 可包括目的位置的目錄及磁碟機。 <paramref name="NewPath" /> 指定的檔案名稱不能已經存在。</param>
        <summary>重新命名磁碟的檔案或目錄。 相較於 <see langword="Rename" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`函式重新命名檔案，並將它移到另一個目錄，如有必要。 `Rename`函式可以將檔案移到磁碟機，但它只能重新命名現有的目錄時兩者`NewPath`和`OldPath`都位於相同的磁碟機。 `Rename` 無法建立新的檔案或目錄。  
  
 使用`Rename`函式開啟的檔案會產生錯誤。 您必須先關閉開啟的檔案，才能重新命名。 `Rename` 引數不能包含多個字元 （*） 和單一字元 （？） 的萬用字元。  
  
> [!IMPORTANT]
>  當使用`Rename`將來自未受保護位置的檔案複製到受保護的位置中，該檔案會保留的限制較少的權限。 請檢查以確定未造成可能的安全性風險。  
  
   
  
## Examples  
 這個範例會使用`Rename`函式來重新命名檔案。 基於此範例的詳細資訊，請假設已指定的目錄已經存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路徑無效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> 檔案不存在。</exception>
        <exception cref="T:System.IO.IOException">無法重新命名為不同的裝置。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">如何：在 Visual Basic 中重新命名檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉所有使用 <see langword="FileOpen" /> 函式開啟的磁碟檔案。 相較於 <see langword="Reset" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`函式會關閉開啟的所有作用中檔案`FileOpen`函式，並具有相同的功能`FileClose()`不含任何參數。  
  
   
  
## Examples  
 這個範例會使用`Reset`函式來關閉所有開啟的檔案並寫入磁碟中的所有檔案緩衝區的內容。 請注意，使用`Object`變數`FileNumber`做為字串和數字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End 陳述式</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必要。 <see langword="String" /> 運算式，可識別要移除的目錄或資料夾。 <paramref name="Path" /> 可包括磁碟機。 如果未指定磁碟機，則 <see langword="RmDir" /> 會移除目前磁碟機上的目錄。</param>
        <summary>移除現有的目錄。 相較於 <see langword="RmDir" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試使用，就會發生錯誤`RmDir`包含檔案的目錄。 使用`Kill`函式來刪除所有檔案，然後再移除目錄。  
  
   
  
## Examples  
 這個範例會使用`RmDir`函式以移除現有的目錄。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 尚未指定或是空的。</exception>
        <exception cref="T:System.IO.IOException">目標目錄包含檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目錄不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。 相較於 <see langword="Seek" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含有效檔案編號的 <see langword="Integer" />。</param>
        <summary>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。 相較於 <see langword="Seek" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 傳回介於 1 到 2,147,483,647 之間的值 (相當於 2 ^31-1) 之間，內含。  
  
 以下說明每個檔案存取模式的傳回值：  
  
|模式|傳回值|  
|-|-|  
|`Random`|下一個記錄讀取或寫入的數目|  
|`Binary`, `Input`, `Output`, `Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。|  
  
   
  
## Examples  
 這個範例會使用`Seek`函數來傳回目前的檔案位置。 此範例假設`TestFile`是包含的結構記錄檔`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 在開啟的檔案`Random`模式中，`Seek`傳回下一筆記錄的數目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`傳回下一項作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 這個範例會使用`Seek`函式，以將位置設定下一個要讀取或寫入檔案。  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`設定下一個作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含有效檔案編號的 <see langword="Integer" />。</param>
        <param name="Position">必要。 在 1–2,147,483,647 範圍之間的數字 (包括頭尾)，表示應該發生下一個讀取 / 寫入作業的位置。</param>
        <summary>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。 相較於 <see langword="Seek" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 傳回介於 1 到 2,147,483,647 之間的值 (相當於 2 ^31-1) 之間，內含。  
  
 以下說明每個檔案存取模式的傳回值：  
  
|模式|傳回值|  
|-|-|  
|`Random`|下一個記錄讀取或寫入的數目|  
|`Binary`, `Input`, `Output`, `Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。|  
  
   
  
## Examples  
 這個範例會使用`Seek`函數來傳回目前的檔案位置。 此範例假設`TestFile`是包含的結構記錄檔`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 在開啟的檔案`Random`模式中，`Seek`傳回下一筆記錄的數目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`傳回下一項作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 這個範例會使用`Seek`函式，以將位置設定下一個要讀取或寫入檔案。  
  
 以外的其他模式中開啟之檔案`Random`模式中，`Seek`設定下一個作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">在 Visual Basic 中讀取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">在 Visual Basic 中寫入檔案</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔名的 <see langword="String" /> 運算式。 <paramref name="PathName" /> 可包括目錄或資料夾及磁碟機。</param>
        <param name="Attributes">必要。 常數或數值運算式，其總和可以表示檔案屬性。</param>
        <summary>設定檔案的屬性 (Attribute) 資訊。 相較於 <see langword="SetAttr" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試設定已開啟之檔案的屬性，就會發生執行階段錯誤。  
  
 `Attributes`引數的列舉值如下所示：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbNormal`|標準模式 （預設值）。|  
|`ReadOnly`|`vbReadOnly`|唯讀。|  
|`Hidden`|`vbHidden`|隱藏。|  
|`System`|`vbSystem`|系統檔案。|  
|`Volume`|`vbVolume`|磁碟區標籤|  
|`Directory`|`vbDirectory`|目錄或資料夾。|  
|`Archive`|`vbArchive`|前次備份之後，檔案已經有了變更。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉類型 (Enumeration) 是由 Visual Basic 語言所指定。 名稱可在您的程式碼，而不是實際的值中的任何地方使用。  
  
   
  
## Examples  
 這個範例會使用`SetAttr`函式來設定檔案的屬性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> 類型無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必要。 在顯示或列印清單中的下一個運算式之前所要插入的空格數。</param>
        <summary>搭配 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式使用，以定位輸出。</summary>
        <returns>搭配 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式使用，以定位輸出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`少於輸出行寬度下, 一個列印位置立即遵循的列印的空格數目。 如果`Count`大於輸出行寬度，`SPC`計算中使用的公式的下一步 列印位置：  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 比方說，如果目前的列印位置為 24，輸出行寬度是 80，且您指定`SPC(90)`下, 一個列印時會啟動位置為 34 （目前的列印位置 + 90/80 的餘數）。 如果目前的列印位置與輸出行寬度之間的差異是小於`Count`(或`Count` `Mod` *寬度*)，則`SPC`函式就會跳到下一行的開頭，並產生空間等於`Count`– (*寬度*– *currentprintposition*)。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以容納寬字母。  
  
   
  
## Examples  
 這個範例會使用`SPC`函式用於定位輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 運算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</summary>
        <returns>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的行上目前的列印位置大於`Column`，`TAB`就會跳到資料行值等於`Column`在下一步 的輸出行。 如果`Column`小於 1，`TAB`的列印位置移至 資料行 1。 如果`Column`大於輸出行寬度，`TAB`計算中使用的公式的下一步 列印位置：  
  
 資料行的 Mod 寬度  
  
 例如，如果*寬度*是 80，且您指定`TAB(90)`下, 一個列印會開始於行 10 （90/80 的餘數）。 如果`Column`小於目前的列印位置，在下一行中的導出的列印位置在列印開始。 如果導出的列印位置大於目前的列印位置，列印會在計算列印位置位於同一行上。  
  
 在輸出行上最左邊的列印位置一律為 1。 當您使用`Print`或是`PrintLine`函數來列印至檔案，最右邊的列印位置是輸出檔，您可以使用設定的目前寬度`FileWidth`函式。  
  
 `TAB`函式也會搭配`WriteLine`函式。 它不能搭配<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以包含廣泛的字母。  
  
   
  
## Examples  
 這個範例會使用`TAB`函式用於定位輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 運算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">選擇性。 在顯示或列印清單中的下一個運算式之前所要移至的欄位編號。 如果省略，則 <see langword="TAB" /> 會將插入點移到下一個列印區 (Print Zone) 的開頭。</param>
        <summary>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</summary>
        <returns>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的行上目前的列印位置是否大於`Column`，`TAB`就會跳到資料行值等於`Column`在下一步 的輸出行。 如果`Column`小於 1，`TAB`的列印位置移至 資料行 1。 如果`Column`大於輸出行寬度，`TAB`計算中使用的公式的下一步 列印位置：  
  
 資料行的 Mod 寬度  
  
 例如，如果*寬度*是 80，且您指定`TAB(90)`下, 一個列印會開始於行 10 （90/80 的餘數）。 如果`Column`小於目前的列印位置，在下一行中的導出的列印位置在列印開始。 導出的列印位置是否大於目前的列印位置，列印會在計算列印位置位於同一行上。  
  
 在輸出行上最左邊的列印位置一律為 1。 當您使用`Print`或是`PrintLine`函數來列印至檔案，最右邊的列印位置是輸出檔，您可以使用設定的目前寬度`FileWidth`函式。  
  
 `TAB`函式也會搭配`WriteLine`函式。 它不能搭配<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以包含廣泛的字母。  
  
   
  
## Examples  
 這個範例會使用`TAB`函式用於定位輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 運算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Record">選擇性。 要鎖定或解除鎖定的唯一資料錄或位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="FromRecord">選擇性。 要鎖定或解除鎖定的第一筆資料錄或第一個位元組的編號。</param>
        <param name="ToRecord">選擇性。 要鎖定或解除鎖定的最後一筆資料錄或最後一個位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會在配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`都未提供，鎖定將會針對整個檔案。 如果`Record`單獨指定單一資料錄將會鎖定/解除鎖定。  
  
 如果已為循序的輸入或輸出中，開啟檔案`Lock`並`Unlock`影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含的結構記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含任何有效檔案數目的 <see langword="Integer" /> 運算式。</param>
        <param name="Output">選擇性。 要寫入檔案的一或多個逗點分隔運算式。</param>
        <summary>將資料寫入循序檔。 使用 <see langword="Write" /> 寫入的資料，通常會透過使用 <see langword="Input" /> 從檔案讀取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。  
  
 不同於`Print`函式，`Write`函式會插入項目和字串的引號之間插入逗號會寫入至檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數字`Boolean`，日期、 null、 和`Error`支援的資料格式。 因此資料一律可以讀取並正確地解譯使用遵循下列通用假設`Input`，而不論地區設定：  
  
-   寫入的數值資料使用句點作為小數分隔符號。  
  
-   針對`Boolean`資料，可以是`#TRUE#`或`#FALSE#`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
-   日期資料會寫入至使用通用的日期格式的檔案。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
-   如果，則不寫入至檔案`Output`是空的資料。 不過，對於 null 資料，`#NULL#`寫入。  
  
-   針對`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。  
  
 `WriteLine` 插入新行字元 (也就是歸位字元/換，或是`Chr(13) + Chr(10)`)，撰寫最後一個字元之後`Output`檔案。  
  
 您也可以使用雙引號括住，在字串中內嵌引號或""。 例如，套用至物件的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 傳回字串，其值為`Double quotation marks aren't "difficult" to handle`。  
  
 寫入檔案，使用`Write`或是`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Write`函式，將原始資料寫入循序檔。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含任何有效檔案數目的 <see langword="Integer" /> 運算式。</param>
        <param name="Output">選擇性。 要寫入檔案的一或多個逗點分隔運算式。</param>
        <summary>將資料寫入循序檔。 使用 <see langword="Write" /> 寫入的資料，通常會透過使用 <see langword="Input" /> 從檔案讀取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函式針對回溯相容性提供，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱 <<c0> [ 使用 Visual Basic 存取檔案](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。  
  
 不同於`Print`函式，`Write`函式會插入項目和字串的引號之間插入逗號會寫入至檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數字`Boolean`，日期、 null、 和`Error`支援的資料格式。 因此資料一律可以讀取並正確地解譯使用遵循下列通用假設`Input`，而不論地區設定：  
  
-   寫入的數值資料使用句點作為小數分隔符號。  
  
-   針對`Boolean`資料，可以是`#TRUE#`或`#FALSE#`列印。 `True`和`False`關鍵字不會轉譯，不論地區設定為何。  
  
-   日期資料會寫入至使用通用的日期格式的檔案。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
-   如果，則不寫入至檔案`Output`是空的資料。 不過，對於 null 資料，`#NULL#`寫入。  
  
-   針對`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。  
  
 `WriteLine` 插入新行字元 (也就是歸位字元/換，或是`Chr(13) + Chr(10)`)，撰寫最後一個字元之後`Output`檔案。  
  
 您也可以使用雙引號括住，在字串中內嵌引號或""。 例如，套用至物件的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 傳回字串，其值為`Double quotation marks aren't "difficult" to handle`。  
  
 寫入檔案，使用`Write`或是`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Write`函式，將原始資料寫入循序檔。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 存取檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中將文字寫入檔案</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何： 將文字寫入至檔案以 streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>