<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="588728944ca294baca2932f2aae0887dfd3ec4be" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30351682" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="FileSystem" /> 模組包含用於執行檔案、目錄或資料夾及系統等作業的程序。 <see langword="My" /> 功能提供比使用 <see langword="FileSystem" /> 模組更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個模組支援的 Visual Basic 語言關鍵字和存取檔案和資料夾的執行階段程式庫成員。  
  
   
  
## Examples  
 這個範例會使用`GetAttr`函式來判斷檔案和目錄或資料夾的屬性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必要。 <see langword="String" /> 運算式，用來識別要成為新預設目錄或資料夾的目錄或資料夾。 <c>Path</c> 可包含磁碟機。 如果未指定磁碟機，則 <see langword="ChDir" /> 會變更目前磁碟機上的預設目錄或資料夾。</param>
        <summary>變更目前的目錄或資料夾。 <see langword="My" /> 功能提供了比 <see langword="ChDir" /> 函式更強大的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函式會變更預設目錄，但未預設磁碟機。 例如，如果預設磁碟機 C，下列陳述式會變更磁碟機 D 上的預設目錄，但 C 則保持預設磁碟機：  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 您可以進行相對目錄變更為輸入兩個句號，如下所示：  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函式需要 unmanaged 程式碼權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和。  
  
   
  
## Examples  
 這個範例會使用`ChDir`函式來變更目前的目錄或資料夾。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 是空的。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定的磁碟無效，或磁碟無法使用。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>變更目前的磁碟機。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必要。 指定現有磁碟機的字串運算式。 如果您提供長度為零的字串 ("")，則目前的磁碟機將不會變更。 如果 <c>Drive</c> 引數是多個字元的字串，則 <see langword="ChDrive" /> 僅會使用第一個字母。</param>
        <summary>變更目前的磁碟機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函式需要 unmanaged 程式碼權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 這個範例會使用`ChDrive`函式來變更目前的磁碟機。 如果磁碟機不存在，則函式會擲回例外狀況。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的磁碟無效，或磁碟無法使用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必要。 指定現有磁碟機的字串運算式。 如果您提供長度為零的字串 ("")，則目前的磁碟機將不會變更。 如果 <c>Drive</c> 引數是多個字元的字串，則 <see langword="ChDrive" /> 僅會使用第一個字母。</param>
        <summary>變更目前的磁碟機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函式需要 unmanaged 程式碼權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 這個範例會使用`ChDrive`函式來變更目前的磁碟機。 如果磁碟機不存在，則函式會擲回例外狀況。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的磁碟無效，或磁碟無法使用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回表示目前路徑的字串。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="CurDir" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回表示目前路徑的字串。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="CurDir" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示目前路徑的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`CurDir`函數來傳回目前的路徑。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">選擇性。 指定現有磁碟機的 <see langword="Char" /> 運算式。 如果未指定磁碟機，或 <c>Drive</c> 是長度為零的字串 ("")，則 <see langword="CurDir" /> 會傳回目前磁碟機的路徑。</param>
        <summary>傳回表示目前路徑的字串。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="CurDir" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示目前路徑的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`CurDir`函數來傳回目前的路徑。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回的字串表示符合指定模式或檔案屬性的檔案、目錄或資料夾的名稱，也可以是磁碟機的磁碟區標籤。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="Dir" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回的字串表示符合指定模式或檔案屬性的檔案、目錄或資料夾的名稱，也可以是磁碟機的磁碟區標籤。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="Dir" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>表示檔案、目錄或資料夾名稱的字串，該字串符合指定的模式或檔案屬性 (Attribute)，也可以是磁碟機的磁碟區標籤 (Label)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 `VbVolume` 傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。  
  
 您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含參數的函式。  
  
> [!IMPORTANT]
>  若要正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>和<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>旗標<xref:System.Security.Permissions.FileIOPermission>要執行的程式碼授與。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`引數的列舉值如下：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|預設值： 指定不含屬性的檔案。|  
|`ReadOnly`|`vbReadOnly`|唯讀檔案，檔案也指定沒有屬性。|  
|`Hidden`|`vbHidden`|隱藏的檔案，檔案也指定沒有屬性。|  
|`System`|`vbSystem`|系統檔案，檔案也指定沒有屬性。|  
|`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。|  
|`Directory`|`vbDirectory`|指定目錄或資料夾，以及不含屬性的檔案。|  
|`Archive`|`vbArchive`|前次備份之後，檔案已經有了變更。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉所指定的 Visual Basic 語言，並可用於您的程式碼，而非實際值的任何位置。  
  
   
  
## Examples  
 這個範例會使用`Dir`函式來檢查特定檔案和目錄是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">選擇性。 <see langword="String" /> 運算式，可指定檔名、目錄或資料夾名稱或磁碟機的磁碟區標籤。 如果找不到 <c>PathName</c>，則會傳回長度為零的字串 (<see langword="&quot;&quot;" />)。</param>
        <param name="Attributes">選擇性。 列舉類型或數值運算式，其值可指定檔案屬性。 如果省略，則 <see langword="Dir" /> 會傳回符合 <c>PathName</c> 的檔案，但是沒有屬性。</param>
        <summary>傳回的字串表示符合指定模式或檔案屬性的檔案、目錄或資料夾的名稱，也可以是磁碟機的磁碟區標籤。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="Dir" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>表示檔案、目錄或資料夾名稱的字串，該字串符合指定的模式或檔案屬性 (Attribute)，也可以是磁碟機的磁碟區標籤 (Label)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 `VbVolume` 傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。  
  
 您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含任何參數的函式。  
  
> [!IMPORTANT]
>  若要正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>和<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>旗標<xref:System.Security.Permissions.FileIOPermission>要執行的程式碼授與。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`引數的列舉值如下：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|預設值： 指定不含任何屬性的檔案。|  
|`ReadOnly`|`vbReadOnly`|指定唯讀檔案，除了沒有任何屬性的檔案。|  
|`Hidden`|`vbHidden`|指定隱藏的檔案，除了沒有任何屬性的檔案。|  
|`System`|`vbSystem`|指定系統檔案，除了沒有任何屬性的檔案。|  
|`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。|  
|`Directory`|`vbDirectory`|指定目錄或資料夾，以及不含任何屬性的檔案。|  
|`Archive`|`vbArchive`|前次備份之後，檔案已經有了變更。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉所指定的 Visual Basic 語言，並可用於您的程式碼，用來取代實際值的任何位置。  
  
   
  
## Examples  
 這個範例會使用`Dir`函式來檢查特定檔案和目錄是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含任何有效檔案編號的 <see langword="Integer" />。</param>
        <summary>當已經到達為 <see langword="True" /> 或循序 <see langword="Random" /> 開啟的檔案之結尾時，傳回布林值 (Boolean) <see langword="Input" />。</summary>
        <returns>當已經到達為 <see langword="True" /> 或循序 <see langword="Random" /> 開啟的檔案之結尾時，傳回布林值 (Boolean) <see langword="Input" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`以避免嘗試取得輸入超過檔案結尾所產生的錯誤。  
  
 `EOF`函式會傳回`False`直到已到達檔案結尾。 開啟的檔案與`Random`或`Binary`存取`EOF`傳回`False`直到最後一個執行`FileGet`函式不能讀取整個記錄。  
  
 開啟的檔案與`Binary`存取，嘗試讀取檔案使用透過`Input`函式，直到`EOF`傳回`True`會產生錯誤。 使用`LOF`和`Loc`函式，而不是`EOF`讀取二進位檔案時`Input`，或使用`Get`時使用`EOF`函式。 開啟的檔案與`Output`，`EOF`一律會傳回`True`。  
  
   
  
## Examples  
 這個範例會使用`EOF`函式來偵測檔案的結尾。 這個範例假設`Testfile`是文字檔案，其中包含幾行文字。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 <see langword="Integer" />。 任何有效的檔案數目。</param>
        <summary>傳回列舉類型，表示使用 <see langword="FileOpen" /> 函式開啟的檔案之檔案模式。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="FileAttr" /> 函式更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>下列列舉類型值表示檔案存取模式：  
  
 <list type="table"><item><term> 值  
  
 </term><description> 模式  
  
 </description></item><item><term> 1  
  
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  
  
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  
  
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  
  
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函數會傳回代表使用開啟的檔案模式列舉`FileOpen`函式。  
  
   
  
## Examples  
 這個範例會使用`FileAttr`函數來傳回已開啟的檔案的檔案模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">選擇性。 參數陣列，具有 0 個或更多要關閉的通道。</param>
        <summary>將輸入/輸出 (I/O) 結果導向使用 <see langword="FileOpen" /> 函式開啟的檔案。 <see langword="My" /> 提供更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[How to： 以 StreamReader 從檔案讀取文字](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[How to： 將文字寫入檔案以 StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[逐步解說： 中管理檔案和目錄Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。  
  
 如果您省略`FileNumbers`，所有使用中的檔案開啟`FileOpen`函式會關閉。  
  
 當您關閉已開啟的檔案`Output`或`Append`，該檔案的作業系統緩衝區寫入輸出的最後的緩衝區。 所有的緩衝區空間的封閉型相關聯檔案發行。  
  
 當`FileClose`函式執行，其檔案的檔案關聯數字結尾。  
  
   
  
## Examples  
 這個範例會使用`FileClose`函式，以關閉 檔案開啟為`Input`。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必要。 <see langword="String" /> 運算式，指定要複製的檔案名稱。 <c>Source</c> 可包含原始程式檔的目錄或資料夾及磁碟機。</param>
        <param name="Destination">必要。 <see langword="String" /> 運算式，指定目標檔案名稱。 <c>Destination</c> 可包含目的檔案的目錄或資料夾及磁碟機。</param>
        <summary>複製檔案。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 提供比 <see langword="FileCopy" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試使用`FileCopy`函式在目前開啟的檔案，就會發生錯誤。  
  
 `FileCopy` 需要完全信任，才能在本機磁碟機。  
  
   
  
## Examples  
 這個範例會使用`FileCopy`函式複製到另一個檔案。 此範例的目的，假設`SrcFile`是包含資料的檔案。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> 或 <paramref name="Destination" /> 為無效值或尚未指定。</exception>
        <exception cref="T:System.IO.IOException">檔案已經開啟。</exception>
        <exception cref="T:System.IO.FileNotFoundException">檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔名的 <see langword="String" /> 運算式。 <c>PathName</c> 可包含目錄或資料夾及磁碟機。</param>
        <summary>傳回 <see langword="Date" /> 值，表示寫入檔案的日期和時間。 相較於 <see langword="FileDateTime" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Date" /> 值，表示建立檔案或上次修改檔案的日期和時間。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`FileDateTime`建立或上次修改函數來判斷日期和時間的檔案。 日期和時間顯示的格式為基礎的系統地區設定。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> 無效或包含萬用字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目標檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會寫入至與檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會寫入至與檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果不使用描述項。 然後的大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會寫入至與檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會寫入至與檔案`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要為字串寫入描述長度的雙位元組描述元。 預設值為 <see langword="False" />。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="ArrayIsDynamic">選擇性。 只有在編寫陣列時才適用。 指定是否將陣列視為動態 (Dynamic)，以及是否有必要指定描述陣列大小和界限的陣列描述元。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要為字串寫入描述長度的雙位元組描述元。 預設值為 <see langword="False" />。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。 相較於 <see langword="FileGet" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGet`通常會先寫入至檔案使用`FilePut`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或位元組繼上次`FileGet`或`FilePut`函式 (或最後一個指向`Seek`函式) 會讀取。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGet`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是，有符合所讀取的資料長度的資料錄長度。  
  
-   根據預設，如果變數是一個字串，`FileGet`讀取兩個位元組描述元，其中包含字串的長度，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串。置入檔案時，不寫入長度描述元。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果變數是陣列，您可以選擇是否要讀取的大小和陣列的維度屬性的描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當讀取陣列，您必須符合陣列寫入的方式。 如果它具有描述元寫入，您必須讀取的描述元。 如果未使用的描述元，大小和陣列界限的傳入`FileGet`決定要讀取的內容。  
  
     描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 個位元組的分散，如下所示：  
  
    -   描述元的 18 個位元組: (2 + 8 * 2)  
  
    -   200 個位元組的資料: (5 * 10 * 4)。  
  
-   如果變數讀入是任何其他類型的變數 （不可變長度字串或物件）`FileGet`讀取變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於所讀取的資料長度。  
  
-   `FileGet` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePut`) 加上其長度等於 2 加上 8 倍的維度數目的描述元: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別項目所需的所有位元組的總和。 這包括任何的陣列，其描述元。 `VBFixedString`屬性可以套用至字串欄位的結構，表示當寫入字串的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGet` 連續; 從磁碟讀取所有變數也就是說，無需之間的填補的記錄。  
  
-   在結構中，陣列以外的所有陣列`FileGet`讀取的資料。 沒有描述元是唯讀的。  
  
-   `FileGet` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
    > [!IMPORTANT]
    >  從檔案讀取使用`FileGet`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，資料將讀取至其中。</param>
        <param name="RecordNumber">選擇性。 要開始讀取的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將開放磁碟檔案的資料讀取到變數中。  相較於 <see langword="FileGetObject" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`而不是使用函式`FileGet`若要避免模稜兩可在編譯時期，如果型別`Object`傳回而不是另一個類型，例如`Integer`， `Long`， `Short`，依此類推。  
  
 如果您想要寫出`Variant`型別，`FileGetObject`需要。 有疑問，如果您使用物件的第二個參數，都建議您使用`FilePutObject`和`FileGetObject`。  
  
 `FileGetObject` 只能在有效`Random`和`Binary`模式。  
  
 資料讀取`FileGetObject`通常寫入`FilePutObject`。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`，`FileGetObject`最後一個之後讀取的記錄或位元組`FileGetObject`或`FilePutObject`函式 (或最後一個指向`Seek`函式)。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在讀取資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FileGetObject`讀取的資料錄長度界限中後續的記錄。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾及開頭的下一筆記錄之間的間距。 因為填補資料的數量無法精確判斷，所以最好能夠符合所讀取的資料長度的資料錄長度。  
  
-   讀取變數是否為字串，預設`FileGetObject`讀取包含字串長度的兩個位元組描述元，並再讀取變數的資料。 因此，所指定的資料錄長度`RecordLength`子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。 Visual Basic 6.0 及舊版支援固定長度字串和讀取檔案時，長度的描述項不會寫入。 如果您想要讀取的描述項的字串，您應該傳遞`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果被讀入變數是陣列，則記錄所指定的長度`RecordLength`中的參數`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目： 2 + 8 * NumberOfDimensions。  
  
     例如，下列陣列宣告需要 218 位元組陣列寫入時磁碟：  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 位元組會分散，如下所示： 18 個位元組 (2 + 8 * 2)，描述元 100 個位元組 (5 * 10 * 4) 的資料。  
  
-   `FileGetObject` 如同讀取每個個別，只不過是沒有任何項目之間的填補，讀取結構的項目。 在磁碟上，動態陣列中的使用者定義型別 (使用撰寫`FilePutObject`) 加上其長度等於 2 加上 8 倍的維度數目的描述元： 2 + 8 * NumberOfDimensions。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於讀取個別的項目，包括任何的陣列，其描述元所需的所有位元組的總和。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>類別可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，所有的`Random`套用規則，但有下列例外：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FileGetObject` 所有連續讀取變數，從磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FileGetObject`讀取的資料。 沒有描述元是唯讀的。  
  
 `FileGetObject` 讀取可變長度的字串不是結構不會預期雙位元組長度的描述項的項目。 讀取的位元組數目等於已經在字串中的字元數。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
   
  
## Examples  
 下列範例會讀取記錄，到測試檔案，並接著會擷取它。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔案的 <see langword="String" /> 運算式。 <c>PathName</c> 可包含目錄或資料夾及磁碟機。</param>
        <summary>傳回 <see langword="Long" /> 值，指定檔案的長度 (以位元組為單位)。 相較於 <see langword="FileLen" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Long" /> 指定檔案長度的值 (以位元組為單位)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的檔案時，開啟`FileLen`函式呼叫，傳回的值代表在它已開啟檔案的大小。  
  
> [!NOTE]
>  取得目前已開啟的檔案的長度，請使用`LOF`函式。  
  
   
  
## Examples  
 這個範例會使用`FileLen`函數來傳回檔案的長度，以位元組為單位。 此範例的目的，假設`TestFile`是包含某些資料的檔案。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。 使用 <see langword="FreeFile" /> 函式取得下一個可用的檔案編號。</param>
        <param name="FileName">必要。 <see langword="String" /> 運算式，可指定檔名，也可能包括目錄或資料夾及磁碟機。</param>
        <param name="Mode">必要。 指定檔案模式的列舉類型：<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" /> 或 <see langword="Random" />  如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.OpenMode" />。</param>
        <param name="Access">選擇性。 指定開啟檔案上允許的作業之列舉類型：<see langword="Read" />、<see langword="Write" /> 或 <see langword="ReadWrite" />。 預設值為 <see langword="ReadWrite" />。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.OpenAccess" />。</param>
        <param name="Share">選擇性。 指定開啟的檔案上其他處理序不允許之作業的列舉類型：<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" /> 和 <see langword="Lock Read Write" />。 預設值為 <see langword="Lock Read Write" />。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.OpenShare" />。</param>
        <param name="RecordLength">選擇性。 數字小於或等於 32,767 (位元組)。 對於為隨機存取開啟的檔案而言，這個值是資料錄長度。 對於循序檔案而言，這個值是緩衝的字元數。</param>
        <summary>開啟要當做輸入或輸出的檔案。 相較於 <see langword="FileOpen" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 您必須先開啟檔案，才能在其上執行任何的 I/O 作業。 `FileOpen` 會針對 I/O 配置緩衝區至檔案，並判斷要使用之緩衝區的存取模式。  
  
> [!IMPORTANT]
>  當寫入檔案時，應用程式可能要建立檔案，如果嘗試寫入的檔案不存在。 若要這樣做，需要的權限的 建立檔案的目錄。 不過，如果所指定的檔案`FileName`確實存在，應用程式需求`Write`權限只檔案本身。 盡量，以協助改善安全性，在部署和授與建立檔案的任一處`Write`該檔案的權限唯一的而不是整個目錄。 若要改善安全性，請將資料寫入使用者目錄而不是根目錄或 Program Files 目錄。  
  
 若要開啟頻道可以找到使用`FreeFile()`函式。  
  
> [!IMPORTANT]
>  `FileOpen`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 此範例說明的各種用法`FileOpen`函式會啟用輸入和輸出至檔案。  
  
 下列程式碼會開啟檔案`TestFile`中`Input`模式。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 這個範例會開啟中的檔案`Binary`模式只允許寫入作業。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下列範例會開啟中的檔案`Random`模式。 檔案包含結構的記錄`Person`。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 這個程式碼範例會開啟中的檔案`Output`模式; 任何處理程序可以讀取或寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 這個程式碼範例會開啟中的檔案`Binary`模式進行讀取; 其他處理序無法讀取檔案。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">資料錄的長度為負數 (而且不等於 -1)。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> 已經開啟，或 <paramref name="FileName" /> 無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要針對檔案的字串編寫二位元組字串長度的描述元。 預設值為 <see langword="False" />。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <param name="ArrayIsDynamic">選擇性。 只有在編寫陣列時才適用。 指定陣列是否要視為動態 (Dynamic)，以及是否要針對描述長度的字串編寫陣列描述元。</param>
        <param name="StringIsFixedLength">選擇性。 只有在編寫字串時才適用。 指定是否要針對檔案的字串編寫二位元組字串長度的描述元。 預設值為 <see langword="False" />。</param>
        <summary>將變數資料寫入磁碟檔案。 相較於 <see langword="FilePut" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePut` 寫入的資料，通常會透過使用 `FileGet` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。  
  
-   如果寫入的變數是字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。  
  
-   `FilePut` 如同寫入每個個別，但沒有任何項目之間的填補，將結構的項目。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。  
  
    > [!NOTE]
    >  字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，  
  
## <a name="binary-mode"></a>二進位模式  
 在 開啟檔案的`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
-   在結構中，陣列以外的所有陣列`FilePut`寫入的資料。 會不寫入任何描述項。  
  
-   `FilePut` 寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 例如，下列陳述式會將 11 個位元組寫入檔案編號 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   寫入檔案，使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`FilePut`函式將資料寫入檔案。 結構的五筆記錄`Person`寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等於 -1。</exception>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 有效的變數名稱，該名稱包含已寫入磁碟的資料。</param>
        <param name="RecordNumber">選擇性。 寫入開始的資料錄數目 (<see langword="Random" /> 模式檔案) 或位元組數目 (<see langword="Binary" /> 模式檔案)。</param>
        <summary>將變數資料寫入磁碟檔案。  相較於 <see langword="FilePutObject" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`而不是使用函式`FilePut`若要避免模稜兩可在編譯時期，如果型別`Object`傳遞，而另一個類型，例如`Integer`， `Long`， `Short`，依此類推。  
  
 `FilePutObject` 寫入，並讀取描述物件的描述元。 如果您想要寫出`Variant`型別，`FilePutObject`需要。 有疑問，如果您使用物件的第二個參數，我們建議一律使用`FilePutObject`和`FileGetObject`。  
  
 `FilePutObject` 只能在有效`Random`和`Binary`模式。  
  
 使用 `FilePutObject` 寫入的資料，通常會透過使用 `FileGetObject` 從檔案讀取。  
  
 第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`，`FilePutObject`寫入最後一個之後的下一個記錄或位元組`FileGetObject`或`FilePutObject`函式 (或資料錄或位元組指向最後一個`Seek`函式)。  
  
 `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePutObject` 引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePutObject`，您必須執行相同的`FileGetObject`，和您也必須確定該字串會初始化為預期的長度。  
  
## <a name="random-mode"></a>隨機模式  
 在 開啟檔案的`Random`模式中，則適用下列規則：  
  
-   如果正在寫入資料的長度小於指定的長度`RecordLength`子句`FileOpen`函式，`FilePutObject`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為填補資料的數量無法精確判斷，所以通常最好是有相符的資料寫入的資料錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式擲回例外狀況。  
  
-   如果寫入的變數是物件所包含的數字類型，`FilePutObject`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePutObject`寫入 6 個位元組： 識別做為物件的兩個位元組`VarType(3)`(`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。  
  
-   如果正在寫入的變數是物件，包含字串，`FilePutObject`寫入兩個位元組的描述項，識別`VarType(8)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。  
  
-   如果寫入的變數是陣列，則所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二進位模式  
 在開啟檔案的`Binary`模式中，所有`Random`模式規則將套用，除了：  
  
-   `RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePutObject` 將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。  
  
   
  
## Examples  
 這個範例會使用`FilePutObject`函式，將字串寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="RecordWidth">必要。 0–255 範圍內的數值運算式 (包含頭尾)，表示在開始新行之前，會有多少字元出現在一行上。 如果 <c>RecordWidth</c> 等於 0，則一行的長度將沒有限制。 <c>RecordWidth</c> 的預設值為 0。</param>
        <summary>為藉由使用 <see langword="FileOpen" /> 函式開啟的檔案指派輸出行寬度。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用`FileWidth`函式可設定檔案的輸出線條寬度。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see langword="Integer" /> 值，表示可供 <see langword="FileOpen" /> 函式使用的下一個可用的檔案編號。</summary>
        <returns>傳回 <see langword="Integer" /> 值，表示可供 <see langword="FileOpen" /> 函式使用的下一個可用的檔案編號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`提供尚未使用的檔案數字。  
  
   
  
## Examples  
 這個範例會使用`FreeFile`函式傳回下一個可用的檔案數目。 五個檔案都開啟迴圈內的輸出和特定範例資料會寫入每一個。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">使用中的檔案超過 255 個。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔案、目錄或資料夾名稱的 <see langword="String" /> 運算式。 <c>PathName</c> 可包含目錄或資料夾及磁碟機。</param>
        <summary>傳回 <see langword="FileAttribute" /> 值，表示檔案、目錄或資料夾的屬性。 相較於 <see langword="FileAttribute" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>
          <see langword="GetAttr" /> 傳回的值是以下列舉值的總和：  
  
 <list type="table"><item><term> 值  
  
 </term><description> 常數  
  
 </description><description> 描述  
  
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 一般。  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 唯讀。  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 隱藏。  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> 系統檔案。  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> 目錄或資料夾。  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> 前次備份之後，檔案已經有了變更。  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> 檔案有不同的名稱。  
  
 </description></item></list><block subset="none" type="note"><para>  
 這些列舉類型 (Enumeration) 是由 Visual Basic 語言所指定。 您可在程式碼中的任何地方使用這些名稱來取代實際值。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷設定了哪些屬性，請使用`And`運算子來執行所傳回的值的位元比較`GetAttr`函式和您想要個別的檔案屬性的值。 如果結果不是零，該屬性會設定命名的檔案。 例如，下列的傳回值`And`運算式是如果`Archive`未設定屬性：  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 如果傳回非零值`Archive`屬性設定。  
  
   
  
## Examples  
 這個範例會使用`GetAttr`函式來判斷檔案和目錄或資料夾的屬性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> 無效或包含萬用字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目標檔案不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，已寫入它使用資料的數行程式`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，已寫入它使用資料的數行程式`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Value">必要。 當變數所指派的值是讀自於檔案時，這些變數不可以是陣列或物件變數。</param>
        <summary>自開啟的循序檔中讀取資料，並將該資料指派至變數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。  
  
 讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。  
  
|資料|指派給變數的值|  
|-|-|  
|用來分隔逗號或空白行|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間|  
|#ERROR `errornumber`#|`errornumber` （變數會是標記為錯誤的物件）|  
  
 如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。  
  
> [!NOTE]
>  `Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。  
  
> [!IMPORTANT]
>  從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Input`函式可從檔案讀取資料到兩個變數。 這個範例假設`TestFile`是檔案，有數行的資料寫入使用`Write`函式中，每行包含在引號內，並以逗號分隔，例如數字的字串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="CharCount">必要。 任何有效的數值運算式，指定要讀取的字元數。</param>
        <summary>傳回 <see langword="String" /> 值，其中包含於 <see langword="Input" /> 或 <see langword="Binary" /> 模式下開啟之檔案中的字元。 相較於 <see langword="InputString" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>傳回 <see langword="String" /> 值，其中包含於 <see langword="Input" /> 或 <see langword="Binary" /> 模式下開啟之檔案中的字元。 相較於 <see langword="InputString" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`InputString`函式通常會寫入至檔案使用`Print`或`FilePut`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。  
  
 不同於`Input`函式，`InputString`函式會傳回讀取的字元。 這包括逗號、 換行字元、 換、 引號和前置空格。  
  
 開啟的檔案與`Binary`存取，嘗試讀取整個檔案使用`InputString`函式，直到`EOF`傳回`True`會產生錯誤。 使用`LOF`和`Loc`函式，而不是`EOF`使用讀取二進位檔案時`InputString`，或使用`FileGet`當您使用`EOF`函式。  
  
> [!NOTE]
>  當從檔案讀取，請勿根據檔案名稱副檔名的檔案內容的安全性決策。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
   
  
## Examples  
 這個範例會使用`InputString`函式來一次從檔案讀取一個字元，並列印它`Output`視窗。 這個範例假設`MyFile`是有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 或 &gt; 214。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 <see langword="String" /> 運算式，指定要刪除的一個或多個檔案的名稱。 <c>PathName</c> 可包含目錄或資料夾及磁碟機。</param>
        <summary>從磁碟中刪除檔案。 相較於 <see langword="Kill" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。  
  
 **安全性注意事項**才能執行，`Kill`函式需要`Read`和`PathDiscovery`旗標<xref:System.Security.Permissions.FileIOPermission>授與給執行的程式碼。 如需詳細資訊，請參閱<xref:System.Security.SecurityException>[程式碼存取權限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 這個範例會使用`Kill`函式，從磁碟刪除檔案。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目標檔案已開啟。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到目標檔案。</exception>
        <exception cref="T:System.Security.SecurityException">權限遭拒。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <summary>從開啟的循序檔案中讀取單一行，並將它指派給 <see langword="String" /> 變數。</summary>
        <returns>從開啟的循序檔案中讀取單一行，並將它指派給 <see langword="String" /> 變數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 資料讀取`LineInput`通常會先寫入至檔案使用`Print`。  
  
> [!IMPORTANT]
>  時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。  
  
 `LineInput`函式會從檔案的一個字元讀取一次直到它遇到歸位字元 (`Chr(13)`) 或歸位字元/換 (`Chr(13) + Chr(10)`) 序列。 歸位字元 / 換行字元循序會略過而不是附加的字元字串。  
  
> [!IMPORTANT]
>  從檔案讀取使用`LineInput`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。  
  
   
  
## Examples  
 這個範例會使用`LineInput`函式來讀取一行從連續的檔案，並將它指派給變數。 這個範例假設`TestFile`是有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">已到達檔案結尾。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的 <see langword="Integer" /> 檔案編號。</param>
        <summary>傳回 <see langword="Long" /> 值，指定開啟檔案中目前的讀取/寫入位置。</summary>
        <returns>傳回 <see langword="Long" /> 值，指定開啟檔案中目前的讀取/寫入位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`函式是以零為起始，則使用它來擷取檔案中的第一個位元組，則會傳回 0。  
  
 `Loc`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 以下描述的傳回值為每個檔案存取模式：  
  
|模式|傳回值|  
|-|-|  
|`Random`|最後一筆記錄中讀取或寫入至檔案的數目。|  
|`Sequential`|除以 128 檔案中的目前位元組位置。 不過，所傳回資訊`Loc`循序檔案尚未使用或必要的。|  
|`Binary`|讀取或寫入的最後一個位元組的位置。|  
  
   
  
## Examples  
 這個範例會使用`Loc`函數來傳回目前的讀取/寫入位置中開啟的檔案。 這個範例假設`MyFile`是有數行的範例資料的文字檔。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。  
  
 如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含結構的記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Record">選擇性。 要鎖定或解除鎖定的唯一資料錄或位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。  
  
 如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含結構的記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="FromRecord">選擇性。 要鎖定或解除鎖定的第一筆資料錄或第一個位元組的編號。</param>
        <param name="ToRecord">選擇性。 要鎖定或解除鎖定的最後一筆資料錄或最後一個位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。  
  
 如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含結構的記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含有效檔案編號的 <see langword="Integer" />。</param>
        <summary>傳回 <see langword="Long" />，表示使用 <see langword="FileOpen" /> 函式開啟之檔案之大小 (以位元組為單位)。 相較於 <see langword="LOF" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>傳回 <see langword="Long" />，表示使用 <see langword="FileOpen" /> 函式開啟之檔案之大小 (以位元組為單位)。 相較於 <see langword="LOF" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FileLen`函式可取得不是開啟的檔案的長度。  
  
   
  
## Examples  
 這個範例會使用`LOF`函式來判斷開啟檔案的大小。 這個範例假設`TestFile`是文字檔案，其中包含範例資料。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必要。 <see langword="String" /> 運算式，可識別要建立的目錄。 <c>Path</c> 可包含磁碟機。 如果未指定磁碟機，則 <see langword="MkDir" /> 會在目前磁碟機上建立新目錄。</param>
        <summary>建立新目錄。 相較於 <see langword="MkDir" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函式會建立新的目錄。  
  
   
  
## Examples  
 這個範例會使用`MkDir`函式來建立目錄。 如果未指定磁碟機，在目前的磁碟機上建立新的目錄。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 尚未指定或是空的。</exception>
        <exception cref="T:System.Security.SecurityException">權限遭拒。</exception>
        <exception cref="T:System.IO.IOException">目錄已經存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Output">選擇性。 要寫入檔案的零或多個逗點分隔運算式。  
  
 <c>Output</c> 引數設定為：  
  
 <see langword="T:System.IO.IOException" />︰檔案模式無效。  
  
 <see langword="T:System.IO.IOException" />：<c>FileNumber</c> 成員不存在。</param>
        <summary>將顯示格式資料寫入循序檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包含行結尾處換行字元不過，`PrintLine`包含換行字元。  
  
 資料寫入與`Print`通常會從檔案讀取使用`LineInput`或`Input`。  
  
 如果您省略`Output`如`PrintLine`，列印一行空白行檔案; 以取得`Print`，沒有輸出。 以逗號分隔的多個運算式將會對齊索引標籤的界限，而混合逗號和`TAB`可能會造成不一致的結果。  
  
 如`Boolean`資料，在`True`或`False`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。  
  
 日期資料寫入檔案中，使用您的系統能辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
 不寫入至檔案如果`Output`是空的資料。 不過，如果`Output`清單資料是`DBNull`，`Null`寫入檔案。  
  
 如`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定為何不會轉譯關鍵字。  
  
 寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的十進位分隔符號。 如果使用者想要使用多個地區設定，輸出資料，`Write`應使用。  
  
 寫入檔案，使用`Print`或`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Print`和`PrintLine`函式將資料寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Output">選擇性。 要寫入檔案的零或多個逗點分隔運算式。  
  
 <c>Output</c> 引數設定為：  
  
 <see langword="T:System.IO.IOException" />︰檔案模式無效。  
  
 <see langword="T:System.IO.IOException" />：<c>FileNumber</c> 成員不存在。</param>
        <summary>將顯示格式資料寫入循序檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包含行結尾處換行字元不過，`PrintLine`包含換行字元。  
  
 資料寫入與`Print`通常會從檔案讀取使用`LineInput`或`Input`。  
  
 如果您省略`Output`如`PrintLine`，列印一行空白行檔案; 以取得`Print`，沒有輸出。 以逗號分隔的多個運算式將會對齊索引標籤的界限，而混合逗號和`TAB`可能會造成不一致的結果。  
  
 如`Boolean`資料，在`True`或`False`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。  
  
 日期資料寫入檔案中，使用系統所能辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
 不寫入至檔案如果`Output`是空的資料。 不過，如果`Output`清單資料是`DBNull`，`Null`寫入檔案。  
  
 如`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定為何不會轉譯關鍵字。  
  
 寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的十進位分隔符號。 如果使用者想要使用多個地區設定，輸出資料，`Write`應使用。  
  
 寫入檔案，使用`Print`或`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Print`和`PrintLine`函式將資料寫入檔案。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必要。 <see langword="String" /> 運算式，指定現有的檔案名稱和位置。 <c>OldPath</c> 可包含檔案的目錄及磁碟機。</param>
        <param name="NewPath">必要。 <see langword="String" /> 運算式，指定新檔案的名稱和位置。 <c>NewPath</c> 可包含目的位置的目錄及磁碟機。 <c>NewPath</c> 指定的檔案名稱不能已經存在。</param>
        <summary>重新命名磁碟的檔案或目錄。 相較於 <see langword="Rename" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`函式重新命名的檔案，並將它移到不同的目錄，如有必要。 `Rename`函式可以將檔案移到磁碟機，但它只能重新命名現有的目錄時同時`NewPath`和`OldPath`位於相同的磁碟機上。 `Rename` 無法建立新檔案或目錄。  
  
 使用`Rename`開啟的檔案的函式會產生錯誤。 您必須關閉開啟的檔案再重新命名它。 `Rename` 引數不能包含多個字元 （*） 和單一字元 （？） 的萬用字元。  
  
> [!IMPORTANT]
>  當使用`Rename`將從受保護的位置將檔案複製到受保護的位置，檔案會保留較不受限的權限。 請檢查並確定沒有引入可能的安全性風險。  
  
   
  
## Examples  
 這個範例會使用`Rename`函式，將檔案重新命名。 此範例的目的，假設已經指定的目錄存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路徑無效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> 檔案不存在。</exception>
        <exception cref="T:System.IO.IOException">無法重新命名為不同的裝置。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉所有使用 <see langword="FileOpen" /> 函式開啟的磁碟檔案。 相較於 <see langword="Reset" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`函式會關閉所有開啟的作用中的檔案`FileOpen`函式，並擁有的相同功能與`FileClose()`不含任何參數。  
  
   
  
## Examples  
 這個範例會使用`Reset`函式來關閉所有開啟的檔案並寫入磁碟中的所有檔案緩衝區的內容。 請注意使用`Object`變數`FileNumber`做為字串和數字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必要。 <see langword="String" /> 運算式，可識別要移除的目錄或資料夾。 <c>Path</c> 可包含磁碟機。 如果未指定磁碟機，則 <see langword="RmDir" /> 會移除目前磁碟機上的目錄。</param>
        <summary>移除現有的目錄。 相較於 <see langword="RmDir" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試使用，就會發生錯誤`RmDir`包含檔案的目錄上。 使用`Kill`函式來刪除所有檔案，然後再移除目錄。  
  
   
  
## Examples  
 這個範例會使用`RmDir`函式以移除現有的目錄。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 尚未指定或是空的。</exception>
        <exception cref="T:System.IO.IOException">目標目錄包含檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目錄不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。 相較於 <see langword="Seek" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含有效檔案編號的 <see langword="Integer" />。</param>
        <summary>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。 相較於 <see langword="Seek" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 傳回介於 1 到 2147483647 之間的值 (相當於 2 ^31-1) 之間，內含。  
  
 以下描述的傳回值，每個檔案存取模式：  
  
|模式|傳回值|  
|-|-|  
|`Random`|下一個記錄讀取或寫入的數目|  
|`Binary`、`Input`、`Output``Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。|  
  
   
  
## Examples  
 這個範例會使用`Seek`函數來傳回目前的檔案位置。 這個範例假設`TestFile`是包含結構的記錄檔`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 在 開啟檔案的`Random`模式中，`Seek`傳回下一筆記錄的數目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 檔案不是在模式中開啟`Random`模式中，`Seek`傳回下一項作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 這個範例會使用`Seek`函式，以將位置設定下一個要讀取或寫入檔案。  
  
 檔案不是在模式中開啟`Random`模式中，`Seek`設定下一個作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含有效檔案編號的 <see langword="Integer" />。</param>
        <param name="Position">必要。 在 1–2,147,483,647 範圍之間的數字 (包括頭尾)，表示應該發生下一個讀取 / 寫入作業的位置。</param>
        <summary>傳回指定使用 <see langword="Long" /> 函式開啟的檔案中目前讀取/寫入位置的 <see langword="FileOpen" />，或設定使用 <see langword="FileOpen" /> 函式開啟的檔案中下一個讀取/寫入作業的位置。 相較於 <see langword="Seek" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 傳回介於 1 到 2147483647 之間的值 (相當於 2 ^31-1) 之間，內含。  
  
 以下描述的傳回值，每個檔案存取模式：  
  
|模式|傳回值|  
|-|-|  
|`Random`|下一個記錄讀取或寫入的數目|  
|`Binary`、`Input`、`Output``Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。|  
  
   
  
## Examples  
 這個範例會使用`Seek`函數來傳回目前的檔案位置。 這個範例假設`TestFile`是包含結構的記錄檔`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 在 開啟檔案的`Random`模式中，`Seek`傳回下一筆記錄的數目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 檔案不是在模式中開啟`Random`模式中，`Seek`傳回下一項作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 這個範例會使用`Seek`函式，以將位置設定下一個要讀取或寫入檔案。  
  
 檔案不是在模式中開啟`Random`模式中，`Seek`設定下一個作業就會發生的位元組位置。 假設`TestFile`是包含幾行文字的檔案。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必要。 指定檔名的 <see langword="String" /> 運算式。 <c>PathName</c> 可包含目錄或資料夾及磁碟機。</param>
        <param name="Attributes">必要。 常數或數值運算式，其總和可以表示檔案屬性。</param>
        <summary>設定檔案的屬性 (Attribute) 資訊。 相較於 <see langword="SetAttr" />，<see langword="My" /> 功能可提升檔案 I/O 作業的產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您嘗試設定開啟檔案的屬性，就會發生執行階段錯誤。  
  
 `Attributes`引數的列舉值如下：  
  
|值|常數|描述|  
|-|-|-|  
|`Normal`|`vbNormal`|標準 （預設值）。|  
|`ReadOnly`|`vbReadOnly`|唯讀。|  
|`Hidden`|`vbHidden`|隱藏。|  
|`System`|`vbSystem`|系統檔案。|  
|`Volume`|`vbVolume`|磁碟區標籤|  
|`Directory`|`vbDirectory`|目錄或資料夾。|  
|`Archive`|`vbArchive`|前次備份之後，檔案已經有了變更。|  
|`Alias`|`vbAlias`|檔案有不同的名稱。|  
  
> [!NOTE]
>  這些列舉類型 (Enumeration) 是由 Visual Basic 語言所指定。 名稱可以用在您的程式碼，而非實際值的處。  
  
   
  
## Examples  
 這個範例會使用`SetAttr`函式可設定檔案的屬性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> 類型無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必要。 在顯示或列印清單中的下一個運算式之前所要插入的空格數。</param>
        <summary>搭配 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式使用，以定位輸出。</summary>
        <returns>搭配 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式使用，以定位輸出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`少於輸出線條寬度下, 一個列印位置立即遵循的列印的空格數目。 如果`Count`大於輸出的行寬，`SPC`計算下一步的列印位置，使用的公式：  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 例如，當目前的列印位置為 24，輸出線條寬度為 80，並且您指定`SPC(90)`下, 一個列印將會開始於位置 34 （目前的列印位置 + 90/80 的餘數）。 如果目前的列印位置而輸出線條的寬度之間的差異小於`Count`(或`Count` `Mod` *寬度*)、`SPC`函式會跳到下一行的開頭，並產生空間等於`Count`– (*寬度*– *currentprintposition*)。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以容納寬字母。  
  
   
  
## Examples  
 這個範例會使用`SPC`函式，將輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</summary>
        <returns>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的行上目前的列印位置大於`Column`，`TAB`會跳到資料行的值等於`Column`在下一行中輸出。 如果`Column`小於 1，`TAB`的列印位置移至資料行 1。 如果`Column`大於輸出的行寬，`TAB`計算下一步的列印位置，使用的公式：  
  
 資料行 Mod 寬度  
  
 例如，如果*寬度*為 80，而且您指定`TAB(90)`下, 一個列印會開始資料行 10 （90/80 的餘數）。 如果`Column`小於目前的列印位置，列印在下一行導出的位置開始。 如果導出的列印位置大於目前的列印位置，列印會在導出列印位置在同一行。  
  
 在輸出行上最左邊的列印位置永遠為 1。 當您使用`Print`或`PrintLine`函數來列印至檔案，最右邊的列印位置是您可以使用設定輸出檔的目前寬度`FileWidth`函式。  
  
 `TAB`函式也可用以`WriteLine`函式。 它不能與<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以包含寬的字母。  
  
   
  
## Examples  
 這個範例會使用`TAB`函式，將輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">選擇性。 在顯示或列印清單中的下一個運算式之前所要移至的欄位編號。 如果省略，則 <see langword="TAB" /> 會將插入點移到下一個列印區 (Print Zone) 的開頭。</param>
        <summary>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</summary>
        <returns>配合 <see langword="Print" /> 或 <see langword="PrintLine" /> 函式用於定位輸出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的行上目前的列印位置大於`Column`，`TAB`會跳到資料行的值等於`Column`在下一行中輸出。 如果`Column`小於 1，`TAB`的列印位置移至資料行 1。 如果`Column`大於輸出的行寬，`TAB`計算下一步的列印位置，使用的公式：  
  
 資料行 Mod 寬度  
  
 例如，如果*寬度*為 80，而且您指定`TAB(90)`下, 一個列印會開始資料行 10 （90/80 的餘數）。 如果`Column`小於目前的列印位置，列印在下一行導出的位置開始。 如果導出的列印位置大於目前的列印位置，列印會在導出列印位置在同一行。  
  
 在輸出行上最左邊的列印位置永遠為 1。 當您使用`Print`或`PrintLine`函數來列印至檔案，最右邊的列印位置是您可以使用設定輸出檔的目前寬度`FileWidth`函式。  
  
 `TAB`函式也可用以`WriteLine`函式。 它不能與<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  請確定您的表格式資料行的寬度不足以包含寬的字母。  
  
   
  
## Examples  
 這個範例會使用`TAB`函式，將輸出檔案中，然後在**輸出**視窗。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。  
  
 如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含結構的記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="Record">選擇性。 要鎖定或解除鎖定的唯一資料錄或位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。  
  
 如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含結構的記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 任何有效的檔案數目。</param>
        <param name="FromRecord">選擇性。 要鎖定或解除鎖定的第一筆資料錄或第一個位元組的編號。</param>
        <param name="ToRecord">選擇性。 要鎖定或解除鎖定的最後一筆資料錄或最後一個位元組的編號。</param>
        <summary>控制項由其他處理序存取以 <see langword="Open" /> 函式開啟的整個或部分檔案。 <see langword="My" /> 功能提供比 <see langword="Lock" /> 和 <see langword="Unlock" /> 更優越的檔案 I/O 作業產能和效能。 如需詳細資訊，請參閱<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。  
  
 `Lock` 和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。  
  
 如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此範例說明如何使用`Lock`和`Unlock`函式。 這個範例假設`People.txt`是包含結構的記錄檔`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含任何有效檔案數目的 <see langword="Integer" /> 運算式。</param>
        <param name="Output">選擇性。 要寫入檔案的一或多個逗點分隔運算式。</param>
        <summary>將資料寫入循序檔。 使用 <see langword="Write" /> 寫入的資料，通常會透過使用 <see langword="Input" /> 從檔案讀取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。  
  
 不同於`Print`函式，`Write`函式插入項目和引號括住的字串之間的逗號，當寫入檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數值， `Boolean`，日期、 null、 和`Error`資料格式都受到支援。 因此資料一律可以讀取並正確解譯使用，會遵循下列通用假設`Input`，而不論地區設定：  
  
-   寫入的數值資料使用句號當做十進位分隔符號。  
  
-   如`Boolean`資料，在`#TRUE#`或`#FALSE#`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。  
  
-   日期資料會寫入至檔案使用通用的日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
-   不寫入至檔案如果`Output`是空的資料。 不過，對於 null 的資料，`#NULL#`寫入。  
  
-   如`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。  
  
 `WriteLine` 插入新行字元 (也就是歸位字元/換，或`Chr(13) + Chr(10)`)、 撰寫最後一個字元之後`Output`檔案。  
  
 您也可以使用雙引號括住，在字串中內嵌引號或""。 例如，套用至物件的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 傳回值是字串`Double quotation marks aren't "difficult" to handle`。  
  
 寫入檔案，使用`Write`或`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Write`函式，將原始資料寫入至循序檔案。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">檔案模式無效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必要。 包含任何有效檔案數目的 <see langword="Integer" /> 運算式。</param>
        <param name="Output">選擇性。 要寫入檔案的一或多個逗點分隔運算式。</param>
        <summary>將資料寫入循序檔。 使用 <see langword="Write" /> 寫入的資料，通常會透過使用 <see langword="Input" /> 從檔案讀取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。  
  
 不同於`Print`函式，`Write`函式插入項目和引號括住的字串之間的逗號，當寫入檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數值， `Boolean`，日期、 null、 和`Error`資料格式都受到支援。 因此資料一律可以讀取並正確解譯使用，會遵循下列通用假設`Input`，而不論地區設定：  
  
-   寫入的數值資料使用句號當做十進位分隔符號。  
  
-   如`Boolean`資料，在`#TRUE#`或`#FALSE#`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。  
  
-   日期資料會寫入至檔案使用通用的日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。  
  
-   不寫入至檔案如果`Output`是空的資料。 不過，對於 null 的資料，`#NULL#`寫入。  
  
-   如`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。  
  
 `WriteLine` 插入新行字元 (也就是歸位字元/換，或`Chr(13) + Chr(10)`)、 撰寫最後一個字元之後`Output`檔案。  
  
 您也可以使用雙引號括住，在字串中內嵌引號或""。 例如，套用至物件的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 傳回值是字串`Double quotation marks aren't "difficult" to handle`。  
  
 寫入檔案，使用`Write`或`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 這個範例會使用`Write`函式，將原始資料寫入至循序檔案。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>