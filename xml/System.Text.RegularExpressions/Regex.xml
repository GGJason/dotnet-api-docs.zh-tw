<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bb2051ea3f84d7f65cf8d414a93bce613dcad0ff" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36608489" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示不變的規則運算式 (Regular Expression)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>類別代表.NET Framework 規則運算式引擎。 可用於快速剖析大量文字，尋找特定的字元模式;擷取、 編輯、 取代或刪除文字子字串;並將擷取的字串新增至集合，以產生報表。  
  
> [!NOTE]
>  如果您主要的優點是要判斷它是否符合特定模式來驗證字串，您可以使用<xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType>類別。  
  
 若要使用規則運算式，您會定義您想要使用中所述的語法來識別文字資料流中的模式[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 接下來，您可以選擇性地具現化<xref:System.Text.RegularExpressions.Regex>物件。 最後，您可以呼叫執行某些作業，例如取代符合規則運算式模式的文字，或識別模式比對的方法。  
  
> [!NOTE]
>  某些常見的規則運算式模式，請參閱[規則運算式範例](~/docs/standard/base-types/regular-expression-examples.md)。 另外還有數的規則運算式模式，例如在線上文件庫[一般 Expressions.info](https://www.regular-expressions.info/examples.html)。  
  
<a name="remarks"></a> 如需有關使用<xref:System.Text.RegularExpressions.Regex>類別，請參閱本主題中的下列各節：  
  
-   [Regex vs。字串方法](#regex_vs_string)  
  
-   [靜態與執行個體方法](#static_vs_instance)  
  
-   [執行規則運算式作業](#regex_ops)  
  
-   [定義逾時值](#define_timeout)  
  
 如需規則運算式語言的詳細資訊，請參閱[規則運算式語言 - 快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)，或下載並列印下列其中一本小手冊：  
  
 [Word (.docx) 格式的快速參考](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [PDF (.pdf) 格式的快速參考](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex vs。字串方法  
 <xref:System.String?displayProperty=nameWithType>類別包含您可以使用執行模式比對文字的數個搜尋和比較方法。 例如， <xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.EndsWith%2A?displayProperty=nameWithType>，和<xref:System.String.StartsWith%2A?displayProperty=nameWithType>方法，判斷字串執行個體是否包含指定的子字串; 而<xref:System.String.IndexOf%2A?displayProperty=nameWithType>， <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>， <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>，和<xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType>方法傳回的開始在字串中指定的子字串的位置。 使用的方法<xref:System.String?displayProperty=nameWithType>類別時，您要搜尋特定字串。 使用<xref:System.Text.RegularExpressions.Regex>類別時，您要搜尋特定的模式字串中。 如需詳細資訊和範例，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)。  
  
 [回註解](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>靜態與執行個體方法  
 定義規則運算式模式之後，您可以提供給規則運算式引擎在任一種方式：  
  
-   藉由執行個體化<xref:System.Text.RegularExpressions.Regex>表示規則運算式物件。 若要這樣做，您將傳遞至規則運算式模式<xref:System.Text.RegularExpressions.Regex.%23ctor%2A>建構函式。 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的; 當您具現化<xref:System.Text.RegularExpressions.Regex>規則運算式物件，無法變更物件的規則運算式。  
  
-   藉由提供規則運算式和要搜尋的文字`static`(`Shared`在 Visual Basic 中)<xref:System.Text.RegularExpressions.Regex>方法。 這可讓您使用規則運算式，而不需要明確建立<xref:System.Text.RegularExpressions.Regex>物件。  
  
 所有<xref:System.Text.RegularExpressions.Regex>模式識別方法包含靜態和執行個體的多載。  
  
 規則運算式引擎必須編譯特定模式，才能使用此模式。 因為<xref:System.Text.RegularExpressions.Regex>物件是不變，這是一次性程序，就會發生時<xref:System.Text.RegularExpressions.Regex>呼叫類別建構函式或靜態方法。 若要消除重複編譯單一規則運算式的需要，規則運算式引擎會快取靜態方法呼叫中所編譯的規則運算式。 如此一來，規則運算式模式比對方法提供相當的效能，針對靜態和執行個體方法。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 版，全都編譯規則運算式，是否使用這些認證執行個體或靜態方法中呼叫，快取。 從.NET Framework 2.0 開始，只有在靜態方法呼叫中使用的規則運算式會快取。  
  
 不過，快取效能造成不良影響下列兩個案例中：  
  
-   當您使用靜態方法呼叫，且含有大量規則運算式。 根據預設，規則運算式引擎會快取 15 個最近使用靜態規則運算式。 如果您的應用程式會使用超過 15 個靜態規則運算式中，某些規則運算式就必須重新編譯。 若要避免此重新編譯，您可以增加<xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>屬性。  
  
-   當您具現化新<xref:System.Text.RegularExpressions.Regex>使用先前已編譯的規則運算式物件。 例如，下列程式碼定義規則運算式，在文字資料流中找到重複的文字。 雖然此範例會使用單一規則運算式，它會具現化新<xref:System.Text.RegularExpressions.Regex>物件以處理每一行文字。 這會導致重新編譯的規則運算式與迴圈的每個反覆項目。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     若要避免重新編譯，您應該具現化單一<xref:System.Text.RegularExpressions.Regex>均可存取所有的程式碼時需要它，改寫下列範例所示的物件。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [回註解](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>執行規則運算式作業  
 您是否決定具現化<xref:System.Text.RegularExpressions.Regex>物件，並呼叫其方法或呼叫靜態方法，<xref:System.Text.RegularExpressions.Regex>類別提供了下列的模式比對功能：  
  
-   驗證的相符項目。 您呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法，以判斷是否有相符項目。  
  
-   擷取單一相符項目。 您呼叫<xref:System.Text.RegularExpressions.Regex.Match%2A>方法來擷取<xref:System.Text.RegularExpressions.Match>物件，表示字串或部分字串的第一個相符項目。 可以藉由呼叫擷取後續相符項目的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。  
  
-   擷取所有相符項目。 您呼叫<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法來擷取<xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType>物件，代表找到的字串或字串的部分的所有相符項目。  
  
-   取代相符的文字。 您呼叫<xref:System.Text.RegularExpressions.Regex.Replace%2A>方法，以取代相符的文字。 取代文字，也可以定義規則運算式。 此外，某些<xref:System.Text.RegularExpressions.Regex.Replace%2A>方法包括<xref:System.Text.RegularExpressions.MatchEvaluator>參數，可讓您以程式設計方式定義取代文字。  
  
-   建立從輸入字串的組件的正確的字串陣列。 您呼叫<xref:System.Text.RegularExpressions.Regex.Split%2A>方法來分割輸入的字串，在規則運算式所定義的位置。  
  
 其模式比對的方法，除了<xref:System.Text.RegularExpressions.Regex>類別包含數種特殊用途的方法：  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A>方法會逸出任何可能會解譯為規則運算式或輸入的字串中的規則運算式運算子的字元。  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法會移除這些逸出字元。  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會建立包含預先定義的規則運算式的組件。 .NET Framework 中包含這些特殊用途的組件中的範例<xref:System.Web.RegularExpressions?displayProperty=nameWithType>命名空間。  
  
 [回註解](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>定義逾時值  
 .NET Framework 支援的功能完整的規則運算式語言提供大幅的功能及彈性在模式比對。 不過，功能與彈性有其代價： 效能不佳的風險。 執行效能很差的規則運算式是很容易建立。 在某些情況下，可能會依賴大量回溯規則運算式作業停止回應時，它們會處理幾乎符合規則運算式模式的文字。 如需.NET Framework 規則運算式引擎的詳細資訊，請參閱[規則運算式行為的詳細資料](~/docs/standard/base-types/details-of-regular-expression-behavior.md)。 如需大量回溯的詳細資訊，請參閱[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。  
  
 從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，您可以定義逾時間隔，規則運算式相符項目。 如果規則運算式引擎無法識別符合此時間間隔內，比對作業會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 在大部分情況下，如此可防止規則運算式引擎嘗試比對幾乎符合規則運算式模式的文字所浪費的處理能力。 它也可能表示，不過的逾時間隔已設定太低，或是目前機器工作負載的效能，導致整體的降低。  
  
 處理例外狀況的方式取決於例外狀況的原因。 如果因為逾時間隔設定太低，就會發生例外狀況或因為過多的機器工作負載，您可以增加逾時間隔並重試比對作業。 因為規則運算式會依賴大量回溯，就會發生例外狀況，您可以假設相符項目不存在，以及 （選擇性） 您可以記錄資訊可協助您修改規則運算式模式。  
  
 您可以藉由呼叫設定逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式，當您具現化規則運算式物件。 靜態方法，您可以設定逾時間隔，藉由呼叫的比對方法的多載`matchTimeout`參數。 如果您未明確設定的逾時值，預設的逾時值是取決於下列條件：  
  
-   使用全應用程式逾時的值，如果有一個存在。 這可以是應用程式定義域，適用於任何逾時值<xref:System.Text.RegularExpressions.Regex>物件具現化，或呼叫靜態方法。 您可以設定整個應用程式的逾時值，藉由呼叫<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法，以指定的字串表示<xref:System.TimeSpan>"REGEX_DEFAULT_MATCH_TIMEOUT"屬性的值。  
  
-   使用的值來<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>，如果已設定沒有整個應用程式的逾時值。  
  
> [!IMPORTANT]
>  我們建議您在所有的規則運算式模式比對作業設定的逾時值。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)。  
  
 [回註解](#remarks)  
  
   
  
## Examples  
 下列範例會使用規則運算式，檢查有重複出現的文字字串中。 規則運算式`\b(?<word>\w+)\s+(\k<word>)\b`可以解譯為下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`(?<word>\w+)`|比對一個或多個文字字元，最多字邊界。 將此擷取的群組命名`word`。|  
|`\s+`|比對一個或多個空格字元。|  
|`(\k<word>)`|比對擷取的群組命名`word`。|  
|`\b`|比對字邊界。|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 下列範例說明如何使用規則運算式以檢查是否為字串表示貨幣值，或者具有正確格式來表示貨幣值。 在此情況下，規則運算式，會動態建立從<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>使用者的目前文化特性的屬性。 如果系統的目前文化特性是 EN-US，產生的規則運算式是`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`。 下表所示，可以解譯這個規則運算式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|在字串開頭開始。|  
|`\s*`|比對零個以上的空白字元。|  
|`[\+-]?`|比對零個或一個正號或負號。|  
|`\s?`|比對零個或一個空白字元。|  
|`\$?`|比對零個或一個貨幣符號。|  
|`\s?`|比對零個或一個空白字元。|  
|`\d*`|比對零個或多個十進位數字。|  
|`\.?`|比對零個或一個小數點符號。|  
|`\d{2}?`|比對兩個十進位數字零或一次。|  
|`(\d*\.?\d{2}?){1}`|比對整數和小數的位數，小數點符號分隔至少一次的模式。|  
|`$`|比對字串的結尾。|  
  
 在此情況下，規則運算式假設有效貨幣字串不包含群組分隔符號符號，而且它有沒有小數的數字或目前的文化特性所定義的小數位數<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>屬性。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 在此範例中的規則運算式，會動態建立，因為我們不知道在設計階段是否目前文化特性的貨幣符號、 小數符號或正的和負的符號可能無法正確解譯為規則，規則運算式引擎運算式語言運算子。 若要防止任何的錯譯，範例會傳遞至每個動態產生的字串<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <see cref="T:System.Text.RegularExpressions.Regex" />類別是不變 （唯讀） 和安全執行緒。 <see cref="T:System.Text.RegularExpressions.Regex" /> 可以在任何執行緒上建立和執行緒之間共用物件。 如需詳細資訊，請參閱 [執行緒 Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)。</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，這個建構函式會保護;只可以呼叫的類別衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>為指定的規則運算式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。  
  
 呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29>建構函式相當於呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式，其值為<xref:System.Text.RegularExpressions.RegexOptions.None>如`options`引數。  
  
 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的這表示它可以用僅適用於您定義您所建立的比對模式。 不過，它可以單獨使用任意數目的時間而沒有重新編譯。  
  
 這個建構函式會嘗試定義中的任何字母字元的區分大小寫比對規則運算式物件具現化`pattern`。 不區分大小寫的比對中，使用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>建構函式。  
  
   
  
## Examples  
 下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的單字，"a"或"t"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 請注意，規則運算式模式，無法比對的字"The"開頭的文字，因為比較會區分大小寫預設值。 例如不區分大小寫的比較中，請參閱<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>這個建構函式會建立<see cref="T:System.Text.RegularExpressions.Regex" />會使用預設的逾時值，在其中建立的應用程式定義域的物件。如果尚未應用程式定義域定義逾時值<see cref="T:System.Text.RegularExpressions.Regex" />物件會使用值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，這樣就不會逾時的作業。建立建議建構函式<see cref="T:System.Text.RegularExpressions.Regex" />物件是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">包含序列化模式和 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 資訊的物件。</param>
        <param name="context">這個序列化的目的端。 (不使用這個參數；請指定 <see langword="null" />)。</param>
        <summary>使用序列化的資料，初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 包含的模式為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> 包含無效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 旗標。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會修改規則運算式。</param>
        <summary>使用會修改模式的選項，為指定的規則運算式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。  
  
 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的這表示它可以用僅適用於您定義您所建立的比對參數。 不過，它可以單獨使用任意數目的時間而沒有重新編譯。  
  
   
  
## Examples  
 下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的單字，"a"或"t"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 請注意比對集合包含文字"The"開頭的文字，因為`options`已定義參數不區分大小寫的比較。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 包含無效的旗標。</exception>
        <block subset="none" type="usage">
          <para>這個建構函式會建立<see cref="T:System.Text.RegularExpressions.Regex" />會使用預設的逾時值，在其中建立的應用程式定義域的物件。如果尚未應用程式定義域定義逾時值<see cref="T:System.Text.RegularExpressions.Regex" />物件會使用值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，這樣就不會逾時的作業。建立建議建構函式<see cref="T:System.Text.RegularExpressions.Regex" />物件是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會修改規則運算式。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>針對指定的規則運算式，使用修改模式的選項，以及指定在逾時前模式比對方法應該嘗試比對的時間長度的值，初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。  
  
 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的這表示它可以用僅適用於您定義當您建立比對模式。 不過，它可以單獨使用任意數目的時間而沒有重新編譯。  
  
 `matchTimeout`參數指定時間長度的模式比對方法應嘗試尋找相符項目，即會逾時。如果沒有找到符合該時間間隔中，會擲回的模式比對方法<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何預設逾時值為應用程式定義域，定義<xref:System.Text.RegularExpressions.Regex>建立物件。 執行個體模式比對方法觀察`matchTimeout`逾時間隔包括下列：  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)和[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 若要設定的合理的逾時間隔，請考慮下列因素：  
  
-   長度與複雜度的規則運算式模式。 長、 更複雜的規則運算式會需要更多的時間比短且更簡單。  
  
-   預期的機器工作負載。 在 CPU 和記憶體使用率過高的系統上處理花費的時間。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式來具現化<xref:System.Text.RegularExpressions.Regex>逾時值為一秒的物件。 規則運算式模式 `(a+)+$`會在行尾比對一個或多個 "a" 字元的一個或多個序列，並且受限於大量回溯。 如果<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>會擲回，則範例會增加逾時值，最多三秒的最大值。 否則，它會放棄嘗試比對模式。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定在已編譯規則運算式目前靜態快取中項目的最大數目。</summary>
        <value>靜態快取中項目的最大數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>類別會維護內部快取已編譯的規則運算式的靜態方法呼叫中使用。 如果在設定作業中指定的值小於目前的快取大小，快取項目都會被捨棄，直到快取大小是否等於指定的值。  
  
 根據預設，快取保存 15 編譯靜態規則運算式。 您的應用程式通常不會修改快取的大小。 使用<xref:System.Text.RegularExpressions.Regex.CacheSize%2A>屬性只有當您想要關閉 快取，或當您有非常大的快取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定作業中的值小於零。</exception>
        <block subset="none" type="usage">
          <para>在之前的.NET Framework [！INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]，規則運算式用於這兩個靜態和快取執行個體方法呼叫。從 [！靜態方法呼叫會快取中使用 INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]，只在規則運算式。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字典，對應具名擷取群組及其索引值。</summary>
        <value>對應具名擷取群組及其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，這個屬性受到保護。它只能從衍生自的類別存取<xref:System.Text.RegularExpressions.Regex>類別。  
  
 設定作業會嘗試將指派給屬性的值<xref:System.Collections.Hashtable>物件; 如果這個轉換會失敗，則會呼叫<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">在設定作業中指派給 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 的屬性值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字典，對應編號的擷取群組及其索引值。</summary>
        <value>對應編號的擷取群組及其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，這個屬性受到保護。它只能從衍生自的類別存取<xref:System.Text.RegularExpressions.Regex>類別。  
  
 設定作業會嘗試將指派給屬性的值<xref:System.Collections.Hashtable>物件; 如果這個轉換會失敗，則會呼叫<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">在設定作業中指派給 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 的屬性值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>編譯規則運算式並將它們以單一組件 (Assembly) 儲存至磁碟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

.NET Core 上呼叫`Regex.CompileToAssembly`方法擲回<xref:System.PlatformNotSupportedException>; 不支援寫出組件。
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">陣列，描述要編譯的規則運算式。</param>
        <param name="assemblyname">組件的檔案名稱。</param>
        <summary>將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件編譯為具名組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>方法產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由類別。 一般而言，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>方法從個別的應用程式會產生編譯的規則運算式的組件呼叫。 每個規則運算式包含在組件具有下列特性：  
  
-   它衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
-   它指派由所定義的完整限定的名稱`fullnamespace`和`name`參數對應<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。  
  
-   它有預設值 （或無參數） 建構函式。  
  
 一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。  
  
   
  
## Examples  
 下列範例會建立名為 RegexLib.dll 組件。 組件包含兩個已編譯的規則運算式。 首先， `Utilities.RegularExpressions.DuplicatedString`，比對兩個相同的連續文字。 第二個， `Utilities.RegularExpressions.EmailAddress`，會檢查字串是否具有正確的格式為電子郵件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 然後具現化並使用下列範例會檢查重複的文字字串的規則運算式。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立組件） 的參考加入至專案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。  或 <paramref name="regexinfos" /> 中一或多個物件的規則運算式模式包含無效的語法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</exception>
        <block subset="none" type="usage">
          <para>如果您正在開發上具有的系統 [！INCLUDE[net_v45](~/includes/net-v45-md.md)] 或其點發行版本安裝目標 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法來建立包含的組件編譯的規則運算式。嘗試使用其中一種規則運算式，因為在系統上的組件，具有 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 擲回例外狀況。若要暫時解決此問題，您可以執行下列其中一:-建置組件，其中包含已在系統上編譯的規則運算式 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 改為更新版本的安裝。 -而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />，擷取已編譯的規則運算式的組件時，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">陣列，描述要編譯的規則運算式。</param>
        <param name="assemblyname">組件的檔案名稱。</param>
        <param name="attributes">陣列，定義要套用至組件的屬性。</param>
        <summary>將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件編譯為具有指定之屬性的具名組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>方法產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由類別。 一般而言，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>方法從個別的應用程式會產生編譯的規則運算式的組件呼叫。 每個規則運算式包含在組件具有下列特性：  
  
-   它衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
-   它指派由所定義的完整限定的名稱`fullnamespace`和`name`參數對應<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。  
  
-   它有預設值 （或無參數） 建構函式。  
  
 一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。  
  
 因為<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會產生在方法呼叫，而不是使用特定語言的類別定義關鍵字的.NET Framework 組件 (例如`class`在 C# 或`Class`...`End Class` 在 Visual Basic 中)，所以不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。 `attributes`參數提供的替代方法，用於定義套用至組件的屬性。 針對每個您想要套用至組件的屬性，執行下列作業：  
  
1.  建立陣列<xref:System.Type>代表您想要呼叫的屬性建構函式的參數類型的物件。  
  
2.  擷取<xref:System.Type>物件，代表您想要套用至新的組件的屬性類別。  
  
3.  呼叫<xref:System.Type.GetConstructor%2A>方法屬性的<xref:System.Type>物件，以擷取<xref:System.Reflection.ConstructorInfo>物件，代表您想要呼叫的屬性建構函式。 傳遞<xref:System.Type.GetConstructor%2A>方法陣列的<xref:System.Type>代表建構函式的參數類型的物件。  
  
4.  建立<xref:System.Object>陣列，定義要傳遞給該屬性的建構函式的參數。  
  
5.  具現化<xref:System.Reflection.Emit.CustomAttributeBuilder>物件，並傳遞其建構函式<xref:System.Reflection.ConstructorInfo>步驟 3 中所擷取的物件和<xref:System.Object>在步驟 4 建立的陣列。  
  
 接著，您可以將這些陣列<xref:System.Reflection.Emit.CustomAttributeBuilder>物件而不是`attributes`參數<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會建立名為 RegexLib.dll 組件，並套用<xref:System.Reflection.AssemblyTitleAttribute>屬性。 組件包含兩個已編譯的規則運算式。 首先， `Utilities.RegularExpressions.DuplicatedString`，比對兩個相同的連續文字。 第二個， `Utilities.RegularExpressions.EmailAddress`，會檢查字串是否具有正確的格式為電子郵件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 您可以確認<xref:System.Reflection.AssemblyTitleAttribute>藉由檢查它的資訊清單，以反映公用程式，例如 ILDasm 屬性套用至組件。  
  
 然後具現化並使用下列範例會檢查重複的文字字串的規則運算式。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立組件） 的參考加入至專案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。  或 <paramref name="regexinfos" /> 中一或多個物件的規則運算式模式包含無效的語法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</exception>
        <block subset="none" type="usage">
          <para>如果您正在開發上具有的系統 [！INCLUDE[net_v45](~/includes/net-v45-md.md)] 或其點發行版本安裝目標 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法來建立包含的組件編譯的規則運算式。嘗試使用其中一種規則運算式，因為在系統上的組件，具有 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 擲回例外狀況。若要暫時解決此問題，您可以執行下列其中一:-建置組件，其中包含已在系統上編譯的規則運算式 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 改為更新版本的安裝。 -而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />，擷取已編譯的規則運算式的組件時，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">陣列，描述要編譯的規則運算式。</param>
        <param name="assemblyname">組件的檔案名稱。</param>
        <param name="attributes">陣列，定義要套用至組件的屬性。</param>
        <param name="resourceFile">要包括在組件中的 Win32 資源檔的名稱。</param>
        <summary>將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件和指定的資源檔編譯為具有指定之屬性的具名組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 群組名稱的集合包含用來在運算式中的擷取群組命名的字串集合。 即使沒有明確命名的擷取群組，它們會自動指派數值的名稱 （"0"、"1"、"2"、"3"，等等）。 每個規則運算式包含在組件具有下列特性：  
  
-   它衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
-   它指派由所定義的完整限定的名稱`fullnamespace`和`name`參數對應<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。  
  
-   它有預設值 （或無參數） 建構函式。  
  
 一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。  
  
 因為<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會產生在方法呼叫，而不是使用特定語言的類別定義關鍵字的.NET Framework 組件 (例如`class`在 C# 或`Class`...`End Class` 在 Visual Basic 中)，所以不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。 `attributes`參數提供的替代方法，用於定義套用至組件的屬性。 針對每個您想要套用至組件的屬性，執行下列作業：  
  
1.  建立陣列<xref:System.Type>代表您想要呼叫的屬性建構函式的參數類型的物件。  
  
2.  擷取<xref:System.Type>物件，代表您想要套用至新的組件的屬性類別。  
  
3.  呼叫<xref:System.Type.GetConstructor%2A>方法屬性的<xref:System.Type>物件，以擷取<xref:System.Reflection.ConstructorInfo>物件，代表您想要呼叫的屬性建構函式。 "0"具名群組代表規則運算式模式比對所有文字。  
  
4.  建立<xref:System.Object>陣列，定義要傳遞給該屬性的建構函式的參數。  
  
5.  具現化<xref:System.Reflection.Emit.CustomAttributeBuilder>物件，並傳遞其建構函式<xref:System.Reflection.ConstructorInfo>步驟 3 中所擷取的物件和<xref:System.Object>在步驟 4 建立的陣列。  
  
 編號的群組之前明確命名的群組集合中，而且具名的群組會出現在規則運算式模式中定義的順序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。  或 <paramref name="regexinfos" /> 中一或多個物件的規則運算式模式包含無效的語法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="resourceFile" /> 參數指定不正確的 Win32 資源檔。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="resourceFile" /> 參數所指定的檔案。</exception>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</exception>
        <block subset="none" type="usage">
          <para>如果您正在開發上具有的系統 [！INCLUDE[net_v45](~/includes/net-v45-md.md)] 或其點發行版本安裝目標 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法來建立包含的組件編譯的規則運算式。嘗試使用其中一種規則運算式，因為在系統上的組件，具有 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 擲回例外狀況。若要暫時解決此問題，您可以執行下列其中一:-建置組件，其中包含已在系統上編譯的規則運算式 [！INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 改為更新版本的安裝。 -而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />，擷取已編譯的規則運算式的組件時，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">輸入字串，包含要轉換的文字。</param>
        <summary>以逸出程式碼取代字元 (\\、*、+、?、|、{、[、(、)、^、$、.、# 和空白字元) 的最小集合，以便逸出這些字元。 這樣會指示規則運算式引擎將這些字元解譯為常值，而非解譯為中繼字元。</summary>
        <returns>字元字串，其中中繼字元已轉換為逸出格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 在此情況下，規則運算式模式<xref:System.Text.RegularExpressions.Regex.Escape%2A>旨在剖析簡單的句子，並識別其第一個單字、 最後一個字，以及結束的標點符號。 下表顯示規則運算式模式的解譯方式： 這是具名群組。 \s 嗎？  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 ((\w+)\s)* 下列範例將說明這點。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 比對一個或多個文字字元後面接著空白字元的零或多個相符項目。 (?<xref:System.Text.RegularExpressions.Regex.Escape%2A>LastWord > \w+)？  
  
> [!NOTE]
>  比對零個或一個的一或多個文字字元。  
  
 (?<xref:System.Text.RegularExpressions.Regex.Escape%2A>標點符號 > \p{Po}) 比對的字元的 Unicode 分類為標點符號，其他。 未具名和具名擷取群組可以存取數字。 未命名的群組會從左到右從 1 開始編號。 （索引 0 （零） 中的擷取群組會代表比對整個）。 具名的群組然後從使用的數字大一開始由左至右編號數目未具名擷取群組。  
  
   
  
## Examples  
 依字串名稱參考 group by 而不是其數目可以提供更快的存取。 下列範例會定義規則運算式， ，符合句子。 規則運算式包含三個擷取群組： 未命名的群組，這會擷取個別的字，空格字元，它可能會遵照; 以及名為群組<xref:System.Text.RegularExpressions.Regex.Escape%2A>可擷取句子; 中的個別字與群組命名為可擷取結束句子的標點符號。 範例會呼叫方法來取得所有擷取的數字群組，然後顯示 [擷取的字串。 此外，\\方法用來表示特定編號的群組是否對應至具名的群組。 比對一個或多個文字字元，並將相符的字串指派給群組，名為<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回規則運算式的擷取群組名稱的陣列。</summary>
        <returns>群組名稱的字串陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指派後面接著任何擷取的群組所擷取的第一個擷取群組的空格字元。 比對後面接著空白字元的任何字元一或多次的一個或多個文字字元的模式。 指定要比對的字元擷取群組。 如果沒有群組名稱對應至，方法會傳回。  
  
 規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。  
  
   
  
## Examples  
 編號的群組會分隔語法 (`ShowMatches`subexpression)，系統會指派數字，根據規則運算式的順序。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 具名的群組會分隔語法 (？`\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})`名稱subexpression) 或 (？ '名稱'subexpression)，其中名稱是子運算式會識別的名稱。 方法識別命名的群組和編號的群組，依據它們在規則運算式中的序數位置。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`(?<FirstWord>\w+)`|比對一個或多個文字字元。 序數位置 0 一律代表整個規則運算式。|  
|所有編號群組則會計算前具名群組，不論它們在規則運算式模式中的實際位置。|比對零個或一個空白字元。|  
|(\w+)|比對一個或多個文字字元。 這是第二個擷取群組。|  
|\s|比對空白字元。|  
|如果是數字的具名群組，方法會傳回群組的名稱。|如果是數字的未命名的群組，方法會傳回數字的字串表示。 這是第一個擷取群組。|  
|例如，如果\<為 1，則方法會傳回"1"。|比對零個或一個的一或多個文字字元。 序數位置 0 一律代表整個規則運算式。|  
|(?\<標點符號 > \p{Po})|比對的字元的 Unicode 分類為標點符號，其他。 序數位置 0 一律代表整個規則運算式。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回對應陣列中群組名稱的擷取群組編號的陣列。</summary>
        <returns>群組編號的整數陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未具名和具名擷取群組可以存取數字。 未命名的群組會從左到右從 1 開始編號。 （索引 0 （零） 中的擷取群組會代表比對整個）。具名的群組然後從使用的數字大一開始由左至右編號數目未具名擷取群組。  
  
 依字串名稱參考 group by 而不是其數目可以提供更快的存取。  
  
   
  
## Examples  
 下列範例會定義規則運算式， `\b((?<word>\w+)\s*)+(?<end>[.?!])`，符合句子。 規則運算式包含三個擷取群組： 未命名的群組，這會擷取個別的字，空格字元，它可能會遵照; 以及名為群組`word`可擷取句子; 中的個別字與群組命名為`end`可擷取結束句子的標點符號。 範例會呼叫<xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A>方法來取得所有擷取的數字群組，然後顯示 擷取的字串。 此外，<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法用來表示特定編號的群組是否對應至具名的群組。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 規則運算式模式的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`(?<word>\w+)`|比對一個或多個文字字元，並將相符的字串指派給群組，名為`word`。|  
|`\s*`|比對零個以上的空白字元。|  
|`((?<word>\w+)\s*)`|指派`word`後面接著任何擷取的群組所擷取的第一個擷取群組的空格字元。|  
|`((?<word>\w+)\s*)+`|比對後面接著空白字元的任何字元一或多次的一個或多個文字字元的模式。|  
|`(?<end>[.?!])`|比對句號、問號或驚嘆號。 指定要比對的字元`end`擷取群組。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">要轉換至對應群組名稱的群組編號。</param>
        <summary>取得對應指定群組編號的群組名稱。</summary>
        <returns>字串，含有與指定群組編號相關聯的群組名稱。 如果沒有對應 <paramref name="i" /> 的群組名稱，方法會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。 編號的群組會分隔語法 (*subexpression*)，系統會指派數字，根據規則運算式的順序。 具名的群組會分隔語法 (？`<`*名稱*`>`*subexpression*) 或 (？ '*名稱*'*subexpression*)，其中*名稱*是子運算式會識別的名稱。 (如需詳細資訊，請參閱[群組建構](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。)<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法識別命名的群組和編號的群組，依據它們在規則運算式中的序數位置。 序數位置 0 一律代表整個規則運算式。 所有編號群組則會計算前具名群組，不論它們在規則運算式模式中的實際位置。  
  
 如果`i`是數字的具名群組，方法會傳回群組的名稱。 如果`i`是數字的未命名的群組，方法會傳回數字的字串表示。 例如，如果`i`為 1，則方法會傳回"1"。 如果`i`不是數的擷取群組，則方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 如果找到模式比對，這個方法所傳回的值再用來擷取<xref:System.Text.RegularExpressions.Group>物件，代表擷取的群組從<xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType>屬性。 <xref:System.Text.RegularExpressions.GroupCollection>物件由<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>屬性。  
  
   
  
## Examples  
 下列範例會定義符合包含美國縣 （市） 名稱、 狀態名稱和郵遞區號地址的規則運算式模式。 此範例會使用<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法來擷取的擷取群組的名稱。 然後，它會使用這些名稱來擷取對應的擷取的群組相符項目。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|比對一個或多個字母或空格字元。 將此擷取的群組名稱的指派`city`。|  
|`,`|比對後面接著空白字元的逗號 （，）。|  
|`(?<state>[A-Za-z]{2})`|比對兩個字母的字元。 將此擷取的群組名稱的指派`state`。 此群組後面必須接著空格字元。|  
|`(?<zip>\d{5}(-\d{4})?)`|比對後面接著零個或一個出現的連字號後面接著四個的數字的五個數字。 將此擷取的群組名稱的指派`zip`。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">群組名稱，要轉換至對應群組編號的。</param>
        <summary>傳回對應指定群組名稱的群組編號。</summary>
        <returns>對應指定群組名稱的群組編號；如果 <paramref name="name" /> 不是有效的群組名稱，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。 編號的群組會分隔語法 (*subexpression*)，系統會指派數字，根據規則運算式的順序。 具名的群組會分隔語法 (？`<`*名稱*`>`*subexpression*) 或 (？ '*名稱*'*subexpression*)，其中*名稱*是子運算式會識別的名稱。 (如需詳細資訊，請參閱[群組建構](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。)<xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A>方法識別命名的群組和編號的群組，依據它們在規則運算式中的序數位置。 序數位置 0 一律代表整個規則運算式。 所有編號群組則會計算前具名群組，不論它們在規則運算式模式中的實際位置。  
  
 如果`name`是出現在規則運算式模式中，則方法會傳回數字的群組數字的字串表示。 如果`name`對應至具名擷取群組會出現在規則運算式模式，方法會傳回其對應的數字。 比較的`name`與群組名稱會區分大小寫。 如果`name`未對應至擷取群組的名稱，或擷取群組，該方法的數字的字串表示會傳回-1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定模式比對作業不應逾時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>類別建構函式和靜態比對的方法使用一些<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常數表示嘗試尋找模式比對應該逾時。  
  
> [!WARNING]
>  將規則運算式引擎的逾時值設定為<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>可能會造成依賴大量回溯，看起來像處理幾乎符合規則運算式模式的文字時停止回應的規則運算式。 如果您停用逾時，您應該確定，您的規則運算式不會依賴大量回溯，和它處理幾乎符合規則運算式模式的文字。  
>   
>  如需處理回溯的詳細資訊，請參閱[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常數可以提供的值為`matchTimeout`下列成員的引數：  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">參考已初始化。</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在作業逾時之前可在模式比對作業中流逝的最長時間。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示規則運算式是否在輸入字串中尋找比對。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <summary>表示 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式是否要在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例說明使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>方法來判斷字串是否為有效的組件數目。 規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。 第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須是數字。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 規則運算式模式為：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|開始一行的開頭比對。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`\d{2}`|比對兩個數值字元。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對三個數值字元。|  
|`(-\d{3}){2}`|找出連字號後面接著三個數字字元，並符合此模式的兩個項目。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`$`|結束在行尾比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="startat">要開始搜尋的字元位置。</param>
        <summary>表示 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中所指定的規則運算式，是否要從字串中指定的起始位置開始，在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例說明使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法來判斷字串是否為有效的組件數目。 它會搜尋字串中的冒號 （:） 字元後面接著的零件編號。 <xref:System.String.IndexOf%28System.Char%29>方法用來決定位置的冒號字元，然後傳遞至<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法。 規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。 第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須是數字。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 規則運算式模式為：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`\d{2}`|比對兩個數值字元。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對三個數值字元。|  
|`(-\d{3}){2}`|找出連字號後面接著三個數字字元，並符合此模式的兩個項目。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`$`|結束在行尾比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>表示指定的規則運算式是否在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與所指定的規則運算式模式`pattern`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。 這個規則運算式模式的規則運算式引擎會快取供快速擷取。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例說明使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法來判斷字串是否為有效的組件數目。 規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。 第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須是數字。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 規則運算式模式為：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|開始一行的開頭比對。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`\d{2}`|比對兩個數值字元。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對三個數值字元。|  
|`(-\d{3}){2}`|找出連字號後面接著三個數字字元，並符合此模式的兩個項目。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`透過`z`或`A`透過`Z`) 或數字字元。|  
|`$`|結束在行尾比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫該方法的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，以驗證模式比對是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>表示指定的規則運算式是否使用指定的比對選項，在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與所指定的規則運算式模式`pattern`和所指定的規則運算式選項`options`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。 這個規則運算式模式的規則運算式引擎會快取供快速擷取。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例說明使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法來判斷字串是否為有效的組件數目。 規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。 第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須是數字。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 規則運算式模式為：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|從字串的開頭開始比對。|  
|`[A-Z0-9]`|比對任何單一字母字元，從`A`透過`Z`，或任何數字字元。|  
|`\d{2}`|比對兩個數值字元。|  
|`[A-Z0-9]`|比對任何單一字母字元，從`A`透過`Z`，或任何數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對三個數值字元。|  
|`(-\d{3}){2}`|找出連字號後面接著三個數字字元，並符合此模式的兩個項目...|  
|`[A-Z0-9]`|比對任何單一字母字元，從`A`透過`Z`，或任何數字字元。|  
|`$`|在字串的結尾結束比對。|  
  
 呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法`options`參數設定為<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>相當於定義下列規則運算式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 進行比較，請參閱範例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，以驗證模式比對是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>指出指定的規則運算式是否使用指定的比對選項和逾時間隔，在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與所指定的規則運算式模式`pattern`和所指定的規則運算式選項`options`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。 這個規則運算式模式的規則運算式引擎會快取供快速擷取。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `matchTimeout`參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)和[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。  
  
   
  
## Examples  
 下列範例說明使用<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來判斷字串是否為有效的組件數目。 規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。 第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須是數字。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。 比對規則運算式模式，應該包含最少搜尋整個輸入字串中，所以方法設定的 500 毫秒的逾時間隔。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 規則運算式模式為：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|從字串的開頭開始比對。|  
|`[A-Z0-9]`|比對任何單一字母字元，從`A`透過`Z`，或任何數字字元。|  
|`\d{2}`|比對兩個數值字元。|  
|`[A-Z0-9]`|比對任何單一字母字元，從`A`透過`Z`，或任何數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對三個數值字元。|  
|`(-\d{3}){2}`|找出連字號後面接著三個數字字元，並符合此模式的兩個項目。|  
|`[A-Z0-9]`|比對任何單一字母字元，從`A`透過`Z`，或任何數字字元。|  
|`$`|在字串的結尾結束比對。|  
  
 呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法`options`參數設定為<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>相當於定義下列規則運算式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 進行比較，請參閱範例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在輸入字串搜尋規則運算式的項目，並傳回正確結果為單一 <see cref="T:System.Text.RegularExpressions.Match" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <summary>在指定的輸入字串中，搜尋符合 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中所指定規則運算式的第一個項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。 如需用來建立規則運算式模式之語言項目的資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子字串，在`input`符合規則運算式模式。 您可以擷取後續相符項目的重複呼叫傳回<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例會尋找規則運算式模式比對在字串中，然後列出相符群組、 擷取和擷取位置。  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 規則運算式模式`(\w+)\s+(car)`比對的以及它前面的文字，"car"這個字的項目。 它被解譯為下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`(\w+)`|比對一個或多個文字字元。 這是第一個擷取群組。|  
|`\s+`|比對一個或多個空格字元。|  
|(car)|比對常值字串"car"。 這是第二個擷取群組。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="startat">要開始搜尋之以零為起始的字元位置。</param>
        <summary>從字串中指定的開始位置開始，在輸入字串中搜尋規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法會傳回符合規則運算式模式，從上或之後的第一個子字串`startat`字元在輸入字串的位置。 如需用來建立規則運算式模式之語言項目的資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 規則運算式模式的<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法會搜尋由呼叫其中一種定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需可用以構成規則運算式模式的項目，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以使用，以選擇性地指定字串中的開始位置`startat`參數。 當規則運算式引擎會剖析從左到右 （預設值） 時，比對和掃描移動 rightward，開始在指定的字元`startat`。 當規則運算式引擎會剖析由右至左 (當規則運算式模式，建構<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>選項)，比對和掃描相反的方向移動，開頭處的字元`startat`-1。 如果您未指定的開始位置，則會搜尋為預設值`startat`位置。 如果規則運算式搜尋從左到右，從預設`startat`位置位於左側`input`; 如果它會搜尋由右至左、 預設`startat`位置位於右邊`input`。  
  
 如果您想要限制相符項目，讓它在字串中特定的字元位置開始，並比對規則運算式引擎不會掃描字串的其餘部分，錨定的規則運算式與`\G`（左邊的左到右模式中，或由右至左模式右邊)。 這會限制比對，因此它必須剛好在啟動`startat`。  
  
 您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回找到在或之後的第一個子字串`startat`字元位置`input`符合規則運算式模式。 您可以擷取後續相符項目的重複呼叫傳回<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 如果當您呼叫建構函式時未設定逾時間隔，若作業 exeeds 所在的應用程式定義域建立任何逾時值，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex>建立物件。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>在指定的輸入字串中搜尋所指定規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。 如需用來建立規則運算式模式之語言項目的資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。 在此情況下，規則運算式引擎會快取的規則運算式模式。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子字串，在`input`符合規則運算式模式。 您可以擷取後續相符項目的重複呼叫傳回<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法來尋找第一個單字，其中包含至少一個`z`字元，然後呼叫<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法來尋找任何其他相符項目。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 規則運算式模式 `\b\w*z+\w*\b` 的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w*`|比對零個、 一個或多個文字字元。|  
|`z+`|比對一個或多個`z`字元。|  
|`\w*`|比對零個、 一個或多個文字字元。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法來擷取模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，可讓您設定的逾時間隔。</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="beginning">定義要搜尋的最左邊位置的輸入字串中以零為起始的字元位置。</param>
        <param name="length">子字串中要包含在搜尋中的字元數。</param>
        <summary>從指定的開始位置開始並且僅搜尋指定數目的字元，在輸入字串中搜尋規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會傳回第一個子字串符合規則運算式模式中輸入字串的一部分。 如需用來建立規則運算式模式之語言項目的資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 規則運算式模式的<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會搜尋由呼叫其中一種定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需可用以構成規則運算式模式的項目，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法搜尋的部份`input`所定義`beginning`和`length`規則運算式模式的參數。 `beginning` 永遠會定義要包含在搜尋中，最左邊字元的索引和`length`定義要搜尋的字元數目上限。 同時，會定義搜尋的範圍。 如果搜尋會繼續從左到右 （預設值），規則運算式引擎會搜尋索引處的字元從`beginning`索引處的字元`beginning`  +  `length` – 1。 如果使用的規則運算式引擎未具現化<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>選項，讓搜尋繼續由右至左，請從索引處的字元，規則運算式引擎搜尋`beginning`  +  `length` – 1 到字元索引處`beginning`。 這個方法會傳回此範圍內找到的第一個相符項目。 您可以擷取後續相符項目的重複呼叫傳回<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。  
  
 您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 如果您未設定逾時值，當您呼叫建構函式時，如果作業超過任何逾時值的應用程式定義域中，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex>建立物件。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> 小於零或大於 <paramref name="input" /> 的長度。  或 <paramref name="length" /> 小於零或大於 <paramref name="input" /> 的長度。  或 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> 識別 <paramref name="input" /> 範圍之外的位置。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>使用指定的比對選項，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。 如需用來建立規則運算式模式之語言項目的資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式和呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子字串中找到`input`符合規則運算式模式。 您可以擷取後續相符項目的重複呼叫傳回<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例會定義規則運算式比對以字母開頭的文字，"a"。 它會使用<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>選項，以確保規則運算式會找出文字開頭為兩個以大寫"a"和小寫"a"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 規則運算式模式 `\ba\w*\b` 的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`a`|比對字元"a"。|  
|`\w*`|比對零個、 一個或多個文字字元。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法來擷取模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，可讓您設定的逾時間隔。</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的比對選項和逾時間隔，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。 如需用來建立規則運算式模式之語言項目的資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式和呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，其值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子字串中找到`input`符合規則運算式模式。 您可以擷取後續相符項目的重複呼叫傳回<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。  
  
 `matchTimeout`參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)和[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在輸入字串中搜尋規則運算式的所有項目，並傳回所有符合項目。</summary>
        <block subset="none" type="usage">
          <para>在比對嘗試藉由呼叫的重複當<see cref="Overload:System.Text.RegularExpressions.Regex.Matches" />方法，規則運算式引擎提供空白比對特殊處理。通常，規則運算式引擎開始搜尋下一個相符項目剛好一個比對離開的地方。不過之後空白的比對，, 規則運算式引擎前進一個字元之前嘗試下一個相符項。此行為可確保規則運算式引擎會透過字串進度。否則，因為空的相符項目不會導致任何向前移動下, 一個相符項目會啟動在先前比對，完全相同的位置，它將會重複比對相同的空字串。在下列範例中，規則運算式模式<c>*</c>搜尋零或多個出現字母"a"，"abaabb"的字串。此範例將示範，產生的輸出<see cref="T:System.Text.RegularExpressions.MatchCollection" />物件包含六個<see cref="T:System.Text.RegularExpressions.Match" />物件。第一個比對嘗試尋找第一個"a"。在完全第一個符合的第一個 b; 之前就會結束，其中的第二個相符項目啟動它會尋找"a"的零個項目，並傳回空字串。第三個相符項目不是完全第二個比對結束的地方，因為第二個相符項目會傳回空字串。相反地，就會開始一個字元後第一個"b"。第三個相符項目尋找兩個"a"，並傳回"aa"。第四個比對嘗試開始，第三個相符項目之前已結束，第二個"b"，並傳回空字串。第五個比對嘗試一次前進一個字元，因此第三個"b"之前開始，並傳回空字串。第六個相符項目開始之後最後一個"b"，並再次傳回空字串。 [！ code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)][！ code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <summary>在指定的輸入字串搜尋規則運算式的所有項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法很類似<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 集合包含只有相符項目且結束於第一個不相符。  
  
 規則運算式模式的<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法會搜尋由呼叫其中一種定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需可用以構成規則運算式模式的項目，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲的評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，擲回例外狀況上執行作業時<xref:System.Text.RegularExpressions.MatchCollection>傳回使用這個方法，如果物件<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和比對作業超過逾時間隔。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法，以識別任何句子中的單字以"es"結尾。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="startat">在輸入字串中開始搜尋的字元位置。</param>
        <summary>自字串中指定的開始位置開始，在指定的輸入字串搜尋規則運算式的所有項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法很類似<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 規則運算式模式的<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法會搜尋由呼叫其中一種定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需可用以構成規則運算式模式的項目，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲的評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，擲回例外狀況上執行作業時<xref:System.Text.RegularExpressions.MatchCollection>傳回使用這個方法，如果物件<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和比對作業超過逾時間隔...  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法來尋找句子的結尾"es"，然後呼叫中的第一個單字<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法，以找出以"es"結尾的任何其他文字。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>在指定的輸入字串搜尋所指定規則運算式的所有相符項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法很類似<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫的執行個體方法`Matches`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲的評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，擲回例外狀況上執行作業時<xref:System.Text.RegularExpressions.MatchCollection>由這個方法傳回，如果逾時間隔由目前應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的物件超過這個逾時間隔。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法，以找出"es"結尾的句子中的任何字。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，針對擷取多個模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，這可讓您指定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會指定用於比對的選項。</param>
        <summary>使用指定的比對選項在指定的輸入字串中，搜尋所指定規則運算式的所有相符項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法很類似<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫的執行個體方法`Matches`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲的評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，擲回例外狀況上執行作業時<xref:System.Text.RegularExpressions.MatchCollection>由這個方法傳回，如果逾時間隔由目前應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的物件超過這個逾時間隔。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法，以找出以"es"，然後呼叫的句子中的任何字<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>執行不區分大小寫的模式與輸入字串比較方法。 如輸出所示，兩個方法會傳回不同的結果。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，針對擷取多個模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會指定用於比對的選項。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的比對選項和逾時間隔，在指定的輸入字串中搜尋所指定規則運算式的所有相符項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法很類似<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫的執行個體方法`Matches`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲的評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，擲回例外狀況上執行作業時<xref:System.Text.RegularExpressions.MatchCollection>如果比對作業超過此所指定的逾時間隔，這個方法中，所傳回的物件`matchTimeout`參數。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法以執行比對"es"結尾的句子中的任何字區分大小寫比較。 然後它會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>執行不區分大小寫的模式與輸入字串比較方法。 在這兩種情況下，逾時間隔設定為一秒。 如輸出所示，兩個方法會傳回不同的結果。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行個體的逾時間隔。</summary>
        <value>在<see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />擲回之前，可在模式比對作業中流逝的最大時間間隔，或者為<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />（如果停用逾時）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性會定義大約的最大時間間隔<xref:System.Text.RegularExpressions.Regex>作業逾時之前執行單一比對作業的執行個體。規則運算式引擎會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>期間經過逾時間隔後其下一個計時檢查例外狀況。 這可防止規則運算式引擎處理輸入的字串需要進行大量回溯。 如需詳細資訊，請參閱[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)和[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)。  
  
 這個屬性是唯讀的。 您可以明確設定該值的各個<xref:System.Text.RegularExpressions.Regex>藉由呼叫物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式，而且您可以將其值設定為所有<xref:System.Text.RegularExpressions.Regex>比對應用程式定義域中的作業，藉由呼叫<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法並提供<xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT"的屬性值，如下列範例所示。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 如果您未明確設定的逾時間隔時，預設值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>是使用與比對作業執行逾時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得傳入 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式的選項。</summary>
        <value>
          <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 列舉的一個或多個成員，代表傳遞至 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式的選項</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Text.RegularExpressions.Regex.Options%2A>屬性都包含一個或多個成員<xref:System.Text.RegularExpressions.RegexOptions>列舉型別。 如果沒有選項中所定義<xref:System.Text.RegularExpressions.Regex>類別建構函式，其值是<xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>。 可用的選項會在中詳細討論[規則運算式選項](~/docs/standard/base-types/regular-expression-options.md)主題。  
  
 請注意，<xref:System.Text.RegularExpressions.Regex.Options%2A>屬性並不會反映內嵌選項定義在規則運算式模式本身。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 基底類別所建立的規則運算式的<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。這些編譯的規則運算式中使用的基底類別實作<see cref="P:System.Text.RegularExpressions.Regex.Options" />屬性。如果已從衍生類別呼叫<see cref="P:System.Text.RegularExpressions.Regex.Options" />屬性會傳回傳遞給選項<paramref name="options" />參數<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />類別建構函式是用來定義規則運算式。</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的字串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="replacement">取代字串。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的所有字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋符合項目會從開頭的`input`字串。 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任何組合和[替代](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，取代模式`a*${test}b`插入的字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元取代模式內。  
  
> [!NOTE]
>  替代是在取代模式中才能辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 可只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會定義規則運算式， `\s+`，符合一或多個空格字元。 取代字串中，""，將它們取代為單一空格字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 下列範例會定義規則運算式， `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`，以及取代模式中， `$2`，移除前置或尾端的貨幣符號的數字的值。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 規則運算式的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\p{Sc}`|比對的貨幣符號。 `{Sc}` 代表任何字元，其 [Unicode Symbol，Currency] 分類的成員。|  
|`\s?`|比對零個或一個空白字元。|  
|`(\p{Sc}\s?)?`|比對零個或一個貨幣符號，後面接著零個或一個空格字元的組合。 這是第一個擷取群組。|  
|`\d+`|比對一個或多個十進位數字。|  
|`\.?`|比對零個或一個句號 （用做為小數分隔符號字元）。|  
|`((?<=\.)\d+)?`|如果句號前一個字元，比對一個或多個十進位數字。 此模式可以比對零或一次。|  
|`(\d+\.?((?<=\.)\d+)?)`|比對一個或多個十進位數字，後面選擇性句號和其他十進位數字的模式。 這是第二個擷取群組。 若要呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29>方法會將整個相符項目取代此擷取群組的值。|  
|`(?(1)&#124;\s?\p{Sc})?`|如果第一個擷取的群組存在，則比對空字串。 否則比對零個或一個空格字元，後面接著貨幣符號。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：  
  
-   規則運算式取代模式中無法隨時可以指定取代字串。  
  
-   取代字串會因某些處理對相符的字串。  
  
-   條件式處理取代字串結果。  
  
 此方法相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法並傳遞每個<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `evaluator`參數是您定義的自訂方法的委派，會檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，以取代相符的輸入。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列程式碼範例會顯示原始的字串、 符合原始字串中的每個字，將已轉換的字串轉換為大寫，然後顯示每個相符的第一個字元。  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="replacement">取代字串。</param>
        <param name="count">取代作業可以發生的最多次數。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋符合項目會從開頭的`input`字串。 規則運算式是由目前的建構函式定義的模式<xref:System.Text.RegularExpressions.Regex>物件。 如果`count`是負數，字串的結尾繼續取代項目。 如果`count`超過的相符項目數，取代所有相符項目。  
  
 `replacement`參數指定的字串來取代第一個`count`中符合`input`。 `replacement` 可以包含常值文字的任何組合和[替代](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，取代模式`a*${test}b`插入的字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元取代模式內。  
  
> [!NOTE]
>  替代是在取代模式中才能辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 可只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會將前五個出現重複的字元取代單一字元。 規則運算式模式`(\w)\1`比對的單一字元的連續項目，並將第一個出現項目指派給第一個擷取群組。 取代模式`$1`整個相符項目取代為第一個擷取群組。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="replacement">取代字串。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫的執行個體方法`Replace`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 搜尋符合項目會從開頭的`input`字串。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任何組合和[替代](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，取代模式`a*${test}b`插入的字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元取代模式內。  
  
> [!NOTE]
>  替代是在取代模式中才能辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 可只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會定義規則運算式， `\s+`，符合一或多個空格字元。 取代字串中，""，將它們取代為單一空格字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法以取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。 規則運算式會使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括在本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法，將包含邏輯磁碟的名稱。 若要成功執行此範例，您應該以您本機電腦的名稱取代常值字串"MyMachine"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|比對兩個連續反斜線 (`\`) 字元。 反斜線字元解譯為逸出字元，因此每個反斜線必須逸出與另一個反斜線。|  
|`(?i:" + Environment.MachineName + ")`|執行不區分大小寫的比對字串所傳回的<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。|  
|`(?:\.\w+)*`|比對句號 (`.`) 字元後面接著一個或多個文字字元。 此比對可以發生零次以上。 不會擷取相符子運算式。|  
|`\\`|符合反斜線 (`\`) 字元。|  
|`((?i:[" + driveNames + "]))`|執行不區分大小寫比對的個別磁碟機字母所組成的字元類別。 此項比對是第一個擷取子運算式。|  
|`\$`|比對常值的貨幣符號 (`$`) 字元。|  
  
 取代模式`$1`整個相符項目取代為第一個擷取子運算式。 也就是說，它會取代 UNC 電腦和磁碟機名稱的磁碟機代號。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />
          <paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：  
  
-   規則運算式取代模式中無法隨時可以指定取代字串。  
  
-   取代字串會因某些處理對相符的字串。  
  
-   條件式處理取代字串結果。  
  
 此方法相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法並傳遞每個<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`參數是您定義的自訂方法的委派，會檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，以取代相符的輸入。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會使用規則運算式從字串擷取個別文字，然後再使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派以呼叫方法，名為`WordScramble`，將金鑰加密在 word 中個別的字母。 若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。 它也會建立使用隨機浮點數值的它所擴展的平行陣列。 陣列會依照呼叫<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法和已排序的陣列提供做為引數<xref:System.String>類別建構函式。 然後傳回此新建立的字串`WordScramble`方法。 規則運算式模式`\w+`比對一個或多個文字字元，規則運算式引擎會繼續將字元加入至比對，直到遇到非文字字元，例如空格字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />
          <paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，用於評估和取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="count">取代將發生的最多次數。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：  
  
-   規則運算式取代模式中無法隨時可以指定取代字串。  
  
-   取代字串會因某些處理對相符的字串。  
  
-   條件式處理取代字串結果。  
  
 此方法相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法並傳遞第一個`count`<xref:System.Text.RegularExpressions.Match>中傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `evaluator`參數是您定義的自訂方法的委派，會檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，以取代相符的輸入。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會使用規則運算式，刻意拼錯一半的清單中的字詞。 它會使用規則運算式`\w*(ie|ei)\w*`以比對包含"ei"或"ie"字元的文字。 它會傳遞第一個要比對文字的下半部`ReverseLetter`方法，這個方法會接著使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>反向"i"和"e"相符的字串中的方法。 其他字維持不變。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 規則運算式 `\w*(ie|ei)\w*` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\w*`|比對零個或多個文字字元。|  
|`(ie&#124;ei)`|比對"ie"或"ei"。|  
|`\w*`|比對零個或多個文字字元。|  
  
 規則運算式模式`([ie])([ie])`中`ReverseLetter`方法符合 diphthong"ei"或"ie 」 中的第一個"i"或"e"，並將代號指派給第一個擷取群組。 它會比對的第二個"i"或"e"，並將代號指派給第二個擷取群組。 兩個字元反過來藉由呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法取代模式`$2$1`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="replacement">取代字串。</param>
        <param name="count">取代可以發生的最多次數。</param>
        <param name="startat">在輸入字串中開始搜尋的字元位置。</param>
        <summary>在指定的輸入子字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋符合項目中啟動`input`字串所指定的位置`startat`參數。 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。 如果`count`是負數，字串的結尾繼續取代項目。 如果`count`超過的相符項目數，取代所有相符項目。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任何組合和[替代](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，取代模式`a*${test}b`插入的字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元取代模式內。  
  
> [!NOTE]
>  替代是在取代模式中才能辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 可只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例 double-spaces 字串的第一行以外的所有節點。 它會定義規則運算式模式， `^.*$`，符合一行文字，呼叫<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法來比對的字串，並使用的第一行`Match.Index`和`Match.Count`屬性，以判斷第二個的開始位置行。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 規則運算式模式 `^.*$` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|比對行首。 (請注意，<xref:System.Text.RegularExpressions.Regex>物件具現化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>選項; 否則這個字元類別會只比對輸入字串的開頭。)|  
|`.*`|比對任何字元零次以上。|  
|`$`|比對行尾。 (請注意，<xref:System.Text.RegularExpressions.Regex>物件具現化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>選項; 否則這個字元類別會只比對輸入字串的開頭。)|  
  
 取代字串 (`vbCrLf + "$&"`在 Visual Basic 中`"\n$&"`C# 中) 會將新行之前比對的字串。 請注意，`\n`在 C# 範例會解譯為新行字元的 C# 編譯器; 它不代表規則運算式字元逸出。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="replacement">取代字串。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。 指定的選項會修改符合的作業。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫的執行個體方法`Replace`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任何組合和[替代](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，取代模式`a*${test}b`插入的字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元取代模式內。  
  
> [!NOTE]
>  替代是在取代模式中才能辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 可只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法以取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。 規則運算式會使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括在本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法，將包含邏輯磁碟的名稱。 所有的規則運算式的字串比較不區分大小寫。 若要成功執行此範例，您應該以您本機電腦的名稱取代常值字串"MyMachine"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|比對兩個連續反斜線 (`\`) 字元。 反斜線字元解譯為逸出字元，因此每個反斜線必須逸出與另一個反斜線。|  
|`+ Environment.MachineName +`|所傳回的字串相符<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。|  
|`(?:\.\w+)*`|比對句號 (`.`) 字元後面接著一個或多個文字字元。 此比對可以發生零次以上。 不會擷取相符子運算式。|  
|`\\`|符合反斜線 (`\`) 字元。|  
|`([" + driveNames + "])`|比對的字元類別包含的個別磁碟機代號。 此項比對是第一個擷取子運算式。|  
|`\$`|比對常值的貨幣符號 (`$`) 字元。|  
  
 取代模式`$1`整個相符項目取代為第一個擷取子運算式。 也就是說，它會取代 UNC 電腦和磁碟機名稱的磁碟機代號。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />
          <paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫它的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。 指定的選項會修改符合的作業。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目中的，如果下列任何一個狀況成立：  
  
-   規則運算式取代模式中無法隨時可以指定取代字串。  
  
-   取代字串會因某些處理對相符的字串。  
  
-   條件式處理取代字串結果。  
  
 此方法相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法並傳遞每個<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`參數是您定義的自訂方法的委派，會檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，以取代相符的輸入。  
  
 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會使用規則運算式從字串擷取個別文字，然後再使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派以呼叫方法，名為`WordScramble`，將金鑰加密在 word 中個別的字母。 若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。 它也會建立使用隨機浮點數值的它所擴展的平行陣列。 陣列會依照呼叫<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法和已排序的陣列提供做為引數<xref:System.String>類別建構函式。 然後傳回此新建立的字串`WordScramble`方法。 規則運算式模式`\w+`比對一個或多個文字字元，規則運算式引擎會繼續將字元加入至比對，直到遇到非文字字元，例如空格字元。 呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包含<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>選項，讓規則運算式模式中的註解`\w+  # Matches all the characters in a word.`會忽略規則運算式引擎。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />
          <paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="count">取代將發生的最多次數。</param>
        <param name="startat">在輸入字串中開始搜尋的字元位置。</param>
        <summary>在指定的輸入子字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：  
  
-   規則運算式取代模式中無法隨時可以指定取代字串。  
  
-   取代字串會因某些處理對相符的字串。  
  
-   條件式處理取代字串結果。  
  
 此方法相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法並傳遞第一個`count`<xref:System.Text.RegularExpressions.Match>中傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `evaluator`參數是您定義的自訂方法的委派，會檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，以取代相符的輸入。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="replacement">取代字串。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。 如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫的執行個體方法`Replace`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任何組合和[替代](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 例如，取代模式`a*${test}b`插入的字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元取代模式內。  
  
> [!NOTE]
>  替代是在取代模式中才能辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)、 可只在規則運算式模式中，而且無法辨識取代模式中。  
  
 `matchTimeout`參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)和[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法以取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。 規則運算式會使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法，將包含邏輯磁碟的名稱。 所有的規則運算式的字串比較會區分大小寫，和任何單一的取代作業逾時，如果 0.5 秒內找不到相符項目。 若要成功執行此範例，您應該以您本機電腦的名稱取代常值字串"MyMachine"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|比對兩個連續反斜線 (`\`) 字元。 反斜線字元解譯為逸出字元，因此每個反斜線必須逸出與另一個反斜線。|  
|`+ Environment.MachineName +`|所傳回的字串相符<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。|  
|`(?:\.\w+)*`|比對句號 (`.`) 字元後面接著一個或多個文字字元。 此比對可以發生零次以上。 不會擷取相符子運算式。|  
|`\\`|符合反斜線 (`\`) 字元。|  
|`([" + driveNames + "])`|比對的字元類別包含的個別磁碟機代號。 此項比對是第一個擷取子運算式。|  
|`\$`|比對常值的貨幣符號 (`$`) 字元。|  
  
 取代模式`$1`整個相符項目取代為第一個擷取子運算式。 也就是說，它會取代 UNC 電腦和磁碟機名稱的磁碟機代號。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />
          <paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的子字串。 如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：  
  
-   規則運算式取代模式中無法輕易地加以指定取代字串。  
  
-   如果是取代字串得到的某些處理執行比對的字串。  
  
-   如果是取代字串而產生的條件式處理。  
  
 此方法相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法並傳遞每個<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`參數是您定義的自訂方法的委派，會檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，以取代相符的輸入。  
  
 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 `matchTimeout`參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯，從顯示的規則運算式 」 停止回應時，它們會處理輸入，其中包含相符項目附近。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)和[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>來決定方法是否有任何取代項目與輸入字串的方法。  
  
   
  
## Examples  
 下列範例會使用規則運算式從字串擷取個別文字，然後再使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派以呼叫方法，名為`WordScramble`，將金鑰加密在 word 中個別的字母。 若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。 它也會建立使用隨機浮點數值的它所擴展的平行陣列。 陣列會依照呼叫<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法和已排序的陣列提供做為引數<xref:System.String>類別建構函式。 然後傳回此新建立的字串`WordScramble`方法。 規則運算式模式`\w+`比對一個或多個文字字元，規則運算式引擎會繼續將字元加入至比對，直到遇到非文字字元，例如空格字元。 呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包含<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>選項，讓規則運算式模式中的註解`\w+  # Matches all the characters in a word.`會忽略規則運算式引擎。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />
          <paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出規則運算式是否由右至左搜尋。</summary>
        <value>如果規則運算式由右至左搜尋，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> 是`true`如果<xref:System.Text.RegularExpressions.Regex>建立執行個體與<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>選項。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在規則運算式比對所定義的位置，將輸入字串分割成子字串陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <summary>在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定之規則運算式模式所定義的位置，將輸入字串分隔成子字串的陣列。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是類似於<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割在規則運算式，而不是一組字元所決定的分隔符號字串。 將字串分割為許多次。 如果不找到任何分隔符號，則傳回的值會包含一個項目，其值為原始的輸入的字串。  
  
 如果多個相符項目彼此相鄰的、 空字串會插入至陣列。 例如，分割上的單一連字號的字串會造成傳回的陣列，其中兩個相鄰的連字號找不到，下列程式碼所示的位置包含空字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。 下列範例會使用規則運算式模式`\d+`分割輸入的字串的數字字元。 因為字串開始和結尾相符的字元數值，傳回的陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 如果規則運算式可以比對空字串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%29>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。 例如:   
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 請注意，傳回的陣列也會包含空字串開頭和結尾的陣列。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過指定的逾時間隔，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="count">分隔作業可以發生的最多次數。</param>
        <summary>在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是類似於<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割在規則運算式，而不是一組字元所決定的分隔符號字串。 `count`參數會指定到其中的子字串的最大數目`input`可以分割成字串; 最後一個字串包含 unsplit 的字串的其餘部分。 A`count`為零的值會提供分割成許多次越好的預設行為。  
  
 如果多個相符項目彼此相鄰或開頭或結尾找到相符`input`，而且找到符合項目數目至少兩個小於`count`，空字串插入到陣列。 也就是說，從相鄰的相符項目或開頭或結尾的輸入字串的相符項目會造成的空字串會算入判斷是否數目比對的子字串等於`count`。 在下列範例中，規則運算式`/d+`用來分割輸入的字串成最多三個子字串包含一個或多個十進位數字。 輸入字串的開頭比對規則運算式模式，因為第一個陣列元素包含<xref:System.String.Empty?displayProperty=nameWithType>、 第二個包含字母字元，輸入字串中第一個集合，而第三個包含字串的其餘部分一節的第三個相符項目。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 如果規則運算式中使用擷取括號，就會分隔字串的陣列中包含任何擷取的文字。 不過，任何陣列元素包含擷取的文字不會包含在判斷是否相符項目數目已達到`count`。 例如，顯示分割成最多四個的子字串結果七個元素陣列，如以下程式碼中的"apple-apricot-梅紅-西洋梨-香蕉"字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 版中，只擷取的文字第一個集合擷取括號會包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字加入至傳回的陣列。 不過，在傳回陣列中包含擷取的文字的項目不會計算在決定是否數目比對的子字串等於`count`。 例如，下列程式碼，規則運算式會使用日期的項目擷取的日期字串兩組擷取括號。 第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。 若要呼叫<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>方法然後傳回陣列中指定最多兩個項目。 如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，則方法會傳回兩個元素的字串陣列。 如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，方法會傳回三個元素的字串陣列。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 如果規則運算式可以比對空字串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。 下列範例分割成字串 「 字元 」，因為輸入字串中有許多項目。 由於 null 字串比對輸入字串的開頭，則傳回的陣列的開頭插入的 null 字串。 這會造成要在輸入字串結尾處的兩個字元所組成的第十個項目。  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過指定的逾時間隔，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>在規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是類似於<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割在規則運算式，而不是一組字元所決定的分隔符號字串。 `input`字串分割成許多次越好。 如果`pattern`中找不到`input`字串，傳回的值包含一個項目，其值是原始`input`字串。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  編譯為靜態的呼叫中使用的規則運算式<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。 若要自行管理編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多個相符項目彼此相鄰的、 空字串會插入至陣列。 例如，分割上的單一連字號的字串會造成傳回的陣列，其中兩個相鄰的連字號找不到，下列程式碼所示的位置包含空字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。 下列範例會使用規則運算式模式`\d+`分割輸入的字串的數字字元。 因為字串開始和結尾相符的字元數值，傳回的陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果規則運算式可以比對空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。 例如:   
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 請注意，傳回的陣列也會包含空字串開頭和結尾的陣列。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過逾時間隔，此方法會呼叫的應用程式定義域指定，會擲回例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫該方法的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，來分割文字模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="count">分隔作業可以發生的最多次數。</param>
        <param name="startat">在輸入字串中要開始搜尋的字元位置。</param>
        <summary>在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。 規則運算式模式從輸入字串中指定的字元位置開始搜尋。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是類似於<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割在規則運算式，而不是一組字元所決定的分隔符號字串。 `count`參數會指定到其中的子字串的最大數目`input`字串分割; 最後一個字串包含 unsplit 的字串的其餘部分。 A`count`為零的值會提供分割成許多次越好的預設行為。 `startat`參數定義的第一個分隔符號搜尋開始的點 （這可以用來略過前置空白字元）。  
  
 如果沒有符合的項目從`count`+ 1 定位在字串中，方法會傳回一個項目陣列，包含`input`字串。 如果找不到一或多個相符項目，傳回的陣列的第一個元素包含從第一個字元，最多前比對一個字元字串的第一個部分。  
  
 如果多個相符項目彼此相鄰，而且找到符合項目數目是至少兩個小於`count`，空字串插入到陣列。 同樣地，如果在找到相符項目`startat`，是在字串中的第一個字元，傳回之陣列的第一個項目為空字串。 也就是空的字串所產生的相鄰的相符項目會計算在決定是否數目比對的子字串等於`count`。 在下列範例中，規則運算式`\d+`用來尋找數字字元的第一個子字串的開始位置在字串中，然後再將字串分割最多三次起始該位置。 由於規則運算式模式比對輸入字串的開頭，傳回的字串陣列包含空字串、 五個字元的英數字字串，以及字串的其餘部分  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 如果規則運算式中使用擷取括號，就會分隔字串的陣列中包含任何擷取的文字。 不過，任何陣列元素包含擷取的文字不會包含在判斷是否相符項目數目已達到`count`。 例如，分割字串 '"apple-apricot-plum-pear-pomegranate-pineapple-peach 」 成四個最多的子字串開始於 15 字元字串中的結果七個元素的陣列，如下列程式碼所示。  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 例如，下列程式碼會使用兩組擷取括號來擷取個別的文字字串中。 第一組擷取括號會擷取連字號，和第二個集合擷取的垂直列。 如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除垂直列字元;如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 如果規則運算式可以比對空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。 下列範例會分割成多的項目字串 「 字元 」 包含輸入的字串，以字元當做開頭為"a"。 因為 null 字串比對輸入字串的結尾，傳回的陣列結尾處插入的 null 字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過指定的逾時間隔，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。 指定的選項會修改符合的作業。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是類似於<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割在規則運算式，而不是一組字元所決定的分隔符號字串。 將字串分割為許多次。 如果不找到任何分隔符號，則傳回值包含一個項目，其值是原始`input`字串。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  編譯為靜態的呼叫中使用的規則運算式<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。 若要自行管理編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多個相符項目彼此相鄰的、 空字串會插入至陣列。 例如，分割上的單一連字號的字串會造成傳回的陣列中找到兩個相鄰的連字號的位置包含空字串。  
  
 如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。 下列範例會使用規則運算式模式`[a-z]+`分割輸入的字串的大寫或小寫字母的字元。 因為字串開始和結尾相符的字母字元，則傳回的陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果規則運算式可以比對空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過逾時間隔，此方法會呼叫的應用程式定義域指定，會擲回例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>此方法等於呼叫該方法的應用程式定義域的預設逾時值一段時間後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，來分割文字模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。 如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</summary>
        <returns>字串陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法都是類似於<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割在規則運算式，而不是一組字元所決定的分隔符號字串。 將字串分割為許多次。 如果不找到任何分隔符號，則傳回值包含一個項目，其值是原始`input`字串。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  編譯為靜態的呼叫中使用的規則運算式<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。 若要自行管理編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多個相符項目彼此相鄰的、 空字串會插入至陣列。 例如，分割上的單一連字號的字串會造成傳回的陣列中找到兩個相鄰的連字號的位置包含空字串。  
  
 如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。 下列範例會使用規則運算式模式`[a-z]+`分割輸入的字串的大寫或小寫字母的字元。 因為字串開始和結尾相符的字母字元，則傳回的陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果規則運算式可以比對空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。  
  
 `matchTimeout`參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱[規則運算式的最佳作法](~/docs/standard/base-types/best-practices.md)和[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  或 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage">
          <para>我們建議您將<paramref name="matchTimeout" />參數，以適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎會提供稍微較佳的效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入衍生自已知且受信任的來源或靜態文字所組成。這不包括已動態使用者所輸入的文字。 -當規則運算式模式徹底測試以確保它有效率地處理符合，不符合，而且即將相符。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">要使用序列化資訊來填入的物件。</param>
        <param name="context">要儲存並擷取序列化資料的位置。 這個參數保留給未來的版本使用。</param>
        <summary>將還原序列化目前 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件所需的資料填入 (Populate) <see cref="T:System.Text.RegularExpressions.Regex" /> 物件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回傳遞至 <see langword="Regex" /> 建構函式中的規則運算式模式。</summary>
        <returns>
          <paramref name="pattern" /> 參數，傳遞至 <see langword="Regex" /> 建構函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱[.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)和[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 基底類別所建立的規則運算式的<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。這些編譯規則運算式使用<see cref="M:System.Text.RegularExpressions.Regex.ToString" />基底類別的實作。如果已從衍生類別呼叫<see cref="M:System.Text.RegularExpressions.Regex.ToString" />方法會傳回字串傳遞給<paramref name="pattern" />參數<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />類別建構函式是用來定義規則運算式。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">輸入字串，包含要轉換的文字。</param>
        <summary>轉換輸入字串中任何逸出的字元。</summary>
        <returns>字元字串，其中任何逸出字元轉換成其未逸出格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法會執行下列兩個轉換的其中一個：  
  
-   它會反轉所執行的轉換<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法藉由移除逸出字元 ("\\」) 從逸出方法的每個字元。 這些包括\\，*，+，？， &#124;，{，[，（、）、 ^、 $、。，# 和空白字元。 此外，<xref:System.Text.RegularExpressions.Regex.Unescape%2A>右括號 (]) 和關閉括號 （}） 字元不逸出方法。  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 無法回復的逸出的字串完全無法推算精確哪些字元不逸出因為  
  
-   它會將不可列印字元的表示法取代字元本身。 例如，它會取代 \a \x07。 它會取代的字元表示為 \a、 \b、 \e、 \n、 \r、 \f、 \t 和 \v。  
  
 如果<xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法遇到其他逸出序列，它無法轉換，例如 \w 或 \s，就會擲回<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> 包含無法辨認的逸出序列。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 屬性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 選項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 屬性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 選項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">要檢查的逾時間隔。</param>
        <summary>檢查逾時間隔是否在可接受的範圍內。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>