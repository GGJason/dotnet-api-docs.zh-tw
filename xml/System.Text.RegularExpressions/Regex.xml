<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67e7f6049333b12bfe1d234f9c97a4c28d6d4845" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39999290" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="2884e-101">表示不變的規則運算式 (Regular Expression)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2884e-101">Represents an immutable regular expression.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-102"><xref:System.Text.RegularExpressions.Regex>類別代表.NET Framework 規則運算式引擎。</span><span class="sxs-lookup"><span data-stu-id="2884e-102">The <xref:System.Text.RegularExpressions.Regex> class represents the .NET Framework's regular expression engine.</span></span> <span data-ttu-id="2884e-103">它可用來快速剖析大量文字以尋找特定的字元模式;若要擷取、 編輯、 取代或刪除文字子字串;並將擷取的字串新增至集合，以便產生報表。</span><span class="sxs-lookup"><span data-stu-id="2884e-103">It can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-104">如果您的主要興趣是要判斷它是否符合特定模式來驗證字串中，您可以使用<xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-104">If your primary interest is to validate a string by determining whether it conforms to a particular pattern, you can use the <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="2884e-105">若要使用規則運算式，您會定義您想要使用所述的語法來識別文字資料流中的模式[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-105">To use regular expressions, you define the pattern that you want to identify in a text stream by using the syntax documented in [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span> <span data-ttu-id="2884e-106">接下來，您可以選擇性地具現化<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-106">Next, you can optionally instantiate a <xref:System.Text.RegularExpressions.Regex> object.</span></span> <span data-ttu-id="2884e-107">最後，您可以呼叫執行某項作業，例如取代符合規則運算式模式的文字，或識別模式比對的方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-107">Finally, you call a method that performs some operation, such as replacing text that matches the regular expression pattern, or identifying a pattern match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-108">一些常見的規則運算式模式，請參閱 <<c0> [ 規則運算式範例](~/docs/standard/base-types/regular-expression-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-108">For some common regular expression patterns, see [Regular Expression Examples](~/docs/standard/base-types/regular-expression-examples.md).</span></span> <span data-ttu-id="2884e-109">另外還有幾個的線上程式庫的規則運算式模式，例如在[一般 Expressions.info](https://www.regular-expressions.info/examples.html)。</span><span class="sxs-lookup"><span data-stu-id="2884e-109">There are also a number of online libraries of regular expression patterns, such as the one at [Regular-Expressions.info](https://www.regular-expressions.info/examples.html).</span></span>  
  
<a name="remarks"></a> <span data-ttu-id="2884e-110">如需有關使用<xref:System.Text.RegularExpressions.Regex>類別，請參閱本主題中的下列章節：</span><span class="sxs-lookup"><span data-stu-id="2884e-110">For more information about using the <xref:System.Text.RegularExpressions.Regex> class, see the following sections in this topic:</span></span>  
  
-   [<span data-ttu-id="2884e-111">Regex vs。字串方法</span><span class="sxs-lookup"><span data-stu-id="2884e-111">Regex vs. String Methods</span></span>](#regex_vs_string)  
  
-   [<span data-ttu-id="2884e-112">靜態與執行個體方法</span><span class="sxs-lookup"><span data-stu-id="2884e-112">Static vs. Instance Methods</span></span>](#static_vs_instance)  
  
-   [<span data-ttu-id="2884e-113">執行規則運算式作業</span><span class="sxs-lookup"><span data-stu-id="2884e-113">Performing Regular Expression Operations</span></span>](#regex_ops)  
  
-   [<span data-ttu-id="2884e-114">定義的逾時值</span><span class="sxs-lookup"><span data-stu-id="2884e-114">Defining a Time-Out Value</span></span>](#define_timeout)  
  
 <span data-ttu-id="2884e-115">如需規則運算式語言的詳細資訊，請參閱[規則運算式語言 - 快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)，或下載並列印下列其中一本小手冊：</span><span class="sxs-lookup"><span data-stu-id="2884e-115">For more information about the regular expression language, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md) or download and print one of these brochures:</span></span>  
  
 [<span data-ttu-id="2884e-116">Word (.docx) 格式的快速參考</span><span class="sxs-lookup"><span data-stu-id="2884e-116">Quick Reference in Word (.docx) format</span></span>](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [<span data-ttu-id="2884e-117">PDF (.pdf) 格式的快速參考</span><span class="sxs-lookup"><span data-stu-id="2884e-117">Quick Reference in PDF (.pdf) format</span></span>](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a><span data-ttu-id="2884e-118">Regex vs。字串方法</span><span class="sxs-lookup"><span data-stu-id="2884e-118">Regex vs. String Methods</span></span>  
 <span data-ttu-id="2884e-119"><xref:System.String?displayProperty=nameWithType>類別包含數個搜尋和比較方法，您可以使用執行模式比對文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-119">The <xref:System.String?displayProperty=nameWithType> class includes several search and comparison methods that you can use to perform pattern matching with text.</span></span> <span data-ttu-id="2884e-120">例如， <xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.EndsWith%2A?displayProperty=nameWithType>，和<xref:System.String.StartsWith%2A?displayProperty=nameWithType>判斷方法的字串執行個體是否包含指定的子字串; 和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>， <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>， <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>，和<xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType>方法傳回的起始在字串中指定的子字串的位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-120">For example, the <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, and <xref:System.String.StartsWith%2A?displayProperty=nameWithType> methods determine whether a string instance contains a specified substring; and the <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, and <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> methods return the starting position of a specified substring in a string.</span></span> <span data-ttu-id="2884e-121">使用的方法<xref:System.String?displayProperty=nameWithType>類別，在您要搜尋特定字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-121">Use the methods of the <xref:System.String?displayProperty=nameWithType> class when you are searching for a specific string.</span></span> <span data-ttu-id="2884e-122">使用<xref:System.Text.RegularExpressions.Regex>類別，在您要搜尋特定的模式字串中。</span><span class="sxs-lookup"><span data-stu-id="2884e-122">Use the <xref:System.Text.RegularExpressions.Regex> class when you are searching for a specific pattern in a string.</span></span> <span data-ttu-id="2884e-123">如需詳細資訊和範例，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-123">For more information and examples, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
 [<span data-ttu-id="2884e-124">回到 < 備註 ></span><span class="sxs-lookup"><span data-stu-id="2884e-124">Back to Remarks</span></span>](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a><span data-ttu-id="2884e-125">靜態與執行個體方法</span><span class="sxs-lookup"><span data-stu-id="2884e-125">Static vs. Instance Methods</span></span>  
 <span data-ttu-id="2884e-126">定義規則運算式模式之後，您可以提供規則運算式引擎在兩種方式之一：</span><span class="sxs-lookup"><span data-stu-id="2884e-126">After you define a regular expression pattern, you can provide it to the regular expression engine in either of two ways:</span></span>  
  
-   <span data-ttu-id="2884e-127">藉由執行個體化<xref:System.Text.RegularExpressions.Regex>代表規則運算式的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-127">By instantiating a <xref:System.Text.RegularExpressions.Regex> object that represents the regular expression.</span></span> <span data-ttu-id="2884e-128">若要這樣做，您會傳遞至規則運算式模式<xref:System.Text.RegularExpressions.Regex.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-128">To do this, you pass the regular expression pattern to a <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> constructor.</span></span> <span data-ttu-id="2884e-129">A<xref:System.Text.RegularExpressions.Regex>物件是不可變，當您具現化<xref:System.Text.RegularExpressions.Regex>物件的規則運算式物件的規則運算式不能變更。</span><span class="sxs-lookup"><span data-stu-id="2884e-129">A <xref:System.Text.RegularExpressions.Regex> object is immutable; when you instantiate a <xref:System.Text.RegularExpressions.Regex> object with a regular expression, that object's regular expression cannot be changed.</span></span>  
  
-   <span data-ttu-id="2884e-130">提供規則運算式和要搜尋的文字`static`(`Shared` Visual Basic 中)<xref:System.Text.RegularExpressions.Regex>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-130">By supplying both the regular expression and the text to search to a `static` (`Shared` in Visual Basic) <xref:System.Text.RegularExpressions.Regex> method.</span></span> <span data-ttu-id="2884e-131">這可讓您使用規則運算式，而不需要明確建立<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-131">This enables you to use a regular expression without explicitly creating a <xref:System.Text.RegularExpressions.Regex> object.</span></span>  
  
 <span data-ttu-id="2884e-132">所有<xref:System.Text.RegularExpressions.Regex>模式識別方法包含兩個靜態和執行個體的多載。</span><span class="sxs-lookup"><span data-stu-id="2884e-132">All <xref:System.Text.RegularExpressions.Regex> pattern identification methods include both static and instance overloads.</span></span>  
  
 <span data-ttu-id="2884e-133">規則運算式引擎必須編譯特定模式，才能使用此模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-133">The regular expression engine must compile a particular pattern before the pattern can be used.</span></span> <span data-ttu-id="2884e-134">因為<xref:System.Text.RegularExpressions.Regex>物件是不可變，這樣一來，就會發生的一次性程序時<xref:System.Text.RegularExpressions.Regex>呼叫類別建構函式或靜態方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-134">Because <xref:System.Text.RegularExpressions.Regex> objects are immutable, this is a one-time procedure that occurs when a <xref:System.Text.RegularExpressions.Regex> class constructor or a static method is called.</span></span> <span data-ttu-id="2884e-135">若要排除不需要進行重複編譯單一規則運算式，規則運算式引擎會快取已編譯的規則運算式的靜態方法呼叫中使用。</span><span class="sxs-lookup"><span data-stu-id="2884e-135">To eliminate the need to repeatedly compile a single regular expression, the regular expression engine caches the compiled regular expressions used in static method calls.</span></span> <span data-ttu-id="2884e-136">如此一來，規則運算式模式比對方法會提供相當的效能，若為靜態和執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-136">As a result, regular expression pattern-matching methods offer comparable performance for static and instance methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2884e-137">在.NET Framework 1.0 和 1.1 中，所有已編譯規則運算式，它們是否已使用執行個體或靜態方法中呼叫，快取。</span><span class="sxs-lookup"><span data-stu-id="2884e-137">In the .NET Framework versions 1.0 and 1.1, all compiled regular expressions, whether they were used in instance or static method calls, were cached.</span></span> <span data-ttu-id="2884e-138">從.NET Framework 2.0 開始，只有在靜態方法呼叫中使用的規則運算式會快取。</span><span class="sxs-lookup"><span data-stu-id="2884e-138">Starting with the .NET Framework 2.0, only regular expressions used in static method calls are cached.</span></span>  
  
 <span data-ttu-id="2884e-139">不過，快取可能會影響效能，在下列兩種情況：</span><span class="sxs-lookup"><span data-stu-id="2884e-139">However, caching can adversely affect performance in the following two cases:</span></span>  
  
-   <span data-ttu-id="2884e-140">當您使用靜態方法呼叫，且含有大量的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-140">When you use static method calls with a large number of regular expressions.</span></span> <span data-ttu-id="2884e-141">根據預設，規則運算式引擎會快取 15 的最近使用過靜態規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-141">By default, the regular expression engine caches the 15 most recently used static regular expressions.</span></span> <span data-ttu-id="2884e-142">如果您的應用程式會使用 15 個以上的靜態規則運算式，就必須重新編譯一些規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-142">If your application uses more than 15 static regular expressions, some regular expressions must be recompiled.</span></span> <span data-ttu-id="2884e-143">若要避免此重新編譯，您可以增加<xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-143">To prevent this recompilation, you can increase the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="2884e-144">當您具現化新<xref:System.Text.RegularExpressions.Regex>使用先前已編譯的規則運算式的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-144">When you instantiate new <xref:System.Text.RegularExpressions.Regex> objects with regular expressions that have previously been compiled.</span></span> <span data-ttu-id="2884e-145">例如，下列程式碼會定義規則運算式，以在文字資料流中找出重複的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-145">For example, the following code defines a regular expression to locate duplicated words in a text stream.</span></span> <span data-ttu-id="2884e-146">雖然此範例會使用單一規則運算式，它會具現化新<xref:System.Text.RegularExpressions.Regex>物件來處理每一行文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-146">Although the example uses a single regular expression, it instantiates a new <xref:System.Text.RegularExpressions.Regex> object to process each line of text.</span></span> <span data-ttu-id="2884e-147">這會導致重新編譯的規則運算式與迴圈的每個反覆項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-147">This results in the recompilation of the regular expression with each iteration of the loop.</span></span>  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     <span data-ttu-id="2884e-148">若要避免重新編譯，您應該具現化一個<xref:System.Text.RegularExpressions.Regex>是可存取所有的程式碼時需要它，如下列重寫範例所示的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-148">To prevent recompilation, you should instantiate a single <xref:System.Text.RegularExpressions.Regex> object that is accessible to all code that requires it, as shown in the following rewritten example.</span></span>  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [<span data-ttu-id="2884e-149">回到 < 備註 ></span><span class="sxs-lookup"><span data-stu-id="2884e-149">Back to Remarks</span></span>](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a><span data-ttu-id="2884e-150">執行規則運算式作業</span><span class="sxs-lookup"><span data-stu-id="2884e-150">Performing Regular Expression Operations</span></span>  
 <span data-ttu-id="2884e-151">您是否決定具現化<xref:System.Text.RegularExpressions.Regex>物件並呼叫其方法或呼叫靜態方法，<xref:System.Text.RegularExpressions.Regex>類別提供下列的模式比對功能：</span><span class="sxs-lookup"><span data-stu-id="2884e-151">Whether you decide to instantiate a <xref:System.Text.RegularExpressions.Regex> object and call its methods or call static methods, the <xref:System.Text.RegularExpressions.Regex> class offers the following pattern-matching functionality:</span></span>  
  
-   <span data-ttu-id="2884e-152">驗證的相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-152">Validation of a match.</span></span> <span data-ttu-id="2884e-153">您呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法，以判斷是否有相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-153">You call the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> method to determine whether a match is present.</span></span>  
  
-   <span data-ttu-id="2884e-154">擷取單一相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-154">Retrieval of a single match.</span></span> <span data-ttu-id="2884e-155">您呼叫<xref:System.Text.RegularExpressions.Regex.Match%2A>方法來擷取<xref:System.Text.RegularExpressions.Match>物件，表示字串中或部分字串的第一個相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-155">You call the <xref:System.Text.RegularExpressions.Regex.Match%2A> method to retrieve a <xref:System.Text.RegularExpressions.Match> object that represents the first match in a string or in part of a string.</span></span> <span data-ttu-id="2884e-156">可以藉由呼叫擷取後續相符項目的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-156">Subsequent matches can be retrieved by calling the <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="2884e-157">擷取所有相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-157">Retrieval of all matches.</span></span> <span data-ttu-id="2884e-158">您呼叫<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法來擷取<xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType>物件，表示為字串或字串的部分所找到的所有相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-158">You call the <xref:System.Text.RegularExpressions.Regex.Matches%2A> method to retrieve a <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> object that represents all the matches found in a string or in part of a string.</span></span>  
  
-   <span data-ttu-id="2884e-159">取代相符的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-159">Replacement of matched text.</span></span> <span data-ttu-id="2884e-160">您呼叫<xref:System.Text.RegularExpressions.Regex.Replace%2A>來取代相符的文字的方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-160">You call the <xref:System.Text.RegularExpressions.Regex.Replace%2A> method to replace matched text.</span></span> <span data-ttu-id="2884e-161">取代文字也可以定義規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-161">The replacement text can also be defined by a regular expression.</span></span> <span data-ttu-id="2884e-162">此外，某些<xref:System.Text.RegularExpressions.Regex.Replace%2A>方法包括<xref:System.Text.RegularExpressions.MatchEvaluator>參數，可讓您以程式設計方式定義的替代文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-162">In addition, some of the <xref:System.Text.RegularExpressions.Regex.Replace%2A> methods include a <xref:System.Text.RegularExpressions.MatchEvaluator> parameter that enables you to programmatically define the replacement text.</span></span>  
  
-   <span data-ttu-id="2884e-163">建立的字串陣列，由輸入字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="2884e-163">Creation of a string array that is formed from parts of an input string.</span></span> <span data-ttu-id="2884e-164">您呼叫<xref:System.Text.RegularExpressions.Regex.Split%2A>方法來分割輸入的字串的規則運算式所定義的位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-164">You call the <xref:System.Text.RegularExpressions.Regex.Split%2A> method to split an input string at positions that are defined by the regular expression.</span></span>  
  
 <span data-ttu-id="2884e-165">其模式比對的方法，除了<xref:System.Text.RegularExpressions.Regex>類別包含數個特殊用途的方法：</span><span class="sxs-lookup"><span data-stu-id="2884e-165">In addition to its pattern-matching methods, the <xref:System.Text.RegularExpressions.Regex> class includes several special-purpose methods:</span></span>  
  
-   <span data-ttu-id="2884e-166"><xref:System.Text.RegularExpressions.Regex.Escape%2A>方法會逸出任何可能會解譯為規則運算式或輸入的字串中的規則運算式運算子的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-166">The <xref:System.Text.RegularExpressions.Regex.Escape%2A> method escapes any characters that may be interpreted as regular expression operators in a regular expression or input string.</span></span>  
  
-   <span data-ttu-id="2884e-167"><xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法會移除這些逸出字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-167">The <xref:System.Text.RegularExpressions.Regex.Unescape%2A> method removes these escape characters.</span></span>  
  
-   <span data-ttu-id="2884e-168"><xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會建立包含預先定義的規則運算式的組件。</span><span class="sxs-lookup"><span data-stu-id="2884e-168">The <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> method creates an assembly that contains predefined regular expressions.</span></span> <span data-ttu-id="2884e-169">.NET Framework 包含這些特殊用途的組件中的範例<xref:System.Web.RegularExpressions?displayProperty=nameWithType>命名空間。</span><span class="sxs-lookup"><span data-stu-id="2884e-169">The .NET Framework contains examples of these special-purpose assemblies in the <xref:System.Web.RegularExpressions?displayProperty=nameWithType> namespace.</span></span>  
  
 [<span data-ttu-id="2884e-170">回到 < 備註 ></span><span class="sxs-lookup"><span data-stu-id="2884e-170">Back to Remarks</span></span>](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a><span data-ttu-id="2884e-171">定義的逾時值</span><span class="sxs-lookup"><span data-stu-id="2884e-171">Defining a Time-Out Value</span></span>  
 <span data-ttu-id="2884e-172">.NET Framework 支援完整的規則運算式語言提供大幅的功能與彈性在模式比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-172">The .NET Framework supports a full-featured regular expression language that provides substantial power and flexibility in pattern matching.</span></span> <span data-ttu-id="2884e-173">不過，支援與彈性是有代價： 效能不佳的風險。</span><span class="sxs-lookup"><span data-stu-id="2884e-173">However, the power and flexibility come at a cost: the risk of poor performance.</span></span> <span data-ttu-id="2884e-174">執行效能不佳的規則運算式是非常容易建立。</span><span class="sxs-lookup"><span data-stu-id="2884e-174">Regular expressions that perform poorly are surprisingly easy to create.</span></span> <span data-ttu-id="2884e-175">在某些情況下，依賴大量回溯規則運算式作業似乎停止回應時它們會處理幾乎符合規則運算式模式的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-175">In some cases, regular expression operations that rely on excessive backtracking can appear to stop responding when they process text that nearly matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-176">如需有關.NET Framework 規則運算式引擎的詳細資訊，請參閱 <<c0> [ 規則運算式行為的詳細資料](~/docs/standard/base-types/details-of-regular-expression-behavior.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-176">For more information about the .NET Framework regular expression engine, see [Details of Regular Expression Behavior](~/docs/standard/base-types/details-of-regular-expression-behavior.md).</span></span> <span data-ttu-id="2884e-177">如需有關大量回溯的詳細資訊，請參閱 <<c0> [ 回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-177">For more information about excessive backtracking, see [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
 <span data-ttu-id="2884e-178">從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，您可以定義逾時間隔，規則運算式相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-178">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can define a time-out interval for regular expression matches.</span></span> <span data-ttu-id="2884e-179">如果規則運算式引擎無法識別此時間間隔內的相符項目，比對作業會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-179">If the regular expression engine cannot identify a match within this time interval, the matching operation throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-180">在大部分情況下，這可防止規則運算式引擎嘗試比對幾乎符合規則運算式模式的文字所浪費的處理能力。</span><span class="sxs-lookup"><span data-stu-id="2884e-180">In most cases, this prevents the regular expression engine from wasting processing power by trying to match text that nearly matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-181">它也可能表示，不過，，已設定的逾時間隔太低，或目前的電腦負載的效能，導致整體效能降低。</span><span class="sxs-lookup"><span data-stu-id="2884e-181">It also could indicate, however, that the timeout interval has been set too low, or that the current machine load has caused an overall degradation in performance.</span></span>  
  
 <span data-ttu-id="2884e-182">處理例外狀況的方式，取決於例外狀況的原因。</span><span class="sxs-lookup"><span data-stu-id="2884e-182">How you handle the exception depends on the cause of the exception.</span></span> <span data-ttu-id="2884e-183">如果因為逾時間隔設得太低，就會發生例外狀況，或因為過多的電腦工作負載，您可以增加逾時間隔並重試比對的作業。</span><span class="sxs-lookup"><span data-stu-id="2884e-183">If the exception occurs because the time-out interval is set too low or because of excessive machine load, you can increase the time-out interval and retry the matching operation.</span></span> <span data-ttu-id="2884e-184">如果規則運算式依賴大量回溯，就會發生例外狀況，您可以假設相符項目不存在，而且 （選擇性） 您可以在此記錄可協助您修改規則運算式模式的資訊。</span><span class="sxs-lookup"><span data-stu-id="2884e-184">If the exception occurs because the regular expression relies on excessive backtracking, you can assume that a match does not exist, and, optionally, you can log information that will help you modify the regular expression pattern.</span></span>  
  
 <span data-ttu-id="2884e-185">您可以藉由呼叫設定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式，當您具現化規則運算式物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-185">You can set a time-out interval by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor when you instantiate a regular expression object.</span></span> <span data-ttu-id="2884e-186">對於靜態方法，您可以設定逾時間隔，藉由呼叫的比對方法的多載`matchTimeout`參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-186">For static methods, you can set a time-out interval by calling an overload of a matching method that has a `matchTimeout` parameter.</span></span> <span data-ttu-id="2884e-187">如果您未明確設定的逾時值，預設的逾時值是以下列方式決定：</span><span class="sxs-lookup"><span data-stu-id="2884e-187">If you do not set a time-out value explicitly, the default time-out value  is determined as follows:</span></span>  
  
-   <span data-ttu-id="2884e-188">使用整個應用程式的逾時的值，如果有一個存在。</span><span class="sxs-lookup"><span data-stu-id="2884e-188">By using the application-wide time-out value, if one exists.</span></span> <span data-ttu-id="2884e-189">這可以是應用程式定義域，適用於任何逾時值<xref:System.Text.RegularExpressions.Regex>物件具現化或靜態方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="2884e-189">This can be any time-out value that applies to the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is instantiated or the static method call is made.</span></span> <span data-ttu-id="2884e-190">您可以藉由呼叫設定整個應用程式的逾時值<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法，以指派的字串表示<xref:System.TimeSpan>"REGEX_DEFAULT_MATCH_TIMEOUT"屬性值。</span><span class="sxs-lookup"><span data-stu-id="2884e-190">You can set the application-wide time-out value by calling the <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> method to assign the string representation of a <xref:System.TimeSpan> value to the "REGEX_DEFAULT_MATCH_TIMEOUT" property.</span></span>  
  
-   <span data-ttu-id="2884e-191">使用值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>，如果已不設定任何全應用程式的逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-191">By using the value <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, if no application-wide time-out value has been set.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2884e-192">我們建議您所有的規則運算式模式比對作業中設定的逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-192">We recommend that you set a time-out value in all regular expression pattern-matching operations.</span></span> <span data-ttu-id="2884e-193">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-193">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md).</span></span>  
  
 [<span data-ttu-id="2884e-194">回到 < 備註 ></span><span class="sxs-lookup"><span data-stu-id="2884e-194">Back to Remarks</span></span>](#remarks)  
  
   
  
## Examples  
 <span data-ttu-id="2884e-195">下列範例會使用規則運算式，檢查有重複出現的文字字串中。</span><span class="sxs-lookup"><span data-stu-id="2884e-195">The following example uses a regular expression to check for repeated occurrences of words in a string.</span></span> <span data-ttu-id="2884e-196">規則運算式`\b(?<word>\w+)\s+(\k<word>)\b`可以解譯為下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-196">The regular expression `\b(?<word>\w+)\s+(\k<word>)\b` can be interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-197">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-197">Pattern</span></span>|<span data-ttu-id="2884e-198">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-198">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-199">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-199">Start the match at a word boundary.</span></span>|  
|`(?<word>\w+)`|<span data-ttu-id="2884e-200">比對到字邊界的一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-200">Match one or more word characters up to a word boundary.</span></span> <span data-ttu-id="2884e-201">此擷取的群組命名為`word`。</span><span class="sxs-lookup"><span data-stu-id="2884e-201">Name this captured group `word`.</span></span>|  
|`\s+`|<span data-ttu-id="2884e-202">比對一或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-202">Match one or more white-space characters.</span></span>|  
|`(\k<word>)`|<span data-ttu-id="2884e-203">比對擷取的群組，稱為`word`。</span><span class="sxs-lookup"><span data-stu-id="2884e-203">Match the captured group that is named `word`.</span></span>|  
|`\b`|<span data-ttu-id="2884e-204">比對字邊界。</span><span class="sxs-lookup"><span data-stu-id="2884e-204">Match a word boundary.</span></span>|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 <span data-ttu-id="2884e-205">下列範例說明如何使用規則運算式，以檢查是否為字串表示貨幣值，或者具有正確的格式來表示貨幣值。</span><span class="sxs-lookup"><span data-stu-id="2884e-205">The following example illustrates the use of a regular expression to check whether a string either represents a currency value or has the correct format to represent a currency value.</span></span> <span data-ttu-id="2884e-206">在此情況下，規則運算式，會動態建立從<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>使用者目前的文化特性的屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-206">In this case, the regular expression is built dynamically from the <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties for the user's current culture.</span></span> <span data-ttu-id="2884e-207">如果系統的目前文化特性是 EN-US，產生的規則運算式是`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`。</span><span class="sxs-lookup"><span data-stu-id="2884e-207">If the system's current culture is en-US, the resulting regular expression is `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`.</span></span> <span data-ttu-id="2884e-208">下表所示，可以解譯這個規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-208">This regular expression can be interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-209">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-209">Pattern</span></span>|<span data-ttu-id="2884e-210">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-210">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2884e-211">字串的開頭開始。</span><span class="sxs-lookup"><span data-stu-id="2884e-211">Start at the beginning of the string.</span></span>|  
|`\s*`|<span data-ttu-id="2884e-212">比對零個以上的空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-212">Match zero or more white-space characters.</span></span>|  
|`[\+-]?`|<span data-ttu-id="2884e-213">比對零個或一個出現的正號或負號。</span><span class="sxs-lookup"><span data-stu-id="2884e-213">Match zero or one occurrence of either the positive sign or the negative sign.</span></span>|  
|`\s?`|<span data-ttu-id="2884e-214">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-214">Match zero or one white-space character.</span></span>|  
|`\$?`|<span data-ttu-id="2884e-215">比對零個或一個出現的貨幣符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-215">Match zero or one occurrence of the dollar sign.</span></span>|  
|`\s?`|<span data-ttu-id="2884e-216">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-216">Match zero or one white-space character.</span></span>|  
|`\d*`|<span data-ttu-id="2884e-217">比對零個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="2884e-217">Match zero or more decimal digits.</span></span>|  
|`\.?`|<span data-ttu-id="2884e-218">比對零個或一個小數點符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-218">Match zero or one decimal point symbol.</span></span>|  
|`\d{2}?`|<span data-ttu-id="2884e-219">比對兩個十進位數字零或一次。</span><span class="sxs-lookup"><span data-stu-id="2884e-219">Match two decimal digits zero or one time.</span></span>|  
|`(\d*\.?\d{2}?){1}`|<span data-ttu-id="2884e-220">比對整數和小數的位數，小數點符號來分隔至少一次的模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-220">Match the pattern of integral and fractional digits separated by a decimal point symbol at least one time.</span></span>|  
|`$`|<span data-ttu-id="2884e-221">比對字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="2884e-221">Match the end of the string.</span></span>|  
  
 <span data-ttu-id="2884e-222">在此情況下，規則運算式假設有效貨幣字串不包含群組分隔符號，而且它有沒有小數位數或目前的文化特性所定義的小數位數數目<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-222">In this case, the regular expression assumes that a valid currency string does not contain group separator symbols, and that it has either no fractional digits or the number of fractional digits defined by the current culture's <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> property.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 <span data-ttu-id="2884e-223">由於動態建置規則運算式，在此範例中，我們不知道在設計階段是否目前文化特性的貨幣符號、 小數符號或正的和負號可能會被錯誤解譯為一般的規則運算式引擎運算式語言的運算子。</span><span class="sxs-lookup"><span data-stu-id="2884e-223">Because the regular expression in this example is built dynamically, we do not know at design time whether the current culture's currency symbol, decimal sign, or positive and negative signs might be misinterpreted by the regular expression engine as regular expression language operators.</span></span> <span data-ttu-id="2884e-224">若要避免任何的錯譯，範例會傳遞至每個動態產生的字串<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-224">To prevent any misinterpretation, the example passes each dynamically generated string to the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="2884e-225">
        <see cref="T:System.Text.RegularExpressions.Regex" />類別是不可變 （唯讀） 和安全執行緒。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2884e-225">The <see cref="T:System.Text.RegularExpressions.Regex" /> class is immutable (read-only) and thread safe.</span>
      </span>
      <span data-ttu-id="2884e-226">
        <see cref="T:System.Text.RegularExpressions.Regex" /> 物件可以在任何執行緒上建立與執行緒之間共用。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2884e-226">
          <see cref="T:System.Text.RegularExpressions.Regex" /> objects can be created on any thread and shared between threads.</span>
      </span>
      <span data-ttu-id="2884e-227">如需詳細資訊，請參閱 &lt;&lt;c0&gt; [ 的執行緒安全](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2884e-227">For more information, see [Thread Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-228">初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-228">Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-229">初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-229">Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-230">請注意，受到這個建構函式;它只由衍生自的類別呼叫<xref:System.Text.RegularExpressions.Regex>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-230">Note that this constructor is protected; it can only be called by classes derived from the <xref:System.Text.RegularExpressions.Regex> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">
          <span data-ttu-id="2884e-231">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-231">The regular expression pattern to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-232">為指定的規則運算式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-232">Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-233">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-233">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-234">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。</span><span class="sxs-lookup"><span data-stu-id="2884e-234">For more information about regular expressions, see the [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md) topics.</span></span>  
  
 <span data-ttu-id="2884e-235">呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29>建構函式相當於呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式值是<xref:System.Text.RegularExpressions.RegexOptions.None>如`options`引數。</span><span class="sxs-lookup"><span data-stu-id="2884e-235">Calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> constructor is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor with a value of <xref:System.Text.RegularExpressions.RegexOptions.None> for the `options` argument.</span></span>  
  
 <span data-ttu-id="2884e-236">A<xref:System.Text.RegularExpressions.Regex>物件是不可變的也就是說，它可以僅適用於您在建立時定義的比對模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-236">A <xref:System.Text.RegularExpressions.Regex> object is immutable, which means that it can be used only for the match pattern you define when you create it.</span></span> <span data-ttu-id="2884e-237">不過，它可以使用任意數目的時間，而不需要重新編譯。</span><span class="sxs-lookup"><span data-stu-id="2884e-237">However, it can be used any number of times without being recompiled.</span></span>  
  
 <span data-ttu-id="2884e-238">這個建構函式會嘗試定義中的任何字母字元的區分大小寫比對規則運算式物件具現化`pattern`。</span><span class="sxs-lookup"><span data-stu-id="2884e-238">This constructor instantiates a regular expression object that attempts a case-sensitive match of any alphabetical characters defined in `pattern`.</span></span> <span data-ttu-id="2884e-239">不區分大小寫的比對中，使用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-239">For a case-insensitive match, use the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-240">下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的字組"a"或"t"。</span><span class="sxs-lookup"><span data-stu-id="2884e-240">The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 <span data-ttu-id="2884e-241">請注意，規則運算式模式無法符合這個字"The"開頭的文字，因為預設區分大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="2884e-241">Note that the regular expression pattern cannot match the word "The" at the beginning of the text, because comparisons are case-sensitive by default.</span></span> <span data-ttu-id="2884e-242">如需範例的不區分大小寫的比較，請參閱<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-242">For an example of case-insensitive comparison, see the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-243">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-243">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-244">
            <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-244">
              <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-245">
            <para>這個建構函式會建立<see cref="T:System.Text.RegularExpressions.Regex" />會使用預設的逾時值，在其中建立應用程式定義域的物件。如果應用程式定義域中，尚未定義的逾時值<see cref="T:System.Text.RegularExpressions.Regex" />物件會使用值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，這樣就不會逾時的作業。建立建議建構函式<see cref="T:System.Text.RegularExpressions.Regex" />物件是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-245">
              <para>This constructor creates a <see cref="T:System.Text.RegularExpressions.Regex" /> object that uses the default time-out value of the application domain in which it is created. If a time-out value has not been defined for the application domain,  the <see cref="T:System.Text.RegularExpressions.Regex" /> object uses the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the operation from timing out. The recommended constructor for creating a <see cref="T:System.Text.RegularExpressions.Regex" /> object is <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="2884e-246">包含序列化模式和 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 資訊的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-246">The object that contains a serialized pattern and <see cref="T:System.Text.RegularExpressions.RegexOptions" /> information.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="2884e-247">這個序列化的目的端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-247">The destination for this serialization.</span>
          </span>
          <span data-ttu-id="2884e-248">(不使用這個參數；請指定 <see langword="null" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-248">(This parameter is not used; specify <see langword="null" />.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-249">使用序列化的資料，初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-249">Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class by using serialized data.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-250">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-250">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-251">
            <paramref name="info" /> 包含的模式為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-251">The pattern that <paramref name="info" /> contains is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-252">
            <paramref name="info" /> 包含無效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-252">
              <paramref name="info" /> contains an invalid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> flag.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">
          <span data-ttu-id="2884e-253">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-253">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-254">列舉值的位元組合，這些值會修改規則運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-254">A bitwise combination of the enumeration values that modify the regular expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-255">使用會修改模式的選項，為指定的規則運算式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-255">Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression, with options that modify the pattern.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-256">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-256">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-257">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。</span><span class="sxs-lookup"><span data-stu-id="2884e-257">For more information about regular expressions, see the [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md) topics.</span></span>  
  
 <span data-ttu-id="2884e-258">A<xref:System.Text.RegularExpressions.Regex>物件是不可變的也就是說，它可以僅適用於您在建立時定義的比對參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-258">A <xref:System.Text.RegularExpressions.Regex> object is immutable, which means that it can be used only for the match parameters you define when you create it.</span></span> <span data-ttu-id="2884e-259">不過，它可以使用任意數目的時間，而不需要重新編譯。</span><span class="sxs-lookup"><span data-stu-id="2884e-259">However, it can be used any number of times without being recompiled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-260">下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的字組"a"或"t"。</span><span class="sxs-lookup"><span data-stu-id="2884e-260">The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 <span data-ttu-id="2884e-261">請注意，比對集合包含的文字"The"開頭的文字，因為`options`已定義參數不區分大小寫的比較。</span><span class="sxs-lookup"><span data-stu-id="2884e-261">Note that the match collection includes the word "The" that begins the text because the `options` parameter has defined case-insensitive comparisons.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-262">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-262">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-263">
            <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-263">
              <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-264">
            <paramref name="options" /> 包含無效的旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-264">
              <paramref name="options" /> contains an invalid flag.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-265">
            <para>這個建構函式會建立<see cref="T:System.Text.RegularExpressions.Regex" />會使用預設的逾時值，在其中建立應用程式定義域的物件。如果應用程式定義域中，尚未定義的逾時值<see cref="T:System.Text.RegularExpressions.Regex" />物件會使用值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，這樣就不會逾時的作業。建立建議建構函式<see cref="T:System.Text.RegularExpressions.Regex" />物件是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-265">
              <para>This constructor creates a <see cref="T:System.Text.RegularExpressions.Regex" /> object that uses the default time-out value of the application domain in which it is created. If a time-out value has not been defined for the application domain, the <see cref="T:System.Text.RegularExpressions.Regex" /> object uses the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the operation from timing out. The recommended constructor for creating a <see cref="T:System.Text.RegularExpressions.Regex" /> object is <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">
          <span data-ttu-id="2884e-266">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-266">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-267">列舉值的位元組合，這些值會修改規則運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-267">A bitwise combination of the enumeration values that modify the regular expression.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-268">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-268">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-269">針對指定的規則運算式，使用修改模式的選項，以及指定在逾時前模式比對方法應該嘗試比對的時間長度的值，初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-269">Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-270">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-270">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-271">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。</span><span class="sxs-lookup"><span data-stu-id="2884e-271">For more information about regular expressions, see the [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md) topics.</span></span>  
  
 <span data-ttu-id="2884e-272">A<xref:System.Text.RegularExpressions.Regex>物件是不可變的也就是說，它可以僅適用於您定義當您建立比對模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-272">A <xref:System.Text.RegularExpressions.Regex> object is immutable, which means that it can be used only for the match pattern that you define when you create it.</span></span> <span data-ttu-id="2884e-273">不過，它可以使用任意數目的時間，而不需要重新編譯。</span><span class="sxs-lookup"><span data-stu-id="2884e-273">However, it can be used any number of times without being recompiled.</span></span>  
  
 <span data-ttu-id="2884e-274">`matchTimeout`參數會指定多久模式比對方法應該嘗試逾時之前，尋找相符項目。如果沒有相符項目位於該時間間隔，模式比對的方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-274">The `matchTimeout` parameter specifies how long a pattern-matching method should try to find a match before it times out. If no match is found in that time interval, the pattern-matching method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-275">`matchTimeout` 覆寫應用程式定義域中定義任何預設的逾時值<xref:System.Text.RegularExpressions.Regex>建立物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-275">`matchTimeout` overrides any default time-out value defined for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-276">執行個體模式比對方法觀察`matchTimeout`逾時間隔包括下列：</span><span class="sxs-lookup"><span data-stu-id="2884e-276">The instance pattern-matching methods that observe the `matchTimeout` time-out interval include the following:</span></span>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="2884e-277">將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。</span><span class="sxs-lookup"><span data-stu-id="2884e-277">Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</span></span> <span data-ttu-id="2884e-278">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-278">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md) and [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-279">若要設定合理的逾時間隔，請考慮下列因素：</span><span class="sxs-lookup"><span data-stu-id="2884e-279">To set a reasonable time-out interval, consider the following factors:</span></span>  
  
-   <span data-ttu-id="2884e-280">長度和複雜度的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-280">The length and complexity of the regular expression pattern.</span></span> <span data-ttu-id="2884e-281">時間更長、 更複雜的規則運算式需要更多的時間比比較簡短而簡單的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-281">Longer and more complex regular expressions require more time than shorter and simpler ones.</span></span>  
  
-   <span data-ttu-id="2884e-282">預期的電腦工作負載。</span><span class="sxs-lookup"><span data-stu-id="2884e-282">The expected machine load.</span></span> <span data-ttu-id="2884e-283">處理會有 CPU 和記憶體使用率過高的系統上的更多的時間。</span><span class="sxs-lookup"><span data-stu-id="2884e-283">Processing takes more time on systems that have high CPU and memory utilization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-284">下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式來具現化<xref:System.Text.RegularExpressions.Regex>逾時值為一秒的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-284">The following example calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="2884e-285">規則運算式模式 `(a+)+$`會在行尾比對一個或多個 "a" 字元的一個或多個序列，並且受限於大量回溯。</span><span class="sxs-lookup"><span data-stu-id="2884e-285">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="2884e-286">如果<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>會擲回，則範例會增加逾時值，最多三秒的最大值。</span><span class="sxs-lookup"><span data-stu-id="2884e-286">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to the maximum value of three seconds.</span></span> <span data-ttu-id="2884e-287">否則，它會放棄嘗試比對模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-287">Otherwise, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-288">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-288">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-289">
            <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-289">
              <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-290">
            <paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-290">
              <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.</span>
          </span>
          <span data-ttu-id="2884e-291">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-291">-or-</span>
          </span>
          <span data-ttu-id="2884e-292">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-292">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-293">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-293">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-294">取得或設定在已編譯規則運算式目前靜態快取中項目的最大數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-294">Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2884e-295">靜態快取中項目的最大數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-295">The maximum number of entries in the static cache.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-296"><xref:System.Text.RegularExpressions.Regex>類別會負責維護內部的靜態方法呼叫中使用的已編譯規則運算式快取。</span><span class="sxs-lookup"><span data-stu-id="2884e-296">The <xref:System.Text.RegularExpressions.Regex> class maintains an internal cache of compiled regular expressions used in static method calls.</span></span> <span data-ttu-id="2884e-297">如果在設定作業中指定的值小於目前的快取大小，快取項目都會被捨棄，直到快取大小是否等於指定的值。</span><span class="sxs-lookup"><span data-stu-id="2884e-297">If the value specified in a set operation is less than the current cache size, cache entries are discarded until the cache size is equal to the specified value.</span></span>  
  
 <span data-ttu-id="2884e-298">根據預設，快取會儲存 15 個已編譯的靜態規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-298">By default, the cache holds 15 compiled static regular expressions.</span></span> <span data-ttu-id="2884e-299">您的應用程式通常不會修改快取的大小。</span><span class="sxs-lookup"><span data-stu-id="2884e-299">Your application typically will not have to modify the size of the cache.</span></span> <span data-ttu-id="2884e-300">使用<xref:System.Text.RegularExpressions.Regex.CacheSize%2A>只有當您想要關閉 快取，或當您有非常大的快取的屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-300">Use the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> property only when you want to turn off caching or when you have an unusually large cache.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-301">設定作業中的值小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-301">The value in a set operation is less than zero.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-302">
            <para>在.NET Framework 之前[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]、 規則運算式用於這兩個靜態和快取執行個體方法呼叫。開頭為[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]、 一般只會快取靜態方法呼叫中使用的運算式。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-302">
              <para>In the .NET Framework prior to the [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], regular expressions used in both static and instance method calls were cached. Beginning with the [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], only regular expressions used in static method calls are cached.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-303">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-303">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-304">取得或設定字典，對應具名擷取群組及其索引值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-304">Gets or sets a dictionary that maps named capturing groups to their index values.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2884e-305">對應具名擷取群組及其索引值的字典。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-305">A dictionary that maps named capturing groups to their index values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-306">請注意，這個屬性會受到保護;它只能從衍生自的類別存取<xref:System.Text.RegularExpressions.Regex>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-306">Note that this property is protected; it can only be accessed from a class derived from the <xref:System.Text.RegularExpressions.Regex> class.</span></span>  
  
 <span data-ttu-id="2884e-307">設定作業會嘗試將指派給屬性的值<xref:System.Collections.Hashtable>物件; 如果這項轉換會失敗，則會呼叫<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-307">A set operation attempts to convert the value assigned to the property to a <xref:System.Collections.Hashtable> object; if this conversion fails, it calls the <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-308">在設定作業中指派給 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 的屬性值是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-308">The value assigned to the <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> property in a set operation is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-309">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-309">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-310">取得或設定字典，對應編號的擷取群組及其索引值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-310">Gets or sets a dictionary that maps numbered capturing groups to their index values.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2884e-311">對應編號的擷取群組及其索引值的字典。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-311">A dictionary that maps numbered capturing groups to their index values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-312">請注意，這個屬性會受到保護;它只能從衍生自的類別存取<xref:System.Text.RegularExpressions.Regex>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-312">Note that this property is protected; it can only be accessed from a class derived from the <xref:System.Text.RegularExpressions.Regex> class.</span></span>  
  
 <span data-ttu-id="2884e-313">設定作業會嘗試將指派給屬性的值<xref:System.Collections.Hashtable>物件; 如果這項轉換會失敗，則會呼叫<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-313">A set operation attempts to convert the value assigned to the property to a <xref:System.Collections.Hashtable> object; if this conversion fails, it calls the <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-314">在設定作業中指派給 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 的屬性值是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-314">The value assigned to the <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> property in a set operation is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-315">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-315">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-316">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-316">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-317">編譯規則運算式並將它們以單一組件 (Assembly) 儲存至磁碟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-317">Compiles regular expressions and saves them to disk in a single assembly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="2884e-318">在.NET Core 上呼叫`Regex.CompileToAssembly`方法擲回<xref:System.PlatformNotSupportedException>; 不支援寫出組件。</span><span class="sxs-lookup"><span data-stu-id="2884e-318">On .NET Core, calls to the `Regex.CompileToAssembly` method throw a <xref:System.PlatformNotSupportedException>; writing out an assembly is not supported.</span></span>
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">
          <span data-ttu-id="2884e-319">陣列，描述要編譯的規則運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-319">An array that describes the regular expressions to compile.</span>
          </span>
        </param>
        <param name="assemblyname">
          <span data-ttu-id="2884e-320">組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-320">The file name of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-321">將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件編譯為具名組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-321">Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects to a named assembly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-322"><xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>方法會產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由一個類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-322">The <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class.</span></span> <span data-ttu-id="2884e-323">一般而言，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>從個別的應用程式所產生的已編譯的規則運算式的組件呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-323">Typically, the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> method is called from a separate application that generates an assembly of compiled regular expressions.</span></span> <span data-ttu-id="2884e-324">每個組件中包含的規則運算式具有下列特性：</span><span class="sxs-lookup"><span data-stu-id="2884e-324">Each regular expression included in the assembly has the following characteristics:</span></span>  
  
-   <span data-ttu-id="2884e-325">它衍生自<xref:System.Text.RegularExpressions.Regex>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-325">It is derived from the <xref:System.Text.RegularExpressions.Regex> class.</span></span>  
  
-   <span data-ttu-id="2884e-326">它指派所定義的完整限定的名稱`fullnamespace`並`name`對應的參數<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-326">It is assigned the fully qualified name that is defined by the `fullnamespace` and `name` parameters of its corresponding <xref:System.Text.RegularExpressions.RegexCompilationInfo> object.</span></span>  
  
-   <span data-ttu-id="2884e-327">它有預設值 （或無參數） 建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-327">It has a default (or parameterless) constructor.</span></span>  
  
 <span data-ttu-id="2884e-328">一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-328">Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-329">下列範例會建立名為 RegexLib.dll 組件。</span><span class="sxs-lookup"><span data-stu-id="2884e-329">The following example creates an assembly named RegexLib.dll.</span></span> <span data-ttu-id="2884e-330">組件包含兩個已編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-330">The assembly includes two compiled regular expressions.</span></span> <span data-ttu-id="2884e-331">第一天， `Utilities.RegularExpressions.DuplicatedString`，比對兩個相同的連續文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-331">The first, `Utilities.RegularExpressions.DuplicatedString`, matches two identical contiguous words.</span></span> <span data-ttu-id="2884e-332">第二個， `Utilities.RegularExpressions.EmailAddress`，檢查字串是否具有正確格式的電子郵件地址。</span><span class="sxs-lookup"><span data-stu-id="2884e-332">The second, `Utilities.RegularExpressions.EmailAddress`, checks whether a string has the correct format to be an email address.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 <span data-ttu-id="2884e-333">檢查重複的文字字串的規則運算式然後具現化，並使用下列的範例。</span><span class="sxs-lookup"><span data-stu-id="2884e-333">The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 <span data-ttu-id="2884e-334">成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立的組件） 的參考加入至專案。</span><span class="sxs-lookup"><span data-stu-id="2884e-334">Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-335">
            <paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-335">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.</span>
          </span>
          <span data-ttu-id="2884e-336">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-336">-or-</span>
          </span>
          <span data-ttu-id="2884e-337">
            <paramref name="regexinfos" /> 中一個或多個物件的規則運算式模式包含無效的語法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-337">The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-338">
            <paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-338">
              <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2884e-339">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-339">.NET Core only: Creating an assembly of compiled regular expressions is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-340">
            <para>如果您正在開發的系統上，具有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或其點發行版本安裝目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法用來建立包含的組件編譯的規則運算式。嘗試使用其中一個規則運算式，因為在系統上的組件具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]會擲回例外狀況。若要解決此問題，您可以執行下列其中一項:-建立可包含的系統上，已編譯的規則運算式的組件[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安裝的更新版本。 -而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />並從組件中擷取已編譯的規則運算式，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-340">
              <para>If you are developing on a system that has [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or its point releases installed, you target [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], and you use the <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> method to create an assembly that contains compiled regular expressions. Trying to use one of the regular expressions in that assembly on a system that has [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] throws an exception. To work around this problem, you can do either of the following:  -   Build the assembly that contains the compiled regular expressions on a system that has [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] instead of later versions installed.  -   Instead of calling <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> and retrieving the compiled regular expression from an assembly, use either static or instance <see cref="T:System.Text.RegularExpressions.Regex" /> methods with the <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option when you instantiate a <see cref="T:System.Text.RegularExpressions.Regex" /> object or call a regular expression pattern matching method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">
          <span data-ttu-id="2884e-341">陣列，描述要編譯的規則運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-341">An array that describes the regular expressions to compile.</span>
          </span>
        </param>
        <param name="assemblyname">
          <span data-ttu-id="2884e-342">組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-342">The file name of the assembly.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="2884e-343">陣列，定義要套用至組件的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-343">An array that defines the attributes to apply to the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-344">將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件編譯為具有指定之屬性的具名組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-344">Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects to a named assembly with the specified attributes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-345"><xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>方法會產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由一個類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-345">The <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class.</span></span> <span data-ttu-id="2884e-346">一般而言，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>從個別的應用程式所產生的已編譯的規則運算式的組件呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-346">Typically, the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> method is called from a separate application that generates an assembly of compiled regular expressions.</span></span> <span data-ttu-id="2884e-347">每個組件中包含的規則運算式具有下列特性：</span><span class="sxs-lookup"><span data-stu-id="2884e-347">Each regular expression included in the assembly has the following characteristics:</span></span>  
  
-   <span data-ttu-id="2884e-348">它衍生自<xref:System.Text.RegularExpressions.Regex>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-348">It is derived from the <xref:System.Text.RegularExpressions.Regex> class.</span></span>  
  
-   <span data-ttu-id="2884e-349">它指派所定義的完整限定的名稱`fullnamespace`並`name`對應的參數<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-349">It is assigned the fully qualified name that is defined by the `fullnamespace` and `name` parameters of its corresponding <xref:System.Text.RegularExpressions.RegexCompilationInfo> object.</span></span>  
  
-   <span data-ttu-id="2884e-350">它有預設值 （或無參數） 建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-350">It has a default (or parameterless) constructor.</span></span>  
  
 <span data-ttu-id="2884e-351">一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-351">Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</span></span>  
  
 <span data-ttu-id="2884e-352">因為<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會產生.NET Framework 組件，而不是使用特定語言的類別定義關鍵字的方法呼叫 (例如`class`在 C# 或`Class`...`End Class`</span><span class="sxs-lookup"><span data-stu-id="2884e-352">Because the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as `class` in C# or `Class`…`End Class`</span></span> <span data-ttu-id="2884e-353">在 Visual Basic 中)，它不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-353">in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</span></span> <span data-ttu-id="2884e-354">`attributes`參數提供的替代方法來定義將套用至組件的屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-354">The `attributes` parameter provides an alternative method for defining the attributes that apply to the assembly.</span></span> <span data-ttu-id="2884e-355">針對每個您想要套用至組件的屬性，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="2884e-355">For each attribute that you want to apply to the assembly, do the following:</span></span>  
  
1.  <span data-ttu-id="2884e-356">建立陣列<xref:System.Type>代表您想要呼叫的屬性建構函式的參數類型的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-356">Create an array of <xref:System.Type> objects representing the parameter types of the attribute constructor that you want to call.</span></span>  
  
2.  <span data-ttu-id="2884e-357">擷取<xref:System.Type>物件，表示您想要套用至新的組件的屬性類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-357">Retrieve a <xref:System.Type> object representing the attribute class that you want to apply to the new assembly.</span></span>  
  
3.  <span data-ttu-id="2884e-358">呼叫<xref:System.Type.GetConstructor%2A>屬性的方法<xref:System.Type>物件來擷取<xref:System.Reflection.ConstructorInfo>物件，表示您想要呼叫的屬性建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-358">Call the <xref:System.Type.GetConstructor%2A> method of the attribute <xref:System.Type> object to retrieve a <xref:System.Reflection.ConstructorInfo> object representing the attribute constructor that you want to call.</span></span> <span data-ttu-id="2884e-359">傳遞<xref:System.Type.GetConstructor%2A>方法的陣列的<xref:System.Type>表示建構函式的參數類型的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-359">Pass the <xref:System.Type.GetConstructor%2A> method the array of <xref:System.Type> objects that represents the constructor's parameter types.</span></span>  
  
4.  <span data-ttu-id="2884e-360">建立<xref:System.Object>陣列，定義要傳遞給屬性的建構函式的參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-360">Create a <xref:System.Object> array that defines the parameters to pass to the attribute's constructor.</span></span>  
  
5.  <span data-ttu-id="2884e-361">具現化<xref:System.Reflection.Emit.CustomAttributeBuilder>物件，並傳遞其建構函式<xref:System.Reflection.ConstructorInfo>擷取在步驟 3 中的物件和<xref:System.Object>步驟 4 中建立的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-361">Instantiate a <xref:System.Reflection.Emit.CustomAttributeBuilder> object by passing its constructor the <xref:System.Reflection.ConstructorInfo> object retrieved in step 3 and the <xref:System.Object> array created in step 4.</span></span>  
  
 <span data-ttu-id="2884e-362">然後，您就可以傳遞這些陣列<xref:System.Reflection.Emit.CustomAttributeBuilder>而不是物件`attributes`參數來<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-362">You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-363">下列範例會建立名為 RegexLib.dll 組件，並套用<xref:System.Reflection.AssemblyTitleAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-363">The following example creates an assembly named RegexLib.dll and applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to it.</span></span> <span data-ttu-id="2884e-364">組件包含兩個已編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-364">The assembly includes two compiled regular expressions.</span></span> <span data-ttu-id="2884e-365">第一天， `Utilities.RegularExpressions.DuplicatedString`，比對兩個相同的連續文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-365">The first, `Utilities.RegularExpressions.DuplicatedString`, matches two identical contiguous words.</span></span> <span data-ttu-id="2884e-366">第二個， `Utilities.RegularExpressions.EmailAddress`，檢查字串是否具有正確格式的電子郵件地址。</span><span class="sxs-lookup"><span data-stu-id="2884e-366">The second, `Utilities.RegularExpressions.EmailAddress`, checks whether a string has the correct format to be an email address.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 <span data-ttu-id="2884e-367">您可以確認<xref:System.Reflection.AssemblyTitleAttribute>藉由檢查它的資訊清單，使用反映公用程式，例如 ILDasm 屬性套用至組件。</span><span class="sxs-lookup"><span data-stu-id="2884e-367">You can verify that the <xref:System.Reflection.AssemblyTitleAttribute> attribute has been applied to the assembly by examining its manifest with a reflection utility such as ILDasm.</span></span>  
  
 <span data-ttu-id="2884e-368">檢查重複的文字字串的規則運算式然後具現化，並使用下列的範例。</span><span class="sxs-lookup"><span data-stu-id="2884e-368">The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 <span data-ttu-id="2884e-369">成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立的組件） 的參考加入至專案。</span><span class="sxs-lookup"><span data-stu-id="2884e-369">Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-370">
            <paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-370">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.</span>
          </span>
          <span data-ttu-id="2884e-371">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-371">-or-</span>
          </span>
          <span data-ttu-id="2884e-372">
            <paramref name="regexinfos" /> 中一個或多個物件的規則運算式模式包含無效的語法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-372">The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-373">
            <paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-373">
              <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2884e-374">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-374">.NET Core only: Creating an assembly of compiled regular expressions is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-375">
            <para>如果您正在開發的系統上，具有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或其點發行版本安裝目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法用來建立包含的組件編譯的規則運算式。嘗試使用其中一個規則運算式，因為在系統上的組件具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]會擲回例外狀況。若要解決此問題，您可以執行下列其中一項:-建立可包含的系統上，已編譯的規則運算式的組件[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安裝的更新版本。 -而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />並從組件中擷取已編譯的規則運算式，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-375">
              <para>If you are developing on a system that has [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or its point releases installed, you target [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], and you use the <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> method to create an assembly that contains compiled regular expressions. Trying to use one of the regular expressions in that assembly on a system that has [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] throws an exception. To work around this problem, you can do either of the following:  -   Build the assembly that contains the compiled regular expressions on a system that has [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] instead of later versions installed.  -   Instead of calling <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> and retrieving the compiled regular expression from an assembly, use either static or instance <see cref="T:System.Text.RegularExpressions.Regex" /> methods with the <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option when you instantiate a <see cref="T:System.Text.RegularExpressions.Regex" /> object or call a regular expression pattern matching method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">
          <span data-ttu-id="2884e-376">陣列，描述要編譯的規則運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-376">An array that describes the regular expressions to compile.</span>
          </span>
        </param>
        <param name="assemblyname">
          <span data-ttu-id="2884e-377">組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-377">The file name of the assembly.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="2884e-378">陣列，定義要套用至組件的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-378">An array that defines the attributes to apply to the assembly.</span>
          </span>
        </param>
        <param name="resourceFile">
          <span data-ttu-id="2884e-379">要包括在組件中的 Win32 資源檔的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-379">The name of the Win32 resource file to include in the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-380">將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件和指定的資源檔編譯為具有指定之屬性的具名組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-380">Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects and a specified resource file to a named assembly with the specified attributes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-381">[\]，組件名稱、 CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 方法會產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由一個類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-381">The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class.</span></span> <span data-ttu-id="2884e-382">一般而言，[\]，組件名稱、 CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 會從個別的應用程式所產生的已編譯的規則運算式的組件呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-382">Typically, the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method is called from a separate application that generates an assembly of compiled regular expressions.</span></span> <span data-ttu-id="2884e-383">每個組件中包含的規則運算式具有下列特性：</span><span class="sxs-lookup"><span data-stu-id="2884e-383">Each regular expression included in the assembly has the following characteristics:</span></span>  
  
-   <span data-ttu-id="2884e-384">它衍生自<xref:System.Text.RegularExpressions.Regex>類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-384">It is derived from the <xref:System.Text.RegularExpressions.Regex> class.</span></span>  
  
-   <span data-ttu-id="2884e-385">它指派所定義的完整限定的名稱`fullnamespace`並`name`對應的參數<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-385">It is assigned the fully qualified name that is defined by the `fullnamespace` and `name` parameters of its corresponding <xref:System.Text.RegularExpressions.RegexCompilationInfo> object.</span></span>  
  
-   <span data-ttu-id="2884e-386">它有預設值 （或無參數） 建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-386">It has a default (or parameterless) constructor.</span></span>  
  
 <span data-ttu-id="2884e-387">一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-387">Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</span></span>  
  
 <span data-ttu-id="2884e-388">因為<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會產生.NET Framework 組件，而不是使用特定語言的類別定義關鍵字的方法呼叫 (例如`class`在 C# 或`Class`...`End Class`</span><span class="sxs-lookup"><span data-stu-id="2884e-388">Because the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as `class` in C# or `Class`…`End Class`</span></span> <span data-ttu-id="2884e-389">在 Visual Basic 中)，它不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-389">in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</span></span> <span data-ttu-id="2884e-390">`attributes`參數提供的替代方法來定義將套用至組件的屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-390">The `attributes` parameter provides an alternative method for defining the attributes that apply to the assembly.</span></span> <span data-ttu-id="2884e-391">針對每個您想要套用至組件的屬性，執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="2884e-391">For each attribute that you want to apply to the assembly, do the following:</span></span>  
  
1.  <span data-ttu-id="2884e-392">建立陣列<xref:System.Type>代表您想要呼叫的屬性建構函式的參數類型的物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-392">Create an array of <xref:System.Type> objects representing the parameter types of the attribute constructor that you want to call.</span></span>  
  
2.  <span data-ttu-id="2884e-393">擷取<xref:System.Type>物件，表示您想要套用至新的組件的屬性類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-393">Retrieve a <xref:System.Type> object representing the attribute class that you want to apply to the new assembly.</span></span>  
  
3.  <span data-ttu-id="2884e-394">呼叫<xref:System.Type.GetConstructor%2A>屬性的方法<xref:System.Type>物件來擷取<xref:System.Reflection.ConstructorInfo>物件，表示您想要呼叫的屬性建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-394">Call the <xref:System.Type.GetConstructor%2A> method of the attribute <xref:System.Type> object to retrieve a <xref:System.Reflection.ConstructorInfo> object representing the attribute constructor that you want to call.</span></span> <span data-ttu-id="2884e-395">傳遞<xref:System.Type.GetConstructor%2A>方法的陣列的<xref:System.Type>表示建構函式的參數類型的物件</span><span class="sxs-lookup"><span data-stu-id="2884e-395">Pass the <xref:System.Type.GetConstructor%2A> method the array of <xref:System.Type> objects that represents the constructor's parameter types</span></span>  
  
4.  <span data-ttu-id="2884e-396">建立<xref:System.Object>陣列，定義要傳遞給屬性的建構函式的參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-396">Create a <xref:System.Object> array that defines the parameters to pass to the attribute's constructor.</span></span>  
  
5.  <span data-ttu-id="2884e-397">具現化<xref:System.Reflection.Emit.CustomAttributeBuilder>物件，並傳遞其建構函式<xref:System.Reflection.ConstructorInfo>擷取在步驟 3 中的物件和<xref:System.Object>步驟 4 中建立的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-397">Instantiate a <xref:System.Reflection.Emit.CustomAttributeBuilder> object by passing its constructor the <xref:System.Reflection.ConstructorInfo> object retrieved in step 3 and the <xref:System.Object> array created in step 4.</span></span>  
  
 <span data-ttu-id="2884e-398">然後，您就可以傳遞這些陣列<xref:System.Reflection.Emit.CustomAttributeBuilder>而不是物件`attributes`參數，以 [\]，組件名稱、 CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-398">You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-399">
            <paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-399">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.</span>
          </span>
          <span data-ttu-id="2884e-400">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-400">-or-</span>
          </span>
          <span data-ttu-id="2884e-401">
            <paramref name="regexinfos" /> 中一個或多個物件的規則運算式模式包含無效的語法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-401">The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-402">
            <paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-402">
              <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="2884e-403">
            <paramref name="resourceFile" /> 參數指定不正確的 Win32 資源檔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-403">The <paramref name="resourceFile" /> parameter designates an invalid Win32 resource file.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="2884e-404">找不到 <paramref name="resourceFile" /> 參數所指定的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-404">The file designated by the <paramref name="resourceFile" /> parameter cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2884e-405">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-405">.NET Core only: Creating an assembly of compiled regular expressions is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-406">
            <para>如果您正在開發的系統上，具有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或其點發行版本安裝目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法用來建立包含的組件編譯的規則運算式。嘗試使用其中一個規則運算式，因為在系統上的組件具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]會擲回例外狀況。若要解決此問題，您可以執行下列其中一項:-建立可包含的系統上，已編譯的規則運算式的組件[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安裝的更新版本。 -而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />並從組件中擷取已編譯的規則運算式，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-406">
              <para>If you are developing on a system that has [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or its point releases installed, you target [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], and you use the <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> method to create an assembly that contains compiled regular expressions. Trying to use one of the regular expressions in that assembly on a system that has [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] throws an exception. To work around this problem, you can do either of the following:  -   Build the assembly that contains the compiled regular expressions on a system that has [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] instead of later versions installed.  -   Instead of calling <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> and retrieving the compiled regular expression from an assembly, use either static or instance <see cref="T:System.Text.RegularExpressions.Regex" /> methods with the <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option when you instantiate a <see cref="T:System.Text.RegularExpressions.Regex" /> object or call a regular expression pattern matching method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">
          <span data-ttu-id="2884e-407">輸入字串，包含要轉換的文字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-407">The input string that contains the text to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-408">以逸出程式碼取代字元 (\\、\*、+、?、|、{、[、(、)、^、$、.、# 和空白字元) 的最小集合，以便逸出這些字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-408">Escapes a minimal set of characters (\\, \*, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes.</span>
          </span>
          <span data-ttu-id="2884e-409">這樣會指示規則運算式引擎將這些字元解譯為常值，而非解譯為中繼字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-409">This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-410">字元字串，其中中繼字元已轉換為逸出格式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-410">A string of characters with metacharacters converted to their escaped form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-411"><xref:System.Text.RegularExpressions.Regex.Escape%2A> 將字串轉換，讓規則運算式引擎會解譯為字元常值可能包含任何中繼字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-411"><xref:System.Text.RegularExpressions.Regex.Escape%2A> converts a string so that the regular expression engine will interpret any metacharacters that it may contain as character literals.</span></span> <span data-ttu-id="2884e-412">例如，請考慮規則運算式是設計用來擷取所直接左右方括號 （[和]） 從文字分隔的註解。</span><span class="sxs-lookup"><span data-stu-id="2884e-412">For example, consider a regular expression that is designed to extract comments that are delimited by straight opening and closing brackets ([ and ]) from text.</span></span> <span data-ttu-id="2884e-413">在下列範例中，規則運算式 「 [(.\*?)]"會解譯為字元類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-413">In the following example, the regular expression "[(.\*?)]" is interpreted as a character class.</span></span> <span data-ttu-id="2884e-414">而不是比對輸入文字中內嵌的註解，規則運算式比對每個左或右括號、 句號、 星號或問號。</span><span class="sxs-lookup"><span data-stu-id="2884e-414">Rather than matching comments embedded in the input text, the regular expression matches each opening or closing parenthesis, period, asterisk, or question mark.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 <span data-ttu-id="2884e-415">不過，如果左括號會逸出，傳遞至<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法中，規則運算式成功比對輸入字串中內嵌的註解。</span><span class="sxs-lookup"><span data-stu-id="2884e-415">However, if the opening bracket is escaped by passing it to the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method, the regular expression succeeds in matching comments that are embedded in the input string.</span></span> <span data-ttu-id="2884e-416">下列範例將說明這點。</span><span class="sxs-lookup"><span data-stu-id="2884e-416">The following example illustrates this.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 <span data-ttu-id="2884e-417">在所使用的靜態文字定義規則運算式中，會被解譯字面意義，而不是為中繼字元的字元可以逸出前加上反斜線符號 (\\) 以及透過呼叫<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-417">In a regular expression that is defined by using static text, characters that are to be interpreted literally rather than as metacharacters can be escaped by preceding them with a backslash symbol (\\) as well as by calling the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method.</span></span> <span data-ttu-id="2884e-418">以動態方式使用在設計階段未知的字元定義的規則運算式中呼叫<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法是特別重要，以確保該規則運算式引擎會解譯個別字元做為常值而不是比為中繼字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-418">In a regular expression that is defined dynamically using characters that are not known at design time, calling the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method is particularly important to ensure that the regular expression engine interprets individual characters as literals rather than as metacharacters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-419">如果規則運算式模式包含數字符號 （#） 或常值空白字元，則必須逸出如果輸入的文字會剖析與<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>啟用的選項。</span><span class="sxs-lookup"><span data-stu-id="2884e-419">If a regular expression pattern includes either the number sign (#) or literal white-space characters, they must be escaped if input text is parsed with the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option enabled.</span></span>  
  
 <span data-ttu-id="2884e-420">雖然<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法會逸出直接開啟括號 ([])，並開啟括號 （{}） 字元，它不會逸出其對應的結尾字元 (] 和})。</span><span class="sxs-lookup"><span data-stu-id="2884e-420">While the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method escapes the straight opening bracket ([) and opening brace ({) characters, it does not escape their corresponding closing characters (] and }).</span></span> <span data-ttu-id="2884e-421">在大部分情況下，逸出這些不需要。</span><span class="sxs-lookup"><span data-stu-id="2884e-421">In most cases, escaping these is not necessary.</span></span> <span data-ttu-id="2884e-422">如果右括號或大括號前面並沒有其對應的開頭字元，規則運算式引擎會將它解譯常值。</span><span class="sxs-lookup"><span data-stu-id="2884e-422">If a closing bracket or brace is not preceded by its corresponding opening character, the regular expression engine interprets it literally.</span></span> <span data-ttu-id="2884e-423">如果開啟 braket 或大括號會解譯為中繼字元中，規則運算式引擎會解譯第一個對應的結尾字元做為中繼字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-423">If an opening braket or brace is interpreted as a metacharacter, the regular expression engine interprets the first corresponding closing character as a metacharacter.</span></span> <span data-ttu-id="2884e-424">如果不想要的行為，右括號或大括號應該逸出明確前面加上反斜線 (\\) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-424">If this is not the desired behavior, the closing bracket or brace should be escaped by explicitly prepending the backslash (\\) character.</span></span> <span data-ttu-id="2884e-425">如需圖例，請參閱 < 範例 > 一節。</span><span class="sxs-lookup"><span data-stu-id="2884e-425">For an illustration, see the Example section.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-426">下列範例會從文字擷取註解。</span><span class="sxs-lookup"><span data-stu-id="2884e-426">The following example extracts comments from text.</span></span> <span data-ttu-id="2884e-427">它會假設註解以開始註解符號並選取使用者結束註解符號分隔。</span><span class="sxs-lookup"><span data-stu-id="2884e-427">It assumes that the comments are delimited by a begin comment symbol and an end comment symbol that is selected by the user.</span></span> <span data-ttu-id="2884e-428">註解符號要解譯為常值，因為它們會傳遞至<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法，以確保，它們無法被錯誤解譯為中繼字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-428">Because the comment symbols are to be interpreted literally, they are passed to the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method to ensure that they cannot be misinterpreted as metacharacters.</span></span> <span data-ttu-id="2884e-429">此外，範例明確檢查使用者輸入的結尾註解符號是右括號 (]) 或大括號 （}）。</span><span class="sxs-lookup"><span data-stu-id="2884e-429">In addition, the example explicitly checks whether the end comment symbol entered by the user is a closing bracket (]) or brace (}).</span></span> <span data-ttu-id="2884e-430">如果是，反斜線字元 (\\) 前面加上括號或大括號，因此它解譯為常值。</span><span class="sxs-lookup"><span data-stu-id="2884e-430">If it is, a backslash character (\\) is prepended to the bracket or brace so that it is interpreted literally.</span></span> <span data-ttu-id="2884e-431">請注意，此範例也會使用<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>顯示註解，而不是其開頭和結尾的註解符號以及註解的集合。</span><span class="sxs-lookup"><span data-stu-id="2884e-431">Note that the example also uses the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> collection to display the comment only, rather than the comment together with its opening and closing comment symbols.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-432">
            <paramref name="str" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-432">
              <paramref name="str" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-433">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-433">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-434">傳回規則運算式的擷取群組名稱的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-434">Returns an array of capturing group names for the regular expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-435">群組名稱的字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-435">A string array of group names.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-436">群組名稱的集合包含一組用來在運算式中的擷取群組命名的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-436">The collection of group names contains the set of strings used to name capturing groups in the expression.</span></span> <span data-ttu-id="2884e-437">即使沒有明確命名的擷取群組，它們會自動指派數值名稱 （"0"、"1"、"2"、"3"，等等）。</span><span class="sxs-lookup"><span data-stu-id="2884e-437">Even if capturing groups are not explicitly named, they are automatically assigned numerical names ("0", "1", "2", "3", and so on).</span></span> <span data-ttu-id="2884e-438">"0"具名群組代表規則運算式模式所比對的所有文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-438">The "0" named group represents all text matched by the regular expression pattern.</span></span> <span data-ttu-id="2884e-439">編號的群組的前面明確具名的群組是在集合中，而具名的群組會出現在規則運算式模式中定義的順序。</span><span class="sxs-lookup"><span data-stu-id="2884e-439">Numbered groups precede explicitly named groups in the collection, and named groups appear in the order in which they are defined in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="2884e-440">您可以使用<xref:System.Array.Length%2A>屬性在這個方法來判斷規則運算式中的群組數目所傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-440">You can use the <xref:System.Array.Length%2A> property on the array returned by this method to determine the number of groups in a regular expression.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-441">下列範例會定義一般用途`ShowMatches`方法，以顯示群組的名稱的規則運算式，其相符的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-441">The following example defines a general-purpose `ShowMatches` method that displays the names of regular expression groups and their matched text.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 <span data-ttu-id="2884e-442">在此情況下，規則運算式模式`\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})`旨在剖析簡單的句子，並識別其第一個字，最後一個字，並結束的標點符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-442">In this case, the regular expression pattern `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` is intended to parse a simple sentence, and to identify its first word, last word, and ending punctuation mark.</span></span> <span data-ttu-id="2884e-443">下表顯示規則運算式模式的解譯方式：</span><span class="sxs-lookup"><span data-stu-id="2884e-443">The following table shows how the regular expression pattern is interpreted:</span></span>  
  
|<span data-ttu-id="2884e-444">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-444">Pattern</span></span>|<span data-ttu-id="2884e-445">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-445">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-446">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-446">Begin the match at a word boundary.</span></span>|  
|`(?<FirstWord>\w+)`|<span data-ttu-id="2884e-447">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-447">Match one or more word characters.</span></span> <span data-ttu-id="2884e-448">這是`FirstWord`具名群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-448">This is the `FirstWord` named group.</span></span>|  
|<span data-ttu-id="2884e-449">\s？</span><span class="sxs-lookup"><span data-stu-id="2884e-449">\s?</span></span>|<span data-ttu-id="2884e-450">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-450">Match zero or one white-space characters.</span></span>|  
|<span data-ttu-id="2884e-451">(\w+)</span><span class="sxs-lookup"><span data-stu-id="2884e-451">(\w+)</span></span>|<span data-ttu-id="2884e-452">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-452">Match one or more word characters.</span></span> <span data-ttu-id="2884e-453">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-453">This is the second capturing group.</span></span>|  
|<span data-ttu-id="2884e-454">\s</span><span class="sxs-lookup"><span data-stu-id="2884e-454">\s</span></span>|<span data-ttu-id="2884e-455">比對空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-455">Match a white-space character.</span></span>|  
|<span data-ttu-id="2884e-456">((\w+)\s)\*</span><span class="sxs-lookup"><span data-stu-id="2884e-456">((\w+)\s)\*</span></span>|<span data-ttu-id="2884e-457">比對一或多個文字字元後面接著空白字元的零或多個發生次數。</span><span class="sxs-lookup"><span data-stu-id="2884e-457">Match zero or more occurrences of one or more word characters followed by a white space.</span></span> <span data-ttu-id="2884e-458">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-458">This is the first capturing group.</span></span>|  
|<span data-ttu-id="2884e-459">(?\<LastWord > \w+)？</span><span class="sxs-lookup"><span data-stu-id="2884e-459">(?\<LastWord>\w+)?</span></span>|<span data-ttu-id="2884e-460">比對零個或一個出現的一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-460">Match zero or one occurrence of one or more word characters.</span></span> <span data-ttu-id="2884e-461">這是`LastWord`具名群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-461">This is the `LastWord` named group.</span></span>|  
|<span data-ttu-id="2884e-462">(?\<標點符號 > \p{Po})</span><span class="sxs-lookup"><span data-stu-id="2884e-462">(?\<Punctuation>\p{Po})</span></span>|<span data-ttu-id="2884e-463">比對的字元的 Unicode 分類為標點符號，其他。</span><span class="sxs-lookup"><span data-stu-id="2884e-463">Match a character whose Unicode category is Punctuation, Other.</span></span> <span data-ttu-id="2884e-464">這是`Punctuation`具名群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-464">This is the `Punctuation` named group.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-465">傳回對應陣列中群組名稱的擷取群組編號的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-465">Returns an array of capturing group numbers that correspond to group names in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-466">群組編號的整數陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-466">An integer array of group numbers.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-467">未具名和具名擷取群組可以存取數字。</span><span class="sxs-lookup"><span data-stu-id="2884e-467">Both unnamed and named capturing groups can be accessed by number.</span></span> <span data-ttu-id="2884e-468">未具名的群組是從左到 1 開始由左至右編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-468">Unnamed groups are numbered from left to right starting with 1.</span></span> <span data-ttu-id="2884e-469">（索引 0 （零） 中的擷取群組會代表比對整個）。具名的群組則從左編號開始由左至右的數字大一比數目未具名擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-469">(The capturing group in index 0 (zero) represents the match as a whole.)  Named groups are then numbered from left to right starting with a number that is one greater than the number of unnamed capturing groups.</span></span>  
  
 <span data-ttu-id="2884e-470">依字串名稱參考它的號碼，而不是由群組可以提供更快速的存取。</span><span class="sxs-lookup"><span data-stu-id="2884e-470">Referencing a group by its number instead of by string name can provide faster access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-471">下列範例會定義規則運算式， `\b((?<word>\w+)\s*)+(?<end>[.?!])`，會比對的句子。</span><span class="sxs-lookup"><span data-stu-id="2884e-471">The following example defines a regular expression, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, that matches a sentence.</span></span> <span data-ttu-id="2884e-472">規則運算式包含三個擷取群組： 擷取個別的字，以及空格字元可能會在它後面; 未命名的群組群組名稱`word`，會擷取在句子; 中的個別文字，並群組命名為`end`，捕捉結尾的句子的標點符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-472">The regular expression includes three capturing groups: an unnamed group that captures an individual word along with a space character that may follow it; a group named `word` that captures the individual words in the sentence; and a group named `end` that captures the punctuation that ends the sentence.</span></span> <span data-ttu-id="2884e-473">此範例會呼叫<xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A>方法來取得所有擷取的數字分組，並接著會顯示其擷取的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-473">The example calls the <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> method to get the numbers of all capturing groups, and then displays their captured string.</span></span> <span data-ttu-id="2884e-474">颾魤 ㄛ<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法用來指出特定編號的群組是否對應至具名的群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-474">In addition, the <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> method is used to indicate whether a particular numbered group corresponds to a named group.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 <span data-ttu-id="2884e-475">規則運算式模式的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-475">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-476">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-476">Pattern</span></span>|<span data-ttu-id="2884e-477">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-477">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-478">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-478">Begin the match at a word boundary.</span></span>|  
|`(?<word>\w+)`|<span data-ttu-id="2884e-479">比對一或多個文字字元，並將相符的字串指派給群組，名為`word`。</span><span class="sxs-lookup"><span data-stu-id="2884e-479">Match one or more word characters and assign the matched strings to a group named `word`.</span></span>|  
|`\s*`|<span data-ttu-id="2884e-480">比對零個以上的空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-480">Match zero or more white-space characters.</span></span>|  
|`((?<word>\w+)\s*)`|<span data-ttu-id="2884e-481">指派`word`後面接著任何的擷取的群組所擷取的第一個擷取群組的空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-481">Assign the `word` captured group followed by any captured white-space characters to the first captured group.</span></span>|  
|`((?<word>\w+)\s*)+`|<span data-ttu-id="2884e-482">比對後面接著任何泛空白字元一或多次的一或多個文字字元的模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-482">Match the pattern of one or more word characters followed by any white-space characters one or more times.</span></span>|  
|`(?<end>[.?!])`|<span data-ttu-id="2884e-483">比對句號、問號或驚嘆號。</span><span class="sxs-lookup"><span data-stu-id="2884e-483">Match a period, question mark, or exclamation point.</span></span> <span data-ttu-id="2884e-484">指派要比對的字元`end`擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-484">Assign the matched character to the `end` capturing group.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">
          <span data-ttu-id="2884e-485">要轉換至對應群組名稱的群組編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-485">The group number to convert to the corresponding group name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-486">取得對應指定群組編號的群組名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-486">Gets the group name that corresponds to the specified group number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-487">字串，含有與指定群組編號相關聯的群組名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-487">A string that contains the group name associated with the specified group number.</span>
          </span>
          <span data-ttu-id="2884e-488">如果沒有對應 <paramref name="i" /> 的群組名稱，方法會傳回 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-488">If there is no group name that corresponds to <paramref name="i" />, the method returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-489">規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-489">A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</span></span> <span data-ttu-id="2884e-490">編號的群組會分隔語法 (*subexpression*)，系統會指派數字，根據在規則運算式中的順序。</span><span class="sxs-lookup"><span data-stu-id="2884e-490">Numbered groups are delimited by the syntax (*subexpression*) and are assigned numbers based on their order in the regular expression.</span></span> <span data-ttu-id="2884e-491">具名的群組語法分隔 (？`<`*名稱*`>`*subexpression*) 或 (？ '*名稱*'*subexpression*)，其中*名稱*是子運算式會識別的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-491">Named groups are delimited by the syntax (?`<`*name*`>`*subexpression*) or (?'*name*'*subexpression*), where *name* is the name by which the subexpression will be identified.</span></span> <span data-ttu-id="2884e-492">(如需詳細資訊，請參閱[群組建構](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。)<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法識別命名的群組和編號的群組，由其規則運算式中的序數位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-492">(For more information, see [Grouping Constructs](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) The <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</span></span> <span data-ttu-id="2884e-493">序數位置 0 一律代表整個規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-493">Ordinal position zero always represents the entire regular expression.</span></span> <span data-ttu-id="2884e-494">所有已編號群組都會計算在內具名群組，不論它們在規則運算式模式中的實際位置之前。</span><span class="sxs-lookup"><span data-stu-id="2884e-494">All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="2884e-495">如果`i`是數字的具名群組，方法會傳回群組的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-495">If `i` is the number of a named group, the method returns the name of the group.</span></span> <span data-ttu-id="2884e-496">如果`i`是數字的未命名的群組，方法會傳回數字的字串表示。</span><span class="sxs-lookup"><span data-stu-id="2884e-496">If `i` is the number of an unnamed group, the method returns the string representation of the number.</span></span> <span data-ttu-id="2884e-497">例如，如果`i`為 1，則方法會傳回"1"。</span><span class="sxs-lookup"><span data-stu-id="2884e-497">For example, if `i` is 1, the method returns "1".</span></span> <span data-ttu-id="2884e-498">如果`i`不是數字的擷取群組，此方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-498">If `i` is not the number of a capturing group, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-499">如果找到模式比對，則這個方法所傳回的值然後用來擷取<xref:System.Text.RegularExpressions.Group>物件，表示從擷取的群組<xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-499">If a pattern match is found, the value returned by this method can then be used to retrieve the <xref:System.Text.RegularExpressions.Group> object that represents the captured group from the <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2884e-500"><xref:System.Text.RegularExpressions.GroupCollection>物件由<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-500">The <xref:System.Text.RegularExpressions.GroupCollection> object is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-501">下列範例會定義符合包含美國城市名稱、 狀態名稱和郵遞區號地址的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-501">The following example defines a regular expression pattern that matches an address line containing a U.S. city name, state name, and zip code.</span></span> <span data-ttu-id="2884e-502">此範例會使用<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法來擷取的擷取群組的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-502">The example uses the <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> method to retrieve the names of capturing groups.</span></span> <span data-ttu-id="2884e-503">然後會使用這些名稱擷取對應的擷取的群組相符的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-503">It then uses these names to retrieve the corresponding captured groups for matches.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 <span data-ttu-id="2884e-504">下列的運算式所定義的規則運算式模式：</span><span class="sxs-lookup"><span data-stu-id="2884e-504">The regular expression pattern is defined by the following expression:</span></span>  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 <span data-ttu-id="2884e-505">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-505">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-506">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-506">Pattern</span></span>|<span data-ttu-id="2884e-507">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-507">Description</span></span>|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|<span data-ttu-id="2884e-508">比對一或多個字母或空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-508">Match one or more alphabetic or white-space character.</span></span> <span data-ttu-id="2884e-509">將這個擷取的群組名稱的指派`city`。</span><span class="sxs-lookup"><span data-stu-id="2884e-509">Assign this captured group the name `city`.</span></span>|  
|`,`|<span data-ttu-id="2884e-510">比對後面接著空白字元的逗號 （，）。</span><span class="sxs-lookup"><span data-stu-id="2884e-510">Match a comma (,) followed by a white-space character.</span></span>|  
|`(?<state>[A-Za-z]{2})`|<span data-ttu-id="2884e-511">比對兩個字母的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-511">Match two alphabetic characters.</span></span> <span data-ttu-id="2884e-512">將這個擷取的群組名稱的指派`state`。</span><span class="sxs-lookup"><span data-stu-id="2884e-512">Assign this captured group the name `state`.</span></span> <span data-ttu-id="2884e-513">此群組必須緊接著空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-513">This group should be followed by a white-space character.</span></span>|  
|`(?<zip>\d{5}(-\d{4})?)`|<span data-ttu-id="2884e-514">比對後面接著連字號後面接著四個數字的零個或一個出現的五個字。</span><span class="sxs-lookup"><span data-stu-id="2884e-514">Match five numeric digits followed by either zero or one occurrence of a hyphen followed by four digits.</span></span> <span data-ttu-id="2884e-515">將這個擷取的群組名稱的指派`zip`。</span><span class="sxs-lookup"><span data-stu-id="2884e-515">Assign this captured group the name `zip`.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2884e-516">群組名稱，要轉換至對應群組編號的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-516">The group name to convert to the corresponding group number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-517">傳回對應指定群組名稱的群組編號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-517">Returns the group number that corresponds to the specified group name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-518">對應指定群組名稱的群組編號；如果 <paramref name="name" /> 不是有效的群組名稱，則為 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-518">The group number that corresponds to the specified group name, or -1 if <paramref name="name" /> is not a valid group name.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-519">規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-519">A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</span></span> <span data-ttu-id="2884e-520">編號的群組會分隔語法 (*subexpression*)，系統會指派數字，根據在規則運算式中的順序。</span><span class="sxs-lookup"><span data-stu-id="2884e-520">Numbered groups are delimited by the syntax (*subexpression*) and are assigned numbers based on their order in the regular expression.</span></span> <span data-ttu-id="2884e-521">具名的群組語法分隔 (？`<`*名稱*`>`*subexpression*) 或 (？ '*名稱*'*subexpression*)，其中*名稱*是子運算式會識別的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-521">Named groups are delimited by the syntax (?`<`*name*`>`*subexpression*) or (?'*name*'*subexpression*), where *name* is the name by which the subexpression will be identified.</span></span> <span data-ttu-id="2884e-522">(如需詳細資訊，請參閱[群組建構](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。)<xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A>方法識別命名的群組和編號的群組，由其規則運算式中的序數位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-522">(For more information, see [Grouping Constructs](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) The <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</span></span> <span data-ttu-id="2884e-523">序數位置 0 一律代表整個規則運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-523">Ordinal position zero always represents the entire regular expression.</span></span> <span data-ttu-id="2884e-524">所有已編號群組都會計算在內具名群組，不論它們在規則運算式模式中的實際位置之前。</span><span class="sxs-lookup"><span data-stu-id="2884e-524">All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="2884e-525">如果`name`出現在規則運算式模式中，此方法將傳回的數字的群組編號的字串表示法。</span><span class="sxs-lookup"><span data-stu-id="2884e-525">If `name` is the string representation of a group number that is present in the regular expression pattern, the method returns that number.</span></span> <span data-ttu-id="2884e-526">如果`name`對應具名擷取群組會出現在規則運算式模式，此方法會傳回其對應的數字。</span><span class="sxs-lookup"><span data-stu-id="2884e-526">If `name` corresponds to a named capturing group that is present in the regular expression pattern, the method returns its corresponding number.</span></span> <span data-ttu-id="2884e-527">比較`name`與群組名稱會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="2884e-527">The comparison of `name` with the group name is case-sensitive.</span></span> <span data-ttu-id="2884e-528">如果`name`未對應至擷取群組的名稱或數目的擷取群組，此方法的字串表示法傳回-1。</span><span class="sxs-lookup"><span data-stu-id="2884e-528">If `name` does not correspond to the name of a capturing group or to the string representation of the number of a capturing group, the method returns -1.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-529">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-529">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-530">指定模式比對作業不應逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-530">Specifies that a pattern-matching operation should not time out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-531"><xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>類別建構函式和靜態比對的方法使用一些<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常數，表示嘗試尋找模式比對應該逾時。</span><span class="sxs-lookup"><span data-stu-id="2884e-531">The <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> class constructor and a number of static matching methods use the <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constant to indicate that the attempt to find a pattern match should not time out.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="2884e-532">將規則運算式引擎的逾時值設定為<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>可能會造成規則運算式依賴大量回溯，才會出現停止回應時處理幾乎符合規則運算式模式的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-532">Setting the regular expression engine's time-out value to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> can cause regular expressions that rely on excessive backtracking to appear to stop responding when processing text that nearly matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-533">如果您停用逾時，您應該確定您的規則運算式不需要大量使用回溯和它處理幾乎符合規則運算式模式的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-533">If you disable time-outs, you should ensure that your regular expression does not rely on excessive backtracking and that it handles text that nearly matches the regular expression pattern.</span></span>  
>   
>  <span data-ttu-id="2884e-534">如需有關處理回溯的詳細資訊，請參閱[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-534">For more information about handling backtracking, see [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
 <span data-ttu-id="2884e-535"><xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常數可以提供的值為`matchTimeout`下列成員的引數：</span><span class="sxs-lookup"><span data-stu-id="2884e-535">The <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constant can be supplied as the value of the `matchTimeout` argument of the following members:</span></span>  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-536">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-536">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2884e-537">參考已初始化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-537">References have already been initialized.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-538">在作業逾時之前可在模式比對作業中流逝的最長時間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-538">The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-539">指示規則運算式是否在輸入字串中尋找比對。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-539">Indicates whether the regular expression finds a match in the input string.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-540">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-540">The string to search for a match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-541">表示 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式是否要在指定的輸入字串中尋找相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-541">Indicates whether the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor finds a match in a specified input string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-542">如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-542">
              <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-543"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-543">The <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</span></span> <span data-ttu-id="2884e-544">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-544">If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <xref:System.Text.RegularExpressions.Regex.Match%2A> or <xref:System.Text.RegularExpressions.Regex.Matches%2A> method.</span></span>  
  
 <span data-ttu-id="2884e-545">如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-545">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-546">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-546">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-547">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-547">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-548">下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>方法來判斷字串是否為有效的組件數目。</span><span class="sxs-lookup"><span data-stu-id="2884e-548">The following example illustrates the use of the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> method to determine whether a string is a valid part number.</span></span> <span data-ttu-id="2884e-549">規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-549">The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</span></span> <span data-ttu-id="2884e-550">第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-550">The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</span></span> <span data-ttu-id="2884e-551">第二個集合，其中包含三個字元，必須為數值。</span><span class="sxs-lookup"><span data-stu-id="2884e-551">The second set, which consists of three characters, must be numeric.</span></span> <span data-ttu-id="2884e-552">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-552">The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 <span data-ttu-id="2884e-553">規則運算式模式為：</span><span class="sxs-lookup"><span data-stu-id="2884e-553">The regular expression pattern is:</span></span>  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 <span data-ttu-id="2884e-554">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-554">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-555">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-555">Pattern</span></span>|<span data-ttu-id="2884e-556">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-556">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2884e-557">開始在一行的開頭比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-557">Begin the match at the beginning of the line.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-558">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-558">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`\d{2}`|<span data-ttu-id="2884e-559">比對兩個數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-559">Match two numeric characters.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-560">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-560">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`-`|<span data-ttu-id="2884e-561">比對連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-561">Match a hyphen.</span></span>|  
|`\d{3}`|<span data-ttu-id="2884e-562">比對剛好三個數值字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-562">Match exactly three numeric characters.</span></span>|  
|`(-\d{3}){2}`|<span data-ttu-id="2884e-563">尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-563">Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-564">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-564">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`$`|<span data-ttu-id="2884e-565">結束比對一行的結尾。</span><span class="sxs-lookup"><span data-stu-id="2884e-565">End the match at the end of the line.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-566">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-566">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-567">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-567">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-568">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-568">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-569">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-569">The string to search for a match.</span>
          </span>
        </param>
        <param name="startat">
          <span data-ttu-id="2884e-570">要開始搜尋的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-570">The character position at which to start the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-571">表示 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中所指定的規則運算式，是否要從字串中指定的起始位置開始，在指定的輸入字串中尋找相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-571">Indicates whether the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-572">如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-572">
              <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-573"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-573">The <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</span></span> <span data-ttu-id="2884e-574">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-574">If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <xref:System.Text.RegularExpressions.Regex.Match%2A> or <xref:System.Text.RegularExpressions.Regex.Matches%2A> method.</span></span>  
  
 <span data-ttu-id="2884e-575">如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-575">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-576">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-576">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-577">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-577">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-578">下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法來判斷字串是否為有效的組件數目。</span><span class="sxs-lookup"><span data-stu-id="2884e-578">The following example illustrates the use of the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> method to determine whether a string is a valid part number.</span></span> <span data-ttu-id="2884e-579">它會搜尋後面的冒號 （:） 字元在字串中的零件編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-579">It searches for a part number that follows a colon (:) character in a string.</span></span> <span data-ttu-id="2884e-580"><xref:System.String.IndexOf%28System.Char%29>方法來判別的冒號字元，然後傳遞至位置<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-580">The <xref:System.String.IndexOf%28System.Char%29> method is used to determine the position of the colon character, which is then passed to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="2884e-581">規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-581">The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</span></span> <span data-ttu-id="2884e-582">第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-582">The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</span></span> <span data-ttu-id="2884e-583">第二個集合，其中包含三個字元，必須為數值。</span><span class="sxs-lookup"><span data-stu-id="2884e-583">The second set, which consists of three characters, must be numeric.</span></span> <span data-ttu-id="2884e-584">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-584">The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 <span data-ttu-id="2884e-585">規則運算式模式為：</span><span class="sxs-lookup"><span data-stu-id="2884e-585">The regular expression pattern is:</span></span>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 <span data-ttu-id="2884e-586">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-586">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-587">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-587">Pattern</span></span>|<span data-ttu-id="2884e-588">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-588">Description</span></span>|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-589">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-589">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`\d{2}`|<span data-ttu-id="2884e-590">比對兩個數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-590">Match two numeric characters.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-591">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-591">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`-`|<span data-ttu-id="2884e-592">比對連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-592">Match a hyphen.</span></span>|  
|`\d{3}`|<span data-ttu-id="2884e-593">比對剛好三個數值字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-593">Match exactly three numeric characters.</span></span>|  
|`(-\d{3}){2}`|<span data-ttu-id="2884e-594">尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-594">Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-595">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-595">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`$`|<span data-ttu-id="2884e-596">結束比對一行的結尾。</span><span class="sxs-lookup"><span data-stu-id="2884e-596">End the match at the end of the line.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-597">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-597">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-598">
            <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-598">
              <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-599">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-599">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-600">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-600">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-601">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-601">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-602">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-602">The regular expression pattern to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-603">表示指定的規則運算式是否在指定的輸入字串中尋找相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-603">Indicates whether the specified regular expression finds a match in the specified input string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-604">如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-604">
              <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-605"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-605">The <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</span></span> <span data-ttu-id="2884e-606">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-606">If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <xref:System.Text.RegularExpressions.Regex.Match%2A> or <xref:System.Text.RegularExpressions.Regex.Matches%2A> method.</span></span>  
  
 <span data-ttu-id="2884e-607">靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>所指定的規則運算式模式的物件`pattern`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-607">The static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> method is equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the regular expression pattern specified by `pattern` and calling the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instance method.</span></span> <span data-ttu-id="2884e-608">這個規則運算式模式的規則運算式引擎會快取供快速擷取。</span><span class="sxs-lookup"><span data-stu-id="2884e-608">This regular expression pattern is cached for rapid retrieval by the regular expression engine.</span></span>  
  
 <span data-ttu-id="2884e-609">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-609">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-610">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-610">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-611">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-611">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-612">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-612">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-613">下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法來判斷字串是否為有效的組件數目。</span><span class="sxs-lookup"><span data-stu-id="2884e-613">The following example illustrates the use of the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> method to determine whether a string is a valid part number.</span></span> <span data-ttu-id="2884e-614">規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-614">The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</span></span> <span data-ttu-id="2884e-615">第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-615">The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</span></span> <span data-ttu-id="2884e-616">第二個集合，其中包含三個字元，必須為數值。</span><span class="sxs-lookup"><span data-stu-id="2884e-616">The second set, which consists of three characters, must be numeric.</span></span> <span data-ttu-id="2884e-617">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-617">The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 <span data-ttu-id="2884e-618">規則運算式模式為：</span><span class="sxs-lookup"><span data-stu-id="2884e-618">The regular expression pattern is:</span></span>  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 <span data-ttu-id="2884e-619">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-619">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-620">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-620">Pattern</span></span>|<span data-ttu-id="2884e-621">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-621">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2884e-622">開始在一行的開頭比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-622">Begin the match at the beginning of the line.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-623">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-623">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`\d{2}`|<span data-ttu-id="2884e-624">比對兩個數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-624">Match two numeric characters.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-625">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-625">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`-`|<span data-ttu-id="2884e-626">比對連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-626">Match a hyphen.</span></span>|  
|`\d{3}`|<span data-ttu-id="2884e-627">比對剛好三個數值字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-627">Match exactly three numeric characters.</span></span>|  
|`(-\d{3}){2}`|<span data-ttu-id="2884e-628">尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-628">Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</span></span>|  
|`[a-zA-Z0-9]`|<span data-ttu-id="2884e-629">比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-629">Match a single alphabetic character (`a` through `z` or `A` through `Z`) or numeric character.</span></span>|  
|`$`|<span data-ttu-id="2884e-630">結束比對一行的結尾。</span><span class="sxs-lookup"><span data-stu-id="2884e-630">End the match at the end of the line.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-631">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-631">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-632">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-632">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-633">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-633">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-634">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-634">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-635">
            <para>此方法等於呼叫該方法的應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，驗證模式比對是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-635">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for verifying a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-636">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-636">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-637">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-637">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-638">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-638">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-639">表示指定的規則運算式是否使用指定的比對選項，在指定的輸入字串中尋找相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-639">Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-640">如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-640">
              <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-641"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-641">The <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</span></span> <span data-ttu-id="2884e-642">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-642">If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <xref:System.Text.RegularExpressions.Regex.Match%2A> or <xref:System.Text.RegularExpressions.Regex.Matches%2A> method.</span></span>  
  
 <span data-ttu-id="2884e-643">靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>所指定的規則運算式模式的物件`pattern`及所指定的規則運算式選項`options`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-643">The static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method is equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the regular expression pattern specified by `pattern` and the regular expression options specified by `options` and calling the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instance method.</span></span> <span data-ttu-id="2884e-644">這個規則運算式模式的規則運算式引擎會快取供快速擷取。</span><span class="sxs-lookup"><span data-stu-id="2884e-644">This regular expression pattern is cached for rapid retrieval by the regular expression engine.</span></span>  
  
 <span data-ttu-id="2884e-645">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-645">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-646">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-646">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-647">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-647">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-648">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-648">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-649">下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法來判斷字串是否為有效的組件數目。</span><span class="sxs-lookup"><span data-stu-id="2884e-649">The following example illustrates the use of the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> method to determine whether a string is a valid part number.</span></span> <span data-ttu-id="2884e-650">規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-650">The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</span></span> <span data-ttu-id="2884e-651">第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-651">The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</span></span> <span data-ttu-id="2884e-652">第二個集合，其中包含三個字元，必須為數值。</span><span class="sxs-lookup"><span data-stu-id="2884e-652">The second set, which consists of three characters, must be numeric.</span></span> <span data-ttu-id="2884e-653">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-653">The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 <span data-ttu-id="2884e-654">規則運算式模式為：</span><span class="sxs-lookup"><span data-stu-id="2884e-654">The regular expression pattern is:</span></span>  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 <span data-ttu-id="2884e-655">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-655">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-656">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-656">Pattern</span></span>|<span data-ttu-id="2884e-657">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-657">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2884e-658">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-658">Begin the match at the beginning of the string.</span></span>|  
|`[A-Z0-9]`|<span data-ttu-id="2884e-659">比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-659">Match any single alphabetic character from `A` through `Z`, or any numeric character.</span></span>|  
|`\d{2}`|<span data-ttu-id="2884e-660">比對兩個數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-660">Match two numeric characters.</span></span>|  
|`[A-Z0-9]`|<span data-ttu-id="2884e-661">比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-661">Match any single alphabetic character from `A` through `Z`, or any numeric character.</span></span>|  
|`-`|<span data-ttu-id="2884e-662">比對連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-662">Match a hyphen.</span></span>|  
|`\d{3}`|<span data-ttu-id="2884e-663">比對剛好三個數值字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-663">Match exactly three numeric characters.</span></span>|  
|`(-\d{3}){2}`|<span data-ttu-id="2884e-664">尋找後面接著三個的數字字元、 連字號，並符合此模式的兩個項目...</span><span class="sxs-lookup"><span data-stu-id="2884e-664">Find a hyphen followed by three numeric characters, and match two occurrences of this pattern..</span></span>|  
|`[A-Z0-9]`|<span data-ttu-id="2884e-665">比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-665">Match any single alphabetic character from `A` through `Z`, or any numeric character.</span></span>|  
|`$`|<span data-ttu-id="2884e-666">在字串的結尾結束比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-666">End the match at the end of the string.</span></span>|  
  
 <span data-ttu-id="2884e-667">呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法`options`參數設為<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>就相當於定義下列規則運算式：</span><span class="sxs-lookup"><span data-stu-id="2884e-667">Calling the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> is equivalent to defining the following regular expression:</span></span>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 <span data-ttu-id="2884e-668">相較之下，請參閱範例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-668">For comparison, see the example for the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-669">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-669">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-670">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-670">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-671">
            <paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-671">
              <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-672">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-672">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-673">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-673">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-674">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，驗證模式比對是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-674">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for verifying a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-675">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-675">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-676">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-676">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-677">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-677">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-678">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-678">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-679">指出指定的規則運算式是否使用指定的比對選項和逾時間隔，在指定的輸入字串中尋找相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-679">Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-680">如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-680">
              <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-681"><xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-681">The <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</span></span> <span data-ttu-id="2884e-682">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-682">If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <xref:System.Text.RegularExpressions.Regex.Match%2A> or <xref:System.Text.RegularExpressions.Regex.Matches%2A> method.</span></span>  
  
 <span data-ttu-id="2884e-683">靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>所指定的規則運算式模式的物件`pattern`及所指定的規則運算式選項`options`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-683">The static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method is equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the regular expression pattern specified by `pattern` and the regular expression options specified by `options` and calling the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instance method.</span></span> <span data-ttu-id="2884e-684">這個規則運算式模式的規則運算式引擎會快取供快速擷取。</span><span class="sxs-lookup"><span data-stu-id="2884e-684">This regular expression pattern is cached for rapid retrieval by the regular expression engine.</span></span>  
  
 <span data-ttu-id="2884e-685">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-685">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-686">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-686">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-687">`matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。</span><span class="sxs-lookup"><span data-stu-id="2884e-687">The `matchTimeout` parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</span></span> <span data-ttu-id="2884e-688">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-688">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md) and [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-689">如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-689">If no match is found in that time interval, the method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-690">`matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-690">`matchTimeout` overrides any default time-out value defined for the application domain in which the method executes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-691">下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來判斷字串是否為有效的組件數目。</span><span class="sxs-lookup"><span data-stu-id="2884e-691">The following example illustrates the use of the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method to determine whether a string is a valid part number.</span></span> <span data-ttu-id="2884e-692">規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。</span><span class="sxs-lookup"><span data-stu-id="2884e-692">The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</span></span> <span data-ttu-id="2884e-693">第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-693">The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</span></span> <span data-ttu-id="2884e-694">第二個集合，其中包含三個字元，必須為數值。</span><span class="sxs-lookup"><span data-stu-id="2884e-694">The second set, which consists of three characters, must be numeric.</span></span> <span data-ttu-id="2884e-695">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-695">The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</span></span> <span data-ttu-id="2884e-696">比對規則運算式模式，應該牽涉到最少搜尋整個輸入字串中，因此方法設定 500 毫秒的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="2884e-696">Matching the regular expression pattern should involve minimal searching through the input string, so the method sets a time-out interval of 500 milliseconds.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 <span data-ttu-id="2884e-697">規則運算式模式為：</span><span class="sxs-lookup"><span data-stu-id="2884e-697">The regular expression pattern is:</span></span>  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 <span data-ttu-id="2884e-698">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-698">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-699">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-699">Pattern</span></span>|<span data-ttu-id="2884e-700">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-700">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2884e-701">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-701">Begin the match at the beginning of the string.</span></span>|  
|`[A-Z0-9]`|<span data-ttu-id="2884e-702">比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-702">Match any single alphabetic character from `A` through `Z`, or any numeric character.</span></span>|  
|`\d{2}`|<span data-ttu-id="2884e-703">比對兩個數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-703">Match two numeric characters.</span></span>|  
|`[A-Z0-9]`|<span data-ttu-id="2884e-704">比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-704">Match any single alphabetic character from `A` through `Z`, or any numeric character.</span></span>|  
|`-`|<span data-ttu-id="2884e-705">比對連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-705">Match a hyphen.</span></span>|  
|`\d{3}`|<span data-ttu-id="2884e-706">比對剛好三個數值字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-706">Match exactly three numeric characters.</span></span>|  
|`(-\d{3}){2}`|<span data-ttu-id="2884e-707">尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-707">Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</span></span>|  
|`[A-Z0-9]`|<span data-ttu-id="2884e-708">比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-708">Match any single alphabetic character from `A` through `Z`, or any numeric character.</span></span>|  
|`$`|<span data-ttu-id="2884e-709">在字串的結尾結束比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-709">End the match at the end of the string.</span></span>|  
  
 <span data-ttu-id="2884e-710">呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法`options`參數設為<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>就相當於定義下列規則運算式：</span><span class="sxs-lookup"><span data-stu-id="2884e-710">Calling the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> is equivalent to defining the following regular expression:</span></span>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 <span data-ttu-id="2884e-711">相較之下，請參閱範例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-711">For comparison, see the example for the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-712">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-712">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-713">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-713">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-714">
            <paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-714">
              <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.</span>
          </span>
          <span data-ttu-id="2884e-715">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-715">-or-</span>
          </span>
          <span data-ttu-id="2884e-716">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-716">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-717">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-717">A time-out occurred.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-718">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-718">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-719">在輸入字串搜尋規則運算式的項目，並傳回正確結果為單一 <see cref="T:System.Text.RegularExpressions.Match" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-719">Searches an input string for a substring that matches a regular expression pattern and returns the first occurrence as a single <see cref="T:System.Text.RegularExpressions.Match" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-720">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-720">The string to search for a match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-721">在指定的輸入字串中，搜尋符合 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中所指定規則運算式的第一個項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-721">Searches the specified input string for the first occurrence of the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-722">物件，包含符合之項目的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-722">An object that contains information about the match.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-723"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-723">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method returns the first substring that matches a regular expression pattern in an input string.</span></span> <span data-ttu-id="2884e-724">用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-724">For information about the language elements used to build a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-725">您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-725">You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Group.Success%2A> property.</span></span> <span data-ttu-id="2884e-726">如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-726">If a match is found, the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Capture.Value%2A> property contains the substring from `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-727">如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-727">If no match is found, its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-728">這個方法會傳回第一個子`input`符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-728">This method returns the first substring in `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-729">您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-729">You can retrieve subsequent matches by repeatedly calling the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2884e-730">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-730">You can also retrieve all matches in a single method call by calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2884e-731">如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-731">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-732">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-732">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-733">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-733">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-734">下列範例會尋找在字串中，符合規則運算式模式，然後列出相符群組、 擷取和擷取位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-734">The following example finds regular expression pattern matches in a string, then lists the matched groups, captures, and capture positions.</span></span>  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 <span data-ttu-id="2884e-735">規則運算式模式`(\w+)\s+(car)`比對以及字組前面的"car"這個字的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-735">The regular expression pattern `(\w+)\s+(car)` matches occurrences of the word "car" along with the word that precedes it.</span></span> <span data-ttu-id="2884e-736">它被解譯為下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-736">It is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-737">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-737">Pattern</span></span>|<span data-ttu-id="2884e-738">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-738">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="2884e-739">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-739">Match one or more word characters.</span></span> <span data-ttu-id="2884e-740">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-740">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="2884e-741">比對一或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-741">Match one or more white-space characters.</span></span>|  
|<span data-ttu-id="2884e-742">(car)</span><span class="sxs-lookup"><span data-stu-id="2884e-742">(car)</span></span>|<span data-ttu-id="2884e-743">比對常值字串"car"。</span><span class="sxs-lookup"><span data-stu-id="2884e-743">Match the literal string "car".</span></span> <span data-ttu-id="2884e-744">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-744">This is the second capturing group.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-745">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-745">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-746">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-746">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-747">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-747">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-748">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-748">The string to search for a match.</span>
          </span>
        </param>
        <param name="startat">
          <span data-ttu-id="2884e-749">要開始搜尋之以零為起始的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-749">The zero-based character position at which to start the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-750">從字串中指定的開始位置開始，在輸入字串中搜尋規則運算式的第一個相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-750">Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-751">物件，包含符合之項目的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-751">An object that contains information about the match.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-752"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法會傳回符合規則運算式模式，開始在或之後的第一個子字串`startat`字元輸入字串中的位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-752">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> method returns the first substring that matches a regular expression pattern, starting at or after the `startat` character position, in an input string.</span></span> <span data-ttu-id="2884e-753">用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-753">For information about the language elements used to build a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-754">規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-754">The regular expression pattern for which the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> method searches is defined by the call to one of the <xref:System.Text.RegularExpressions.Regex> class constructors.</span></span> <span data-ttu-id="2884e-755">如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-755">For more information about the elements that can form a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-756">您可以使用，以選擇性地指定字串中的起始位置`startat`參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-756">You can optionally specify a starting position in the string by using the `startat` parameter.</span></span> <span data-ttu-id="2884e-757">當規則運算式引擎會剖析從左到右 （預設值） 時，比對和掃描移動 rightward，開始中指定的字元`startat`。</span><span class="sxs-lookup"><span data-stu-id="2884e-757">When the regular expression engine parses from left to right (the default), the match and the scan move rightward, starting at the character specified in `startat`.</span></span> <span data-ttu-id="2884e-758">當規則運算式引擎會剖析從右到左 (規則運算式模式使用的建構時<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>選項)，比對和掃描的相反的方向移動和開頭處的字元`startat`-1。</span><span class="sxs-lookup"><span data-stu-id="2884e-758">When the regular expression engine parses from right to left (when the regular expression pattern is constructed with the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option), the match and scan move in the opposite direction and begin with the character at `startat` -1.</span></span> <span data-ttu-id="2884e-759">如果您未指定的開始位置，則會搜尋的預設值`startat`位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-759">If you do not specify a starting position, the search begins at the default `startat` position.</span></span> <span data-ttu-id="2884e-760">如果規則運算式搜尋從左到右，預設值`startat`位置位於左側`input`; 如果它會搜尋由右至左，預設值`startat`位置位於右端的`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-760">If the regular expression searches from left to right, the default `startat` position is at the left end of `input`; if it searches from right to left, the default `startat` position is at the right end of `input`.</span></span>  
  
 <span data-ttu-id="2884e-761">如果您想要限制相符項目，使它在字串中特定的字元位置開始，並比對規則運算式引擎不會掃描字串的其餘部分，錨定的為規則運算式`\G`（左邊的左到右模式中，或從右至左模式右邊)。</span><span class="sxs-lookup"><span data-stu-id="2884e-761">If you want to restrict a match so that it begins at a particular character position in the string and the regular expression engine does not scan the remainder of the string for a match, anchor the regular expression with a `\G` (at the left for a left-to-right pattern, or at the right for a right-to-left pattern).</span></span> <span data-ttu-id="2884e-762">這會限制比對，因此它必須剛好在啟動`startat`。</span><span class="sxs-lookup"><span data-stu-id="2884e-762">This restricts the match so it must start exactly at `startat`.</span></span>  
  
 <span data-ttu-id="2884e-763">您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-763">You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Group.Success%2A> property.</span></span> <span data-ttu-id="2884e-764">如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-764">If a match is found, the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Capture.Value%2A> property contains the substring from `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-765">如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-765">If no match is found, its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-766">這個方法會傳回找到在或之後的第一個子字串`startat`字元在位置`input`符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-766">This method returns the first substring found at or after the `startat` character position in `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-767">您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-767">You can retrieve subsequent matches by repeatedly calling the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2884e-768">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-768">You can also retrieve all matches in a single method call by calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2884e-769">如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-769">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-770">如果當您呼叫建構函式時，您不會設定逾時間隔，若作業 exeeds 所在的應用程式定義域建立任何逾時值，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex>建立物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-770">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exeeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-771">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-771">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-772">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-772">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-773">
            <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-773">
              <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-774">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-774">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-775">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-775">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-776">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-776">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-777">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-777">The regular expression pattern to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-778">在指定的輸入字串中搜尋所指定規則運算式的第一個相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-778">Searches the specified input string for the first occurrence of the specified regular expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-779">物件，包含符合之項目的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-779">An object that contains information about the match.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-780"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-780">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> method returns the first substring that matches a regular expression pattern in an input string.</span></span> <span data-ttu-id="2884e-781">用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-781">For information about the language elements used to build a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-782">靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-782">The static <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> method is equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method.</span></span> <span data-ttu-id="2884e-783">在此情況下，規則運算式引擎會快取規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-783">In this case, the regular expression engine caches the regular expression pattern.</span></span>  
  
 <span data-ttu-id="2884e-784">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-784">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-785">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-785">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-786">您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-786">You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Group.Success%2A> property.</span></span> <span data-ttu-id="2884e-787">如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-787">If a match is found, the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Capture.Value%2A> property contains the substring from `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-788">如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-788">If no match is found, its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-789">這個方法會傳回第一個子`input`符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-789">This method returns the first substring in `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-790">您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-790">You can retrieve subsequent matches by repeatedly calling the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2884e-791">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-791">You can also retrieve all matches in a single method call by calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2884e-792">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-792">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-793">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-793">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-794">下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法來尋找包含至少一個的第一個單字`z`字元，然後再呼叫<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法來尋找任何其他的相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-794">The following example calls the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> method to find the first word that contains at least one `z` character, and then calls the <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method to find any additional matches.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 <span data-ttu-id="2884e-795">規則運算式模式 `\b\w*z+\w*\b` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-795">The regular expression pattern `\b\w*z+\w*\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-796">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-796">Pattern</span></span>|<span data-ttu-id="2884e-797">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-797">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-798">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-798">Begin the match at a word boundary.</span></span>|  
|`\w*`|<span data-ttu-id="2884e-799">比對零個、 一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-799">Match zero, one, or more word characters.</span></span>|  
|`z+`|<span data-ttu-id="2884e-800">比對的一或多個相符項目`z`字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-800">Match one or more occurrences of the `z` character.</span></span>|  
|`\w*`|<span data-ttu-id="2884e-801">比對零個、 一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-801">Match zero, one, or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="2884e-802">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-802">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-803">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-803">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-804">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-804">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-805">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-805">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-806">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-806">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-807">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法來擷取模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-807">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for retrieving a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-808">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-808">The string to search for a match.</span>
          </span>
        </param>
        <param name="beginning">
          <span data-ttu-id="2884e-809">定義要搜尋的最左邊位置的輸入字串中以零為起始的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-809">The zero-based character position in the input string that defines the leftmost position to be searched.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="2884e-810">子字串中要包含在搜尋中的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-810">The number of characters in the substring to include in the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-811">從指定的開始位置開始並且僅搜尋指定數目的字元，在輸入字串中搜尋規則運算式的第一個相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-811">Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-812">物件，包含符合之項目的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-812">An object that contains information about the match.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-813"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會傳回第一個符合子字串的規則運算式模式中，輸入字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="2884e-813">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> method returns the first substring that matches a regular expression pattern in a portion of an input string.</span></span> <span data-ttu-id="2884e-814">用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-814">For information about the language elements used to build a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-815">規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-815">The regular expression pattern for which the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> method searches is defined by the call to one of the <xref:System.Text.RegularExpressions.Regex> class constructors.</span></span> <span data-ttu-id="2884e-816">如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-816">For more information about the elements that can form a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-817"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會搜尋的部份`input`所定義`beginning`和`length`規則運算式模式的參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-817">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> method searches the portion of `input` defined by the `beginning` and `length` parameters for the regular expression pattern.</span></span> <span data-ttu-id="2884e-818">`beginning` 一定會定義要包含在搜尋中，最左邊字元的索引和`length`定義要搜尋的字元數目上限。</span><span class="sxs-lookup"><span data-stu-id="2884e-818">`beginning` always defines the index of the leftmost character to include in the search, and `length` defines the maximum number of characters to search.</span></span> <span data-ttu-id="2884e-819">在一起，它們會定義搜尋範圍。</span><span class="sxs-lookup"><span data-stu-id="2884e-819">Together, they define the range of the search.</span></span> <span data-ttu-id="2884e-820">如果搜尋會從左到右 （預設值），規則運算式引擎會搜尋的索引處的字元`beginning`中的索引處的字元`beginning`  +  `length` – 1。</span><span class="sxs-lookup"><span data-stu-id="2884e-820">If the search proceeds from left to right (the default), the regular expression engine searches from the character at index `beginning` to the character at index `beginning` + `length` – 1.</span></span> <span data-ttu-id="2884e-821">如果規則運算式引擎使用具現化<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>選項，讓搜尋會由右至左，規則運算式引擎會搜尋的索引處的字元`beginning`  +  `length` – 1 到中的索引處的字元`beginning`。</span><span class="sxs-lookup"><span data-stu-id="2884e-821">If the regular expression engine was instantiated by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option so that the search proceeds from right to left, the regular expression engine searches from the character at index `beginning` + `length` – 1 to the character at index `beginning`.</span></span> <span data-ttu-id="2884e-822">這個方法會傳回此範圍內找到的第一個相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-822">This method returns the first match that it finds within this range.</span></span> <span data-ttu-id="2884e-823">您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-823">You can retrieve subsequent matches by repeatedly calling the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2884e-824">您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-824">You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Group.Success%2A> property.</span></span> <span data-ttu-id="2884e-825">如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-825">If a match is found, the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Capture.Value%2A> property contains the substring from `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-826">如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-826">If no match is found, its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-827">如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-827">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-828">如果您未設定逾時值，當您呼叫建構函式時，如果作業超過任何逾時值應用程式定義域中，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex>建立物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-828">If you do not set a time-out value when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-829">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-829">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-830">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-830">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-831">
            <paramref name="beginning" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-831">
              <paramref name="beginning" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
          <span data-ttu-id="2884e-832">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-832">-or-</span>
          </span>
          <span data-ttu-id="2884e-833">
            <paramref name="length" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-833">
              <paramref name="length" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
          <span data-ttu-id="2884e-834">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-834">-or-</span>
          </span>
          <span data-ttu-id="2884e-835">
            <paramref name="beginning" />
            <see langword="+" />
            <paramref name="length" />
            <see langword="–1" /> 識別 <paramref name="input" /> 範圍之外的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-835">
              <paramref name="beginning" />
              <see langword="+" />
              <paramref name="length" />
              <see langword="–1" /> identifies a position that is outside the range of <paramref name="input" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-836">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-836">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-837">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-837">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-838">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-838">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-839">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-839">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-840">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-840">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-841">使用指定的比對選項，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-841">Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-842">物件，包含符合之項目的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-842">An object that contains information about the match.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-843"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-843">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method returns the first substring that matches a regular expression pattern in an input string.</span></span> <span data-ttu-id="2884e-844">用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-844">For information about the language elements used to build a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-845">靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式和呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-845">The static <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method is equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructor and calling the instance <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method.</span></span>  
  
 <span data-ttu-id="2884e-846">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-846">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-847">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-847">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-848">您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-848">You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Group.Success%2A> property.</span></span> <span data-ttu-id="2884e-849">如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-849">If a match is found, the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Capture.Value%2A> property contains the substring from `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-850">如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-850">If no match is found, its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-851">這個方法會傳回第一個子字串中找到`input`符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-851">This method returns the first substring found in `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-852">您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-852">You can retrieve subsequent matches by repeatedly calling the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.NextMatch%2A> method.</span></span> <span data-ttu-id="2884e-853">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-853">You can also retrieve all matches in a single method call by calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2884e-854">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-854">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-855">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-855">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-856">下列範例會定義規則運算式比對文字開頭為字母"a"。</span><span class="sxs-lookup"><span data-stu-id="2884e-856">The following example defines a regular expression that matches words beginning with the letter "a".</span></span> <span data-ttu-id="2884e-857">它會使用<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>選項，以確保規則運算式會找出開頭的單字這兩個以大寫"a"和小寫"a"。</span><span class="sxs-lookup"><span data-stu-id="2884e-857">It uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option to ensure that the regular expression locates words beginning with both an uppercase "a" and a lowercase "a".</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 <span data-ttu-id="2884e-858">規則運算式模式 `\ba\w*\b` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-858">The regular expression pattern `\ba\w*\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-859">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-859">Pattern</span></span>|<span data-ttu-id="2884e-860">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-860">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-861">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-861">Begin the match at a word boundary.</span></span>|  
|`a`|<span data-ttu-id="2884e-862">比對字元"a"。</span><span class="sxs-lookup"><span data-stu-id="2884e-862">Match the character "a".</span></span>|  
|`\w*`|<span data-ttu-id="2884e-863">比對零個、 一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-863">Match zero, one, or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="2884e-864">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-864">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-865">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-865">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-866">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-866">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-867">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-867">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-868">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-868">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-869">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-869">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-870">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法來擷取模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-870">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for retrieving a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-871">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-871">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-872">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-872">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-873">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-873">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-874">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-874">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-875">使用指定的比對選項和逾時間隔，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-875">Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-876">物件，包含符合之項目的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-876">An object that contains information about the match.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-877"><xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-877">The <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method returns the first substring that matches a regular expression pattern in an input string.</span></span> <span data-ttu-id="2884e-878">用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-878">For information about the language elements used to build a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-879">靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式和呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-879">The static <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method is equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor and calling the instance <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method.</span></span>  
  
 <span data-ttu-id="2884e-880">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-880">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-881">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-881">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-882">您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-882">You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Group.Success%2A> property.</span></span> <span data-ttu-id="2884e-883">如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-883">If a match is found, the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Capture.Value%2A> property contains the substring from `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-884">如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-884">If no match is found, its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2884e-885">這個方法會傳回第一個子字串中找到`input`符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-885">This method returns the first substring found in `input` that matches the regular expression pattern.</span></span> <span data-ttu-id="2884e-886">您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-886">You can retrieve subsequent matches by repeatedly calling the returned <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.NextMatch%2A> method.</span></span> <span data-ttu-id="2884e-887">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-887">You can also retrieve all matches in a single method call by calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="2884e-888">`matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。</span><span class="sxs-lookup"><span data-stu-id="2884e-888">The `matchTimeout` parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</span></span> <span data-ttu-id="2884e-889">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-889">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md) and [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-890">如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-890">If no match is found in that time interval, the method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-891">`matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-891">`matchTimeout` overrides any default time-out value defined for the application domain in which the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-892">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-892">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-893">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-893">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-894">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-894">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
          <span data-ttu-id="2884e-895">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-895">-or-</span>
          </span>
          <span data-ttu-id="2884e-896">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-896">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-897">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-897">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-898">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-898">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-899">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-899">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-900">在輸入字串中搜尋規則運算式的所有項目，並傳回所有符合項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-900">Searches an input string for all occurrences of a regular expression and returns all the matches.</span>
          </span>
        </summary>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-901">
            <para>在比對嘗試藉由呼叫的重複當<see cref="Overload:System.Text.RegularExpressions.Regex.Matches" />方法，規則運算式引擎會提供空白比對特殊處理。通常，規則運算式引擎開始搜尋下一個相符項目，並完全先前比對停止的地方。不過之後在空白比對，, 規則運算式引擎前移一個字元之前嘗試下一個相符項目。此行為可確保規則運算式引擎將循序進行的字串。否則，在空白比對不會導致任何順向移動，因為下一個相符項目會在上一個相符項目完全相同的位置開始，而且它將會重複比對相同的空字串。在下列範例中，規則運算式模式<c>\*</c>搜尋零或多個出現字母"a"，"abaabb"的字串。此範例將示範，產生的輸出<see cref="T:System.Text.RegularExpressions.MatchCollection" />物件包含六個<see cref="T:System.Text.RegularExpressions.Match" />物件。第一的比對嘗試尋找第一個"a"。在完全其中第一個符合結束，第一次的 b; 之前的第二個相符項目啟動它會尋找"a"的零個項目，並傳回空字串。第三個相符項目不會開始完全第二個比對結束的位置，因為第二個相符項目會傳回空字串。相反地，它會更新版本中之後第一個"b", 開始一個字元。第三個相符項目尋找兩個"a"，並傳回"aa"。第四個比對嘗試開始位置的第三個相符項目之前已結束，第二個"b"，並傳回空字串。第五個比對嘗試一次前進一個字元，使其開始之前第三個"b"，並傳回空字串。第六個的相符項目開始之後最後一個"b"，並再次傳回空字串。 [！ 的程式碼 csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [！ 的程式碼 vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-901">
              <para>When a match attempt is repeated by calling the <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> method, the regular expression engine gives empty matches special treatment. Usually, the regular expression engine begins the search for the next match exactly where the previous match left off. However, after an empty match, the regular expression engine advances by one character before trying the next match. This behavior guarantees that the regular expression engine will progress through the string. Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.  In the following example, the regular expression pattern <c>a\*</c> searches for zero or more occurrences of the letter "a" in the string "abaabb". As the output from the example shows, the resulting <see cref="T:System.Text.RegularExpressions.MatchCollection" /> object contains six <see cref="T:System.Text.RegularExpressions.Match" /> objects. The first match attempt finds the first "a". The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string. The third match does not begin exactly where the second match ended, because the second match returned an empty string. Instead, it begins one character later, after the first "b". The third match finds two occurrences of "a" and returns "aa". The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string. The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string. The sixth match begins after the last "b" and returns an empty string again.  [!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-902">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-902">The string to search for a match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-903">在指定的輸入字串搜尋規則運算式的所有項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-903">Searches the specified input string for all occurrences of a regular expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-904">搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-904">A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search.</span>
          </span>
          <span data-ttu-id="2884e-905">如果找不到相符的項目，此方法會傳回空集合物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-905">If no matches are found, the method returns an empty collection object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-906"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="2884e-906">The <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> method is similar to the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method, except that it returns information about all the matches found in the input string, instead of a single match.</span></span> <span data-ttu-id="2884e-907">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="2884e-907">It is equivalent to the following code:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 <span data-ttu-id="2884e-908">集合包含唯一的相符項目，並終止於第一個不相符。</span><span class="sxs-lookup"><span data-stu-id="2884e-908">The collection includes only matches and terminates at the first non-match.</span></span>  
  
 <span data-ttu-id="2884e-909">規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-909">The regular expression pattern for which the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> method searches is defined by the call to one of the <xref:System.Text.RegularExpressions.Regex> class constructors.</span></span> <span data-ttu-id="2884e-910">如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-910">For more information about the elements that can form a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-911"><xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-911">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method uses lazy evaluation to populate the returned <xref:System.Text.RegularExpressions.MatchCollection> object.</span></span> <span data-ttu-id="2884e-912">存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。</span><span class="sxs-lookup"><span data-stu-id="2884e-912">Accessing members of this collection such as <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> causes the collection to be populated immediately.</span></span> <span data-ttu-id="2884e-913">若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next`</span><span class="sxs-lookup"><span data-stu-id="2884e-913">To take advantage of lazy evaluation, you should iterate the collection by using a construct such as `foreach` in C# and `For Each`…`Next`</span></span> <span data-ttu-id="2884e-914">在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="2884e-914">in Visual Basic.</span></span>  
  
 <span data-ttu-id="2884e-915">其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-915">Because of its lazy evaluation, calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> method does not throw a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-916">不過，在執行作業時會擲回例外狀況<xref:System.Text.RegularExpressions.MatchCollection>在這個方法所傳回的物件<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和比對的作業超過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="2884e-916">However, the exception is thrown when an operation is performed on the <xref:System.Text.RegularExpressions.MatchCollection> object returned by this method, if the <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> property is not <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and a matching operation exceeds the time-out interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-917">下列範例會使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法，以識別任何句子中的文字"es"結尾。</span><span class="sxs-lookup"><span data-stu-id="2884e-917">The following example uses the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> method to identify any words in a sentence that end in "es".</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 <span data-ttu-id="2884e-918">規則運算式模式 `\b\w+es\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-918">The regular expression pattern `\b\w+es\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-919">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-919">Pattern</span></span>|<span data-ttu-id="2884e-920">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-920">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-921">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-921">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="2884e-922">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-922">Match one or more word characters.</span></span>|  
|`es`|<span data-ttu-id="2884e-923">比對常值字串"es"。</span><span class="sxs-lookup"><span data-stu-id="2884e-923">Match the literal string "es".</span></span>|  
|`\b`|<span data-ttu-id="2884e-924">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-924">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-925">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-925">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-926">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-926">The string to search for a match.</span>
          </span>
        </param>
        <param name="startat">
          <span data-ttu-id="2884e-927">在輸入字串中開始搜尋的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-927">The character position in the input string at which to start the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-928">自字串中指定的開始位置開始，在指定的輸入字串搜尋規則運算式的所有項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-928">Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-929">搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-929">A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search.</span>
          </span>
          <span data-ttu-id="2884e-930">如果找不到相符的項目，此方法會傳回空集合物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-930">If no matches are found, the method returns an empty collection object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-931"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="2884e-931">The  <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> method is similar to the  <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> method, except that it returns information about all the matches found in the input string, instead of a single match.</span></span> <span data-ttu-id="2884e-932">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="2884e-932">It is equivalent to the following code:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 <span data-ttu-id="2884e-933">規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-933">The regular expression pattern for which the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> method searches is defined by the call to one of the <xref:System.Text.RegularExpressions.Regex> class constructors.</span></span> <span data-ttu-id="2884e-934">如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-934">For more information about the elements that can form a regular expression pattern, see [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-935"><xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-935">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method uses lazy evaluation to populate the returned <xref:System.Text.RegularExpressions.MatchCollection> object.</span></span> <span data-ttu-id="2884e-936">存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。</span><span class="sxs-lookup"><span data-stu-id="2884e-936">Accessing members of this collection such as <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> causes the collection to be populated immediately.</span></span> <span data-ttu-id="2884e-937">若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next`</span><span class="sxs-lookup"><span data-stu-id="2884e-937">To take advantage of lazy evaluation, you should iterate the collection by using a construct such as `foreach` in C# and `For Each`…`Next`</span></span> <span data-ttu-id="2884e-938">在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="2884e-938">in Visual Basic.</span></span>  
  
 <span data-ttu-id="2884e-939">其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-939">Because of its lazy evaluation, calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> method does not throw a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-940">不過，在執行作業時會擲回例外狀況<xref:System.Text.RegularExpressions.MatchCollection>在這個方法所傳回的物件<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和比對的作業超過逾時間隔...</span><span class="sxs-lookup"><span data-stu-id="2884e-940">However, the exception is thrown when an operation is performed on the <xref:System.Text.RegularExpressions.MatchCollection> object returned by this method, if the <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> property is not <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and a matching operation exceeds the time-out interval..</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-941">下列範例會使用<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法來尋找在句子結尾為"es"，然後再呼叫中的第一個字<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法，以找出以"es"結尾的任何其他文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-941">The following example uses the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method to find the first word in a sentence that ends in "es", and then calls the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> method to identify any additional words that end in "es".</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 <span data-ttu-id="2884e-942">規則運算式模式 `\b\w+es\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-942">The regular expression pattern `\b\w+es\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-943">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-943">Pattern</span></span>|<span data-ttu-id="2884e-944">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-944">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-945">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-945">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="2884e-946">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-946">Match one or more word characters.</span></span>|  
|`es`|<span data-ttu-id="2884e-947">比對常值字串"es"。</span><span class="sxs-lookup"><span data-stu-id="2884e-947">Match the literal string "es".</span></span>|  
|`\b`|<span data-ttu-id="2884e-948">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-948">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-949">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-949">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-950">
            <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-950">
              <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-951">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-951">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-952">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-952">The regular expression pattern to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-953">在指定的輸入字串搜尋所指定規則運算式的所有相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-953">Searches the specified input string for all occurrences of a specified regular expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-954">搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-954">A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search.</span>
          </span>
          <span data-ttu-id="2884e-955">如果找不到相符的項目，此方法會傳回空集合物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-955">If no matches are found, the method returns an empty collection object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-956"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="2884e-956">The <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> method is similar to the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> method, except that it returns information about all the matches found in the input string, instead of a single match.</span></span> <span data-ttu-id="2884e-957">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="2884e-957">It is equivalent to the following code:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 <span data-ttu-id="2884e-958">靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Matches`。</span><span class="sxs-lookup"><span data-stu-id="2884e-958">The static `Matches` methods are equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance method `Matches`.</span></span>  
  
 <span data-ttu-id="2884e-959">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-959">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-960">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-960">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-961"><xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-961">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method uses lazy evaluation to populate the returned <xref:System.Text.RegularExpressions.MatchCollection> object.</span></span> <span data-ttu-id="2884e-962">存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。</span><span class="sxs-lookup"><span data-stu-id="2884e-962">Accessing members of this collection such as <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> causes the collection to be populated immediately.</span></span> <span data-ttu-id="2884e-963">若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next`</span><span class="sxs-lookup"><span data-stu-id="2884e-963">To take advantage of lazy evaluation, you should iterate the collection by using a construct such as `foreach` in C# and `For Each`…`Next`</span></span> <span data-ttu-id="2884e-964">在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="2884e-964">in Visual Basic.</span></span>  
  
 <span data-ttu-id="2884e-965">其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-965">Because of its lazy evaluation, calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> method does not throw a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-966">不過，會擲回例外狀況上執行的操作<xref:System.Text.RegularExpressions.MatchCollection>如果目前的應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的逾時間隔，這個方法中，所傳回的物件超過此逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="2884e-966">However, the exception is thrown when an operation is performed on the <xref:System.Text.RegularExpressions.MatchCollection> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-967">下列範例會使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法，以識別在"es"結尾的句子中的任何字。</span><span class="sxs-lookup"><span data-stu-id="2884e-967">The following example uses the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> method to identify any word in a sentence that ends in "es".</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 <span data-ttu-id="2884e-968">規則運算式模式 `\b\w+es\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-968">The regular expression pattern `\b\w+es\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-969">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-969">Pattern</span></span>|<span data-ttu-id="2884e-970">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-970">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-971">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-971">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="2884e-972">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-972">Match one or more word characters.</span></span>|  
|`es`|<span data-ttu-id="2884e-973">比對常值字串"es"。</span><span class="sxs-lookup"><span data-stu-id="2884e-973">Match the literal string "es".</span></span>|  
|`\b`|<span data-ttu-id="2884e-974">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-974">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-975">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-975">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-976">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-976">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-977">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，針對擷取多個模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，這可讓您指定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-977">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for retrieving multiple pattern matches is <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you specify the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-978">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-978">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-979">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-979">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-980">列舉值的位元組合，這些值會指定用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-980">A bitwise combination of the enumeration values that specify options for matching.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-981">使用指定的比對選項在指定的輸入字串中，搜尋所指定規則運算式的所有相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-981">Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-982">搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-982">A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search.</span>
          </span>
          <span data-ttu-id="2884e-983">如果找不到相符的項目，此方法會傳回空集合物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-983">If no matches are found, the method returns an empty collection object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-984"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="2884e-984">The <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method is similar to the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method, except that it returns information about all the matches found in the input string, instead of a single match.</span></span> <span data-ttu-id="2884e-985">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="2884e-985">It is equivalent to the following code:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 <span data-ttu-id="2884e-986">靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Matches`。</span><span class="sxs-lookup"><span data-stu-id="2884e-986">The static `Matches` methods are equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance method `Matches`.</span></span>  
  
 <span data-ttu-id="2884e-987">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-987">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-988">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-988">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-989"><xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-989">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method uses lazy evaluation to populate the returned <xref:System.Text.RegularExpressions.MatchCollection> object.</span></span> <span data-ttu-id="2884e-990">存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。</span><span class="sxs-lookup"><span data-stu-id="2884e-990">Accessing members of this collection such as <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> causes the collection to be populated immediately.</span></span> <span data-ttu-id="2884e-991">若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next`</span><span class="sxs-lookup"><span data-stu-id="2884e-991">To take advantage of lazy evaluation, you should iterate the collection by using a construct such as `foreach` in C# and `For Each`…`Next`</span></span> <span data-ttu-id="2884e-992">在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="2884e-992">in Visual Basic.</span></span>  
  
 <span data-ttu-id="2884e-993">其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-993">Because of its lazy evaluation, calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> method does not throw a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-994">不過，會擲回例外狀況上執行的操作<xref:System.Text.RegularExpressions.MatchCollection>如果目前的應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的逾時間隔，這個方法中，所傳回的物件超過此逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="2884e-994">However, the exception is thrown when an operation is performed on the <xref:System.Text.RegularExpressions.MatchCollection> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-995">下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法，以識別在句子結尾為"es"，然後再呼叫中的任何字組<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法來執行不區分大小寫的模式與輸入字串的比較。</span><span class="sxs-lookup"><span data-stu-id="2884e-995">The following example calls the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> method to identify any word in a sentence that ends in "es", and then calls the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method to perform a case-insensitive comparison of the pattern with the input string.</span></span> <span data-ttu-id="2884e-996">如輸出所示，兩個方法會傳回不同的結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-996">As the output shows, the two methods return different results.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 <span data-ttu-id="2884e-997">規則運算式模式 `\b\w+es\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-997">The regular expression pattern `\b\w+es\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-998">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-998">Pattern</span></span>|<span data-ttu-id="2884e-999">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-999">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-1000">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-1000">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="2884e-1001">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1001">Match one or more word characters.</span></span>|  
|`es`|<span data-ttu-id="2884e-1002">比對常值字串"es"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1002">Match the literal string "es".</span></span>|  
|`\b`|<span data-ttu-id="2884e-1003">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-1003">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1004">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1004">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1005">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1005">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1006">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1006">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1007">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，針對擷取多個模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1007">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for retrieving multiple pattern matches is <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1008">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1008">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1009">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1009">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1010">列舉值的位元組合，這些值會指定用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1010">A bitwise combination of the enumeration values that specify options for matching.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-1011">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1011">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1012">使用指定的比對選項和逾時間隔，在指定的輸入字串中搜尋所指定規則運算式的所有相符項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1012">Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1013">搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1013">A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search.</span>
          </span>
          <span data-ttu-id="2884e-1014">如果找不到相符的項目，此方法會傳回空集合物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1014">If no matches are found, the method returns an empty collection object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1015"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="2884e-1015">The <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method is similar to the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method, except that it returns information about all the matches found in the input string, instead of a single match.</span></span> <span data-ttu-id="2884e-1016">相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="2884e-1016">It is equivalent to the following code:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 <span data-ttu-id="2884e-1017">靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Matches`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1017">The static `Matches` methods are equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance method `Matches`.</span></span>  
  
 <span data-ttu-id="2884e-1018">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1018">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1019">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1019">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-1020"><xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1020">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method uses lazy evaluation to populate the returned <xref:System.Text.RegularExpressions.MatchCollection> object.</span></span> <span data-ttu-id="2884e-1021">存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。</span><span class="sxs-lookup"><span data-stu-id="2884e-1021">Accessing members of this collection such as <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> causes the collection to be populated immediately.</span></span> <span data-ttu-id="2884e-1022">若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next`</span><span class="sxs-lookup"><span data-stu-id="2884e-1022">To take advantage of lazy evaluation, you should iterate the collection by using a construct such as `foreach` in C# and `For Each`…`Next`</span></span> <span data-ttu-id="2884e-1023">在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1023">in Visual Basic.</span></span>  
  
 <span data-ttu-id="2884e-1024">其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1024">Because of its lazy evaluation, calling the <xref:System.Text.RegularExpressions.Regex.Matches%2A> method does not throw a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-1025">不過，在執行作業時會擲回例外狀況<xref:System.Text.RegularExpressions.MatchCollection>如果比對的作業超過此所指定的逾時間隔，這個方法中，所傳回的物件`matchTimeout`參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-1025">However, an exception is thrown when an operation is performed on the <xref:System.Text.RegularExpressions.MatchCollection> object returned by this method, if a matching operation exceeds this time-out interval specified by the`matchTimeout` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1026">下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法，以執行比對任何字在"es"結尾的句子中的區分大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="2884e-1026">The following example calls the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method to perform a case-sensitive comparison that matches any word in a sentence that ends in "es".</span></span> <span data-ttu-id="2884e-1027">然後它會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來執行不區分大小寫的模式與輸入字串的比較。</span><span class="sxs-lookup"><span data-stu-id="2884e-1027">It then calls the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method to perform a case-insensitive comparison of the pattern with the input string.</span></span> <span data-ttu-id="2884e-1028">在這兩種情況下，逾時間隔設為一秒。</span><span class="sxs-lookup"><span data-stu-id="2884e-1028">In both cases, the time-out interval is set to one second.</span></span> <span data-ttu-id="2884e-1029">如輸出所示，兩個方法會傳回不同的結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-1029">As the output shows, the two methods return different results.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 <span data-ttu-id="2884e-1030">規則運算式模式 `\b\w+es\b` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-1030">The regular expression pattern `\b\w+es\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-1031">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1031">Pattern</span></span>|<span data-ttu-id="2884e-1032">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1032">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="2884e-1033">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-1033">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="2884e-1034">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1034">Match one or more word characters.</span></span>|  
|`es`|<span data-ttu-id="2884e-1035">比對常值字串"es"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1035">Match the literal string "es".</span></span>|  
|`\b`|<span data-ttu-id="2884e-1036">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="2884e-1036">End the match at a word boundary.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1037">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1037">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1038">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1038">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1039">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1039">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
          <span data-ttu-id="2884e-1040">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1040">-or-</span>
          </span>
          <span data-ttu-id="2884e-1041">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1041">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1042">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1042">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1043">取得目前執行個體的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1043">Gets the time-out interval of the current instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2884e-1044">在<see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />擲回之前，可在模式比對作業中流逝的最大時間間隔，或者為<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />（如果停用逾時）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1044">The maximum time interval that can elapse in a pattern-matching operation before a <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> is thrown, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> if time-outs are disabled.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1045"><xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性會定義大約最大時間間隔<xref:System.Text.RegularExpressions.Regex>作業逾時之前執行單一比對作業的執行個體。規則運算式引擎會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>經過逾時間隔之後其下一步 計時檢查期間的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1045">The <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> property defines the approximate maximum time interval for a <xref:System.Text.RegularExpressions.Regex> instance to execute a single matching operation before the operation times out. The regular expression engine throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception during its next timing check after the time-out interval has elapsed.</span></span> <span data-ttu-id="2884e-1046">這可防止規則運算式引擎處理需要大量回溯的輸入的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1046">This prevents the regular expression engine from processing input strings that require excessive backtracking.</span></span> <span data-ttu-id="2884e-1047">如需詳細資訊，請參閱 <<c0> [ 回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)並[規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1047">For more information, see [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) and [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md).</span></span>  
  
 <span data-ttu-id="2884e-1048">這個屬性是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="2884e-1048">This property is read-only.</span></span> <span data-ttu-id="2884e-1049">您可以將其值設定個別的明確<xref:System.Text.RegularExpressions.Regex>藉由呼叫物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式，您可以將其值設定為所有<xref:System.Text.RegularExpressions.Regex>比對應用程式定義域中的作業，藉由呼叫<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法，並提供<xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT"屬性值，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-1049">You can set its value explicitly for an individual <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor; and you can set its value for all <xref:System.Text.RegularExpressions.Regex> matching operations in an application domain by calling the <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> method and providing a <xref:System.TimeSpan> value for the "REGEX_DEFAULT_MATCH_TIMEOUT" property, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 <span data-ttu-id="2884e-1050">如果您沒有明確設定的逾時間隔，預設值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>是使用和比對作業執行逾時。</span><span class="sxs-lookup"><span data-stu-id="2884e-1050">If you do not explicitly set a time-out interval, the default value <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> is used, and matching operations do not time out.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1051">取得傳入 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1051">Gets the options that were passed into the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2884e-1052">
            <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 列舉的一個或多個成員，代表傳遞至 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式的選項</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1052">One or more members of the <see cref="T:System.Text.RegularExpressions.RegexOptions" /> enumeration that represent options that were passed to the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1053">值<xref:System.Text.RegularExpressions.Regex.Options%2A>屬性所組成的一或多個成員<xref:System.Text.RegularExpressions.RegexOptions>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="2884e-1053">The value of the <xref:System.Text.RegularExpressions.Regex.Options%2A> property consists of one or more members of the <xref:System.Text.RegularExpressions.RegexOptions> enumeration.</span></span> <span data-ttu-id="2884e-1054">如果沒有選項中未定義<xref:System.Text.RegularExpressions.Regex>類別建構函式，其值是<xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-1054">If no options were defined in the <xref:System.Text.RegularExpressions.Regex> class constructor, its value is <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2884e-1055">可用的選項會詳細討論[Regular Expression Options](~/docs/standard/base-types/regular-expression-options.md)主題。</span><span class="sxs-lookup"><span data-stu-id="2884e-1055">The available options are discussed in detail in the [Regular Expression Options](~/docs/standard/base-types/regular-expression-options.md) topic.</span></span>  
  
 <span data-ttu-id="2884e-1056">請注意，<xref:System.Text.RegularExpressions.Regex.Options%2A>屬性不會反映在規則運算式中定義的內嵌選項模式本身。</span><span class="sxs-lookup"><span data-stu-id="2884e-1056">Note that the <xref:System.Text.RegularExpressions.Regex.Options%2A> property does not reflect inline options defined in the regular expression pattern itself.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="2884e-1057">
            <para>
              <see cref="T:System.Text.RegularExpressions.Regex" /> 所建立的規則運算式的基底類別<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。這些已編譯的規則運算式使用的基底類別實作<see cref="P:System.Text.RegularExpressions.Regex.Options" />屬性。如果從衍生類別中，呼叫<see cref="P:System.Text.RegularExpressions.Regex.Options" />屬性會傳回已傳遞給的選項<paramref name="options" />參數<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />類別建構函式用來定義規則運算式。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1057">
              <para>
                <see cref="T:System.Text.RegularExpressions.Regex" /> is the base class of regular expressions created by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. These compiled regular expressions use the base class implementation of the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property. If called from a derived class, the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property returns the options that were passed to the <paramref name="options" /> parameter of the <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> class constructor that was used to define the regular expression.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1058">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1058">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1059">在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1059">In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1060">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1060">The string to search for a match.</span>
          </span>
        </param>
        <param name="replacement">
          <span data-ttu-id="2884e-1061">取代字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1061">The replacement string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1062">在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的所有字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1062">In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1063">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1063">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1064">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1064">If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1065">相符的項目是搜尋開始的開頭`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1065">The search for matches starts at the beginning of the `input` string.</span></span> <span data-ttu-id="2884e-1066">規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1066">The regular expression is the pattern defined by the constructor for the current <xref:System.Text.RegularExpressions.Regex> object.</span></span>  
  
 <span data-ttu-id="2884e-1067">`replacement`參數指定的字串來取代中的每個相符項目`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1067">The `replacement` parameter specifies the string that is to replace each match in `input`.</span></span> <span data-ttu-id="2884e-1068">`replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1068">`replacement` can consist of any combination of literal text and [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1069">比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1069">For example, the replacement pattern `a*${test}b` inserts the string "a*" followed by the substring that is matched by the `test` capturing group, if any, followed by the string "b".</span></span> <span data-ttu-id="2884e-1070">\* 字元無法辨識為中繼字元的取代模式內。</span><span class="sxs-lookup"><span data-stu-id="2884e-1070">The \* character is not recognized as a metacharacter within a replacement pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1071">替代是取代模式中可以辨識的只是規則運算式語言項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1071">Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</span></span> <span data-ttu-id="2884e-1072">所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1072">All other regular expression language elements, including [character escapes](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), are allowed in regular expression patterns only and are not recognized in replacement patterns.</span></span>  
  
 <span data-ttu-id="2884e-1073">如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1073">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1074">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1074">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1075">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1075">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 <span data-ttu-id="2884e-1076">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1076">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1077">下列範例會定義規則運算式， `\s+`，符合一或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1077">The following example defines a regular expression, `\s+`, that matches one or more white-space characters.</span></span> <span data-ttu-id="2884e-1078">取代字串""，將它們取代為單一空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1078">The replacement string, " ", replaces them with a single space character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 <span data-ttu-id="2884e-1079">下列範例會定義規則運算式中， `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`，並取代模式中， `$2`，從數字的值中移除前置或尾端的貨幣符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1079">The following example defines a regular expression, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`, and a replacement pattern, `$2`, that removes either a leading or a trailing currency symbol from a numeric value.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 <span data-ttu-id="2884e-1080">規則運算式的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-1080">The regular expression is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-1081">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1081">Pattern</span></span>|<span data-ttu-id="2884e-1082">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1082">Description</span></span>|  
|-------------|-----------------|  
|`\p{Sc}`|<span data-ttu-id="2884e-1083">比對貨幣符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1083">Match a currency symbol.</span></span> <span data-ttu-id="2884e-1084">`{Sc}` 表示 Unicode Symbol，Currency 分類隸屬的任何字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1084">`{Sc}` denotes any character that is a member of the Unicode Symbol, Currency category.</span></span>|  
|`\s?`|<span data-ttu-id="2884e-1085">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1085">Match zero or one white-space character.</span></span>|  
|`(\p{Sc}\s?)?`|<span data-ttu-id="2884e-1086">比對零個或一個出現的貨幣符號且後面接著零個或一個空白字元的組合。</span><span class="sxs-lookup"><span data-stu-id="2884e-1086">Match zero or one occurrence of the combination of a currency symbol followed by zero or one white-space character.</span></span> <span data-ttu-id="2884e-1087">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-1087">This is the first capturing group.</span></span>|  
|`\d+`|<span data-ttu-id="2884e-1088">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="2884e-1088">Match one or more decimal digits.</span></span>|  
|`\.?`|<span data-ttu-id="2884e-1089">比對零個或一個出現的期間，（作為小數分隔符號字元）。</span><span class="sxs-lookup"><span data-stu-id="2884e-1089">Match zero or one occurrence of a period (used as a decimal separator character).</span></span>|  
|`((?<=\.)\d+)?`|<span data-ttu-id="2884e-1090">如果句號前一個字元，符合一或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="2884e-1090">If a period is the previous character, match one or more decimal digits.</span></span> <span data-ttu-id="2884e-1091">此模式可以比對零或一次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1091">This pattern can be matched either zero or one time.</span></span>|  
|`(\d+\.?((?<=\.)\d+)?)`|<span data-ttu-id="2884e-1092">比對一或多個十進位數字後面接著選擇性的期間和其他十進位數字的模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1092">Match the pattern of one or more decimal digits followed by an optional period and additional decimal digits.</span></span> <span data-ttu-id="2884e-1093">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-1093">This is the second capturing group.</span></span> <span data-ttu-id="2884e-1094">若要呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29>方法會將整個相符項目取代此擷取群組的值。</span><span class="sxs-lookup"><span data-stu-id="2884e-1094">The call to the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> method replaces the entire match with the value of this captured group.</span></span>|  
|`(?(1)&#124;\s?\p{Sc})?`|<span data-ttu-id="2884e-1095">如果第一個擷取的群組存在，則比對空字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1095">If the first captured group exists, match an empty string.</span></span> <span data-ttu-id="2884e-1096">否則，比對零個或一個空格字元，後面接著貨幣符號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1096">Otherwise, match zero or one white-space character followed by a currency symbol.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1097">
            <paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1097">
              <paramref name="input" /> or <paramref name="replacement" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1098">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1098">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1099">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1099">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1100">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1100">The string to search for a match.</span>
          </span>
        </param>
        <param name="evaluator">
          <span data-ttu-id="2884e-1101">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1101">A custom method that examines each match and returns either the original matched string or a replacement string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1102">在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1102">In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1103">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1103">A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1104">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1104">If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1105"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="2884e-1105">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> method is useful for replacing a regular expression match if any of the following conditions is true:</span></span>  
  
-   <span data-ttu-id="2884e-1106">取代字串不能輕易地指定規則運算式取代模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1106">The replacement string cannot readily be specified by a regular expression replacement pattern.</span></span>  
  
-   <span data-ttu-id="2884e-1107">取代字串會產生從相符的字串上進行一些處理。</span><span class="sxs-lookup"><span data-stu-id="2884e-1107">The replacement string results from some processing done on the matched string.</span></span>  
  
-   <span data-ttu-id="2884e-1108">取代字串的條件式處理結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-1108">The replacement string results from conditional processing.</span></span>  
  
 <span data-ttu-id="2884e-1109">此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1109">The method is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> method and passing each <xref:System.Text.RegularExpressions.Match> object in the returned <xref:System.Text.RegularExpressions.MatchCollection> collection to the `evaluator` delegate.</span></span>  
  
 <span data-ttu-id="2884e-1110">規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1110">The regular expression is the pattern defined by the constructor for the current <xref:System.Text.RegularExpressions.Regex> object.</span></span>  
  
 <span data-ttu-id="2884e-1111">`evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1111">The `evaluator` parameter is the delegate for a custom method that you define and that examines each match.</span></span> <span data-ttu-id="2884e-1112">自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1112">The custom method must have the following signature to match the <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 <span data-ttu-id="2884e-1113">您的自訂方法會傳回字串，取代相符的輸入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1113">Your custom method returns a string that replaces the matched input.</span></span>  
  
 <span data-ttu-id="2884e-1114">如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1114">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1115">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1115">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1116">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1116">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 <span data-ttu-id="2884e-1117">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1117">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1118">下列程式碼範例會顯示為原始字串、 比對原始字串中的每個字，將已轉換的字串轉換為大寫，然後顯示每個符合結果的第一個字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1118">The following code example displays an original string, matches each word in the original string, converts the first character of each match to uppercase, then displays the converted string.</span></span>  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1119">
            <paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1119">
              <paramref name="input" /> or <paramref name="evaluator" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1120">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1120">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1121">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1121">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1122">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1122">The string to search for a match.</span>
          </span>
        </param>
        <param name="replacement">
          <span data-ttu-id="2884e-1123">取代字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1123">The replacement string.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2884e-1124">取代作業可以發生的最多次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1124">The maximum number of times the replacement can occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1125">在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1125">In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1126">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1126">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1127">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1127">If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1128">相符的項目是搜尋開始的開頭`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1128">The search for matches starts at the beginning of the `input` string.</span></span> <span data-ttu-id="2884e-1129">規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1129">The regular expression is the pattern that is defined by the constructor for the current <xref:System.Text.RegularExpressions.Regex> object.</span></span> <span data-ttu-id="2884e-1130">如果`count`是負數，字串的結尾繼續取代項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1130">If `count` is negative, replacements continue to the end of the string.</span></span> <span data-ttu-id="2884e-1131">如果`count`超過的相符項目數，會取代所有相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1131">If `count` exceeds the number of matches, all matches are replaced.</span></span>  
  
 <span data-ttu-id="2884e-1132">`replacement`參數指定的字串來取代第一個`count`中的比對`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1132">The `replacement` parameter specifies the string that is to replace the first `count` matches in `input`.</span></span> <span data-ttu-id="2884e-1133">`replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1133">`replacement` can consist of any combination of literal text and [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1134">比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1134">For example, the replacement pattern `a*${test}b` inserts the string "a*" followed by the substring that is matched by the `test` capturing group, if any, followed by the string "b".</span></span> <span data-ttu-id="2884e-1135">\* 字元無法辨識為中繼字元的取代模式內。</span><span class="sxs-lookup"><span data-stu-id="2884e-1135">The \* character is not recognized as a metacharacter within a replacement pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1136">替代是取代模式中可以辨識的只是規則運算式語言項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1136">Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</span></span> <span data-ttu-id="2884e-1137">所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1137">All other regular expression language elements, including [character escapes](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), are allowed in regular expression patterns only and are not recognized in replacement patterns.</span></span>  
  
 <span data-ttu-id="2884e-1138">如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1138">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1139">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1139">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1140">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1140">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 <span data-ttu-id="2884e-1141">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1141">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1142">下列範例會將前五個出現重複的字元取代單一字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1142">The following example replaces the first five occurrences of duplicated characters with a single character.</span></span> <span data-ttu-id="2884e-1143">規則運算式模式`(\w)\1`比對單一字元的連續項目，並將第一個相符項目指派給第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-1143">The regular expression pattern `(\w)\1` matches consecutive occurrences of a single character and assigns the first occurrence to the first capturing group.</span></span> <span data-ttu-id="2884e-1144">取代模式`$1`整個相符項目取代為第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-1144">The replacement pattern `$1` replaces the entire match with the first captured group.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1145">
            <paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1145">
              <paramref name="input" /> or <paramref name="replacement" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1146">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1146">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1147">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1147">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1148">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1148">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1149">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1149">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="replacement">
          <span data-ttu-id="2884e-1150">取代字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1150">The replacement string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1151">在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1151">In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1152">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1152">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1153">如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1153">If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1154">靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Replace`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1154">The static `Replace` methods are equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance method `Replace`.</span></span>  
  
 <span data-ttu-id="2884e-1155">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1155">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1156">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1156">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span> <span data-ttu-id="2884e-1157">相符的項目是搜尋開始的開頭`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1157">The search for matches starts at the beginning of the `input` string.</span></span>  
  
 <span data-ttu-id="2884e-1158">`replacement`參數指定的字串來取代中的每個相符項目`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1158">The `replacement` parameter specifies the string that is to replace each match in `input`.</span></span> <span data-ttu-id="2884e-1159">`replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1159">`replacement` can consist of any combination of literal text and [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1160">比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1160">For example, the replacement pattern `a*${test}b` inserts the string "a*" followed by the substring that is matched by the `test` capturing group, if any, followed by the string "b".</span></span> <span data-ttu-id="2884e-1161">\* 字元無法辨識為中繼字元的取代模式內。</span><span class="sxs-lookup"><span data-stu-id="2884e-1161">The \* character is not recognized as a metacharacter within a replacement pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1162">替代是取代模式中可以辨識的只是規則運算式語言項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1162">Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</span></span> <span data-ttu-id="2884e-1163">所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1163">All other regular expression language elements, including [character escapes](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), are allowed in regular expression patterns only and are not recognized in replacement patterns.</span></span>  
  
 <span data-ttu-id="2884e-1164">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1164">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-1165">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1165">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="2884e-1166">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1166">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1167">下列範例會定義規則運算式， `\s+`，符合一或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1167">The following example defines a regular expression, `\s+`, that matches one or more white-space characters.</span></span> <span data-ttu-id="2884e-1168">取代字串""，將它們取代為單一空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1168">The replacement string, " ", replaces them with a single space character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 <span data-ttu-id="2884e-1169">下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法來取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-1169">The following example uses the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> method to replace the local machine and drive names in a UNC path with a local file path.</span></span> <span data-ttu-id="2884e-1170">使用規則運算式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法來包含邏輯磁碟機的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-1170">The regular expression uses the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to include the name of the local computer, and the <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> method to include the names of the logical drives.</span></span> <span data-ttu-id="2884e-1171">若要成功執行範例，您應該以您的本機電腦名稱來取代常值字串"MyMachine"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1171">To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 <span data-ttu-id="2884e-1172">下列的運算式所定義的規則運算式模式：</span><span class="sxs-lookup"><span data-stu-id="2884e-1172">The regular expression pattern is defined by the following expression:</span></span>  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 <span data-ttu-id="2884e-1173">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1173">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-1174">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1174">Pattern</span></span>|<span data-ttu-id="2884e-1175">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1175">Description</span></span>|  
|-------------|-----------------|  
|`\\\\`|<span data-ttu-id="2884e-1176">比對兩個連續的反斜線 (`\`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1176">Match two consecutive backslash (`\`) characters.</span></span> <span data-ttu-id="2884e-1177">因為反斜線字元會解譯為逸出字元，則必須逸出每個反斜線與另一個反斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1177">Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</span></span>|  
|`(?i:" + Environment.MachineName + ")`|<span data-ttu-id="2884e-1178">執行不區分大小寫的比對所傳回的字串<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-1178">Perform a case-insensitive match of the string that is returned by the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property.</span></span>|  
|`(?:\.\w+)*`|<span data-ttu-id="2884e-1179">比對句號 (`.`) 字元後面接著一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1179">Match the period (`.`) character followed by one or more word characters.</span></span> <span data-ttu-id="2884e-1180">此種比對可能是零或多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1180">This match can occur zero or more times.</span></span> <span data-ttu-id="2884e-1181">不會擷取相符子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1181">The matched subexpression is not captured.</span></span>|  
|`\\`|<span data-ttu-id="2884e-1182">比對反斜線 (`\`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1182">Match a backslash (`\`) character.</span></span>|  
|`((?i:[" + driveNames + "]))`|<span data-ttu-id="2884e-1183">執行不區分大小寫的比對的個別磁碟機 lettters 所組成的字元類別。</span><span class="sxs-lookup"><span data-stu-id="2884e-1183">Perform a case-insensitive match of the character class that consists of the individual drive lettters.</span></span> <span data-ttu-id="2884e-1184">此相符項目是第一個擷取的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1184">This match is the first captured subexpression.</span></span>|  
|`\$`|<span data-ttu-id="2884e-1185">比對常值貨幣符號 (`$`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1185">Match the literal dollar sign (`$`) character.</span></span>|  
  
 <span data-ttu-id="2884e-1186">取代模式`$1`整個相符項目取代為第一個擷取的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1186">The replacement pattern `$1` replaces the entire match with the first captured subexpression.</span></span> <span data-ttu-id="2884e-1187">也就是說，它會取代 UNC 機器和磁碟機名稱的磁碟機代號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1187">That is, it replaces the UNC machine and drive name with the drive letter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1188">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1188">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1189">
            <paramref name="input" />
            <paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1189">
              <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1190">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1190">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1191">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1191">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1192">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，來取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1192">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for replacing a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1193">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1193">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1194">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1194">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="evaluator">
          <span data-ttu-id="2884e-1195">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1195">A custom method that examines each match and returns either the original matched string or a replacement string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1196">在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1196">In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1197">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1197">A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1198">如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1198">If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1199"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="2884e-1199">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> method is useful for replacing a regular expression match if any of the following conditions is true:</span></span>  
  
-   <span data-ttu-id="2884e-1200">取代字串不能輕易地指定規則運算式取代模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1200">The replacement string cannot readily be specified by a regular expression replacement pattern.</span></span>  
  
-   <span data-ttu-id="2884e-1201">取代字串會產生從相符的字串上進行一些處理。</span><span class="sxs-lookup"><span data-stu-id="2884e-1201">The replacement string results from some processing done on the matched string.</span></span>  
  
-   <span data-ttu-id="2884e-1202">取代字串的條件式處理結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-1202">The replacement string results from conditional processing.</span></span>  
  
 <span data-ttu-id="2884e-1203">此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1203">The method is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> method and passing each <xref:System.Text.RegularExpressions.Match> object in the returned <xref:System.Text.RegularExpressions.MatchCollection> collection to the `evaluator` delegate.</span></span>  
  
 <span data-ttu-id="2884e-1204">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1204">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1205">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1205">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-1206">`evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1206">The `evaluator` parameter is the delegate for a custom method that you define and that examines each match.</span></span> <span data-ttu-id="2884e-1207">自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1207">The custom method must have the following signature to match the <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 <span data-ttu-id="2884e-1208">您的自訂方法會傳回字串，取代相符的輸入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1208">Your custom method returns a string that replaces the matched input.</span></span>  
  
 <span data-ttu-id="2884e-1209">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1209">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-1210">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1210">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="2884e-1211">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1211">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1212">下列範例使用規則運算式從字串中，擷取個別文字，然後使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派来呼叫一個名為`WordScramble`，將金鑰加密的文字中個別的字母。</span><span class="sxs-lookup"><span data-stu-id="2884e-1212">The following example uses a regular expression to extract the individual words from a string, and then uses a <xref:System.Text.RegularExpressions.MatchEvaluator> delegate to call a method named `WordScramble` that scrambles the individual letters in the word.</span></span> <span data-ttu-id="2884e-1213">若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1213">To do this, the `WordScramble` method creates an array that contains the characters in the match.</span></span> <span data-ttu-id="2884e-1214">它也會使用隨機浮點數建立平行的陣列，它會填入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1214">It also creates a parallel array that it populates with random floating-point numbers.</span></span> <span data-ttu-id="2884e-1215">藉由呼叫排序陣列<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，並已排序的陣列做為引數提供<xref:System.String>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1215">The arrays are sorted by calling the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method, and the sorted array is provided as an argument to a <xref:System.String> class constructor.</span></span> <span data-ttu-id="2884e-1216">然後傳回此新建立的字串`WordScramble`方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1216">This newly created string is then returned by the `WordScramble` method.</span></span> <span data-ttu-id="2884e-1217">規則運算式模式`\w+`符合一或多個文字字元，規則運算式引擎會繼續將字元加入至相符項目，直到遇到非文字字元，例如空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1217">The regular expression pattern `\w+` matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1218">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1218">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1219">
            <paramref name="input" />
            <paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1219">
              <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1220">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1220">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1221">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1221">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1222">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，用於評估和取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1222">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for evaluating and replacing a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1223">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1223">The string to search for a match.</span>
          </span>
        </param>
        <param name="evaluator">
          <span data-ttu-id="2884e-1224">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1224">A custom method that examines each match and returns either the original matched string or a replacement string.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2884e-1225">取代將發生的最多次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1225">The maximum number of times the replacement will occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1226">在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1226">In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1227">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1227">A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1228">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1228">If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1229"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="2884e-1229">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> method is useful for replacing a regular expression match if any of the following conditions is true:</span></span>  
  
-   <span data-ttu-id="2884e-1230">取代字串不能輕易地指定規則運算式取代模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1230">The replacement string cannot readily be specified by a regular expression replacement pattern.</span></span>  
  
-   <span data-ttu-id="2884e-1231">取代字串會產生從相符的字串上進行一些處理。</span><span class="sxs-lookup"><span data-stu-id="2884e-1231">The replacement string results from some processing done on the matched string.</span></span>  
  
-   <span data-ttu-id="2884e-1232">取代字串的條件式處理結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-1232">The replacement string results from conditional processing.</span></span>  
  
 <span data-ttu-id="2884e-1233">此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法並傳遞第一個`count`<xref:System.Text.RegularExpressions.Match>中所傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1233">The method is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> method and passing the first `count`<xref:System.Text.RegularExpressions.Match> objects in the returned <xref:System.Text.RegularExpressions.MatchCollection> collection to the `evaluator` delegate.</span></span>  
  
 <span data-ttu-id="2884e-1234">規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1234">The regular expression is the pattern defined by the constructor for the current <xref:System.Text.RegularExpressions.Regex> object.</span></span>  
  
 <span data-ttu-id="2884e-1235">`evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1235">The `evaluator` parameter is the delegate for a custom method that you define and that examines each match.</span></span> <span data-ttu-id="2884e-1236">自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1236">The custom method must have the following signature to match the <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 <span data-ttu-id="2884e-1237">您的自訂方法會傳回字串，取代相符的輸入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1237">Your custom method returns a string that replaces the matched input.</span></span>  
  
 <span data-ttu-id="2884e-1238">如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1238">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1239">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1239">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1240">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1240">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 <span data-ttu-id="2884e-1241">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1241">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1242">下列範例會使用規則運算式，刻意拼錯一半的清單中的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-1242">The following example uses a regular expression to deliberately misspell half of the words in a list.</span></span> <span data-ttu-id="2884e-1243">它會使用規則運算式`\w*(ie|ei)\w*`比對包含 「 ie 」 或 「 ei"字元的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-1243">It uses the regular expression `\w*(ie|ei)\w*` to match words that include the characters "ie" or "ei".</span></span> <span data-ttu-id="2884e-1244">它會傳遞第一個符合的單字，下半`ReverseLetter`方法，這個方法會接著使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法，以反轉"i"和"e"相符的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1244">It passes the first half of the matching words to the `ReverseLetter` method, which, in turn, uses the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method to reverse "i" and "e" in the matched string.</span></span> <span data-ttu-id="2884e-1245">其餘的字維持不變。</span><span class="sxs-lookup"><span data-stu-id="2884e-1245">The remaining words remain unchanged.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 <span data-ttu-id="2884e-1246">規則運算式 `\w*(ie|ei)\w*` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-1246">The regular expression `\w*(ie|ei)\w*` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-1247">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1247">Pattern</span></span>|<span data-ttu-id="2884e-1248">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1248">Description</span></span>|  
|-------------|-----------------|  
|`\w*`|<span data-ttu-id="2884e-1249">比對零個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1249">Match zero or more word characters.</span></span>|  
|`(ie&#124;ei)`|<span data-ttu-id="2884e-1250">符合 「 ie 」 或 「 ei"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1250">Match either "ie" or "ei".</span></span>|  
|`\w*`|<span data-ttu-id="2884e-1251">比對零個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1251">Match zero or more word characters.</span></span>|  
  
 <span data-ttu-id="2884e-1252">規則運算式模式`([ie])([ie])`在`ReverseLetter`方法中 diphthong 「 ie 」 或 「 ei 」 比對的第一個"i"或"e"，並將字母指派給第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-1252">The regular expression pattern `([ie])([ie])` in the `ReverseLetter` method matches the first "i" or "e" in the diphthong "ie" or "ei" and assigns the letter to the first capturing group.</span></span> <span data-ttu-id="2884e-1253">它符合第二個"i"或"e"，並將代號指派給第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="2884e-1253">It matches the second "i" or "e" and assigns the letter to the second capturing group.</span></span> <span data-ttu-id="2884e-1254">藉由呼叫接著會反轉兩個字元<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法取代模式`$2$1`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1254">The two characters are then reversed by calling the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> method with the replacement pattern `$2$1`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1255">
            <paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1255">
              <paramref name="input" /> or <paramref name="evaluator" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1256">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1256">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1257">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1257">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1258">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1258">The string to search for a match.</span>
          </span>
        </param>
        <param name="replacement">
          <span data-ttu-id="2884e-1259">取代字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1259">The replacement string.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2884e-1260">取代可以發生的最多次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1260">Maximum number of times the replacement can occur.</span>
          </span>
        </param>
        <param name="startat">
          <span data-ttu-id="2884e-1261">在輸入字串中開始搜尋的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1261">The character position in the input string where the search begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1262">在指定的輸入子字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1262">In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1263">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1263">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1264">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1264">If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1265">搜尋符合項目以啟動`input`所指定位置的字串`startat`參數。</span><span class="sxs-lookup"><span data-stu-id="2884e-1265">The search for matches starts in the `input` string at the position specified by the `startat` parameter.</span></span> <span data-ttu-id="2884e-1266">規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1266">The regular expression is the pattern defined by the constructor for the current <xref:System.Text.RegularExpressions.Regex> object.</span></span> <span data-ttu-id="2884e-1267">如果`count`是負數，字串的結尾繼續取代項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1267">If `count` is negative, replacements continue to the end of the string.</span></span> <span data-ttu-id="2884e-1268">如果`count`超過的相符項目數，會取代所有相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1268">If `count` exceeds the number of matches, all matches are replaced.</span></span>  
  
 <span data-ttu-id="2884e-1269">`replacement`參數指定的字串來取代中的每個相符項目`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1269">The `replacement` parameter specifies the string that is to replace each match in `input`.</span></span> <span data-ttu-id="2884e-1270">`replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1270">`replacement` can consist of any combination of literal text and [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1271">比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1271">For example, the replacement pattern `a*${test}b` inserts the string "a*" followed by the substring that is matched by the `test` capturing group, if any, followed by the string "b".</span></span> <span data-ttu-id="2884e-1272">\* 字元無法辨識為中繼字元的取代模式內。</span><span class="sxs-lookup"><span data-stu-id="2884e-1272">The \* character is not recognized as a metacharacter within a replacement pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1273">替代是取代模式中可以辨識的只是規則運算式語言項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1273">Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</span></span> <span data-ttu-id="2884e-1274">所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1274">All other regular expression language elements, including [character escapes](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), are allowed in regular expression patterns only and are not recognized in replacement patterns.</span></span>  
  
 <span data-ttu-id="2884e-1275">如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1275">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1276">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1276">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1277">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1277">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 <span data-ttu-id="2884e-1278">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1278">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1279">下列範例 double-spaces 以外的所有字串的第一行。</span><span class="sxs-lookup"><span data-stu-id="2884e-1279">The following example double-spaces all but the first line of a string.</span></span> <span data-ttu-id="2884e-1280">它會定義規則運算式模式中， `^.*$`，符合一行文字，呼叫<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法來比對的字串，並使用第一行`Match.Index`和`Match.Count`屬性，以判斷第二個的開始位置行。</span><span class="sxs-lookup"><span data-stu-id="2884e-1280">It defines a regular expression pattern, `^.*$`, that matches a line of text, calls the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> method to match the first line of the string, and uses the `Match.Index` and `Match.Count` properties to determine the starting position of the second line.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 <span data-ttu-id="2884e-1281">規則運算式模式 `^.*$` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-1281">The regular expression pattern `^.*$` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2884e-1282">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1282">Pattern</span></span>|<span data-ttu-id="2884e-1283">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1283">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2884e-1284">比對行首。</span><span class="sxs-lookup"><span data-stu-id="2884e-1284">Match the start of a line.</span></span> <span data-ttu-id="2884e-1285">(請注意，<xref:System.Text.RegularExpressions.Regex>物件具現化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>選項; 否則此字元類別會只比對輸入字串的開頭。)</span><span class="sxs-lookup"><span data-stu-id="2884e-1285">(Note that the <xref:System.Text.RegularExpressions.Regex> object was instantiated by using the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; otherwise, this character class would only match the beginning of the input string.)</span></span>|  
|`.*`|<span data-ttu-id="2884e-1286">比對任何字元零或多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1286">Match any character zero or more times.</span></span>|  
|`$`|<span data-ttu-id="2884e-1287">比對一行的結尾。</span><span class="sxs-lookup"><span data-stu-id="2884e-1287">Match the end of a line.</span></span> <span data-ttu-id="2884e-1288">(請注意，<xref:System.Text.RegularExpressions.Regex>物件具現化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>選項; 否則此字元類別會只比對輸入字串的開頭。)</span><span class="sxs-lookup"><span data-stu-id="2884e-1288">(Note that the <xref:System.Text.RegularExpressions.Regex> object was instantiated by using the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; otherwise, this character class would only match the beginning of the input string.)</span></span>|  
  
 <span data-ttu-id="2884e-1289">取代字串 (`vbCrLf + "$&"`在 Visual Basic 中`"\n$&"`C# 中) 將加入新的一行之前相符的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1289">The replacement string (`vbCrLf + "$&"` in Visual Basic, `"\n$&"` in C#) adds a new line before the matched string.</span></span> <span data-ttu-id="2884e-1290">請注意，`\n`在 C# 範例會解譯為新行字元與 C# 編譯器; 它不代表規則運算式字元逸出。</span><span class="sxs-lookup"><span data-stu-id="2884e-1290">Note that `\n` in the C# example is interpreted as the newline character by the C# compiler; it does not represent a regular expression character escape.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1291">
            <paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1291">
              <paramref name="input" /> or <paramref name="replacement" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1292">
            <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1292">
              <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1293">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1293">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1294">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1294">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1295">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1295">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1296">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1296">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="replacement">
          <span data-ttu-id="2884e-1297">取代字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1297">The replacement string.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1298">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1298">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1299">在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1299">In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</span>
          </span>
          <span data-ttu-id="2884e-1300">指定的選項會修改符合的作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1300">Specified options modify the matching operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1301">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1301">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1302">如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1302">If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1303">靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Replace`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1303">The static `Replace` methods are equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance method `Replace`.</span></span>  
  
 <span data-ttu-id="2884e-1304">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1304">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1305">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1305">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span> <span data-ttu-id="2884e-1306">如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</span><span class="sxs-lookup"><span data-stu-id="2884e-1306">If you specify <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> for the `options` parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</span></span>  
  
 <span data-ttu-id="2884e-1307">`replacement`參數指定的字串來取代中的每個相符項目`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1307">The `replacement` parameter specifies the string that is to replace each match in `input`.</span></span> <span data-ttu-id="2884e-1308">`replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1308">`replacement` can consist of any combination of literal text and [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1309">比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1309">For example, the replacement pattern `a*${test}b` inserts the string "a*" followed by the substring that is matched by the `test` capturing group, if any, followed by the string "b".</span></span> <span data-ttu-id="2884e-1310">\* 字元無法辨識為中繼字元的取代模式內。</span><span class="sxs-lookup"><span data-stu-id="2884e-1310">The \* character is not recognized as a metacharacter within a replacement pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1311">替代是取代模式中可以辨識的只是規則運算式語言項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1311">Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</span></span> <span data-ttu-id="2884e-1312">所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1312">All other regular expression language elements, including [character escapes](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), are allowed in regular expression patterns only and are not recognized in replacement patterns.</span></span>  
  
 <span data-ttu-id="2884e-1313">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1313">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-1314">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1314">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="2884e-1315">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1315">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1316">下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法來取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-1316">The following example uses the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> method to replace the local machine and drive names in a UNC path with a local file path.</span></span> <span data-ttu-id="2884e-1317">使用規則運算式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法來包含邏輯磁碟機的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-1317">The regular expression uses the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to include the name of the local computer, and the <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> method to include the names of the logical drives.</span></span> <span data-ttu-id="2884e-1318">所有的規則運算式的字串比較不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="2884e-1318">All regular expression string comparisons are case-insensitive.</span></span> <span data-ttu-id="2884e-1319">若要成功執行範例，您應該以您的本機電腦名稱來取代常值字串"MyMachine"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1319">To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 <span data-ttu-id="2884e-1320">下列的運算式所定義的規則運算式模式：</span><span class="sxs-lookup"><span data-stu-id="2884e-1320">The regular expression pattern is defined by the following expression:</span></span>  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 <span data-ttu-id="2884e-1321">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1321">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-1322">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1322">Pattern</span></span>|<span data-ttu-id="2884e-1323">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1323">Description</span></span>|  
|-------------|-----------------|  
|`\\\\`|<span data-ttu-id="2884e-1324">比對兩個連續的反斜線 (`\`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1324">Match two consecutive backslash (`\`) characters.</span></span> <span data-ttu-id="2884e-1325">因為反斜線字元會解譯為逸出字元，則必須逸出每個反斜線與另一個反斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1325">Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</span></span>|  
|`+ Environment.MachineName +`|<span data-ttu-id="2884e-1326">所傳回的字串相符<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-1326">Match the string that is returned by the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property.</span></span>|  
|`(?:\.\w+)*`|<span data-ttu-id="2884e-1327">比對句號 (`.`) 字元後面接著一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1327">Match the period (`.`) character followed by one or more word characters.</span></span> <span data-ttu-id="2884e-1328">此種比對可能是零或多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1328">This match can occur zero or more times.</span></span> <span data-ttu-id="2884e-1329">不會擷取相符子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1329">The matched subexpression is not captured.</span></span>|  
|`\\`|<span data-ttu-id="2884e-1330">比對反斜線 (`\`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1330">Match a backslash (`\`) character.</span></span>|  
|`([" + driveNames + "])`|<span data-ttu-id="2884e-1331">比對的字元類別，其中包含的個別磁碟機代號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1331">Match the character class that consists of the individual drive letters.</span></span> <span data-ttu-id="2884e-1332">此相符項目是第一個擷取的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1332">This match is the first captured subexpression.</span></span>|  
|`\$`|<span data-ttu-id="2884e-1333">比對常值貨幣符號 (`$`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1333">Match the literal dollar sign (`$`) character.</span></span>|  
  
 <span data-ttu-id="2884e-1334">取代模式`$1`整個相符項目取代為第一個擷取的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1334">The replacement pattern `$1` replaces the entire match with the first captured subexpression.</span></span> <span data-ttu-id="2884e-1335">也就是說，它會取代 UNC 機器和磁碟機名稱的磁碟機代號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1335">That is, it replaces the UNC machine and drive name with the drive letter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1336">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1336">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1337">
            <paramref name="input" />
            <paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1337">
              <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1338">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1338">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1339">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1339">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1340">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1340">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1341">
            <para>此方法等於呼叫它之應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，來取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1341">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for replacing a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1342">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1342">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1343">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1343">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="evaluator">
          <span data-ttu-id="2884e-1344">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1344">A custom method that examines each match and returns either the original matched string or a replacement string.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1345">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1345">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1346">在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1346">In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</span>
          </span>
          <span data-ttu-id="2884e-1347">指定的選項會修改符合的作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1347">Specified options modify the matching operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1348">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1348">A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1349">如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1349">If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1350"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目中的，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="2884e-1350">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is useful for replacing a regular expression match in if any of the following conditions is true:</span></span>  
  
-   <span data-ttu-id="2884e-1351">取代字串不能輕易地指定規則運算式取代模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1351">The replacement string cannot readily be specified by a regular expression replacement pattern.</span></span>  
  
-   <span data-ttu-id="2884e-1352">取代字串會產生從相符的字串上進行一些處理。</span><span class="sxs-lookup"><span data-stu-id="2884e-1352">The replacement string results from some processing done on the matched string.</span></span>  
  
-   <span data-ttu-id="2884e-1353">取代字串的條件式處理結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-1353">The replacement string results from conditional processing.</span></span>  
  
 <span data-ttu-id="2884e-1354">此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1354">The method is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method and passing each <xref:System.Text.RegularExpressions.Match> object in the returned <xref:System.Text.RegularExpressions.MatchCollection> collection to the `evaluator` delegate.</span></span>  
  
 <span data-ttu-id="2884e-1355">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1355">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1356">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1356">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-1357">`evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1357">The `evaluator` parameter is the delegate for a custom method that you define and that examines each match.</span></span> <span data-ttu-id="2884e-1358">自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1358">The custom method must have the following signature to match the <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 <span data-ttu-id="2884e-1359">您的自訂方法會傳回字串，取代相符的輸入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1359">Your custom method returns a string that replaces the matched input.</span></span>  
  
 <span data-ttu-id="2884e-1360">如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</span><span class="sxs-lookup"><span data-stu-id="2884e-1360">If you specify <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> for the `options` parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</span></span>  
  
 <span data-ttu-id="2884e-1361">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1361">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-1362">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1362">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="2884e-1363">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1363">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1364">下列範例使用規則運算式從字串中，擷取個別文字，然後使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派来呼叫一個名為`WordScramble`，將金鑰加密的文字中個別的字母。</span><span class="sxs-lookup"><span data-stu-id="2884e-1364">The following example uses a regular expression to extract the individual words from a string, and then uses a <xref:System.Text.RegularExpressions.MatchEvaluator> delegate to call a method named `WordScramble` that scrambles the individual letters in the word.</span></span> <span data-ttu-id="2884e-1365">若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1365">To do this, the `WordScramble` method creates an array that contains the characters in the match.</span></span> <span data-ttu-id="2884e-1366">它也會使用隨機浮點數建立平行的陣列，它會填入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1366">It also creates a parallel array that it populates with random floating-point numbers.</span></span> <span data-ttu-id="2884e-1367">藉由呼叫排序陣列<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，並已排序的陣列做為引數提供<xref:System.String>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1367">The arrays are sorted by calling the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method, and the sorted array is provided as an argument to a <xref:System.String> class constructor.</span></span> <span data-ttu-id="2884e-1368">然後傳回此新建立的字串`WordScramble`方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1368">This newly created string is then returned by the `WordScramble` method.</span></span> <span data-ttu-id="2884e-1369">規則運算式模式`\w+`符合一或多個文字字元，規則運算式引擎會繼續將字元加入至相符項目，直到遇到非文字字元，例如空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1369">The regular expression pattern `\w+` matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</span></span> <span data-ttu-id="2884e-1370">在呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包含<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>選項，讓規則運算式模式中的註解`\w+  # Matches all the characters in a word.`會忽略規則運算式引擎。</span><span class="sxs-lookup"><span data-stu-id="2884e-1370">The call to the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> method includes the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option so that the comment in the regular expression pattern `\w+  # Matches all the characters in a word.` is ignored by the regular expression engine.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1371">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1371">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1372">
            <paramref name="input" />
            <paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1372">
              <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1373">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1373">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1374">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1374">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1375">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1375">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1376">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1376">The string to search for a match.</span>
          </span>
        </param>
        <param name="evaluator">
          <span data-ttu-id="2884e-1377">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1377">A custom method that examines each match and returns either the original matched string or a replacement string.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2884e-1378">取代將發生的最多次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1378">The maximum number of times the replacement will occur.</span>
          </span>
        </param>
        <param name="startat">
          <span data-ttu-id="2884e-1379">在輸入字串中開始搜尋的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1379">The character position in the input string where the search begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1380">在指定的輸入子字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1380">In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1381">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1381">A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1382">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1382">If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1383"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="2884e-1383">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method is useful for replacing a regular expression match if any of the following conditions is true:</span></span>  
  
-   <span data-ttu-id="2884e-1384">取代字串不能輕易地指定規則運算式取代模式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1384">The replacement string cannot readily be specified by a regular expression replacement pattern.</span></span>  
  
-   <span data-ttu-id="2884e-1385">取代字串會產生從相符的字串上進行一些處理。</span><span class="sxs-lookup"><span data-stu-id="2884e-1385">The replacement string results from some processing done on the matched string.</span></span>  
  
-   <span data-ttu-id="2884e-1386">取代字串的條件式處理結果。</span><span class="sxs-lookup"><span data-stu-id="2884e-1386">The replacement string results from conditional processing.</span></span>  
  
 <span data-ttu-id="2884e-1387">此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法並傳遞第一個`count`<xref:System.Text.RegularExpressions.Match>中所傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1387">The method is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method and passing the first `count`<xref:System.Text.RegularExpressions.Match> objects in the returned <xref:System.Text.RegularExpressions.MatchCollection> collection to the `evaluator` delegate.</span></span>  
  
 <span data-ttu-id="2884e-1388">規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。</span><span class="sxs-lookup"><span data-stu-id="2884e-1388">The regular expression is the pattern defined by the constructor for the current <xref:System.Text.RegularExpressions.Regex> object.</span></span>  
  
 <span data-ttu-id="2884e-1389">`evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1389">The `evaluator` parameter is the delegate for a custom method that you define and that examines each match.</span></span> <span data-ttu-id="2884e-1390">自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1390">The custom method must have the following signature to match the <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 <span data-ttu-id="2884e-1391">您的自訂方法會傳回字串，取代相符的輸入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1391">Your custom method returns a string that replaces the matched input.</span></span>  
  
 <span data-ttu-id="2884e-1392">如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1392">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1393">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1393">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1394">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1394">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 <span data-ttu-id="2884e-1395">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1395">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1396">
            <paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1396">
              <paramref name="input" /> or <paramref name="evaluator" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1397">
            <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1397">
              <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1398">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1398">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1399">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1399">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1400">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1400">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1401">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1401">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="replacement">
          <span data-ttu-id="2884e-1402">取代字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1402">The replacement string.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1403">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1403">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-1404">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1404">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1405">在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1405">In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</span>
          </span>
          <span data-ttu-id="2884e-1406">如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1406">Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1407">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1407">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1408">如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1408">If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1409">靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Replace`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1409">The static `Replace` methods are equivalent to constructing a <xref:System.Text.RegularExpressions.Regex> object with the specified regular expression pattern and calling the instance method `Replace`.</span></span>  
  
 <span data-ttu-id="2884e-1410">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1410">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1411">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1411">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span> <span data-ttu-id="2884e-1412">如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</span><span class="sxs-lookup"><span data-stu-id="2884e-1412">If you specify <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> for the `options` parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</span></span>  
  
 <span data-ttu-id="2884e-1413">`replacement`參數指定的字串來取代中的每個相符項目`input`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1413">The `replacement` parameter specifies the string that is to replace each match in `input`.</span></span> <span data-ttu-id="2884e-1414">`replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1414">`replacement` can consist of any combination of literal text and [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1415">比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1415">For example, the replacement pattern `a*${test}b` inserts the string "a*" followed by the substring that is matched by the `test` capturing group, if any, followed by the string "b".</span></span> <span data-ttu-id="2884e-1416">\* 字元無法辨識為中繼字元的取代模式內。</span><span class="sxs-lookup"><span data-stu-id="2884e-1416">The \* character is not recognized as a metacharacter within a replacement pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1417">替代是取代模式中可以辨識的只是規則運算式語言項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1417">Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</span></span> <span data-ttu-id="2884e-1418">所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1418">All other regular expression language elements, including [character escapes](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), are allowed in regular expression patterns only and are not recognized in replacement patterns.</span></span>  
  
 <span data-ttu-id="2884e-1419">`matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。</span><span class="sxs-lookup"><span data-stu-id="2884e-1419">The `matchTimeout` parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</span></span> <span data-ttu-id="2884e-1420">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1420">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md) and [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1421">如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1421">If no match is found in that time interval, the method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-1422">`matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-1422">`matchTimeout` overrides any default time-out value defined for the application domain in which the method executes.</span></span>  
  
 <span data-ttu-id="2884e-1423">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1423">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1424">下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-1424">The following example uses the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> method to replace the local machine and drive names in a UNC path with a local file path.</span></span> <span data-ttu-id="2884e-1425">使用規則運算式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法來包含邏輯磁碟機的名稱。</span><span class="sxs-lookup"><span data-stu-id="2884e-1425">The regular expression uses the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to include the name of the local computer and the <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> method to include the names of the logical drives.</span></span> <span data-ttu-id="2884e-1426">所有的規則運算式的字串比較會區分大小寫，而任何單一的取代作業會逾時，如果 0.5 秒內找不到相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1426">All regular expression string comparisons are case-insensitive, and any single replacement operation times out if a match cannot be found in 0.5 second.</span></span> <span data-ttu-id="2884e-1427">若要成功執行範例，您應該以您的本機電腦名稱來取代常值字串"MyMachine"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1427">To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 <span data-ttu-id="2884e-1428">下列的運算式所定義的規則運算式模式：</span><span class="sxs-lookup"><span data-stu-id="2884e-1428">The regular expression pattern is defined by the following expression:</span></span>  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 <span data-ttu-id="2884e-1429">下表顯示規則運算式模式的解譯方式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1429">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="2884e-1430">模式</span><span class="sxs-lookup"><span data-stu-id="2884e-1430">Pattern</span></span>|<span data-ttu-id="2884e-1431">描述</span><span class="sxs-lookup"><span data-stu-id="2884e-1431">Description</span></span>|  
|-------------|-----------------|  
|`\\\\`|<span data-ttu-id="2884e-1432">比對兩個連續的反斜線 (`\`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1432">Match two consecutive backslash (`\`) characters.</span></span> <span data-ttu-id="2884e-1433">因為反斜線字元會解譯為逸出字元，則必須逸出每個反斜線與另一個反斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1433">Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</span></span>|  
|`+ Environment.MachineName +`|<span data-ttu-id="2884e-1434">所傳回的字串相符<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="2884e-1434">Match the string that is returned by the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property.</span></span>|  
|`(?:\.\w+)*`|<span data-ttu-id="2884e-1435">比對句號 (`.`) 字元後面接著一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1435">Match the period (`.`) character followed by one or more word characters.</span></span> <span data-ttu-id="2884e-1436">此種比對可能是零或多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1436">This match can occur zero or more times.</span></span> <span data-ttu-id="2884e-1437">不會擷取相符子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1437">The matched subexpression is not captured.</span></span>|  
|`\\`|<span data-ttu-id="2884e-1438">比對反斜線 (`\`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1438">Match a backslash (`\`) character.</span></span>|  
|`([" + driveNames + "])`|<span data-ttu-id="2884e-1439">比對的字元類別，其中包含的個別磁碟機代號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1439">Match the character class that consists of the individual drive letters.</span></span> <span data-ttu-id="2884e-1440">此相符項目是第一個擷取的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1440">This match is the first captured subexpression.</span></span>|  
|`\$`|<span data-ttu-id="2884e-1441">比對常值貨幣符號 (`$`) 字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1441">Match the literal dollar sign (`$`) character.</span></span>|  
  
 <span data-ttu-id="2884e-1442">取代模式`$1`整個相符項目取代為第一個擷取的子運算式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1442">The replacement pattern `$1` replaces the entire match with the first captured subexpression.</span></span> <span data-ttu-id="2884e-1443">也就是說，它會取代 UNC 機器和磁碟機名稱的磁碟機代號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1443">That is, it replaces the UNC machine and drive name with the drive letter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1444">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1444">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1445">
            <paramref name="input" />
            <paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1445">
              <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1446">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1446">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
          <span data-ttu-id="2884e-1447">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1447">-or-</span>
          </span>
          <span data-ttu-id="2884e-1448">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1448">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1449">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1449">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1450">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1450">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1451">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1451">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1452">用來搜尋比對的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1452">The string to search for a match.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1453">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1453">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="evaluator">
          <span data-ttu-id="2884e-1454">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1454">A custom method that examines each match and returns either the original matched string or a replacement string.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1455">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1455">A bitwise combination of enumeration values that provide options for matching.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-1456">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1456">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1457">在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代所有符合指定之規則運算式的子字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1457">In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</span>
          </span>
          <span data-ttu-id="2884e-1458">如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1458">Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1459">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1459">A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</span>
          </span>
          <span data-ttu-id="2884e-1460">如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1460">If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1461"><xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="2884e-1461">The <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is useful for replacing a regular expression match if any of the following conditions is true:</span></span>  
  
-   <span data-ttu-id="2884e-1462">如果無法輕易地規則運算式取代模式所指定取代字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1462">If the replacement string cannot readily be specified by a regular expression replacement pattern.</span></span>  
  
-   <span data-ttu-id="2884e-1463">如果取代字串而產生的一些處理會在相符字串上執行。</span><span class="sxs-lookup"><span data-stu-id="2884e-1463">If the replacement string results from some processing performed on the matched string.</span></span>  
  
-   <span data-ttu-id="2884e-1464">如果取代字串而產生的條件式處理。</span><span class="sxs-lookup"><span data-stu-id="2884e-1464">If the replacement string results from conditional processing.</span></span>  
  
 <span data-ttu-id="2884e-1465">此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1465">The method is equivalent to calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method and passing each <xref:System.Text.RegularExpressions.Match> object in the returned <xref:System.Text.RegularExpressions.MatchCollection> collection to the `evaluator` delegate.</span></span>  
  
 <span data-ttu-id="2884e-1466">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1466">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1467">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1467">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 <span data-ttu-id="2884e-1468">`evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1468">The `evaluator` parameter is the delegate for a custom method that you define and that examines each match.</span></span> <span data-ttu-id="2884e-1469">自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。</span><span class="sxs-lookup"><span data-stu-id="2884e-1469">The custom method must have the following signature to match the <xref:System.Text.RegularExpressions.MatchEvaluator> delegate.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 <span data-ttu-id="2884e-1470">您的自訂方法會傳回字串，取代相符的輸入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1470">Your custom method returns a string that replaces the matched input.</span></span>  
  
 <span data-ttu-id="2884e-1471">如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</span><span class="sxs-lookup"><span data-stu-id="2884e-1471">If you specify <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> for the `options` parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</span></span>  
  
 <span data-ttu-id="2884e-1472">`matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止規則運算式依賴大量回溯不會出現以"停止回應時它們會處理輸入，其中包含相符項目附近。</span><span class="sxs-lookup"><span data-stu-id="2884e-1472">The `matchTimeout` parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to "stop responding when they process input that contains near matches.</span></span> <span data-ttu-id="2884e-1473">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1473">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md) and [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1474">如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1474">If no match is found in that time interval, the method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-1475">`matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-1475">`matchTimeout` overrides any default time-out value defined for the application domain in which the method executes.</span></span>  
  
 <span data-ttu-id="2884e-1476">因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1476">Because the method returns `input` unchanged if there is no match, you can use the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method to determine whether the method has made any replacements to the input string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2884e-1477">下列範例使用規則運算式從字串中，擷取個別文字，然後使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派来呼叫一個名為`WordScramble`，將金鑰加密的文字中個別的字母。</span><span class="sxs-lookup"><span data-stu-id="2884e-1477">The following example uses a regular expression to extract the individual words from a string, and then uses a <xref:System.Text.RegularExpressions.MatchEvaluator> delegate to call a method named `WordScramble` that scrambles the individual letters in the word.</span></span> <span data-ttu-id="2884e-1478">若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1478">To do this, the `WordScramble` method creates an array that contains the characters in the match.</span></span> <span data-ttu-id="2884e-1479">它也會使用隨機浮點數建立平行的陣列，它會填入。</span><span class="sxs-lookup"><span data-stu-id="2884e-1479">It also creates a parallel array that it populates with random floating-point numbers.</span></span> <span data-ttu-id="2884e-1480">藉由呼叫排序陣列<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，並已排序的陣列做為引數提供<xref:System.String>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1480">The arrays are sorted by calling the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method, and the sorted array is provided as an argument to a <xref:System.String> class constructor.</span></span> <span data-ttu-id="2884e-1481">然後傳回此新建立的字串`WordScramble`方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1481">This newly created string is then returned by the `WordScramble` method.</span></span> <span data-ttu-id="2884e-1482">規則運算式模式`\w+`符合一或多個文字字元，規則運算式引擎會繼續將字元加入至相符項目，直到遇到非文字字元，例如空格字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1482">The regular expression pattern `\w+` matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</span></span> <span data-ttu-id="2884e-1483">在呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包含<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>選項，讓規則運算式模式中的註解`\w+  # Matches all the characters in a word.`會忽略規則運算式引擎。</span><span class="sxs-lookup"><span data-stu-id="2884e-1483">The call to the <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> method includes the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option so that the comment in the regular expression pattern `\w+  # Matches all the characters in a word.` is ignored by the regular expression engine.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1484">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1484">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1485">
            <paramref name="input" />
            <paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1485">
              <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1486">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1486">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
          <span data-ttu-id="2884e-1487">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1487">-or-</span>
          </span>
          <span data-ttu-id="2884e-1488">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1488">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1489">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1489">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1490">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1490">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1491">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1491">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1492">取得值，指出規則運算式是否由右至左搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1492">Gets a value that indicates whether the regular expression searches from right to left.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2884e-1493">如果規則運算式由右至左搜尋，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1493">
              <see langword="true" /> if the regular expression searches from right to left; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1494"><xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> 已`true`如果<xref:System.Text.RegularExpressions.Regex>執行個體經由<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>選項。</span><span class="sxs-lookup"><span data-stu-id="2884e-1494"><xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> is `true` if the <xref:System.Text.RegularExpressions.Regex> instance was created with the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> option.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1495">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1495">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1496">在規則運算式比對所定義的位置，將輸入字串分割成子字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1496">Splits an input string into an array of substrings at the positions defined by a regular expression match.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1497">要分隔的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1497">The string to split.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1498">在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定之規則運算式模式所定義的位置，將輸入字串分隔成子字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1498">Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1499">字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1499">An array of strings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1500"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。</span><span class="sxs-lookup"><span data-stu-id="2884e-1500">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> methods are similar to the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method, except that <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> splits the string at a delimiter determined by a regular expression instead of a set of characters.</span></span> <span data-ttu-id="2884e-1501">將字串分割為盡可能多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1501">The string is split as many times as possible.</span></span> <span data-ttu-id="2884e-1502">如果不找到任何分隔符號，則傳回值就會包含其值是原始的輸入的字串的一個項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1502">If no delimiter is found, the return value contains one element whose value is the original input string.</span></span>  
  
 <span data-ttu-id="2884e-1503">如果多個相符項目彼此相鄰，空字串會插入陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1503">If multiple matches are adjacent to one another, an empty string is inserted into the array.</span></span> <span data-ttu-id="2884e-1504">例如，分割上單一連字號的字串會導致傳回的陣列，其中兩個相鄰的連字號找不到，如下列程式碼所示的位置中包含空字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1504">For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 <span data-ttu-id="2884e-1505">如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。</span><span class="sxs-lookup"><span data-stu-id="2884e-1505">If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</span></span> <span data-ttu-id="2884e-1506">下列範例會使用規則運算式模式`\d+`分割輸入的字串的數字的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1506">The following example uses the regular expression pattern `\d+` to split an input string on numeric characters.</span></span> <span data-ttu-id="2884e-1507">因為字串開頭和結尾相符的數字的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-1507">Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 <span data-ttu-id="2884e-1508">如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1508">If capturing parentheses are used in a <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, any captured text is included in the resulting string array.</span></span> <span data-ttu-id="2884e-1509">比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1509">For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 <span data-ttu-id="2884e-1510">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="2884e-1510">However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</span></span> <span data-ttu-id="2884e-1511">在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1511">In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</span></span> <span data-ttu-id="2884e-1512">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1512">Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</span></span> <span data-ttu-id="2884e-1513">比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1513">For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</span></span> <span data-ttu-id="2884e-1514">第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1514">The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</span></span> <span data-ttu-id="2884e-1515">如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。</span><span class="sxs-lookup"><span data-stu-id="2884e-1515">If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 <span data-ttu-id="2884e-1516">如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%29>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1516">If the regular expression can match the empty string, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</span></span> <span data-ttu-id="2884e-1517">例如: </span><span class="sxs-lookup"><span data-stu-id="2884e-1517">For example:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 <span data-ttu-id="2884e-1518">請注意，傳回的陣列也會包含空字串的開頭和結尾的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1518">Note that the returned array also includes an empty string at the beginning and end of the array.</span></span>  
  
 <span data-ttu-id="2884e-1519"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException>擲回例外狀況是 split 作業的執行時間超過所指定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1519">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1520">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1520">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1521">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1521">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1522">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1522">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1523">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1523">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1524">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1524">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1525">要分隔的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1525">The string to be split.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2884e-1526">分隔作業可以發生的最多次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1526">The maximum number of times the split can occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1527">在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1527">Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1528">字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1528">An array of strings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1529"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。</span><span class="sxs-lookup"><span data-stu-id="2884e-1529">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> methods are similar to the <xref:System.String.Split%2A?displayProperty=nameWithType> method, except that <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> splits the string at a delimiter determined by a regular expression instead of a set of characters.</span></span> <span data-ttu-id="2884e-1530">`count`參數會指定在其中的子字串的最大數目`input`可以分割字串; 的最後一個字串包含 unsplit 的其餘部分的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1530">The `count` parameter specifies the maximum number of substrings into which the `input` string can be split; the last string contains the unsplit remainder of the string.</span></span> <span data-ttu-id="2884e-1531">A`count`為零的值會提供分割作業當作盡可能多次的預設行為。</span><span class="sxs-lookup"><span data-stu-id="2884e-1531">A `count` value of zero provides the default behavior of splitting as many times as possible.</span></span>  
  
 <span data-ttu-id="2884e-1532">如果多個相符項目彼此相鄰，或是開頭或結尾找到符合`input`，而且找到相符項目數目至少兩個小於`count`，空字串插入到陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1532">If multiple matches are adjacent to one another or if a match is found at the beginning or end of `input`, and the number of matches found is at least two less than `count`, an empty string is inserted into the array.</span></span> <span data-ttu-id="2884e-1533">也就是造成相鄰的比對或比對的開頭或結尾的輸入字串的空字串會計算在決定是否數目比對的子字串等於`count`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1533">That is, empty strings that result from adjacent matches or from matches at the beginning or end of the input string are counted in determining whether the number of matched substrings equals `count`.</span></span> <span data-ttu-id="2884e-1534">在下列範例中，規則運算式`/d+`用來分割成三個的子字串的最多包含一個或多個十進位數字的輸入的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1534">In the following example, the regular expression `/d+` is used to split an input string that includes one or more decimal digits into a maximum of three substrings.</span></span> <span data-ttu-id="2884e-1535">因為輸入字串的開頭比對規則運算式模式，第一個陣列元素包含<xref:System.String.Empty?displayProperty=nameWithType>、 第二個包含字母字元在輸入字串中，第一個集合，而第三個包含字串的其餘部分會遵循第三個相符項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1535">Because the beginning of the input string matches the regular expression pattern, the first array element contains <xref:System.String.Empty?displayProperty=nameWithType>, the second contains the first set of alphabetic characters in the input string, and the third contains the remainder of the string that follows the third match.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 <span data-ttu-id="2884e-1536">如果規則運算式中擷取括號，就會分割字串的陣列中包含任何擷取的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-1536">If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</span></span> <span data-ttu-id="2884e-1537">不過，包含擷取的文字的任何陣列元素不會計入判斷是否已到達的相符項目數`count`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1537">However, any array elements that contain captured text are not counted in determining whether the number of matches has reached `count`.</span></span> <span data-ttu-id="2884e-1538">例如，顯示分割成最多四個七個元素陣列，如以下程式碼中的子字串結果的"apple-apricot-梅紅-西洋梨-banana"字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1538">For example, splitting the string "apple-apricot-plum-pear-banana" into a maximum of four substrings results in a seven-element array, as the following code shows.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 <span data-ttu-id="2884e-1539">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="2884e-1539">However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</span></span> <span data-ttu-id="2884e-1540">在.NET Framework 1.0 和 1.1 中，只擷取的文字從第一個集合擷取括號包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1540">In the .NET Framework 1.0 and 1.1, only captured text from the first set of capturing parentheses is included in the returned array.</span></span> <span data-ttu-id="2884e-1541">從.NET Framework 2.0 開始，所有擷取的文字會加入至傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1541">Starting with the .NET Framework 2.0, all captured text is added to the returned array.</span></span> <span data-ttu-id="2884e-1542">不過，傳回陣列中包含擷取的文字的項目不會計算在決定是否數目比對的子字串等於`count`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1542">However, elements in the returned array that contain captured text are not counted in determining whether the number of matched substrings equals `count`.</span></span> <span data-ttu-id="2884e-1543">比方說，下列程式碼中，規則運算式會使用兩組擷取括號從日期字串中擷取日期的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1543">For example, in the following code, a regular expression uses two sets of capturing parentheses to extract the elements of a date from a date string.</span></span> <span data-ttu-id="2884e-1544">第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1544">The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</span></span> <span data-ttu-id="2884e-1545">若要呼叫<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>方法則指定最多兩個項目中傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1545">The call to the <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> method then specifies a maximum of two elements in the returned array.</span></span> <span data-ttu-id="2884e-1546">如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，方法會傳回兩個項目的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1546">If the example code is compiled and run under the .NET Framework 1.0 or 1.1, the method returns a two-element string array.</span></span> <span data-ttu-id="2884e-1547">如果進行編譯和.NET Framework 2.0 或更新版本下執行，則方法會傳回三個項目的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1547">If it is compiled and run under the .NET Framework 2.0 or later versions, the method returns a three-element string array.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 <span data-ttu-id="2884e-1548">如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1548">If the regular expression can match the empty string, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</span></span> <span data-ttu-id="2884e-1549">下列範例中，將字串"字元 」 分割成因為有許多項目是在輸入字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1549">The following example splits the string "characters" into as many elements as there are in the input string.</span></span> <span data-ttu-id="2884e-1550">因為 null 字串比對輸入字串的開頭，會傳回陣列的開頭插入 null 字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1550">Because the null string matches the beginning of the input string, a null string is inserted at the beginning of the returned array.</span></span> <span data-ttu-id="2884e-1551">這會導致要在輸入字串結尾處的兩個字元所組成的第十個項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1551">This causes the tenth element to consist of the two characters at the end of the input string.</span></span>  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <span data-ttu-id="2884e-1552"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException>擲回例外狀況是 split 作業的執行時間超過所指定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1552">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1553">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1553">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1554">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1554">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1555">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1555">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1556">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1556">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1557">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1557">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1558">要分隔的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1558">The string to split.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1559">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1559">The regular expression pattern to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1560">在規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1560">Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1561">字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1561">An array of strings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1562"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。</span><span class="sxs-lookup"><span data-stu-id="2884e-1562">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> methods are similar to the <xref:System.String.Split%2A?displayProperty=nameWithType> method, except that <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> splits the string at a delimiter determined by a regular expression instead of a set of characters.</span></span> <span data-ttu-id="2884e-1563">`input`字串分割為盡可能多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1563">The `input` string is split as many times as possible.</span></span> <span data-ttu-id="2884e-1564">如果`pattern`中找不到`input`字串，傳回值會包含一個項目，其值是原始`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1564">If `pattern` is not found in the `input` string, the return value contains one element whose value is the original `input` string.</span></span>  
  
 <span data-ttu-id="2884e-1565">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1565">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1566">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1566">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2884e-1567">編譯的規則運算式對靜態呼叫中使用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。</span><span class="sxs-lookup"><span data-stu-id="2884e-1567">Compiled regular expressions used in calls to static <xref:System.Text.RegularExpressions.Regex.Split%2A> methods are automatically cached.</span></span> <span data-ttu-id="2884e-1568">若要自行管理的已編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1568">To manage the lifetime of compiled regular expressions yourself, use the instance <xref:System.Text.RegularExpressions.Regex.Split%2A> methods.</span></span>  
  
 <span data-ttu-id="2884e-1569">如果多個相符項目彼此相鄰，空字串會插入陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1569">If multiple matches are adjacent to one another, an empty string is inserted into the array.</span></span> <span data-ttu-id="2884e-1570">例如，分割上單一連字號的字串會導致傳回的陣列，其中兩個相鄰的連字號找不到，如下列程式碼所示的位置中包含空字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1570">For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 <span data-ttu-id="2884e-1571">如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。</span><span class="sxs-lookup"><span data-stu-id="2884e-1571">If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</span></span> <span data-ttu-id="2884e-1572">下列範例會使用規則運算式模式`\d+`分割輸入的字串的數字的字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1572">The following example uses the regular expression pattern `\d+` to split an input string on numeric characters.</span></span> <span data-ttu-id="2884e-1573">因為字串開頭和結尾相符的數字的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-1573">Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 <span data-ttu-id="2884e-1574">如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1574">If capturing parentheses are used in a <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, any captured text is included in the resulting string array.</span></span> <span data-ttu-id="2884e-1575">比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1575">For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 <span data-ttu-id="2884e-1576">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="2884e-1576">However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</span></span> <span data-ttu-id="2884e-1577">在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1577">In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</span></span> <span data-ttu-id="2884e-1578">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1578">Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</span></span> <span data-ttu-id="2884e-1579">比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1579">For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</span></span> <span data-ttu-id="2884e-1580">第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1580">The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</span></span> <span data-ttu-id="2884e-1581">如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。</span><span class="sxs-lookup"><span data-stu-id="2884e-1581">If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 <span data-ttu-id="2884e-1582">如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1582">If the regular expression can match the empty string, <xref:System.Text.RegularExpressions.Regex.Split%2A> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</span></span> <span data-ttu-id="2884e-1583">例如: </span><span class="sxs-lookup"><span data-stu-id="2884e-1583">For example:</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 <span data-ttu-id="2884e-1584">請注意，傳回的陣列也會包含空字串的開頭和結尾的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1584">Note that the returned array also includes an empty string at the beginning and end of the array.</span></span>  
  
 <span data-ttu-id="2884e-1585"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過逾時間隔的方法呼叫的應用程式定義域指定，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1585">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-1586">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1586">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1587">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1587">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1588">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1588">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1589">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1589">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1590">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1590">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1591">
            <para>此方法等於呼叫該方法的應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，來分割文字模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1591">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for splitting text on a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1592">要分隔的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1592">The string to be split.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="2884e-1593">分隔作業可以發生的最多次數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1593">The maximum number of times the split can occur.</span>
          </span>
        </param>
        <param name="startat">
          <span data-ttu-id="2884e-1594">在輸入字串中要開始搜尋的字元位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1594">The character position in the input string where the search will begin.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1595">在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1595">Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</span>
          </span>
          <span data-ttu-id="2884e-1596">規則運算式模式從輸入字串中指定的字元位置開始搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1596">The search for the regular expression pattern starts at a specified character position in the input string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1597">字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1597">An array of strings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1598"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。</span><span class="sxs-lookup"><span data-stu-id="2884e-1598">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> methods are similar to the <xref:System.String.Split%2A?displayProperty=nameWithType> method, except that <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> splits the string at a delimiter determined by a regular expression instead of a set of characters.</span></span> <span data-ttu-id="2884e-1599">`count`參數會指定在其中的子字串的最大數目`input`字串分割; 的最後一個字串包含 unsplit 的其餘部分的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1599">The `count` parameter specifies the maximum number of substrings into which the `input` string is split; the last string contains the unsplit remainder of the string.</span></span> <span data-ttu-id="2884e-1600">A`count`為零的值會提供分割作業當作盡可能多次的預設行為。</span><span class="sxs-lookup"><span data-stu-id="2884e-1600">A `count` value of zero provides the default behavior of splitting as many times as possible.</span></span> <span data-ttu-id="2884e-1601">`startat`參數定義的第一個分隔符號搜尋開始處的點 （這可以用來略過前置空白字元）。</span><span class="sxs-lookup"><span data-stu-id="2884e-1601">The `startat` parameter defines the point at which the search for the first delimiter begins (this can be used for skipping leading white space).</span></span>  
  
 <span data-ttu-id="2884e-1602">如果沒有符合的項目從`count`+ 1 位置字串中，方法會傳回一個元素的陣列，其中包含`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1602">If no matches are found from the `count`+1 position in the string, the method returns a one-element array that contains the `input` string.</span></span> <span data-ttu-id="2884e-1603">如果找不到一或多個相符項目，傳回的陣列的第一個元素會包含最多前比對一個字元的第一個字元字串的第一個部分。</span><span class="sxs-lookup"><span data-stu-id="2884e-1603">If one or more matches are found, the first element of the returned array contains the first portion of the string from the first character up to one character before the match.</span></span>  
  
 <span data-ttu-id="2884e-1604">如果多個相符項目是彼此相鄰，而且找到相符項目數目是至少兩個小於`count`，空字串插入到陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1604">If multiple matches are adjacent to one another and the number of matches found is at least two less than `count`, an empty string is inserted into the array.</span></span> <span data-ttu-id="2884e-1605">同樣地，如果找到符合的`startat`字串中的第一個字元，則傳回的陣列的第一個項目為空字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1605">Similarly, if a match is found at `startat`, which is the first character in the string, the first element of the returned array is an empty string.</span></span> <span data-ttu-id="2884e-1606">也就是空的字串所產生的相鄰的相符項目會計算在決定是否數目比對的子字串等於`count`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1606">That is, empty strings that result from adjacent matches are counted in determining whether the number of matched substrings equals `count`.</span></span> <span data-ttu-id="2884e-1607">在下列範例中，規則運算式`\d+`用來尋找數字字元的第一個子字串的開始位置在字串中，然後將字串分割最多三次起始該位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-1607">In the following example, the regular expression `\d+` is used to find the starting position of the first substring of numeric characters in a string, and then to split the string a maximum of three times starting at that position.</span></span> <span data-ttu-id="2884e-1608">由於規則運算式模式比對輸入字串的開頭，傳回的字串陣列是空字串、 五個字元的字母字串和組成的字串，其餘部分</span><span class="sxs-lookup"><span data-stu-id="2884e-1608">Because the regular expression pattern matches the beginning of the input string, the returned string array consists of an empty string, a five-character alphabetic string, and the remainder of the string,</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 <span data-ttu-id="2884e-1609">如果規則運算式中擷取括號，就會分割字串的陣列中包含任何擷取的文字。</span><span class="sxs-lookup"><span data-stu-id="2884e-1609">If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</span></span> <span data-ttu-id="2884e-1610">不過，包含擷取的文字的任何陣列元素不會計入判斷是否已到達的相符項目數`count`。</span><span class="sxs-lookup"><span data-stu-id="2884e-1610">However, any array elements that contain captured text are not counted in determining whether the number of matches has reached `count`.</span></span> <span data-ttu-id="2884e-1611">例如，分割字串 '"apple-apricot-plum-pear-pomegranate-pineapple-peach 」 成四個最多的子字串開頭 15 字元字串會產生一個七個元素的陣列，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="2884e-1611">For example, splitting the string '"apple-apricot-plum-pear-pomegranate-pineapple-peach" into a maximum of four substrings beginning at character 15 in the string results in a seven-element array, as the following code shows.</span></span>  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 <span data-ttu-id="2884e-1612">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="2884e-1612">However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</span></span> <span data-ttu-id="2884e-1613">在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1613">In .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</span></span> <span data-ttu-id="2884e-1614">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1614">Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</span></span> <span data-ttu-id="2884e-1615">比方說，下列程式碼會使用兩組擷取括號來擷取個別文字字串中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1615">For example, the following code uses two sets of capturing parentheses to extract the individual words in a string.</span></span> <span data-ttu-id="2884e-1616">第一組擷取括號會擷取連字號，和第二個集合擷取的垂直列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1616">The first set of capturing parentheses captures the hyphen, and the second set captures the vertical bar.</span></span> <span data-ttu-id="2884e-1617">如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除垂直列的字元，如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。</span><span class="sxs-lookup"><span data-stu-id="2884e-1617">If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the vertical bar characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 <span data-ttu-id="2884e-1618">如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1618">If the regular expression can match the empty string, <xref:System.Text.RegularExpressions.Regex.Split%2A> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</span></span> <span data-ttu-id="2884e-1619">下列範例會分割成多個項目字串 「 字元 」 因為輸入的字串包含，開頭為字元"a"。</span><span class="sxs-lookup"><span data-stu-id="2884e-1619">The following example splits the string "characters" into as many elements as the input string contains, starting with the character "a".</span></span> <span data-ttu-id="2884e-1620">因為 null 字串比對輸入字串的結尾，會傳回陣列結尾處插入 null 字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1620">Because the null string matches the end of the input string, a null string is inserted at the end of the returned array.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <span data-ttu-id="2884e-1621"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException>擲回例外狀況是 split 作業的執行時間超過所指定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2884e-1621">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="2884e-1622">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1622">If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <xref:System.Text.RegularExpressions.Regex> object is created.</span></span> <span data-ttu-id="2884e-1623">如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況</span><span class="sxs-lookup"><span data-stu-id="2884e-1623">If no time-out is defined in the <xref:System.Text.RegularExpressions.Regex> constructor call or in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1624">
            <paramref name="input" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1624">
              <paramref name="input" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1625">
            <paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1625">
              <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1626">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1626">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1627">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1627">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1628">要分隔的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1628">The string to split.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1629">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1629">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1630">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1630">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1631">在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1631">Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</span>
          </span>
          <span data-ttu-id="2884e-1632">指定的選項會修改符合的作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1632">Specified options modify the matching operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1633">字串的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1633">An array of strings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1634"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。</span><span class="sxs-lookup"><span data-stu-id="2884e-1634">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> methods are similar to the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method, except that <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> splits the string at a delimiter determined by a regular expression instead of a set of characters.</span></span> <span data-ttu-id="2884e-1635">將字串分割為盡可能多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1635">The string is split as many times as possible.</span></span> <span data-ttu-id="2884e-1636">如果不找到任何分隔符號，則傳回值會包含一個項目，其值是原始`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1636">If no delimiter is found, the return value contains one element whose value is the original `input` string.</span></span>  
  
 <span data-ttu-id="2884e-1637">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1637">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1638">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1638">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2884e-1639">編譯的規則運算式對靜態呼叫中使用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。</span><span class="sxs-lookup"><span data-stu-id="2884e-1639">Compiled regular expressions used in calls to static <xref:System.Text.RegularExpressions.Regex.Split%2A> methods are automatically cached.</span></span> <span data-ttu-id="2884e-1640">若要自行管理的已編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1640">To manage the lifetime of compiled regular expressions yourself, use the instance <xref:System.Text.RegularExpressions.Regex.Split%2A> methods.</span></span>  
  
 <span data-ttu-id="2884e-1641">如果多個相符項目彼此相鄰，空字串會插入陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1641">If multiple matches are adjacent to one another, an empty string is inserted into the array.</span></span> <span data-ttu-id="2884e-1642">例如，分割上單一連字號的字串會導致傳回的陣列，包含空字串中找到兩個相鄰的連字號的位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-1642">For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</span></span>  
  
 <span data-ttu-id="2884e-1643">如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。</span><span class="sxs-lookup"><span data-stu-id="2884e-1643">If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</span></span> <span data-ttu-id="2884e-1644">下列範例會使用規則運算式模式`[a-z]+`分割輸入的字串的任何大寫或小寫的字母字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1644">The following example uses the regular expression pattern `[a-z]+` to split an input string on any uppercase or lowercase alphabetic character.</span></span> <span data-ttu-id="2884e-1645">因為字串開頭和結尾相符的是英文字母的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-1645">Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 <span data-ttu-id="2884e-1646">如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1646">If capturing parentheses are used in a <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, any captured text is included in the resulting string array.</span></span> <span data-ttu-id="2884e-1647">比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1647">For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 <span data-ttu-id="2884e-1648">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="2884e-1648">However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</span></span> <span data-ttu-id="2884e-1649">在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1649">In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</span></span> <span data-ttu-id="2884e-1650">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1650">Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</span></span> <span data-ttu-id="2884e-1651">比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1651">For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</span></span> <span data-ttu-id="2884e-1652">第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1652">The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</span></span> <span data-ttu-id="2884e-1653">如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。</span><span class="sxs-lookup"><span data-stu-id="2884e-1653">If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 <span data-ttu-id="2884e-1654">如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1654">If the regular expression can match the empty string, <xref:System.Text.RegularExpressions.Regex.Split%2A> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</span></span>  
  
 <span data-ttu-id="2884e-1655"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過逾時間隔的方法呼叫的應用程式定義域指定，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1655">The <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</span></span> <span data-ttu-id="2884e-1656">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1656">If no time-out is defined in the application domain's properties, or if the time-out value is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1657">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1657">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1658">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1658">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1659">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1659">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1660">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1660">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1661">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1661">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1662">
            <para>此方法等於呼叫該方法的應用程式定義域的預設逾時值的間隔之後逾時。如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。建議的靜態方法，來分割文字模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1662">
              <para>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called. If a time-out value has not been defined for the application domain, the value <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, which prevents the method from timing out, is used. The recommended static method for splitting text on a pattern match is <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, which lets you set the time-out interval.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">
          <span data-ttu-id="2884e-1663">要分隔的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1663">The string to split.</span>
          </span>
        </param>
        <param name="pattern">
          <span data-ttu-id="2884e-1664">要比對的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1664">The regular expression pattern to match.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="2884e-1665">列舉值的位元組合，提供用於比對的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1665">A bitwise combination of the enumeration values that provide options for matching.</span>
          </span>
        </param>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-1666">間隔，若要表示此方法不會逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1666">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1667">在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1667">Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</span>
          </span>
          <span data-ttu-id="2884e-1668">如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1668">Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1669">字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1669">A string array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1670"><xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。</span><span class="sxs-lookup"><span data-stu-id="2884e-1670">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> methods are similar to the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method, except that <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> splits the string at a delimiter determined by a regular expression instead of a set of characters.</span></span> <span data-ttu-id="2884e-1671">將字串分割為盡可能多次。</span><span class="sxs-lookup"><span data-stu-id="2884e-1671">The string is split as many times as possible.</span></span> <span data-ttu-id="2884e-1672">如果不找到任何分隔符號，則傳回值會包含一個項目，其值是原始`input`字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1672">If no delimiter is found, the return value contains one element whose value is the original `input` string.</span></span>  
  
 <span data-ttu-id="2884e-1673">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1673">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1674">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1674">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2884e-1675">編譯的規則運算式對靜態呼叫中使用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。</span><span class="sxs-lookup"><span data-stu-id="2884e-1675">Compiled regular expressions used in calls to static <xref:System.Text.RegularExpressions.Regex.Split%2A> methods are automatically cached.</span></span> <span data-ttu-id="2884e-1676">若要自行管理的已編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1676">To manage the lifetime of compiled regular expressions yourself, use the instance <xref:System.Text.RegularExpressions.Regex.Split%2A> methods.</span></span>  
  
 <span data-ttu-id="2884e-1677">如果多個相符項目彼此相鄰，空字串會插入陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1677">If multiple matches are adjacent to one another, an empty string is inserted into the array.</span></span> <span data-ttu-id="2884e-1678">例如，分割上單一連字號的字串會導致傳回的陣列，包含空字串中找到兩個相鄰的連字號的位置。</span><span class="sxs-lookup"><span data-stu-id="2884e-1678">For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</span></span>  
  
 <span data-ttu-id="2884e-1679">如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。</span><span class="sxs-lookup"><span data-stu-id="2884e-1679">If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</span></span> <span data-ttu-id="2884e-1680">下列範例會使用規則運算式模式`[a-z]+`分割輸入的字串的任何大寫或小寫的字母字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1680">The following example uses the regular expression pattern `[a-z]+` to split an input string on any uppercase or lowercase alphabetic character.</span></span> <span data-ttu-id="2884e-1681">因為字串開頭和結尾相符的是英文字母的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2884e-1681">Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 <span data-ttu-id="2884e-1682">如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1682">If capturing parentheses are used in a <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, any captured text is included in the resulting string array.</span></span> <span data-ttu-id="2884e-1683">比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。</span><span class="sxs-lookup"><span data-stu-id="2884e-1683">For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 <span data-ttu-id="2884e-1684">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="2884e-1684">However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</span></span> <span data-ttu-id="2884e-1685">在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="2884e-1685">In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</span></span> <span data-ttu-id="2884e-1686">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1686">Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</span></span> <span data-ttu-id="2884e-1687">比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</span><span class="sxs-lookup"><span data-stu-id="2884e-1687">For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</span></span> <span data-ttu-id="2884e-1688">第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。</span><span class="sxs-lookup"><span data-stu-id="2884e-1688">The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</span></span> <span data-ttu-id="2884e-1689">如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。</span><span class="sxs-lookup"><span data-stu-id="2884e-1689">If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 <span data-ttu-id="2884e-1690">如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。</span><span class="sxs-lookup"><span data-stu-id="2884e-1690">If the regular expression can match the empty string, <xref:System.Text.RegularExpressions.Regex.Split%2A> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</span></span>  
  
 <span data-ttu-id="2884e-1691">`matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。</span><span class="sxs-lookup"><span data-stu-id="2884e-1691">The `matchTimeout` parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</span></span> <span data-ttu-id="2884e-1692">如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1692">For more information, see [Best Practices for Regular Expressions](~/docs/standard/base-types/best-practices.md) and [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="2884e-1693">如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2884e-1693">If no match is found in that time interval, the method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2884e-1694">`matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="2884e-1694">`matchTimeout` overrides any default time-out value defined for the application domain in which the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1695">發生規則運算式剖析錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1695">A regular expression parsing error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1696">
            <paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1696">
              <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2884e-1697">
            <paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1697">
              <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</span>
          </span>
          <span data-ttu-id="2884e-1698">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1698">-or-</span>
          </span>
          <span data-ttu-id="2884e-1699">
            <paramref name="matchTimeout" /> 為負數、零或大約大於 24 天。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1699">
              <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">
          <span data-ttu-id="2884e-1700">發生逾時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1700">A time-out occurred.</span>
          </span>
          <span data-ttu-id="2884e-1701">如需逾時的詳細資訊，請參閱＜備註＞一節。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1701">For more information about time-outs, see the Remarks section.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="2884e-1702">
            <para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。不過，您應該停用逾時，只有在下列情況下:-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。這會排除已動態由使用者輸入的文字。 -當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。 -當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1702">
              <para>We recommend that you set the <paramref name="matchTimeout" /> parameter to an appropriate value, such as two seconds. If you disable time-outs by specifying <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, the regular expression engine offers slightly better performance. However, you should disable time-outs only under the following conditions:  -   When the input processed by a regular expression is derived from a known and trusted source or consists of static text. This excludes text that has been dynamically input by users.  -   When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.  -   When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">
          <span data-ttu-id="2884e-1703">要使用序列化資訊來填入的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1703">The object to populate with serialization information.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="2884e-1704">要儲存並擷取序列化資料的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1704">The place to store and retrieve serialized data.</span>
          </span>
          <span data-ttu-id="2884e-1705">這個參數保留給未來的版本使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1705">This parameter is reserved for future use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1706">將還原序列化目前 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件所需的資料填入 (Populate) <see cref="T:System.Text.RegularExpressions.Regex" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1706">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.RegularExpressions.Regex" /> object.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1707">傳回傳遞至 <see langword="Regex" /> 建構函式中的規則運算式模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1707">Returns the regular expression pattern that was passed into the <see langword="Regex" /> constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1708">
            <paramref name="pattern" /> 參數，傳遞至 <see langword="Regex" /> 建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1708">The <paramref name="pattern" /> parameter that was passed into the <see langword="Regex" /> constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1709">`pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</span><span class="sxs-lookup"><span data-stu-id="2884e-1709">The `pattern` parameter consists of regular expression language elements that symbolically describe the string to match.</span></span> <span data-ttu-id="2884e-1710">如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="2884e-1710">For more information about regular expressions, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md) and [Regular Expression Language - Quick Reference](~/docs/standard/base-types/regular-expression-language-quick-reference.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="2884e-1711">
            <para>
              <see cref="T:System.Text.RegularExpressions.Regex" /> 所建立的規則運算式的基底類別<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。這些編譯規則運算式使用<see cref="M:System.Text.RegularExpressions.Regex.ToString" />基底類別的實作。如果從衍生類別中，呼叫<see cref="M:System.Text.RegularExpressions.Regex.ToString" />方法會傳回字串傳遞給<paramref name="pattern" />參數<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />類別建構函式用來定義規則運算式。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1711">
              <para>
                <see cref="T:System.Text.RegularExpressions.Regex" /> is the base class of regular expressions created by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. These compiled regular expressions use the <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementation of the base class. If called from a derived class, the <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> method returns the string that was passed to the <paramref name="pattern" /> parameter of the <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> class constructor that was used to define the regular expression.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">
          <span data-ttu-id="2884e-1712">輸入字串，包含要轉換的文字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1712">The input string containing the text to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1713">轉換輸入字串中任何逸出的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1713">Converts any escaped characters in the input string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1714">字元字串，其中任何逸出字元轉換成其未逸出格式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1714">A string of characters with any escaped characters converted to their unescaped form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2884e-1715"><xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法會執行下列兩個轉換的其中一個：</span><span class="sxs-lookup"><span data-stu-id="2884e-1715">The <xref:System.Text.RegularExpressions.Regex.Unescape%2A> method performs one of the following two transformations:</span></span>  
  
-   <span data-ttu-id="2884e-1716">它會反轉所執行的轉換<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法，藉由移除逸出字元 ("\\」) 從逸出方法的每個字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1716">It reverses the transformation performed by the <xref:System.Text.RegularExpressions.Regex.Escape%2A> method by removing the escape character ("\\") from each character escaped by the method.</span></span> <span data-ttu-id="2884e-1717">其中包括\\，\*，+，？， &#124;，{，[，（、）、 ^、 $、。，# 和空白字元。</span><span class="sxs-lookup"><span data-stu-id="2884e-1717">These include the \\, \*, +, ?, &#124;, {, [, (,), ^, $,., #, and white space characters.</span></span> <span data-ttu-id="2884e-1718">颾魤 ㄛ<xref:System.Text.RegularExpressions.Regex.Unescape%2A>右括號 (]) 和結尾括號 （}） 字元，不逸出方法。</span><span class="sxs-lookup"><span data-stu-id="2884e-1718">In addition, the <xref:System.Text.RegularExpressions.Regex.Unescape%2A> method unescapes the closing bracket (]) and closing brace (}) characters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2884e-1719"><xref:System.Text.RegularExpressions.Regex.Unescape%2A> 無法回復的逸出的字串完全無法推算精確已逸出字元因為</span><span class="sxs-lookup"><span data-stu-id="2884e-1719"><xref:System.Text.RegularExpressions.Regex.Unescape%2A> cannot reverse an escaped string perfectly because it cannot deduce precisely which characters were escaped,</span></span>  
  
-   <span data-ttu-id="2884e-1720">它會將不可列印字元的表示法取代字元本身。</span><span class="sxs-lookup"><span data-stu-id="2884e-1720">It replaces the representation of unprintable characters with the characters themselves.</span></span> <span data-ttu-id="2884e-1721">比方說，它會取代 \a \x07。</span><span class="sxs-lookup"><span data-stu-id="2884e-1721">For example, it replaces \a with \x07.</span></span> <span data-ttu-id="2884e-1722">它會取代字元表示法是 \a、 \b、 \e、 \n、 \r、 \f、 \t 和 \v。</span><span class="sxs-lookup"><span data-stu-id="2884e-1722">The character representations it replaces are \a, \b, \e, \n, \r, \f, \t, and \v.</span></span>  
  
 <span data-ttu-id="2884e-1723">如果<xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法遇到其他逸出序列無法轉換，例如 \w 或 \s，就會擲回<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="2884e-1723">If the <xref:System.Text.RegularExpressions.Regex.Unescape%2A> method encounters other escape sequences that it cannot convert, such as \w or \s, it throws an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2884e-1724">
            <paramref name="str" /> 包含無法辨認的逸出序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1724">
              <paramref name="str" /> includes an unrecognized escape sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2884e-1725">
            <paramref name="str" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1725">
              <paramref name="str" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1726">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1726">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1727">如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 屬性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 選項，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1727">
              <see langword="true" /> if the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property contains the <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2884e-1728">由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1728">Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2884e-1729">如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 屬性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 選項，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1729">
              <see langword="true" /> if the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property contains the <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> option; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">
          <span data-ttu-id="2884e-1730">要檢查的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1730">The time-out interval to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2884e-1731">檢查逾時間隔是否在可接受的範圍內。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2884e-1731">Checks whether a time-out interval is within an acceptable range.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>