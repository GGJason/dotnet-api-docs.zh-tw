<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Regex.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07fd2ccb43296a43eb9c1de7114e0d688441835233.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fd2ccb43296a43eb9c1de7114e0d688441835233</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Represents an immutable regular expression.</source>
          <target state="translated">表示不變的規則運算式 (Regular Expression)。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class represents the .NET Framework's regular expression engine.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別代表.NET Framework 規則運算式引擎。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report.</source>
          <target state="translated">可用於快速剖析大量文字，尋找特定的字元模式;擷取、 編輯、 取代或刪除文字子字串;並將擷取的字串新增至集合，以產生報表。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your primary interest is to validate a string by determining whether it conforms to a particular pattern, you can use the <ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">如果您主要的優點是要判斷它是否符合特定模式來驗證字串，您可以使用<ph id="ph1">&lt;xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To use regular expressions, you define the pattern that you want to identify in a text stream by using the syntax documented in <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">若要使用規則運算式，您會定義您想要使用中所述的語法來識別文字資料流中的模式<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Next, you can optionally instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">接下來，您可以選擇性地具現化<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Finally, you call a method that performs some operation, such as replacing text that matches the regular expression pattern, or identifying a pattern match.</source>
          <target state="translated">最後，您可以呼叫執行某些作業，例如取代符合規則運算式模式的文字，或識別模式比對的方法。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For some common regular expression patterns, see <bpt id="p1">[</bpt>Regular Expression Examples<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>.</source>
          <target state="translated">某些常見的規則運算式模式，請參閱<bpt id="p1">[</bpt>規則運算式範例<ept id="p1">](~/docs/standard/base-types/regular-expression-examples.md)</ept>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>There are also a number of online libraries of regular expression patterns, such as the one at <bpt id="p1">[</bpt>Regular-Expressions.info<ept id="p1">](https://www.regular-expressions.info/examples.html)</ept>.</source>
          <target state="translated">另外還有數的規則運算式模式，例如在線上文件庫<bpt id="p1">[</bpt>一般 Expressions.info<ept id="p1">](https://www.regular-expressions.info/examples.html)</ept>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> For more information about using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class, see the following sections in this topic:</source>
          <target state="translated"><bpt id="p1">&lt;a name="remarks"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> 如需有關使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別，請參閱本主題中的下列各節：</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Regex vs. String Methods<ept id="p1">](#regex_vs_string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Regex vs。字串方法<ept id="p1">](#regex_vs_string)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Static vs. Instance Methods<ept id="p1">](#static_vs_instance)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>靜態與執行個體方法<ept id="p1">](#static_vs_instance)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Performing Regular Expression Operations<ept id="p1">](#regex_ops)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>執行規則運算式作業<ept id="p1">](#regex_ops)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Defining a Time-Out Value<ept id="p1">](#define_timeout)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>定義逾時值<ept id="p1">](#define_timeout)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the regular expression language, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> or download and print one of these brochures:</source>
          <target state="translated">如需規則運算式語言的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言 - 快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>，或下載並列印下列其中一本小手冊：</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in Word (.docx) format<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Word (.docx) 格式的快速參考<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Quick Reference in PDF (.pdf) format<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>PDF (.pdf) 格式的快速參考<ept id="p1">](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regex vs. String Methods</source>
          <target state="translated">Regex vs。字串方法</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class includes several search and comparison methods that you can use to perform pattern matching with text.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph>類別包含您可以使用執行模式比對文字的數個搜尋和比較方法。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> methods determine whether a string instance contains a specified substring; and the <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph> methods return the starting position of a specified substring in a string.</source>
          <target state="translated">例如， <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>，和<ph id="ph3">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph>方法，判斷字串執行個體是否包含指定的子字串; 而<ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph5">&lt;xref:System.String.IndexOfAny%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>，和<ph id="ph7">&lt;xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType&gt;</ph>方法會傳回字串中指定的子字串的開始位置。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the methods of the <ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class when you are searching for a specific string.</source>
          <target state="translated">使用的方法<ph id="ph1">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph>類別時，您要搜尋特定字串。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class when you are searching for a specific pattern in a string.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別時，您要搜尋特定的模式字串中。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information and examples, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊和範例，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>回註解<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Static vs. Instance Methods</source>
          <target state="translated">靜態與執行個體方法</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>After you define a regular expression pattern, you can provide it to the regular expression engine in either of two ways:</source>
          <target state="translated">定義規則運算式模式之後，您可以提供給規則運算式引擎在任一種方式：</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By instantiating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that represents the regular expression.</source>
          <target state="translated">藉由執行個體化<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>表示規則運算式物件。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To do this, you pass the regular expression pattern to a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">若要這樣做，您將傳遞至規則運算式模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%2A&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable; when you instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a regular expression, that object's regular expression cannot be changed.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件是不可變的; 當您具現化<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>規則運算式物件，無法變更物件的規則運算式。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By supplying both the regular expression and the text to search to a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> method.</source>
          <target state="translated">藉由提供規則運算式和要搜尋的文字<ph id="ph1">`static`</ph>(<ph id="ph2">`Shared`</ph>在 Visual Basic 中)<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This enables you to use a regular expression without explicitly creating a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">這可讓您使用規則運算式，而不需要明確建立<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>All <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> pattern identification methods include both static and instance overloads.</source>
          <target state="translated">所有<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>模式識別方法包含靜態和執行個體的多載。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression engine must compile a particular pattern before the pattern can be used.</source>
          <target state="translated">規則運算式引擎必須編譯特定模式，才能使用此模式。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects are immutable, this is a one-time procedure that occurs when a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor or a static method is called.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件是不變，這是一次性程序，就會發生時<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>呼叫類別建構函式或靜態方法。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To eliminate the need to repeatedly compile a single regular expression, the regular expression engine caches the compiled regular expressions used in static method calls.</source>
          <target state="translated">若要消除重複編譯單一規則運算式的需要，規則運算式引擎會快取靜態方法呼叫中所編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As a result, regular expression pattern-matching methods offer comparable performance for static and instance methods.</source>
          <target state="translated">如此一來，規則運算式模式比對方法提供相當的效能，針對靜態和執行個體方法。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the .NET Framework versions 1.0 and 1.1, all compiled regular expressions, whether they were used in instance or static method calls, were cached.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版，全都編譯規則運算式，是否使用這些認證執行個體或靜態方法中呼叫，快取。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the .NET Framework 2.0, only regular expressions used in static method calls are cached.</source>
          <target state="translated">從.NET Framework 2.0 開始，只有在靜態方法呼叫中使用的規則運算式會快取。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, caching can adversely affect performance in the following two cases:</source>
          <target state="translated">不過，快取效能造成不良影響下列兩個案例中：</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you use static method calls with a large number of regular expressions.</source>
          <target state="translated">當您使用靜態方法呼叫，且含有大量規則運算式。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By default, the regular expression engine caches the 15 most recently used static regular expressions.</source>
          <target state="translated">根據預設，規則運算式引擎會快取 15 個最近使用靜態規則運算式。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If your application uses more than 15 static regular expressions, some regular expressions must be recompiled.</source>
          <target state="translated">如果您的應用程式會使用超過 15 個靜態規則運算式中，某些規則運算式就必須重新編譯。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent this recompilation, you can increase the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">若要避免此重新編譯，您可以增加<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When you instantiate new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> objects with regular expressions that have previously been compiled.</source>
          <target state="translated">當您具現化新<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>使用先前已編譯的規則運算式物件。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For example, the following code defines a regular expression to locate duplicated words in a text stream.</source>
          <target state="translated">例如，下列程式碼定義規則運算式，在文字資料流中找到重複的文字。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Although the example uses a single regular expression, it instantiates a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object to process each line of text.</source>
          <target state="translated">雖然此範例會使用單一規則運算式，它會具現化新<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件以處理每一行文字。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This results in the recompilation of the regular expression with each iteration of the loop.</source>
          <target state="translated">這會導致重新編譯的規則運算式與迴圈的每個反覆項目。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent recompilation, you should instantiate a single <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object that is accessible to all code that requires it, as shown in the following rewritten example.</source>
          <target state="translated">若要避免重新編譯，您應該具現化單一<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>均可存取所有的程式碼時需要它，改寫下列範例所示的物件。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>回註解<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Performing Regular Expression Operations</source>
          <target state="translated">執行規則運算式作業</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Whether you decide to instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object and call its methods or call static methods, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class offers the following pattern-matching functionality:</source>
          <target state="translated">您是否決定具現化<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件，並呼叫其方法或呼叫靜態方法，<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別提供了下列的模式比對功能：</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Validation of a match.</source>
          <target state="translated">驗證的相符項目。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method to determine whether a match is present.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph>方法，以判斷是否有相符項目。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of a single match.</source>
          <target state="translated">擷取單一相符項目。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that represents the first match in a string or in part of a string.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph>方法來擷取<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件，表示字串或部分字串的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Subsequent matches can be retrieved by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">可以藉由呼叫擷取後續相符項目的<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Retrieval of all matches.</source>
          <target state="translated">擷取所有相符項目。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph> object that represents all the matches found in a string or in part of a string.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法來擷取<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType&gt;</ph>物件，代表找到的字串或字串的部分的所有相符項目。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Replacement of matched text.</source>
          <target state="translated">取代相符的文字。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> method to replace matched text.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph>方法，以取代相符的文字。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The replacement text can also be defined by a regular expression.</source>
          <target state="translated">取代文字，也可以定義規則運算式。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition, some of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph> methods include a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> parameter that enables you to programmatically define the replacement text.</source>
          <target state="translated">此外，某些<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A&gt;</ph>方法包括<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>參數，可讓您以程式設計方式定義取代文字。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Creation of a string array that is formed from parts of an input string.</source>
          <target state="translated">建立從輸入字串的組件的正確的字串陣列。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> method to split an input string at positions that are defined by the regular expression.</source>
          <target state="translated">您呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法來分割輸入的字串，在規則運算式所定義的位置。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In addition to its pattern-matching methods, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class includes several special-purpose methods:</source>
          <target state="translated">其模式比對的方法，除了<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別包含數種特殊用途的方法：</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes any characters that may be interpreted as regular expression operators in a regular expression or input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法會逸出任何可能會解譯為規則運算式或輸入的字串中的規則運算式運算子的字元。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method removes these escape characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph>方法會移除這些逸出字元。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method creates an assembly that contains predefined regular expressions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph>方法會建立包含預先定義的規則運算式的組件。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework contains examples of these special-purpose assemblies in the <ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph> namespace.</source>
          <target state="translated">.NET Framework 中包含這些特殊用途的組件中的範例<ph id="ph1">&lt;xref:System.Web.RegularExpressions?displayProperty=nameWithType&gt;</ph>命名空間。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>回註解<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Defining a Time-Out Value</source>
          <target state="translated">定義逾時值</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The .NET Framework supports a full-featured regular expression language that provides substantial power and flexibility in pattern matching.</source>
          <target state="translated">.NET Framework 支援的功能完整的規則運算式語言提供大幅的功能及彈性在模式比對。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, the power and flexibility come at a cost: the risk of poor performance.</source>
          <target state="translated">不過，功能與彈性有其代價： 效能不佳的風險。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Regular expressions that perform poorly are surprisingly easy to create.</source>
          <target state="translated">執行效能很差的規則運算式是很容易建立。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In some cases, regular expression operations that rely on excessive backtracking can appear to stop responding when they process text that nearly matches the regular expression pattern.</source>
          <target state="translated">在某些情況下，可能會依賴大量回溯規則運算式作業停止回應時，它們會處理幾乎符合規則運算式模式的文字。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about the .NET Framework regular expression engine, see <bpt id="p1">[</bpt>Details of Regular Expression Behavior<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>.</source>
          <target state="translated">如需.NET Framework 規則運算式引擎的詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式行為的詳細資料<ept id="p1">](~/docs/standard/base-types/details-of-regular-expression-behavior.md)</ept>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information about excessive backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需大量回溯的詳細資訊，請參閱<bpt id="p1">[</bpt>回溯<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can define a time-out interval for regular expression matches.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>，您可以定義逾時間隔，規則運算式相符項目。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the regular expression engine cannot identify a match within this time interval, the matching operation throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">如果規則運算式引擎無法識別符合此時間間隔內，比對作業會擲回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In most cases, this prevents the regular expression engine from wasting processing power by trying to match text that nearly matches the regular expression pattern.</source>
          <target state="translated">在大部分情況下，如此可防止規則運算式引擎嘗試比對幾乎符合規則運算式模式的文字所浪費的處理能力。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>It also could indicate, however, that the timeout interval has been set too low, or that the current machine load has caused an overall degradation in performance.</source>
          <target state="translated">它也可能表示，不過的逾時間隔已設定太低，或是目前機器工作負載的效能，導致整體的降低。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>How you handle the exception depends on the cause of the exception.</source>
          <target state="translated">處理例外狀況的方式取決於例外狀況的原因。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the time-out interval is set too low or because of excessive machine load, you can increase the time-out interval and retry the matching operation.</source>
          <target state="translated">如果因為逾時間隔設定太低，就會發生例外狀況或因為過多的機器工作負載，您可以增加逾時間隔並重試比對作業。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the exception occurs because the regular expression relies on excessive backtracking, you can assume that a match does not exist, and, optionally, you can log information that will help you modify the regular expression pattern.</source>
          <target state="translated">因為規則運算式會依賴大量回溯，就會發生例外狀況，您可以假設相符項目不存在，以及 （選擇性） 您可以記錄資訊可協助您修改規則運算式模式。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set a time-out interval by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor when you instantiate a regular expression object.</source>
          <target state="translated">您可以藉由呼叫設定逾時間隔<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>建構函式，當您具現化規則運算式物件。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For static methods, you can set a time-out interval by calling an overload of a matching method that has a <ph id="ph1">`matchTimeout`</ph> parameter.</source>
          <target state="translated">靜態方法，您可以設定逾時間隔，藉由呼叫的比對方法的多載<ph id="ph1">`matchTimeout`</ph>參數。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If you do not set a time-out value explicitly, the default time-out value  is determined as follows:</source>
          <target state="translated">如果您未明確設定的逾時值，預設的逾時值是取決於下列條件：</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the application-wide time-out value, if one exists.</source>
          <target state="translated">使用全應用程式逾時的值，如果有一個存在。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This can be any time-out value that applies to the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is instantiated or the static method call is made.</source>
          <target state="translated">這可以是應用程式定義域，適用於任何逾時值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件具現化，或呼叫靜態方法。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>You can set the application-wide time-out value by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method to assign the string representation of a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value to the "REGEX_DEFAULT_MATCH_TIMEOUT" property.</source>
          <target state="translated">您可以設定整個應用程式的逾時值，藉由呼叫<ph id="ph1">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph>方法，以指定的字串表示<ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>"REGEX_DEFAULT_MATCH_TIMEOUT"屬性的值。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>By using the value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>, if no application-wide time-out value has been set.</source>
          <target state="translated">使用的值來<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>，如果已設定沒有整個應用程式的逾時值。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>We recommend that you set a time-out value in all regular expression pattern-matching operations.</source>
          <target state="translated">我們建議您在所有的規則運算式模式比對作業設定的逾時值。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><bpt id="p1">[</bpt>Back to Remarks<ept id="p1">](#remarks)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>回註解<ept id="p1">](#remarks)</ept></target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example uses a regular expression to check for repeated occurrences of words in a string.</source>
          <target state="translated">下列範例會使用規則運算式，檢查有重複出現的文字字串中。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The regular expression <ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph> can be interpreted as shown in the following table.</source>
          <target state="translated">規則運算式<ph id="ph1">`\b(?&lt;word&gt;\w+)\s+(\k&lt;word&gt;)\b`</ph>可以解譯為下表所示。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more word characters up to a word boundary.</source>
          <target state="translated">比對一個或多個文字字元，最多字邊界。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Name this captured group <ph id="ph1">`word`</ph>.</source>
          <target state="translated">將此擷取的群組命名<ph id="ph1">`word`</ph>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match one or more white-space characters.</source>
          <target state="translated">比對一個或多個空格字元。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the captured group that is named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">比對擷取的群組命名<ph id="ph1">`word`</ph>。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match a word boundary.</source>
          <target state="translated">比對字邊界。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The following example illustrates the use of a regular expression to check whether a string either represents a currency value or has the correct format to represent a currency value.</source>
          <target state="translated">下列範例說明如何使用規則運算式以檢查是否為字串表示貨幣值，或者具有正確格式來表示貨幣值。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression is built dynamically from the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties for the user's current culture.</source>
          <target state="translated">在此情況下，規則運算式，會動態建立從<ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>，和<ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph>使用者的目前文化特性的屬性。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>If the system's current culture is en-US, the resulting regular expression is <ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>.</source>
          <target state="translated">如果系統的目前文化特性是 EN-US，產生的規則運算式是<ph id="ph1">`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This regular expression can be interpreted as shown in the following table.</source>
          <target state="translated">下表所示，可以解譯這個規則運算式。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Start at the beginning of the string.</source>
          <target state="translated">在字串開頭開始。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">比對零個以上的空白字元。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of either the positive sign or the negative sign.</source>
          <target state="translated">比對零個或一個正號或負號。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one occurrence of the dollar sign.</source>
          <target state="translated">比對零個或一個貨幣符號。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one white-space character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or more decimal digits.</source>
          <target state="translated">比對零個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match zero or one decimal point symbol.</source>
          <target state="translated">比對零個或一個小數點符號。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match two decimal digits zero or one time.</source>
          <target state="translated">比對兩個十進位數字零或一次。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the pattern of integral and fractional digits separated by a decimal point symbol at least one time.</source>
          <target state="translated">比對整數和小數的位數，小數點符號分隔至少一次的模式。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Match the end of the string.</source>
          <target state="translated">比對字串的結尾。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In this case, the regular expression assumes that a valid currency string does not contain group separator symbols, and that it has either no fractional digits or the number of fractional digits defined by the current culture's <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph> property.</source>
          <target state="translated">在此情況下，規則運算式假設有效貨幣字串不包含群組分隔符號符號，而且它有沒有小數的數字或目前的文化特性所定義的小數位數<ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Because the regular expression in this example is built dynamically, we do not know at design time whether the current culture's currency symbol, decimal sign, or positive and negative signs might be misinterpreted by the regular expression engine as regular expression language operators.</source>
          <target state="translated">在此範例中的規則運算式，會動態建立，因為我們不知道在設計階段是否目前文化特性的貨幣符號、 小數符號或正的和負號可能會被錯誤解譯規則運算式引擎為規則運算式語言運算子。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>To prevent any misinterpretation, the example passes each dynamically generated string to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">若要防止任何的錯譯，範例會傳遞至每個動態產生的字串<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class is immutable (read-only) and thread safe.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>類別是不變 （唯讀） 和安全執行緒。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects can be created on any thread and shared between threads.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 可以在任何執行緒上建立和執行緒之間共用物件。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>For more information, see <bpt id="p1">[</bpt>Thread Safety<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>的執行緒安全<ept id="p1">](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor">
          <source>Note that this constructor is protected; it can only be called by classes derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">請注意，這個建構函式會保護;只可以呼叫的類別衍生自<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression.</source>
          <target state="translated">為指定的規則運算式初始化 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>主題。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph> constructor is equivalent to calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor with a value of <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph> for the <ph id="ph4">`options`</ph> argument.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29&gt;</ph>建構函式相當於呼叫<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>建構函式，其值為<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.None&gt;</ph>如<ph id="ph4">`options`</ph>引數。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern you define when you create it.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件是不可變的這表示它可以用僅適用於您定義您所建立的比對模式。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">不過，它可以單獨使用任意數目的時間而沒有重新編譯。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor instantiates a regular expression object that attempts a case-sensitive match of any alphabetical characters defined in <ph id="ph1">`pattern`</ph>.</source>
          <target state="translated">這個建構函式會嘗試定義中的任何字母字元的區分大小寫比對規則運算式物件具現化<ph id="ph1">`pattern`</ph>。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For a case-insensitive match, use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">不區分大小寫的比對中，使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的單字，"a"或"t"。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>Note that the regular expression pattern cannot match the word "The" at the beginning of the text, because comparisons are case-sensitive by default.</source>
          <target state="translated">請注意，規則運算式模式，無法比對的字"The"開頭的文字，因為比較會區分大小寫預設值。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>For an example of case-insensitive comparison, see the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor.</source>
          <target state="translated">例如不區分大小寫的比較中，請參閱<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">這個建構函式會建立<ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>會使用預設的逾時值，在其中建立的應用程式定義域的物件。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String)">
          <source>If a time-out value has not been defined for the application domain,  the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">如果尚未應用程式定義域定義逾時值<ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件會使用值<ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，這樣就不會逾時的作業。建立建議建構函式<ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件是<ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that contains a serialized pattern and <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> information.</source>
          <target state="translated">包含序列化模式和 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 資訊的物件。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination for this serialization.</source>
          <target state="translated">這個序列化的目的端。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(This parameter is not used; specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.)</source>
          <target state="translated">(不使用這個參數；請指定 <ph id="ph1">&lt;see langword="null" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class by using serialized data.</source>
          <target state="translated">使用序列化的資料，初始化 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The pattern that <ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 包含的模式為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> contains an invalid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 包含無效的 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 旗標。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">列舉值的位元組合，這些值會修改規則運算式。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern.</source>
          <target state="translated">使用會修改模式的選項，為指定的規則運算式初始化 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>主題。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match parameters you define when you create it.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件是不可變的這表示它可以用僅適用於您定義您所建立的比對參數。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">不過，它可以單獨使用任意數目的時間而沒有重新編譯。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates how to use this constructor to instantiate a regular expression that matches any word that begins with the letters "a" or "t".</source>
          <target state="translated">下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的單字，"a"或"t"。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Note that the match collection includes the word "The" that begins the text because the <ph id="ph1">`options`</ph> parameter has defined case-insensitive comparisons.</source>
          <target state="translated">請注意比對集合包含文字"The"開頭的文字，因為<ph id="ph1">`options`</ph>已定義參數不區分大小寫的比較。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> contains an invalid flag.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 包含無效的旗標。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This constructor creates a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object that uses the default time-out value of the application domain in which it is created.</source>
          <target state="translated">這個建構函式會建立<ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>會使用預設的逾時值，在其中建立的應用程式定義域的物件。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object uses the value <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the operation from timing out. The recommended constructor for creating a <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object is <ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">如果尚未應用程式定義域定義逾時值<ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件會使用值<ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，這樣就不會逾時的作業。建立建議建構函式<ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件是<ph id="ph4">&lt;see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that modify the regular expression.</source>
          <target state="translated">列舉值的位元組合，這些值會修改規則運算式。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</source>
          <target state="translated">針對指定的規則運算式，使用修改模式的選項，以及指定在逾時前模式比對方法應該嘗試比對的時間長度的值，初始化 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see the <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept> topics.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>主題。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is immutable, which means that it can be used only for the match pattern that you define when you create it.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件是不可變的這表示它可以用僅適用於您定義當您建立比對模式。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, it can be used any number of times without being recompiled.</source>
          <target state="translated">不過，它可以單獨使用任意數目的時間而沒有重新編譯。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern-matching method should try to find a match before it times out. If no match is found in that time interval, the pattern-matching method throws a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph>參數指定時間長度的模式比對方法應嘗試尋找相符項目，即會逾時。如果沒有找到符合該時間間隔中，會擲回的模式比對方法<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 覆寫任何預設逾時值為應用程式定義域，定義<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>建立物件。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The instance pattern-matching methods that observe the <ph id="ph1">`matchTimeout`</ph> time-out interval include the following:</source>
          <target state="translated">執行個體模式比對方法觀察<ph id="ph1">`matchTimeout`</ph>逾時間隔包括下列：</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated">設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>和<bpt id="p2">[</bpt>回溯<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To set a reasonable time-out interval, consider the following factors:</source>
          <target state="translated">若要設定的合理的逾時間隔，請考慮下列因素：</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The length and complexity of the regular expression pattern.</source>
          <target state="translated">長度與複雜度的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Longer and more complex regular expressions require more time than shorter and simpler ones.</source>
          <target state="translated">長、 更複雜的規則運算式會需要更多的時間比短且更簡單。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The expected machine load.</source>
          <target state="translated">預期的機器工作負載。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Processing takes more time on systems that have high CPU and memory utilization.</source>
          <target state="translated">在 CPU 和記憶體使用率過高的系統上處理花費的時間。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a time-out value of one second.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>建構函式來具現化<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>逾時值為一秒的物件。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`(a+)+$`</ph>會在行尾比對一個或多個 "a" 字元的一個或多個序列，並且受限於大量回溯。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> is thrown, the example increases the time-out value up to the maximum value of three seconds.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>會擲回，則範例會增加逾時值，最多三秒的最大值。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Otherwise, it abandons the attempt to match the pattern.</source>
          <target state="translated">否則，它會放棄嘗試比對模式。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</source>
          <target state="translated">取得或設定在已編譯規則運算式目前靜態快取中項目的最大數目。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The maximum number of entries in the static cache.</source>
          <target state="translated">靜態快取中項目的最大數目。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class maintains an internal cache of compiled regular expressions used in static method calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別會維護內部快取已編譯的規則運算式的靜態方法呼叫中使用。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>If the value specified in a set operation is less than the current cache size, cache entries are discarded until the cache size is equal to the specified value.</source>
          <target state="translated">如果在設定作業中指定的值小於目前的快取大小，快取項目都會被捨棄，直到快取大小是否等於指定的值。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>By default, the cache holds 15 compiled static regular expressions.</source>
          <target state="translated">根據預設，快取保存 15 編譯靜態規則運算式。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Your application typically will not have to modify the size of the cache.</source>
          <target state="translated">您的應用程式通常不會修改快取的大小。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph> property only when you want to turn off caching or when you have an unusually large cache.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CacheSize%2A&gt;</ph>屬性只有當您想要關閉 快取，或當您有非常大的快取。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>The value in a set operation is less than zero.</source>
          <target state="translated">設定作業中的值小於零。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>In the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, regular expressions used in both static and instance method calls were cached.</source>
          <target state="translated">在.NET Framework 之前<ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>、 使用中這兩個靜態規則運算式和快取執行個體方法呼叫。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CacheSize">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>, only regular expressions used in static method calls are cached.</source>
          <target state="translated">開頭為<ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph>、 規則只會快取靜態方法呼叫中使用的運算式。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capnames">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Gets or sets a dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">取得或設定字典，對應具名擷取群組及其索引值。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A dictionary that maps named capturing groups to their index values.</source>
          <target state="translated">對應具名擷取群組及其索引值的字典。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">請注意，這個屬性受到保護。它只能從衍生自的類別存取<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">設定作業會嘗試將指派給屬性的值<ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>物件; 如果這個轉換會失敗，則會呼叫<ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.CapNames">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">在設定作業中指派給 <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.CapNames" /&gt;</ph> 的屬性值是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.caps">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Gets or sets a dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">取得或設定字典，對應編號的擷取群組及其索引值。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A dictionary that maps numbered capturing groups to their index values.</source>
          <target state="translated">對應編號的擷取群組及其索引值的字典。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>Note that this property is protected; it can only be accessed from a class derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">請注意，這個屬性受到保護。它只能從衍生自的類別存取<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>A set operation attempts to convert the value assigned to the property to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object; if this conversion fails, it calls the <ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">設定作業會嘗試將指派給屬性的值<ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>物件; 如果這個轉換會失敗，則會呼叫<ph id="ph2">&lt;xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Caps">
          <source>The value assigned to the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> property in a set operation is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">在設定作業中指派給 <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Caps" /&gt;</ph> 的屬性值是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capsize">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.capslist">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Compiles regular expressions and saves them to disk in a single assembly.</source>
          <target state="translated">編譯規則運算式並將它們以單一組件 (Assembly) 儲存至磁碟。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">陣列，描述要編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The file name of the assembly.</source>
          <target state="translated">組件的檔案名稱。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly.</source>
          <target state="translated">將一個或多個指定的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件編譯為具名組件。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph>方法產生.NET Framework 組件中定義的每個規則運算式中<ph id="ph2">`regexinfos`</ph>陣列由類別。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">一般而言，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29&gt;</ph>方法從個別的應用程式會產生編譯的規則運算式的組件呼叫。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">每個規則運算式包含在組件具有下列特性：</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">它衍生自<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">它指派由所定義的完整限定的名稱<ph id="ph1">`fullnamespace`</ph>和<ph id="ph2">`name`</ph>參數對應<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">它有預設值 （或無參數） 建構函式。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The following example creates an assembly named RegexLib.dll.</source>
          <target state="translated">下列範例會建立名為 RegexLib.dll 組件。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">組件包含兩個已編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">首先， <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>，比對兩個相同的連續文字。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">第二個， <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>，會檢查字串是否具有正確的格式為電子郵件地址。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">然後具現化並使用下列範例會檢查重複的文字字串的規則運算式。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立組件） 的參考加入至專案。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 參數的 <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> 屬性值為空字串或 null 字串。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> 中一個或多個物件的規則運算式模式包含無效的語法。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">如果您正在開發具有的系統上<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>或其點發行版本安裝目標<ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，而且您使用<ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph>方法來建立包含的組件編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">嘗試使用其中一種規則運算式，因為在系統上的組件具有<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">若要解決這個問題，您可以執行下列任何一項操作：</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">建置組件，其中包含已在系統上編譯的規則運算式<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>而不是安裝的更新版本。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">而不是呼叫<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph>，擷取已編譯的規則運算式的組件時，使用靜態或執行個體<ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>方法<ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph>選項，當您具現化<ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件或呼叫規則運算式模式比對方法。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">陣列，描述要編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The file name of the assembly.</source>
          <target state="translated">組件的檔案名稱。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">陣列，定義要套用至組件的屬性。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects to a named assembly with the specified attributes.</source>
          <target state="translated">將一個或多個指定的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件編譯為具有指定之屬性的具名組件。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph2">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph>方法產生.NET Framework 組件中定義的每個規則運算式中<ph id="ph2">`regexinfos`</ph>陣列由類別。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph> method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">一般而言，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29&gt;</ph>方法從個別的應用程式會產生編譯的規則運算式的組件呼叫。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">每個規則運算式包含在組件具有下列特性：</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">它衍生自<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">它指派由所定義的完整限定的名稱<ph id="ph1">`fullnamespace`</ph>和<ph id="ph2">`name`</ph>參數對應<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">它有預設值 （或無參數） 建構函式。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph>方法會產生在方法呼叫，而不是使用特定語言的類別定義關鍵字的.NET Framework 組件 (例如<ph id="ph2">`class`</ph>在 C# 或<ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">在 Visual Basic 中)，所以不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated"><ph id="ph1">`attributes`</ph>參數提供的替代方法，用於定義套用至組件的屬性。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">針對每個您想要套用至組件的屬性，執行下列作業：</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">建立陣列<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表您想要呼叫的屬性建構函式的參數類型的物件。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">擷取<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表您想要套用至新的組件的屬性類別。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>方法屬性的<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，以擷取<ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>物件，代表您想要呼叫的屬性建構函式。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types.</source>
          <target state="translated">傳遞<ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>方法陣列的<ph id="ph2">&lt;xref:System.Type&gt;</ph>代表建構函式的參數類型的物件。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">建立<ph id="ph1">&lt;xref:System.Object&gt;</ph>陣列，定義要傳遞給該屬性的建構函式的參數。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">具現化<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>物件，並傳遞其建構函式<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>步驟 3 中所擷取的物件和<ph id="ph3">&lt;xref:System.Object&gt;</ph>在步驟 4 建立的陣列。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">接著，您可以將這些陣列<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>物件而不是<ph id="ph2">`attributes`</ph>參數<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The following example creates an assembly named RegexLib.dll and applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to it.</source>
          <target state="translated">下列範例會建立名為 RegexLib.dll 組件，並套用<ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The assembly includes two compiled regular expressions.</source>
          <target state="translated">組件包含兩個已編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The first, <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>, matches two identical contiguous words.</source>
          <target state="translated">首先， <ph id="ph1">`Utilities.RegularExpressions.DuplicatedString`</ph>，比對兩個相同的連續文字。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The second, <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>, checks whether a string has the correct format to be an email address.</source>
          <target state="translated">第二個， <ph id="ph1">`Utilities.RegularExpressions.EmailAddress`</ph>，會檢查字串是否具有正確的格式為電子郵件地址。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>You can verify that the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute has been applied to the assembly by examining its manifest with a reflection utility such as ILDasm.</source>
          <target state="translated">您可以確認<ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph>藉由檢查它的資訊清單，以反映公用程式，例如 ILDasm 屬性套用至組件。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression that checks a string for duplicate words is then instantiated and used by the following example.</source>
          <target state="translated">然後具現化並使用下列範例會檢查重複的文字字串的規則運算式。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Successful compilation of this second example requires a reference to RegexLib.dll (the assembly created by the first example) to be added to the project.</source>
          <target state="translated">成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立組件） 的參考加入至專案。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 參數的 <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> 屬性值為空字串或 null 字串。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> 中一個或多個物件的規則運算式模式包含無效的語法。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">如果您正在開發具有的系統上<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>或其點發行版本安裝目標<ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，而且您使用<ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph>方法來建立包含的組件編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">嘗試使用其中一種規則運算式，因為在系統上的組件具有<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">若要解決這個問題，您可以執行下列任何一項操作：</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">建置組件，其中包含已在系統上編譯的規則運算式<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>而不是安裝的更新版本。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">而不是呼叫<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph>，擷取已編譯的規則運算式的組件時，使用靜態或執行個體<ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>方法<ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph>選項，當您具現化<ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件或呼叫規則運算式模式比對方法。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that describes the regular expressions to compile.</source>
          <target state="translated">陣列，描述要編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file name of the assembly.</source>
          <target state="translated">組件的檔案名稱。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>An array that defines the attributes to apply to the assembly.</source>
          <target state="translated">陣列，定義要套用至組件的屬性。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The name of the Win32 resource file to include in the assembly.</source>
          <target state="translated">要包括在組件中的 Win32 資源檔的名稱。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Compiles one or more specified <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> objects and a specified resource file to a named assembly with the specified attributes.</source>
          <target state="translated">將一個或多個指定的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件和指定的資源檔編譯為具有指定之屬性的具名組件。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method generates a .NET Framework assembly in which each regular expression defined in the <ph id="ph3">`regexinfos`</ph> array is represented by a class.</source>
          <target state="translated">[<ph id="ph1">\]</ph>，AssemblyName、 CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; 方法會產生.NET Framework 組件中定義的每個規則運算式中<ph id="ph3">`regexinfos`</ph>陣列由類別。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Typically, the [<ph id="ph1">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method is called from a separate application that generates an assembly of compiled regular expressions.</source>
          <target state="translated">一般而言，[<ph id="ph1">\]</ph>，AssemblyName、 CustomAttributeBuilder<ph id="ph2">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; 方法呼叫從個別的應用程式會產生編譯的規則運算式的組件。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Each regular expression included in the assembly has the following characteristics:</source>
          <target state="translated">每個規則運算式包含在組件具有下列特性：</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is derived from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class.</source>
          <target state="translated">它衍生自<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It is assigned the fully qualified name that is defined by the <ph id="ph1">`fullnamespace`</ph> and <ph id="ph2">`name`</ph> parameters of its corresponding <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph> object.</source>
          <target state="translated">它指派由所定義的完整限定的名稱<ph id="ph1">`fullnamespace`</ph>和<ph id="ph2">`name`</ph>參數對應<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexCompilationInfo&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>It has a default (or parameterless) constructor.</source>
          <target state="translated">它有預設值 （或無參數） 建構函式。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Ordinarily, the code that instantiates and uses the compiled regular expression is found in an assembly or application that is separate from the code that creates the assembly.</source>
          <target state="translated">一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph> method generates a .NET Framework assembly from a method call instead of using a particular language's class definition keyword (such as <ph id="ph2">`class`</ph> in C# or <ph id="ph3">`Class`</ph>…<ph id="ph4">`End Class`</ph></source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A&gt;</ph>方法會產生在方法呼叫，而不是使用特定語言的類別定義關鍵字的.NET Framework 組件 (例如<ph id="ph2">`class`</ph>在 C# 或<ph id="ph3">`Class`</ph>...<ph id="ph4">`End Class`</ph></target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>in Visual Basic), it does not allow .NET Framework attributes to be assigned to the assembly by using the development language's standard attribute syntax.</source>
          <target state="translated">在 Visual Basic 中)，所以不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">`attributes`</ph> parameter provides an alternative method for defining the attributes that apply to the assembly.</source>
          <target state="translated"><ph id="ph1">`attributes`</ph>參數提供的替代方法，用於定義套用至組件的屬性。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>For each attribute that you want to apply to the assembly, do the following:</source>
          <target state="translated">針對每個您想要套用至組件的屬性，執行下列作業：</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing the parameter types of the attribute constructor that you want to call.</source>
          <target state="translated">建立陣列<ph id="ph1">&lt;xref:System.Type&gt;</ph>代表您想要呼叫的屬性建構函式的參數類型的物件。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Retrieve a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing the attribute class that you want to apply to the new assembly.</source>
          <target state="translated">擷取<ph id="ph1">&lt;xref:System.Type&gt;</ph>物件，代表您想要套用至新的組件的屬性類別。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method of the attribute <ph id="ph2">&lt;xref:System.Type&gt;</ph> object to retrieve a <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object representing the attribute constructor that you want to call.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>方法屬性的<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件，以擷取<ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>物件，代表您想要呼叫的屬性建構函式。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Pass the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method the array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects that represents the constructor's parameter types</source>
          <target state="translated">傳遞<ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>方法陣列的<ph id="ph2">&lt;xref:System.Type&gt;</ph>物件代表建構函式的參數類型</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Create a <ph id="ph1">&lt;xref:System.Object&gt;</ph> array that defines the parameters to pass to the attribute's constructor.</source>
          <target state="translated">建立<ph id="ph1">&lt;xref:System.Object&gt;</ph>陣列，定義要傳遞給該屬性的建構函式的參數。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instantiate a <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> object by passing its constructor the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object retrieved in step 3 and the <ph id="ph3">&lt;xref:System.Object&gt;</ph> array created in step 4.</source>
          <target state="translated">具現化<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>物件，並傳遞其建構函式<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>步驟 3 中所擷取的物件和<ph id="ph3">&lt;xref:System.Object&gt;</ph>在步驟 4 建立的陣列。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>You can then pass an array of these <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects instead of the <ph id="ph2">`attributes`</ph> parameter to the [<ph id="ph3">\]</ph>, AssemblyName, CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29&gt; method.</source>
          <target state="translated">接著，您可以將這些陣列<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>物件而不是<ph id="ph2">`attributes`</ph>參數 [<ph id="ph3">\]</ph>，AssemblyName、 CustomAttributeBuilder<ph id="ph4">\&lt;</ph>xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 &gt; 方法。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> parameter's <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> property is an empty or null string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 參數的 <ph id="ph2">&lt;see cref="P:System.Reflection.AssemblyName.Name" /&gt;</ph> 屬性值為空字串或 null 字串。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The regular expression pattern of one or more objects in <ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="regexinfos" /&gt;</ph> 中一個或多個物件的規則運算式模式包含無效的語法。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> or <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyname" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="regexinfos" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter designates an invalid Win32 resource file.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> 參數指定不正確的 Win32 資源檔。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>The file designated by the <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> parameter cannot be found.</source>
          <target state="translated">找不到 <ph id="ph1">&lt;paramref name="resourceFile" /&gt;</ph> 參數所指定的檔案。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>If you are developing on a system that has <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or its point releases installed, you target <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, and you use the <ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> method to create an assembly that contains compiled regular expressions.</source>
          <target state="translated">如果您正在開發具有的系統上<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>或其點發行版本安裝目標<ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，而且您使用<ph id="ph3">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph>方法來建立包含的組件編譯的規則運算式。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Trying to use one of the regular expressions in that assembly on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> throws an exception.</source>
          <target state="translated">嘗試使用其中一種規則運算式，因為在系統上的組件具有<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>To work around this problem, you can do either of the following:</source>
          <target state="translated">若要解決這個問題，您可以執行下列任何一項操作：</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Build the assembly that contains the compiled regular expressions on a system that has <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> instead of later versions installed.</source>
          <target state="translated">建置組件，其中包含已在系統上編譯的規則運算式<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>而不是安裝的更新版本。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)">
          <source>Instead of calling <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph> and retrieving the compiled regular expression from an assembly, use either static or instance <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> methods with the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option when you instantiate a <ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object or call a regular expression pattern matching method.</source>
          <target state="translated">而不是呼叫<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /&gt;</ph>，擷取已編譯的規則運算式的組件時，使用靜態或執行個體<ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>方法<ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph>選項，當您具現化<ph id="ph4">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph>物件或呼叫規則運算式模式比對方法。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The input string that contains the text to convert.</source>
          <target state="translated">輸入字串，包含要轉換的文字。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Escapes a minimal set of characters (<ph id="ph1">\\</ph>, *, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes.</source>
          <target state="translated">以逸出程式碼取代字元 (<ph id="ph1">\\</ph>、*、+、?、|、{、[、(、)、^、$、.、# 和空白字元) 的最小集合，以便逸出這些字元。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</source>
          <target state="translated">這樣會指示規則運算式引擎將這些字元解譯為常值，而非解譯為中繼字元。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>A string of characters with metacharacters converted to their escaped form.</source>
          <target state="translated">字元字串，其中中繼字元已轉換為逸出格式。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> converts a string so that the regular expression engine will interpret any metacharacters that it may contain as character literals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> 將字串轉換，讓規則運算式引擎會解譯為字元常值，它可以包含任何中繼字元。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For example, consider a regular expression that is designed to extract comments that are delimited by straight opening and closing brackets ([ and ]) from text.</source>
          <target state="translated">例如，請考慮為了擷取由直線左右方括號 （[和]） 從文字分隔的註解的規則運算式。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In the following example, the regular expression "[(.*?)]" is interpreted as a character class.</source>
          <target state="translated">在下列範例中，規則運算式 「 [(.*?)]"會解譯為字元類別。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Rather than matching comments embedded in the input text, the regular expression matches each opening or closing parenthesis, period, asterisk, or question mark.</source>
          <target state="translated">而不是比對輸入的文字中內嵌的註解，規則運算式比對每個左或右括號、 句號、 星號或問號。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>However, if the opening bracket is escaped by passing it to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method, the regular expression succeeds in matching comments that are embedded in the input string.</source>
          <target state="translated">不過，如果左括號會傳遞至逸出<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法時，規則運算式成功比對輸入字串中內嵌的註解。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example illustrates this.</source>
          <target state="translated">下列範例將說明這點。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined by using static text, characters that are to be interpreted literally rather than as metacharacters can be escaped by preceding them with a backslash symbol (<ph id="ph1">\\</ph>) as well as by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method.</source>
          <target state="translated">在使用靜態文字定義規則運算式中，要解譯為字面意義，而不是為中繼字元的字元可以逸出前加上反斜線符號 (<ph id="ph1">\\</ph>) 以及透過呼叫<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In a regular expression that is defined dynamically using characters that are not known at design time, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method is particularly important to ensure that the regular expression engine interprets individual characters as literals rather than as metacharacters.</source>
          <target state="translated">使用在設計階段未知的字元，以動態方式定義的規則運算式中呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法是特別重要，以確保，規則運算式引擎會解譯個別字元當做常值而不是比為中繼字元。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a regular expression pattern includes either the number sign (#) or literal white-space characters, they must be escaped if input text is parsed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option enabled.</source>
          <target state="translated">如果規則運算式模式包含數字符號 （#） 或常值空白字元，則必須逸出如果輸入的文字會剖析具有<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph>啟用選項。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>While the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method escapes the straight opening bracket ([) and opening brace ({) characters, it does not escape their corresponding closing characters (] and }).</source>
          <target state="translated">雖然<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法會逸出直線開啟括號 ([)，並開啟括號 （{） 字元，它不會逸出其對應的結尾字元 (] 和})。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In most cases, escaping these is not necessary.</source>
          <target state="translated">在大部分情況下，逸出這些不需要。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If a closing bracket or brace is not preceded by its corresponding opening character, the regular expression engine interprets it literally.</source>
          <target state="translated">如果右括號或大括號前面沒有其相對應的開頭字元，規則運算式引擎會將它解譯常值。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If an opening braket or brace is interpreted as a metacharacter, the regular expression engine interprets the first corresponding closing character as a metacharacter.</source>
          <target state="translated">如果開啟 braket 或大括號會解譯為中繼字元中，規則運算式引擎會解譯第一個對應的結尾字元做為中繼字元。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If this is not the desired behavior, the closing bracket or brace should be escaped by explicitly prepending the backslash (<ph id="ph1">\\</ph>) character.</source>
          <target state="translated">如果不想要的行為，右括號或大括號應該逸出的明確前面加上反斜線 (<ph id="ph1">\\</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>For an illustration, see the Example section.</source>
          <target state="translated">如需圖例，請參閱 &lt; 範例 &gt; 一節。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>The following example extracts comments from text.</source>
          <target state="translated">下列範例會從文字擷取註解。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>It assumes that the comments are delimited by a begin comment symbol and an end comment symbol that is selected by the user.</source>
          <target state="translated">它會假設註解以開始註解符號和使用者會選取結束註解符號分隔。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Because the comment symbols are to be interpreted literally, they are passed to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method to ensure that they cannot be misinterpreted as metacharacters.</source>
          <target state="translated">註解符號要解譯為常值，因為它們會傳遞至<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法，以確保，它們不能被錯誤解譯為中繼字元。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>In addition, the example explicitly checks whether the end comment symbol entered by the user is a closing bracket (]) or brace (}).</source>
          <target state="translated">此外，範例明確檢查使用者輸入的註解結束符號是否為右括號 (]) 或大括號 （}）。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>If it is, a backslash character (<ph id="ph1">\\</ph>) is prepended to the bracket or brace so that it is interpreted literally.</source>
          <target state="translated">如果是，反斜線字元 (<ph id="ph1">\\</ph>) 前面加上括號或大括號，所以它解譯為常值。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source>Note that the example also uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> collection to display the comment only, rather than the comment together with its opening and closing comment symbols.</source>
          <target state="translated">請注意，此範例也會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph>顯示註解，而不是其開頭和結尾的註解符號以及註解的集合。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Escape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.factory">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Returns an array of capturing group names for the regular expression.</source>
          <target state="translated">傳回規則運算式的擷取群組名稱的陣列。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>A string array of group names.</source>
          <target state="translated">群組名稱的字串陣列。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The collection of group names contains the set of strings used to name capturing groups in the expression.</source>
          <target state="translated">群組名稱的集合包含用來在運算式中的擷取群組命名的字串集合。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Even if capturing groups are not explicitly named, they are automatically assigned numerical names ("0", "1", "2", "3", and so on).</source>
          <target state="translated">即使沒有明確命名的擷取群組，它們會自動指派數值的名稱 （"0"、"1"、"2"、"3"，等等）。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The "0" named group represents all text matched by the regular expression pattern.</source>
          <target state="translated">"0"具名群組代表規則運算式模式比對所有文字。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Numbered groups precede explicitly named groups in the collection, and named groups appear in the order in which they are defined in the regular expression pattern.</source>
          <target state="translated">編號的群組之前明確命名的群組集合中，而且具名的群組會出現在規則運算式模式中定義的順序。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>You can use the <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property on the array returned by this method to determine the number of groups in a regular expression.</source>
          <target state="translated">您可以使用<ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph>屬性上傳回此方法，以判斷在規則運算式中的群組數目的陣列。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following example defines a general-purpose <ph id="ph1">`ShowMatches`</ph> method that displays the names of regular expression groups and their matched text.</source>
          <target state="translated">下列範例會定義一般用途<ph id="ph1">`ShowMatches`</ph>顯示群組的名稱的規則運算式，其相符的文字的方法。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>In this case, the regular expression pattern <ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph> is intended to parse a simple sentence, and to identify its first word, last word, and ending punctuation mark.</source>
          <target state="translated">在此情況下，規則運算式模式<ph id="ph1">`\b(?&lt;FirstWord&gt;\w+)\s?((\w+)\s)*(?&lt;LastWord&gt;\w+)?(?&lt;Punctuation&gt;\p{Po})`</ph>旨在剖析簡單的句子，並識別其第一個單字、 最後一個字，以及結束的標點符號。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>The following table shows how the regular expression pattern is interpreted:</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式：</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`FirstWord`</ph> named group.</source>
          <target state="translated">這是<ph id="ph1">`FirstWord`</ph>具名群組。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s?</source>
          <target state="translated">\s 嗎？</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one white-space characters.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(\w+)</source>
          <target state="translated">(\w+)</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>\s</source>
          <target state="translated">\s</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a white-space character.</source>
          <target state="translated">比對空白字元。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>((\w+)\s)*</source>
          <target state="translated">((\w+)\s)*</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or more occurrences of one or more word characters followed by a white space.</source>
          <target state="translated">比對一個或多個文字字元後面接著空白字元的零或多個相符項目。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>LastWord&gt;\w+)?</source>
          <target state="translated">(?<ph id="ph1">\&lt;</ph>LastWord &gt; \w+)？</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match zero or one occurrence of one or more word characters.</source>
          <target state="translated">比對零個或一個的一或多個文字字元。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`LastWord`</ph> named group.</source>
          <target state="translated">這是<ph id="ph1">`LastWord`</ph>具名群組。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>(?<ph id="ph1">\&lt;</ph>Punctuation&gt;\p{Po})</source>
          <target state="translated">(?<ph id="ph1">\&lt;</ph>標點符號 &gt; \p{Po})</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>Match a character whose Unicode category is Punctuation, Other.</source>
          <target state="translated">比對的字元的 Unicode 分類為標點符號，其他。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNames">
          <source>This is the <ph id="ph1">`Punctuation`</ph> named group.</source>
          <target state="translated">這是<ph id="ph1">`Punctuation`</ph>具名群組。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Returns an array of capturing group numbers that correspond to group names in an array.</source>
          <target state="translated">傳回對應陣列中群組名稱的擷取群組編號的陣列。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>An integer array of group numbers.</source>
          <target state="translated">群組編號的整數陣列。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Both unnamed and named capturing groups can be accessed by number.</source>
          <target state="translated">未具名和具名擷取群組可以存取數字。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Unnamed groups are numbered from left to right starting with 1.</source>
          <target state="translated">未命名的群組會從左到右從 1 開始編號。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>(The capturing group in index 0 (zero) represents the match as a whole.)  Named groups are then numbered from left to right starting with a number that is one greater than the number of unnamed capturing groups.</source>
          <target state="translated">（索引 0 （零） 中的擷取群組會代表比對整個）。具名的群組然後從使用的數字大一開始由左至右編號數目未具名擷取群組。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Referencing a group by its number instead of by string name can provide faster access.</source>
          <target state="translated">依字串名稱參考 group by 而不是其數目可以提供更快的存取。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The following example defines a regular expression, <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>, that matches a sentence.</source>
          <target state="translated">下列範例會定義規則運算式， <ph id="ph1">`\b((?&lt;word&gt;\w+)\s*)+(?&lt;end&gt;[.?!])`</ph>，符合句子。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression includes three capturing groups: an unnamed group that captures an individual word along with a space character that may follow it; a group named <ph id="ph1">`word`</ph> that captures the individual words in the sentence; and a group named <ph id="ph2">`end`</ph> that captures the punctuation that ends the sentence.</source>
          <target state="translated">規則運算式包含三個擷取群組： 未命名的群組，這會擷取個別的字，空格字元，它可能會遵照; 以及名為群組<ph id="ph1">`word`</ph>可擷取句子; 中的個別字與群組命名為<ph id="ph2">`end`</ph>可擷取結束句子的標點符號。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph> method to get the numbers of all capturing groups, and then displays their captured string.</source>
          <target state="translated">範例會呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A&gt;</ph>方法來取得所有擷取的數字群組，然後顯示 擷取的字串。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method is used to indicate whether a particular numbered group corresponds to a named group.</source>
          <target state="translated">此外，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph>方法用來表示特定編號的群組是否對應至具名的群組。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式模式的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match one or more word characters and assign the matched strings to a group named <ph id="ph1">`word`</ph>.</source>
          <target state="translated">比對一個或多個文字字元，並將相符的字串指派給群組，名為<ph id="ph1">`word`</ph>。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match zero or more white-space characters.</source>
          <target state="translated">比對零個以上的空白字元。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the <ph id="ph1">`word`</ph> captured group followed by any captured white-space characters to the first captured group.</source>
          <target state="translated">指派<ph id="ph1">`word`</ph>後面接著任何擷取的群組所擷取的第一個擷取群組的空格字元。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match the pattern of one or more word characters followed by any white-space characters one or more times.</source>
          <target state="translated">比對後面接著空白字元的任何字元一或多次的一個或多個文字字元的模式。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Match a period, question mark, or exclamation point.</source>
          <target state="translated">比對句號、問號或驚嘆號。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GetGroupNumbers">
          <source>Assign the matched character to the <ph id="ph1">`end`</ph> capturing group.</source>
          <target state="translated">指定要比對的字元<ph id="ph1">`end`</ph>擷取群組。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The group number to convert to the corresponding group name.</source>
          <target state="translated">要轉換至對應群組名稱的群組編號。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Gets the group name that corresponds to the specified group number.</source>
          <target state="translated">取得對應指定群組編號的群組名稱。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A string that contains the group name associated with the specified group number.</source>
          <target state="translated">字串，含有與指定群組編號相關聯的群組名稱。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If there is no group name that corresponds to <ph id="ph1">&lt;paramref name="i" /&gt;</ph>, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">如果沒有對應 <ph id="ph1">&lt;paramref name="i" /&gt;</ph> 的群組名稱，方法會傳回 <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">編號的群組會分隔語法 (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>)，系統會指派數字，根據規則運算式的順序。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">具名的群組會分隔語法 (？<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>名稱<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) 或 (？ '<bpt id="p3">*</bpt>名稱<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>)，其中<bpt id="p5">*</bpt>名稱<ept id="p5">*</ept>是子運算式會識別的名稱。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">(如需詳細資訊，請參閱<bpt id="p1">[</bpt>群組建構<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>。)<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph>方法識別命名的群組和編號的群組，依據它們在規則運算式中的序數位置。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">序數位置 0 一律代表整個規則運算式。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">所有編號群組則會計算前具名群組，不論它們在規則運算式模式中的實際位置。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of a named group, the method returns the name of the group.</source>
          <target state="translated">如果<ph id="ph1">`i`</ph>是數字的具名群組，方法會傳回群組的名稱。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is the number of an unnamed group, the method returns the string representation of the number.</source>
          <target state="translated">如果<ph id="ph1">`i`</ph>是數字的未命名的群組，方法會傳回數字的字串表示。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>For example, if <ph id="ph1">`i`</ph> is 1, the method returns "1".</source>
          <target state="translated">例如，如果<ph id="ph1">`i`</ph>為 1，則方法會傳回"1"。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If <ph id="ph1">`i`</ph> is not the number of a capturing group, the method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`i`</ph>不是數的擷取群組，則方法會傳回<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>If a pattern match is found, the value returned by this method can then be used to retrieve the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object that represents the captured group from the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">如果找到模式比對，這個方法所傳回的值再用來擷取<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph>物件，代表擷取的群組從<ph id="ph2">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>物件由<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following example defines a regular expression pattern that matches an address line containing a U.S. city name, state name, and zip code.</source>
          <target state="translated">下列範例會定義符合包含美國縣 （市） 名稱、 狀態名稱和郵遞區號地址的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph> method to retrieve the names of capturing groups.</source>
          <target state="translated">此範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A&gt;</ph>方法來擷取的擷取群組的名稱。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>It then uses these names to retrieve the corresponding captured groups for matches.</source>
          <target state="translated">然後，它會使用這些名稱來擷取對應的擷取的群組相符項目。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">下列的運算式所定義的規則運算式模式：</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match one or more alphabetic or white-space character.</source>
          <target state="translated">比對一個或多個字母或空格字元。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`city`</ph>.</source>
          <target state="translated">將此擷取的群組名稱的指派<ph id="ph1">`city`</ph>。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match a comma (,) followed by a white-space character.</source>
          <target state="translated">比對後面接著空白字元的逗號 （，）。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match two alphabetic characters.</source>
          <target state="translated">比對兩個字母的字元。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`state`</ph>.</source>
          <target state="translated">將此擷取的群組名稱的指派<ph id="ph1">`state`</ph>。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>This group should be followed by a white-space character.</source>
          <target state="translated">此群組後面必須接著空格字元。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Match five numeric digits followed by either zero or one occurrence of a hyphen followed by four digits.</source>
          <target state="translated">比對後面接著零個或一個出現的連字號後面接著四個的數字的五個數字。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)">
          <source>Assign this captured group the name <ph id="ph1">`zip`</ph>.</source>
          <target state="translated">將此擷取的群組名稱的指派<ph id="ph1">`zip`</ph>。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group name to convert to the corresponding group number.</source>
          <target state="translated">群組名稱，要轉換至對應群組編號的。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Returns the group number that corresponds to the specified group name.</source>
          <target state="translated">傳回對應指定群組名稱的群組編號。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The group number that corresponds to the specified group name, or -1 if <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid group name.</source>
          <target state="translated">對應指定群組名稱的群組編號；如果 <ph id="ph1">&lt;paramref name="name" /&gt;</ph> 不是有效的群組名稱，則為 -1。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>A regular expression pattern may contain either named or numbered capturing groups, which delineate subexpressions within a pattern match.</source>
          <target state="translated">規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Numbered groups are delimited by the syntax (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>) and are assigned numbers based on their order in the regular expression.</source>
          <target state="translated">編號的群組會分隔語法 (<bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>)，系統會指派數字，根據規則運算式的順序。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Named groups are delimited by the syntax (?<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>name<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) or (?'<bpt id="p3">*</bpt>name<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>), where <bpt id="p5">*</bpt>name<ept id="p5">*</ept> is the name by which the subexpression will be identified.</source>
          <target state="translated">具名的群組會分隔語法 (？<ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>名稱<ept id="p1">*</ept><ph id="ph2">`&gt;`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>) 或 (？ '<bpt id="p3">*</bpt>名稱<ept id="p3">*</ept>'<bpt id="p4">*</bpt>subexpression<ept id="p4">*</ept>)，其中<bpt id="p5">*</bpt>名稱<ept id="p5">*</ept>是子運算式會識別的名稱。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>(For more information, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.) The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph> method identifies both named groups and numbered groups by their ordinal positions in the regular expression.</source>
          <target state="translated">(如需詳細資訊，請參閱<bpt id="p1">[</bpt>群組建構<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>。)<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A&gt;</ph>方法識別命名的群組和編號的群組，依據它們在規則運算式中的序數位置。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>Ordinal position zero always represents the entire regular expression.</source>
          <target state="translated">序數位置 0 一律代表整個規則運算式。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>All numbered groups are then counted before named groups, regardless of their actual position in the regular expression pattern.</source>
          <target state="translated">所有編號群組則會計算前具名群組，不論它們在規則運算式模式中的實際位置。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> is the string representation of a group number that is present in the regular expression pattern, the method returns that number.</source>
          <target state="translated">如果<ph id="ph1">`name`</ph>是出現在規則運算式模式中，則方法會傳回數字的群組數字的字串表示。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> corresponds to a named capturing group that is present in the regular expression pattern, the method returns its corresponding number.</source>
          <target state="translated">如果<ph id="ph1">`name`</ph>對應至具名擷取群組會出現在規則運算式模式，方法會傳回其對應的數字。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>The comparison of <ph id="ph1">`name`</ph> with the group name is case-sensitive.</source>
          <target state="translated">比較的<ph id="ph1">`name`</ph>與群組名稱會區分大小寫。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source>If <ph id="ph1">`name`</ph> does not correspond to the name of a capturing group or to the string representation of the number of a capturing group, the method returns -1.</source>
          <target state="translated">如果<ph id="ph1">`name`</ph>未對應至擷取群組的名稱，或擷取群組，該方法的數字的字串表示會傳回-1。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Specifies that a pattern-matching operation should not time out.</source>
          <target state="translated">指定模式比對作業不應逾時。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> class constructor and a number of static matching methods use the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant to indicate that the attempt to find a pattern match should not time out.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>類別建構函式和靜態比對的方法使用一些<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>常數表示嘗試尋找模式比對應該逾時。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>Setting the regular expression engine's time-out value to <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> can cause regular expressions that rely on excessive backtracking to appear to stop responding when processing text that nearly matches the regular expression pattern.</source>
          <target state="translated">將規則運算式引擎的逾時值設定為<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>可能會造成依賴大量回溯，看起來像處理幾乎符合規則運算式模式的文字時停止回應的規則運算式。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>If you disable time-outs, you should ensure that your regular expression does not rely on excessive backtracking and that it handles text that nearly matches the regular expression pattern.</source>
          <target state="translated">如果您停用逾時，您應該確定，您的規則運算式不會依賴大量回溯，和它處理幾乎符合規則運算式模式的文字。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>For more information about handling backtracking, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需處理回溯的詳細資訊，請參閱<bpt id="p1">[</bpt>回溯<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph> constant can be supplied as the value of the <ph id="ph2">`matchTimeout`</ph> argument of the following members:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout&gt;</ph>常數可以提供的值為<ph id="ph2">`matchTimeout`</ph>下列成員的引數：</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.InitializeReferences">
          <source>References have already been initialized.</source>
          <target state="translated">參考已初始化。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.internalMatchTimeout">
          <source>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</source>
          <target state="translated">在作業逾時之前可在模式比對作業中流逝的最長時間。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Indicates whether the regular expression finds a match in the input string.</source>
          <target state="translated">指示規則運算式是否在輸入字串中尋找比對。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in a specified input string.</source>
          <target state="translated">表示 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式中指定的規則運算式是否要在指定的輸入字串中尋找相符項目。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果規則運算式尋找到符合項目，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果比對作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph>方法來判斷字串是否為有效的組件數目。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">第二個集合，其中包含三個字元，必須是數字。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">規則運算式模式為：</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">開始一行的開頭比對。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">比對兩個數值字元。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">比對連字號。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">比對三個數值字元。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">找出連字號後面接著三個數字字元，並符合此模式的兩個項目。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">結束在行尾比對。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The character position at which to start the search.</source>
          <target state="translated">要開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Indicates whether the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</source>
          <target state="translated">表示 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式中所指定的規則運算式，是否要從字串中指定的起始位置開始，在指定的輸入字串中尋找相符項目。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果規則運算式尋找到符合項目，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果比對作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph>方法來判斷字串是否為有效的組件數目。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>It searches for a part number that follows a colon (:) character in a string.</source>
          <target state="translated">它會搜尋字串中的冒號 （:） 字元後面接著的零件編號。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> method is used to determine the position of the colon character, which is then passed to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph>方法用來決定位置的冒號字元，然後傳遞至<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">第二個集合，其中包含三個字元，必須是數字。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The regular expression pattern is:</source>
          <target state="translated">規則運算式模式為：</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match two numeric characters.</source>
          <target state="translated">比對兩個數值字元。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a hyphen.</source>
          <target state="translated">比對連字號。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">比對三個數值字元。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">找出連字號後面接著三個數字字元，並符合此模式的兩個項目。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>End the match at the end of the line.</source>
          <target state="translated">結束在行尾比對。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string.</source>
          <target state="translated">表示指定的規則運算式是否在指定的輸入字串中尋找相符項目。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果規則運算式尋找到符合項目，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and calling the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與所指定的規則運算式模式<ph id="ph3">`pattern`</ph>，然後呼叫<ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph>執行個體方法。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">這個規則運算式模式的規則運算式引擎會快取供快速擷取。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph>方法來判斷字串是否為有效的組件數目。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">第二個集合，其中包含三個字元，必須是數字。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The regular expression pattern is:</source>
          <target state="translated">規則運算式模式為：</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Begin the match at the beginning of the line.</source>
          <target state="translated">開始一行的開頭比對。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match two numeric characters.</source>
          <target state="translated">比對兩個數值字元。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a hyphen.</source>
          <target state="translated">比對連字號。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">比對三個數值字元。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">找出連字號後面接著三個數字字元，並符合此模式的兩個項目。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>Match a single alphabetic character (<ph id="ph1">`a`</ph> through <ph id="ph2">`z`</ph> or <ph id="ph3">`A`</ph> through <ph id="ph4">`Z`</ph>) or numeric character.</source>
          <target state="translated">比對單一字母字元 (<ph id="ph1">`a`</ph>透過<ph id="ph2">`z`</ph>或<ph id="ph3">`A`</ph>透過<ph id="ph4">`Z`</ph>) 或數字字元。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>End the match at the end of the line.</source>
          <target state="translated">結束在行尾比對。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">此方法等於呼叫該方法的應用程式定義域的預設逾時值一段時間後逾時。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，以驗證模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</source>
          <target state="translated">表示指定的規則運算式是否使用指定的比對選項，在指定的輸入字串中尋找相符項目。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果規則運算式尋找到符合項目，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與所指定的規則運算式模式<ph id="ph3">`pattern`</ph>和所指定的規則運算式選項<ph id="ph4">`options`</ph>，然後呼叫<ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph>執行個體方法。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">這個規則運算式模式的規則運算式引擎會快取供快速擷取。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph>方法來判斷字串是否為有效的組件數目。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">第二個集合，其中包含三個字元，必須是數字。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is:</source>
          <target state="translated">規則運算式模式為：</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">從字串的開頭開始比對。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">比對任何單一字母字元，從<ph id="ph1">`A`</ph>透過<ph id="ph2">`Z`</ph>，或任何數字字元。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two numeric characters.</source>
          <target state="translated">比對兩個數值字元。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">比對任何單一字母字元，從<ph id="ph1">`A`</ph>透過<ph id="ph2">`Z`</ph>，或任何數字字元。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a hyphen.</source>
          <target state="translated">比對連字號。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">比對三個數值字元。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern..</source>
          <target state="translated">找出連字號後面接著三個數字字元，並符合此模式的兩個項目...</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">比對任何單一字母字元，從<ph id="ph1">`A`</ph>透過<ph id="ph2">`Z`</ph>，或任何數字字元。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at the end of the string.</source>
          <target state="translated">在字串的結尾結束比對。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法<ph id="ph2">`options`</ph>參數設定為<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph>相當於定義下列規則運算式：</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">進行比較，請參閱範例<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for verifying a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，以驗證模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</source>
          <target state="translated">指出指定的規則運算式是否使用指定的比對選項和逾時間隔，在指定的輸入字串中尋找相符項目。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression finds a match; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果規則運算式尋找到符合項目，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph> method is typically used to validate a string or to ensure that a string conforms to a particular pattern without retrieving that string for subsequent manipulation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A&gt;</ph>方法通常用來驗證該字串，或確保字串符合特定模式而不擷取做後續操作該字串。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you want to determine whether one or more strings match a regular expression pattern and then retrieve them for subsequent manipulation, call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method.</source>
          <target state="translated">如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the regular expression pattern specified by <ph id="ph3">`pattern`</ph> and the regular expression options specified by <ph id="ph4">`options`</ph> and calling the <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph> instance method.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與所指定的規則運算式模式<ph id="ph3">`pattern`</ph>和所指定的規則運算式選項<ph id="ph4">`options`</ph>，然後呼叫<ph id="ph5">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29&gt;</ph>執行個體方法。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This regular expression pattern is cached for rapid retrieval by the regular expression engine.</source>
          <target state="translated">這個規則運算式模式的規則運算式引擎會快取供快速擷取。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph>參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>和<bpt id="p2">[</bpt>回溯<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">如果該時間間隔中找到相符項目，方法會擲回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to determine whether a string is a valid part number.</source>
          <target state="translated">下列範例說明使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法來判斷字串是否為有效的組件數目。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression assumes that the part number has a specific format that consists of three sets of characters separated by hyphens.</source>
          <target state="translated">規則運算式會假設零件編號有三種以連字號分隔的字元組所組成的特定格式。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set, which contains four characters, must consist of an alphanumeric character followed by two numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第一個集合，其中包含四個字元，必須包含後面兩個數值的字元，後面接著英數字元的英數字元。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The second set, which consists of three characters, must be numeric.</source>
          <target state="translated">第二個集合，其中包含三個字元，必須是數字。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The third set, which consists of four characters, must have three numeric characters followed by an alphanumeric character.</source>
          <target state="translated">第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Matching the regular expression pattern should involve minimal searching through the input string, so the method sets a time-out interval of 500 milliseconds.</source>
          <target state="translated">比對規則運算式模式，應該包含最少搜尋整個輸入字串中，所以方法設定的 500 毫秒的逾時間隔。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is:</source>
          <target state="translated">規則運算式模式為：</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at the beginning of the string.</source>
          <target state="translated">從字串的開頭開始比對。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">比對任何單一字母字元，從<ph id="ph1">`A`</ph>透過<ph id="ph2">`Z`</ph>，或任何數字字元。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two numeric characters.</source>
          <target state="translated">比對兩個數值字元。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">比對任何單一字母字元，從<ph id="ph1">`A`</ph>透過<ph id="ph2">`Z`</ph>，或任何數字字元。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a hyphen.</source>
          <target state="translated">比對連字號。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match exactly three numeric characters.</source>
          <target state="translated">比對三個數值字元。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Find a hyphen followed by three numeric characters, and match two occurrences of this pattern.</source>
          <target state="translated">找出連字號後面接著三個數字字元，並符合此模式的兩個項目。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match any single alphabetic character from <ph id="ph1">`A`</ph> through <ph id="ph2">`Z`</ph>, or any numeric character.</source>
          <target state="translated">比對任何單一字母字元，從<ph id="ph1">`A`</ph>透過<ph id="ph2">`Z`</ph>，或任何數字字元。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at the end of the string.</source>
          <target state="translated">在字串的結尾結束比對。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> is equivalent to defining the following regular expression:</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法<ph id="ph2">`options`</ph>參數設定為<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph>相當於定義下列規則運算式：</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For comparison, see the example for the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">進行比較，請參閱範例<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是有效的 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for a substring that matches a regular expression pattern and returns the first occurrence as a single <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object.</source>
          <target state="translated">在輸入字串搜尋規則運算式的項目，並傳回正確結果為單一 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Searches the specified input string for the first occurrence of the regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">在指定的輸入字串中，搜尋符合 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式中所指定規則運算式的第一個項目。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">物件，包含符合之項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需用來建立規則運算式模式之語言項目的資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">如果找到符合的項目，則所傳回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 物件的 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 屬性會包含符合規則運算式模式之 <ph id="ph3">`input`</ph> 的子字串。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果找到相符項目，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">這個方法會傳回第一個子字串，在<ph id="ph1">`input`</ph>符合規則運算式模式。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您可以擷取後續相符項目的重複呼叫傳回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果比對作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The following example finds regular expression pattern matches in a string, then lists the matched groups, captures, and capture positions.</source>
          <target state="translated">下列範例會尋找規則運算式模式比對在字串中，然後列出相符群組、 擷取和擷取位置。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>The regular expression pattern <ph id="ph1">`(\w+)\s+(car)`</ph> matches occurrences of the word "car" along with the word that precedes it.</source>
          <target state="translated">規則運算式模式<ph id="ph1">`(\w+)\s+(car)`</ph>比對的以及它前面的文字，"car"這個字的項目。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>It is interpreted as shown in the following table.</source>
          <target state="translated">它被解譯為下表所示。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match one or more white-space characters.</source>
          <target state="translated">比對一個或多個空格字元。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>(car)</source>
          <target state="translated">(car)</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>Match the literal string "car".</source>
          <target state="translated">比對常值字串"car"。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The zero-based character position at which to start the search.</source>
          <target state="translated">要開始搜尋之以零為起始的字元位置。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">從字串中指定的開始位置開始，在輸入字串中搜尋規則運算式的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">物件，包含符合之項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern, starting at or after the <ph id="ph2">`startat`</ph> character position, in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph>方法會傳回符合規則運算式模式，從上或之後的第一個子字串<ph id="ph2">`startat`</ph>字元在輸入字串的位置。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需用來建立規則運算式模式之語言項目的資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">規則運算式模式的<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph>方法會搜尋由呼叫其中一種定義<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需可用以構成規則運算式模式的項目，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can optionally specify a starting position in the string by using the <ph id="ph1">`startat`</ph> parameter.</source>
          <target state="translated">您可以使用，以選擇性地指定字串中的開始位置<ph id="ph1">`startat`</ph>參數。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from left to right (the default), the match and the scan move rightward, starting at the character specified in <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">當規則運算式引擎會剖析從左到右 （預設值） 時，比對和掃描移動 rightward，開始在指定的字元<ph id="ph1">`startat`</ph>。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>When the regular expression engine parses from right to left (when the regular expression pattern is constructed with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option), the match and scan move in the opposite direction and begin with the character at <ph id="ph2">`startat`</ph> -1.</source>
          <target state="translated">當規則運算式引擎會剖析由右至左 (當規則運算式模式，建構<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph>選項)，比對和掃描相反的方向移動，開頭處的字元<ph id="ph2">`startat`</ph>-1。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not specify a starting position, the search begins at the default <ph id="ph1">`startat`</ph> position.</source>
          <target state="translated">如果您未指定的開始位置，則會搜尋為預設值<ph id="ph1">`startat`</ph>位置。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If the regular expression searches from left to right, the default <ph id="ph1">`startat`</ph> position is at the left end of <ph id="ph2">`input`</ph>; if it searches from right to left, the default <ph id="ph3">`startat`</ph> position is at the right end of <ph id="ph4">`input`</ph>.</source>
          <target state="translated">如果規則運算式搜尋從左到右，從預設<ph id="ph1">`startat`</ph>位置位於左側<ph id="ph2">`input`</ph>; 如果它會搜尋由右至左、 預設<ph id="ph3">`startat`</ph>位置位於右邊<ph id="ph4">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you want to restrict a match so that it begins at a particular character position in the string and the regular expression engine does not scan the remainder of the string for a match, anchor the regular expression with a <ph id="ph1">`\G`</ph> (at the left for a left-to-right pattern, or at the right for a right-to-left pattern).</source>
          <target state="translated">如果您想要限制相符項目，讓它在字串中特定的字元位置開始，並比對規則運算式引擎不會掃描字串的其餘部分，錨定的規則運算式與<ph id="ph1">`\G`</ph>（左邊的左到右模式中，或由右至左模式右邊)。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This restricts the match so it must start exactly at <ph id="ph1">`startat`</ph>.</source>
          <target state="translated">這會限制比對，因此它必須剛好在啟動<ph id="ph1">`startat`</ph>。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">如果找到符合的項目，則所傳回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 物件的 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 屬性會包含符合規則運算式模式之 <ph id="ph3">`input`</ph> 的子字串。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果找到相符項目，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>This method returns the first substring found at or after the <ph id="ph1">`startat`</ph> character position in <ph id="ph2">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">這個方法會傳回找到在或之後的第一個子字串<ph id="ph1">`startat`</ph>字元位置<ph id="ph2">`input`</ph>符合規則運算式模式。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您可以擷取後續相符項目的重複呼叫傳回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果比對作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exeeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">如果當您呼叫建構函式時未設定逾時間隔，若作業 exeeds 所在的應用程式定義域建立任何逾時值，會擲回例外狀況<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>建立物件。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Searches the specified input string for the first occurrence of the specified regular expression.</source>
          <target state="translated">在指定的輸入字串中搜尋所指定規則運算式的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>An object that contains information about the match.</source>
          <target state="translated">物件，包含符合之項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需用來建立規則運算式模式之語言項目的資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫執行個體<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>In this case, the regular expression engine caches the regular expression pattern.</source>
          <target state="translated">在此情況下，規則運算式引擎會快取的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">如果找到符合的項目，則所傳回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 物件的 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 屬性會包含符合規則運算式模式之 <ph id="ph3">`input`</ph> 的子字串。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果找到相符項目，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method returns the first substring in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">這個方法會傳回第一個子字串，在<ph id="ph1">`input`</ph>符合規則運算式模式。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您可以擷取後續相符項目的重複呼叫傳回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method to find the first word that contains at least one <ph id="ph2">`z`</ph> character, and then calls the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method to find any additional matches.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph>方法來尋找第一個單字，其中包含至少一個<ph id="ph2">`z`</ph>字元，然後呼叫<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph>方法來尋找任何其他相符項目。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w*z+\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\w*z+\w*\b`</ph> 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">比對零個、 一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match one or more occurrences of the <ph id="ph1">`z`</ph> character.</source>
          <target state="translated">比對一個或多個<ph id="ph1">`z`</ph>字元。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">比對零個、 一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法來擷取模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The zero-based character position in the input string that defines the leftmost position to be searched.</source>
          <target state="translated">定義要搜尋的最左邊位置的輸入字串中以零為起始的字元位置。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The number of characters in the substring to include in the search.</source>
          <target state="translated">子字串中要包含在搜尋中的字元數。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</source>
          <target state="translated">從指定的開始位置開始並且僅搜尋指定數目的字元，在輸入字串中搜尋規則運算式的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>An object that contains information about the match.</source>
          <target state="translated">物件，包含符合之項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method returns the first substring that matches a regular expression pattern in a portion of an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法會傳回第一個子字串符合規則運算式模式中輸入字串的一部分。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需用來建立規則運算式模式之語言項目的資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">規則運算式模式的<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法會搜尋由呼叫其中一種定義<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需可用以構成規則運算式模式的項目，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method searches the portion of <ph id="ph2">`input`</ph> defined by the <ph id="ph3">`beginning`</ph> and <ph id="ph4">`length`</ph> parameters for the regular expression pattern.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>方法搜尋的部份<ph id="ph2">`input`</ph>所定義<ph id="ph3">`beginning`</ph>和<ph id="ph4">`length`</ph>規則運算式模式的參數。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`beginning`</ph> always defines the index of the leftmost character to include in the search, and <ph id="ph2">`length`</ph> defines the maximum number of characters to search.</source>
          <target state="translated"><ph id="ph1">`beginning`</ph> 永遠會定義要包含在搜尋中，最左邊字元的索引和<ph id="ph2">`length`</ph>定義要搜尋的字元數目上限。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>Together, they define the range of the search.</source>
          <target state="translated">同時，會定義搜尋的範圍。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the search proceeds from left to right (the default), the regular expression engine searches from the character at index <ph id="ph1">`beginning`</ph> to the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1.</source>
          <target state="translated">如果搜尋會繼續從左到右 （預設值），規則運算式引擎會搜尋索引處的字元從<ph id="ph1">`beginning`</ph>索引處的字元<ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If the regular expression engine was instantiated by using the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph> option so that the search proceeds from right to left, the regular expression engine searches from the character at index <ph id="ph2">`beginning`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 to the character at index <ph id="ph5">`beginning`</ph>.</source>
          <target state="translated">如果使用的規則運算式引擎未具現化<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType&gt;</ph>選項，讓搜尋繼續由右至左，請從索引處的字元，規則運算式引擎搜尋<ph id="ph2">`beginning`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 到字元索引處<ph id="ph5">`beginning`</ph>。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>This method returns the first match that it finds within this range.</source>
          <target state="translated">這個方法會傳回此範圍內找到的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您可以擷取後續相符項目的重複呼叫傳回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">如果找到符合的項目，則所傳回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 物件的 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 屬性會包含符合規則運算式模式之 <ph id="ph3">`input`</ph> 的子字串。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果找到相符項目，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果比對作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out value when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">如果您未設定逾時值，當您呼叫建構函式時，如果作業超過任何逾時值的應用程式定義域中，會擲回例外狀況<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>建立物件。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> identifies a position that is outside the range of <ph id="ph5">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="beginning" /&gt;</ph><ph id="ph2">&lt;see langword="+" /&gt;</ph><ph id="ph3">&lt;paramref name="length" /&gt;</ph><ph id="ph4">&lt;see langword="–1" /&gt;</ph> 識別 <ph id="ph5">&lt;paramref name="input" /&gt;</ph> 範圍之外的位置。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</source>
          <target state="translated">使用指定的比對選項，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An object that contains information about the match.</source>
          <target state="translated">物件，包含符合之項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需用來建立規則運算式模式之語言項目的資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>建構函式和呼叫執行個體<ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">如果找到符合的項目，則所傳回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 物件的 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 屬性會包含符合規則運算式模式之 <ph id="ph3">`input`</ph> 的子字串。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果找到相符項目，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">這個方法會傳回第一個子字串中找到<ph id="ph1">`input`</ph>符合規則運算式模式。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">您可以擷取後續相符項目的重複呼叫傳回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the matching operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example defines a regular expression that matches words beginning with the letter "a".</source>
          <target state="translated">下列範例會定義規則運算式比對以字母開頭的文字，"a"。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph> option to ensure that the regular expression locates words beginning with both an uppercase "a" and a lowercase "a".</source>
          <target state="translated">它會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType&gt;</ph>選項，以確保規則運算式會找出文字開頭為兩個以大寫"a"和小寫"a"。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\ba\w*\b`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\ba\w*\b`</ph> 的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character "a".</source>
          <target state="translated">比對字元"a"。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match zero, one, or more word characters.</source>
          <target state="translated">比對零個、 一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法來擷取模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">使用指定的比對選項和逾時間隔，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>An object that contains information about the match.</source>
          <target state="translated">物件，包含符合之項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method returns the first substring that matches a regular expression pattern in an input string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法會傳回符合指定之規則運算式模式，在輸入字串的第一個子字串。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For information about the language elements used to build a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需用來建立規則運算式模式之語言項目的資訊，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> constructor and calling the instance <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>建構函式和呼叫執行個體<ph id="ph4">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can determine whether the regular expression pattern has been found in the input string by checking the value of the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property.</source>
          <target state="translated">您可以判斷是否規則運算式模式發現輸入字串中檢查傳回的值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found, the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the substring from <ph id="ph3">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">如果找到符合的項目，則所傳回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> 物件的 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> 屬性會包含符合規則運算式模式之 <ph id="ph3">`input`</ph> 的子字串。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found, its value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果找到相符項目，其值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This method returns the first substring found in <ph id="ph1">`input`</ph> that matches the regular expression pattern.</source>
          <target state="translated">這個方法會傳回第一個子字串中找到<ph id="ph1">`input`</ph>符合規則運算式模式。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can retrieve subsequent matches by repeatedly calling the returned <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object's <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method.</source>
          <target state="translated">您可以擷取後續相符項目的重複呼叫傳回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>物件的<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>You can also retrieve all matches in a single method call by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph>參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>和<bpt id="p2">[</bpt>回溯<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">如果該時間間隔中找到相符項目，方法會擲回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Searches an input string for all occurrences of a regular expression and returns all the matches.</source>
          <target state="translated">在輸入字串中搜尋規則運算式的所有項目，並傳回所有符合項目。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">在比對嘗試藉由呼叫的重複當<ph id="ph1">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /&gt;</ph>方法，規則運算式引擎提供空白比對特殊處理。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Usually, the regular expression engine begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">通常，規則運算式引擎開始搜尋下一個相符項目剛好一個比對離開的地方。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>However, after an empty match, the regular expression engine advances by one character before trying the next match.</source>
          <target state="translated">不過之後空白的比對，, 規則運算式引擎前進一個字元之前嘗試下一個相符項。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">此行為可確保規則運算式引擎會透過字串進度。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">否則，因為空的相符項目不會導致任何向前移動下, 一個相符項目會啟動在先前比對，完全相同的位置，它將會重複比對相同的空字串。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>In the following example, the regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">在下列範例中，規則運算式模式<bpt id="p1">&lt;c&gt;</bpt>*<ept id="p1">&lt;/c&gt;</ept>搜尋零或多個出現字母"a"，"abaabb"的字串。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>As the output from the example shows, the resulting <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph> object contains six <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects.</source>
          <target state="translated">此範例將示範，產生的輸出<ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchCollection" /&gt;</ph>物件包含六個<ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">第一個比對嘗試尋找第一個"a"。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">在完全第一個符合的第一個 b; 之前就會結束，其中的第二個相符項目啟動它會尋找"a"的零個項目，並傳回空字串。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">第三個相符項目不是完全第二個比對結束的地方，因為第二個相符項目會傳回空字串。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">相反地，就會開始一個字元後第一個"b"。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">第三個相符項目尋找兩個"a"，並傳回"aa"。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">第四個比對嘗試開始，第三個相符項目之前已結束，第二個"b"，並傳回空字串。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">第五個比對嘗試一次前進一個字元，因此第三個"b"之前開始，並傳回空字串。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Regex">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">第六個相符項目開始之後最後一個"b"，並再次傳回空字串。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Searches the specified input string for all occurrences of a regular expression.</source>
          <target state="translated">在指定的輸入字串搜尋規則運算式的所有項目。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">搜尋之後找到的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 物件集合。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">如果找不到相符的項目，此方法會傳回空集合物件。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph>方法很類似<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">相當於下列程式碼：</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The collection includes only matches and terminates at the first non-match.</source>
          <target state="translated">集合包含只有相符項目且結束於第一個不相符。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">規則運算式模式的<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph>方法會搜尋由呼叫其中一種定義<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需可用以構成規則運算式模式的項目，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法會使用延遲評估來填入傳回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">存取這個集合的成員 (例如 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph>) 會導致立即填入集合。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">若要利用延遲評估，您應該逐一查看集合所使用的建構，例如<ph id="ph1">`foreach`</ph>在 C# 和<ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">其延遲的評估，因為呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph>方法不會擲回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval.</source>
          <target state="translated">不過，擲回例外狀況上執行作業時<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>傳回使用這個方法，如果物件<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph>屬性不是<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>和比對作業超過逾時間隔。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph> method to identify any words in a sentence that end in "es".</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29&gt;</ph>方法，以識別任何句子中的單字以"es"結尾。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\w+es\b`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">比對常值字串"es"。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The character position in the input string at which to start the search.</source>
          <target state="translated">在輸入字串中開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</source>
          <target state="translated">自字串中指定的開始位置開始，在指定的輸入字串搜尋規則運算式的所有項目。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">搜尋之後找到的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 物件集合。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">如果找不到相符的項目，此方法會傳回空集合物件。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The  <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method is similar to the  <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph>方法很類似<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29&gt;</ph>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">相當於下列程式碼：</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern for which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method searches is defined by the call to one of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructors.</source>
          <target state="translated">規則運算式模式的<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph>方法會搜尋由呼叫其中一種定義<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>For more information about the elements that can form a regular expression pattern, see <bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需可用以構成規則運算式模式的項目，請參閱<bpt id="p1">[</bpt>規則運算式語言-快速參考<ept id="p1">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法會使用延遲評估來填入傳回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">存取這個集合的成員 (例如 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph>) 會導致立即填入集合。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">若要利用延遲評估，您應該逐一查看集合所使用的建構，例如<ph id="ph1">`foreach`</ph>在 C# 和<ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>in Visual Basic.</source>
          <target state="translated">在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">其延遲的評估，因為呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph>方法不會擲回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property is not <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> and a matching operation exceeds the time-out interval..</source>
          <target state="translated">不過，擲回例外狀況上執行作業時<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>傳回使用這個方法，如果物件<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph>屬性不是<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>和比對作業超過逾時間隔...</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to find the first word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph> method to identify any additional words that end in "es".</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>方法來尋找句子的結尾"es"，然後呼叫中的第一個單字<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29&gt;</ph>方法，以找出以"es"結尾的任何其他文字。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\w+es\b`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>Match the literal string "es".</source>
          <target state="translated">比對常值字串"es"。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Searches the specified input string for all occurrences of a specified regular expression.</source>
          <target state="translated">在指定的輸入字串搜尋所指定規則運算式的所有相符項目。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">搜尋之後找到的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 物件集合。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">如果找不到相符的項目，此方法會傳回空集合物件。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph>方法很類似<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">相當於下列程式碼：</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">靜態<ph id="ph1">`Matches`</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫的執行個體方法<ph id="ph3">`Matches`</ph>。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法會使用延遲評估來填入傳回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">存取這個集合的成員 (例如 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph>) 會導致立即填入集合。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">若要利用延遲評估，您應該逐一查看集合所使用的建構，例如<ph id="ph1">`foreach`</ph>在 C# 和<ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>in Visual Basic.</source>
          <target state="translated">在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">其延遲的評估，因為呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph>方法不會擲回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">不過，擲回例外狀況上執行作業時<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>由這個方法傳回，如果逾時間隔由目前應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的物件超過這個逾時間隔。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es".</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph>方法，以找出"es"結尾的句子中的任何字。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\w+es\b`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>Match the literal string "es".</source>
          <target state="translated">比對常值字串"es"。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you specify the time-out interval.</source>
          <target state="translated">建議的靜態方法，針對擷取多個模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，這可讓您指定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">列舉值的位元組合，這些值會指定用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</source>
          <target state="translated">使用指定的比對選項在指定的輸入字串中，搜尋所指定規則運算式的所有相符項目。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">搜尋之後找到的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 物件集合。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">如果找不到相符的項目，此方法會傳回空集合物件。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法很類似<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">相當於下列程式碼：</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">靜態<ph id="ph1">`Matches`</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫的執行個體方法<ph id="ph3">`Matches`</ph>。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法會使用延遲評估來填入傳回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">存取這個集合的成員 (例如 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph>) 會導致立即填入集合。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">若要利用延遲評估，您應該逐一查看集合所使用的建構，例如<ph id="ph1">`foreach`</ph>在 C# 和<ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>in Visual Basic.</source>
          <target state="translated">在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">其延遲的評估，因為呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph>方法不會擲回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, the exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a time-out interval is defined by the "REGEX_DEFAULT_MATCH_TIMEOUT" property of the current application domain and a matching operation exceeds this time-out interval.</source>
          <target state="translated">不過，擲回例外狀況上執行作業時<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>由這個方法傳回，如果逾時間隔由目前應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的物件超過這個逾時間隔。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> method to identify any word in a sentence that ends in "es", and then calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph>方法，以找出以"es"，然後呼叫的句子中的任何字<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>執行不區分大小寫的模式與輸入字串比較方法。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">如輸出所示，兩個方法會傳回不同的結果。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\w+es\b`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal string "es".</source>
          <target state="translated">比對常值字串"es"。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for retrieving multiple pattern matches is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，針對擷取多個模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that specify options for matching.</source>
          <target state="translated">列舉值的位元組合，這些值會指定用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</source>
          <target state="translated">使用指定的比對選項和逾時間隔，在指定的輸入字串中搜尋所指定規則運算式的所有相符項目。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A collection of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> objects found by the search.</source>
          <target state="translated">搜尋之後找到的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> 物件集合。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no matches are found, the method returns an empty collection object.</source>
          <target state="translated">如果找不到相符的項目，此方法會傳回空集合物件。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method is similar to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method, except that it returns information about all the matches found in the input string, instead of a single match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法很類似<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>，而不是單一比對輸入字串中找到的方法，但是它會傳回所有相符項目的相關資訊。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">相當於下列程式碼：</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Matches`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Matches`</ph>.</source>
          <target state="translated">靜態<ph id="ph1">`Matches`</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫的執行個體方法<ph id="ph3">`Matches`</ph>。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method uses lazy evaluation to populate the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法會使用延遲評估來填入傳回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Accessing members of this collection such as <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> causes the collection to be populated immediately.</source>
          <target state="translated">存取這個集合的成員 (例如 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph>) 會導致立即填入集合。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To take advantage of lazy evaluation, you should iterate the collection by using a construct such as <ph id="ph1">`foreach`</ph> in C# and <ph id="ph2">`For Each`</ph>…<ph id="ph3">`Next`</ph></source>
          <target state="translated">若要利用延遲評估，您應該逐一查看集合所使用的建構，例如<ph id="ph1">`foreach`</ph>在 C# 和<ph id="ph2">`For Each`</ph>...<ph id="ph3">`Next`</ph></target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>in Visual Basic.</source>
          <target state="translated">在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because of its lazy evaluation, calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph> method does not throw a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">其延遲的評估，因為呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A&gt;</ph>方法不會擲回<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, an exception is thrown when an operation is performed on the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object returned by this method, if a matching operation exceeds this time-out interval specified by the<ph id="ph2">`matchTimeout`</ph> parameter.</source>
          <target state="translated">不過，擲回例外狀況上執行作業時<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>如果比對作業超過此所指定的逾時間隔，這個方法中，所傳回的物件<ph id="ph2">`matchTimeout`</ph>參數。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-sensitive comparison that matches any word in a sentence that ends in "es".</source>
          <target state="translated">下列範例會呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法以執行比對"es"結尾的句子中的任何字區分大小寫比較。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to perform a case-insensitive comparison of the pattern with the input string.</source>
          <target state="translated">然後它會呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>執行不區分大小寫的模式與輸入字串比較方法。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In both cases, the time-out interval is set to one second.</source>
          <target state="translated">在這兩種情況下，逾時間隔設定為一秒。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>As the output shows, the two methods return different results.</source>
          <target state="translated">如輸出所示，兩個方法會傳回不同的結果。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\b\w+es\b`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`\b\w+es\b`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Begin the match at a word boundary.</source>
          <target state="translated">開始字緣比對。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match one or more word characters.</source>
          <target state="translated">比對一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal string "es".</source>
          <target state="translated">比對常值字串"es"。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>End the match at a word boundary.</source>
          <target state="translated">結束字緣比對。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>Gets the time-out interval of the current instance.</source>
          <target state="translated">取得目前執行個體的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The maximum time interval that can elapse in a pattern-matching operation before a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph> is thrown, or <ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> if time-outs are disabled.</source>
          <target state="translated">在<ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /&gt;</ph>擲回之前，可在模式比對作業中流逝的最大時間間隔，或者為<ph id="ph2">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>（如果停用逾時）。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph> property defines the approximate maximum time interval for a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance to execute a single matching operation before the operation times out. The regular expression engine throws a <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception during its next timing check after the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A&gt;</ph>屬性會定義大約的最大時間間隔<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>作業逾時之前執行單一比對作業的執行個體。規則運算式引擎會擲回<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>期間經過逾時間隔後其下一個計時檢查例外狀況。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This prevents the regular expression engine from processing input strings that require excessive backtracking.</source>
          <target state="translated">這可防止規則運算式引擎處理輸入的字串需要進行大量回溯。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>For more information, see <bpt id="p1">[</bpt>Backtracking<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Best Practices for Regular Expressions<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>回溯<ept id="p1">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式的最佳作法<ept id="p2">](~/docs/standard/base-types/best-practices.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>This property is read-only.</source>
          <target state="translated">這個屬性是唯讀的。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>You can set its value explicitly for an individual <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor; and you can set its value for all <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> matching operations in an application domain by calling the <ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph> method and providing a <ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> value for the "REGEX_DEFAULT_MATCH_TIMEOUT" property, as the following example illustrates.</source>
          <target state="translated">您可以明確設定該值的各個<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>藉由呼叫物件<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph>建構函式，而且您可以將其值設定為所有<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>比對應用程式定義域中的作業，藉由呼叫<ph id="ph4">&lt;xref:System.AppDomain.SetData%2A?displayProperty=nameWithType&gt;</ph>方法並提供<ph id="ph5">&lt;xref:System.TimeSpan&gt;</ph> "REGEX_DEFAULT_MATCH_TIMEOUT"的屬性值，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.MatchTimeout">
          <source>If you do not explicitly set a time-out interval, the default value <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph> is used, and matching operations do not time out.</source>
          <target state="translated">如果您未明確設定的逾時間隔時，預設值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>是使用與比對作業執行逾時。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Gets the options that were passed into the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">取得傳入 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式的選項。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>One or more members of the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> enumeration that represent options that were passed to the <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 列舉的一個或多個成員，代表傳遞至 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式的選項</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The value of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property consists of one or more members of the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph> enumeration.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph>屬性都包含一個或多個成員<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions&gt;</ph>列舉型別。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If no options were defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> class constructor, its value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果沒有選項中所定義<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>類別建構函式，其值是<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>The available options are discussed in detail in the <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept> topic.</source>
          <target state="translated">可用的選項會在中詳細討論<bpt id="p1">[</bpt>規則運算式選項<ept id="p1">](~/docs/standard/base-types/regular-expression-options.md)</ept>主題。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph> property does not reflect inline options defined in the regular expression pattern itself.</source>
          <target state="translated">請注意，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Options%2A&gt;</ph>屬性並不會反映內嵌選項定義在規則運算式模式本身。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 基底類別所建立的規則運算式的<ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>These compiled regular expressions use the base class implementation of the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property.</source>
          <target state="translated">這些編譯的規則運算式中使用的基底類別實作<ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.Options">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property returns the options that were passed to the <ph id="ph2">&lt;paramref name="options" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">如果已從衍生類別呼叫<ph id="ph1">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph>屬性會傳回傳遞給選項<ph id="ph2">&lt;paramref name="options" /&gt;</ph>參數<ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph>類別建構函式是用來定義規則運算式。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.pattern">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的字串。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">取代字串。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的所有字串。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">搜尋符合項目會從開頭的<ph id="ph1">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">規則運算式是目前的建構函式所定義的模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph>參數指定的字串來取代中的每個相符項目<ph id="ph2">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 可以包含常值文字的任何組合和<bpt id="p1">[</bpt>替代<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">例如，取代模式<ph id="ph1">`a*${test}b`</ph>插入的字串"*"後面接著所比對的子字串<ph id="ph2">`test`</ph>擷取群組，如果有的話，後面接著字串"b"。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 字元無法辨識為中繼字元取代模式內。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">替代是在取代模式中才能辨識的只是規則運算式語言項目。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">所有其他規則運算式語言項目，包括<bpt id="p1">[</bpt>字元逸出<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>、 可只在規則運算式模式中，而且無法辨識取代模式中。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果取代作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">下列範例會定義規則運算式， <ph id="ph1">`\s+`</ph>，符合一或多個空格字元。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">取代字串中，""，將它們取代為單一空格字元。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>, and a replacement pattern, <ph id="ph2">`$2`</ph>, that removes either a leading or a trailing currency symbol from a numeric value.</source>
          <target state="translated">下列範例會定義規則運算式， <ph id="ph1">`(\p{Sc}\s?)?(\d+\.?((?&lt;=\.)\d+)?)(?(1)|\s?\p{Sc})?`</ph>，以及取代模式中， <ph id="ph2">`$2`</ph>，移除前置或尾端的貨幣符號的數字的值。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The regular expression is interpreted as shown in the following table.</source>
          <target state="translated">規則運算式的解譯方式如下表所示。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match a currency symbol.</source>
          <target state="translated">比對的貨幣符號。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">`{Sc}`</ph> denotes any character that is a member of the Unicode Symbol, Currency category.</source>
          <target state="translated"><ph id="ph1">`{Sc}`</ph> 代表任何字元，其 [Unicode Symbol，Currency] 分類的成員。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one white-space character.</source>
          <target state="translated">比對零個或一個空白字元。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of the combination of a currency symbol followed by zero or one white-space character.</source>
          <target state="translated">比對零個或一個貨幣符號，後面接著零個或一個空格字元的組合。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">這是第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match one or more decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match zero or one occurrence of a period (used as a decimal separator character).</source>
          <target state="translated">比對零個或一個句號 （用做為小數分隔符號字元）。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If a period is the previous character, match one or more decimal digits.</source>
          <target state="translated">如果句號前一個字元，比對一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This pattern can be matched either zero or one time.</source>
          <target state="translated">此模式可以比對零或一次。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Match the pattern of one or more decimal digits followed by an optional period and additional decimal digits.</source>
          <target state="translated">比對一個或多個十進位數字，後面選擇性句號和其他十進位數字的模式。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>This is the second capturing group.</source>
          <target state="translated">這是第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph> method replaces the entire match with the value of this captured group.</source>
          <target state="translated">若要呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29&gt;</ph>方法會將整個相符項目取代此擷取群組的值。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>If the first captured group exists, match an empty string.</source>
          <target state="translated">如果第一個擷取的群組存在，則比對空字串。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>Otherwise, match zero or one white-space character followed by a currency symbol.</source>
          <target state="translated">否則比對零個或一個空格字元，後面接著貨幣符號。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">在指定的輸入字串中，使用 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">規則運算式取代模式中無法隨時可以指定取代字串。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">取代字串會因某些處理對相符的字串。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">條件式處理取代字串結果。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">此方法相當於呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph>方法並傳遞每個<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>在傳回的物件<ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>集合<ph id="ph4">`evaluator`</ph>委派。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">規則運算式是目前的建構函式所定義的模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph>參數是您定義的自訂方法的委派，會檢查每個符合項目。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">自訂的方法必須具有下列簽章，以符合<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">您的自訂方法會傳回字串，以取代相符的輸入。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果取代作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following code example displays an original string, matches each word in the original string, converts the first character of each match to uppercase, then displays the converted string.</source>
          <target state="translated">下列程式碼範例會顯示原始的字串、 符合原始字串中的每個字，將已轉換的字串轉換為大寫，然後顯示每個相符的第一個字元。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">取代字串。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The maximum number of times the replacement can occur.</source>
          <target state="translated">取代作業可以發生的最多次數。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">搜尋符合項目會從開頭的<ph id="ph1">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression is the pattern that is defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">規則運算式是由目前的建構函式定義的模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>是負數，字串的結尾繼續取代項目。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>超過的相符項目數，取代所有相符項目。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace the first <ph id="ph2">`count`</ph> matches in <ph id="ph3">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph>參數指定的字串來取代第一個<ph id="ph2">`count`</ph>中符合<ph id="ph3">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 可以包含常值文字的任何組合和<bpt id="p1">[</bpt>替代<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">例如，取代模式<ph id="ph1">`a*${test}b`</ph>插入的字串"*"後面接著所比對的子字串<ph id="ph2">`test`</ph>擷取群組，如果有的話，後面接著字串"b"。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 字元無法辨識為中繼字元取代模式內。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">替代是在取代模式中才能辨識的只是規則運算式語言項目。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">所有其他規則運算式語言項目，包括<bpt id="p1">[</bpt>字元逸出<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>、 可只在規則運算式模式中，而且無法辨識取代模式中。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果取代作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The following example replaces the first five occurrences of duplicated characters with a single character.</source>
          <target state="translated">下列範例會將前五個出現重複的字元取代單一字元。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`(\w)\1`</ph> matches consecutive occurrences of a single character and assigns the first occurrence to the first capturing group.</source>
          <target state="translated">規則運算式模式<ph id="ph1">`(\w)\1`</ph>比對的單一字元的連續項目，並將第一個出現項目指派給第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured group.</source>
          <target state="translated">取代模式<ph id="ph1">`$1`</ph>整個相符項目取代為第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string.</source>
          <target state="translated">取代字串。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中沒有符合 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 的項目，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">靜態<ph id="ph1">`Replace`</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫的執行個體方法<ph id="ph3">`Replace`</ph>。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The search for matches starts at the beginning of the <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">搜尋符合項目會從開頭的<ph id="ph1">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph>參數指定的字串來取代中的每個相符項目<ph id="ph2">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 可以包含常值文字的任何組合和<bpt id="p1">[</bpt>替代<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">例如，取代模式<ph id="ph1">`a*${test}b`</ph>插入的字串"*"後面接著所比對的子字串<ph id="ph2">`test`</ph>擷取群組，如果有的話，後面接著字串"b"。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 字元無法辨識為中繼字元取代模式內。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">替代是在取代模式中才能辨識的只是規則運算式語言項目。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">所有其他規則運算式語言項目，包括<bpt id="p1">[</bpt>字元逸出<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>、 可只在規則運算式模式中，而且無法辨識取代模式中。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example defines a regular expression, <ph id="ph1">`\s+`</ph>, that matches one or more white-space characters.</source>
          <target state="translated">下列範例會定義規則運算式， <ph id="ph1">`\s+`</ph>，符合一或多個空格字元。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement string, " ", replaces them with a single space character.</source>
          <target state="translated">取代字串中，""，將它們取代為單一空格字元。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph>方法以取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">規則運算式會使用<ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph>屬性，以包括在本機電腦的名稱和<ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph>方法，將包含邏輯磁碟的名稱。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">若要成功執行此範例，您應該以您本機電腦的名稱取代常值字串"MyMachine"。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">下列的運算式所定義的規則運算式模式：</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">比對兩個連續反斜線 (<ph id="ph1">`\`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">反斜線字元解譯為逸出字元，因此每個反斜線必須逸出與另一個反斜線。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">執行不區分大小寫的比對字串所傳回的<ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">比對句號 (<ph id="ph1">`.`</ph>) 字元後面接著一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">此比對可以發生零次以上。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">不會擷取相符子運算式。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">符合反斜線 (<ph id="ph1">`\`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Perform a case-insensitive match of the character class that consists of the individual drive lettters.</source>
          <target state="translated">執行不區分大小寫比對的個別磁碟機字母所組成的字元類別。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">此項比對是第一個擷取子運算式。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">比對常值的貨幣符號 (<ph id="ph1">`$`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">取代模式<ph id="ph1">`$1`</ph>整個相符項目取代為第一個擷取子運算式。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">也就是說，它會取代 UNC 電腦和磁碟機名稱的磁碟機代號。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph><ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，取代模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">在指定的輸入字串中，使用 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中沒有符合 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 的項目，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType&gt;</ph>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">規則運算式取代模式中無法隨時可以指定取代字串。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">取代字串會因某些處理對相符的字串。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">條件式處理取代字串結果。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">此方法相當於呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph>方法並傳遞每個<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>在傳回的物件<ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>集合<ph id="ph4">`evaluator`</ph>委派。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph>參數是您定義的自訂方法的委派，會檢查每個符合項目。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">自訂的方法必須具有下列簽章，以符合<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">您的自訂方法會傳回字串，以取代相符的輸入。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">下列範例會使用規則運算式從字串擷取個別文字，然後再使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派以呼叫方法，名為<ph id="ph2">`WordScramble`</ph>，將金鑰加密在 word 中個別的字母。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">若要這樣做，<ph id="ph1">`WordScramble`</ph>方法會建立陣列，其中包含在比對的字元。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">它也會建立使用隨機浮點數值的它所擴展的平行陣列。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">陣列會依照呼叫<ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph>方法和已排序的陣列提供做為引數<ph id="ph2">&lt;xref:System.String&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">然後傳回此新建立的字串<ph id="ph1">`WordScramble`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\w+`</ph>比對一個或多個文字字元，規則運算式引擎會繼續將字元加入至比對，直到遇到非文字字元，例如空格字元。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph><ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)">
          <source>The recommended static method for evaluating and replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，用於評估和取代模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">取代將發生的最多次數。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">在指定的輸入字串中，使用 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">規則運算式取代模式中無法隨時可以指定取代字串。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">取代字串會因某些處理對相符的字串。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">條件式處理取代字串結果。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">此方法相當於呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType&gt;</ph>方法並傳遞第一個<ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>中傳回的物件<ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>集合<ph id="ph5">`evaluator`</ph>委派。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">規則運算式是目前的建構函式所定義的模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph>參數是您定義的自訂方法的委派，會檢查每個符合項目。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">自訂的方法必須具有下列簽章，以符合<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">您的自訂方法會傳回字串，以取代相符的輸入。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果取代作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The following example uses a regular expression to deliberately misspell half of the words in a list.</source>
          <target state="translated">下列範例會使用規則運算式，刻意拼錯一半的清單中的字詞。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It uses the regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> to match words that include the characters "ie" or "ei".</source>
          <target state="translated">它會使用規則運算式<ph id="ph1">`\w*(ie|ei)\w*`</ph>以比對包含"ei"或"ie"字元的文字。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It passes the first half of the matching words to the <ph id="ph1">`ReverseLetter`</ph> method, which, in turn, uses the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to reverse "i" and "e" in the matched string.</source>
          <target state="translated">它會傳遞第一個要比對文字的下半部<ph id="ph1">`ReverseLetter`</ph>方法，這個方法會接著使用<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>反向"i"和"e"相符的字串中的方法。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The remaining words remain unchanged.</source>
          <target state="translated">其他字維持不變。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression <ph id="ph1">`\w*(ie|ei)\w*`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式 <ph id="ph1">`\w*(ie|ei)\w*`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">比對零個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match either "ie" or "ei".</source>
          <target state="translated">比對"ie"或"ei"。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>Match zero or more word characters.</source>
          <target state="translated">比對零個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`([ie])([ie])`</ph> in the <ph id="ph2">`ReverseLetter`</ph> method matches the first "i" or "e" in the diphthong "ie" or "ei" and assigns the letter to the first capturing group.</source>
          <target state="translated">規則運算式模式<ph id="ph1">`([ie])([ie])`</ph>中<ph id="ph2">`ReverseLetter`</ph>方法符合 diphthong"ei"或"ie 」 中的第一個"i"或"e"，並將代號指派給第一個擷取群組。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>It matches the second "i" or "e" and assigns the letter to the second capturing group.</source>
          <target state="translated">它會比對的第二個"i"或"e"，並將代號指派給第二個擷取群組。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>The two characters are then reversed by calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph> method with the replacement pattern <ph id="ph2">`$2$1`</ph>.</source>
          <target state="translated">兩個字元反過來藉由呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29&gt;</ph>方法取代模式<ph id="ph2">`$2$1`</ph>。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string.</source>
          <target state="translated">取代字串。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Maximum number of times the replacement can occur.</source>
          <target state="translated">取代可以發生的最多次數。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">在輸入字串中開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</source>
          <target state="translated">在指定的輸入子字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The search for matches starts in the <ph id="ph1">`input`</ph> string at the position specified by the <ph id="ph2">`startat`</ph> parameter.</source>
          <target state="translated">搜尋符合項目中啟動<ph id="ph1">`input`</ph>字串所指定的位置<ph id="ph2">`startat`</ph>參數。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">規則運算式是目前的建構函式所定義的模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is negative, replacements continue to the end of the string.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>是負數，字串的結尾繼續取代項目。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`count`</ph> exceeds the number of matches, all matches are replaced.</source>
          <target state="translated">如果<ph id="ph1">`count`</ph>超過的相符項目數，取代所有相符項目。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph>參數指定的字串來取代中的每個相符項目<ph id="ph2">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 可以包含常值文字的任何組合和<bpt id="p1">[</bpt>替代<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">例如，取代模式<ph id="ph1">`a*${test}b`</ph>插入的字串"*"後面接著所比對的子字串<ph id="ph2">`test`</ph>擷取群組，如果有的話，後面接著字串"b"。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 字元無法辨識為中繼字元取代模式內。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">替代是在取代模式中才能辨識的只是規則運算式語言項目。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">所有其他規則運算式語言項目，包括<bpt id="p1">[</bpt>字元逸出<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>、 可只在規則運算式模式中，而且無法辨識取代模式中。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果取代作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The following example double-spaces all but the first line of a string.</source>
          <target state="translated">下列範例 double-spaces 字串的第一行以外的所有節點。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>It defines a regular expression pattern, <ph id="ph1">`^.*$`</ph>, that matches a line of text, calls the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph> method to match the first line of the string, and uses the <ph id="ph3">`Match.Index`</ph> and <ph id="ph4">`Match.Count`</ph> properties to determine the starting position of the second line.</source>
          <target state="translated">它會定義規則運算式模式， <ph id="ph1">`^.*$`</ph>，符合一行文字，呼叫<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%29&gt;</ph>方法來比對的字串，並使用的第一行<ph id="ph3">`Match.Index`</ph>和<ph id="ph4">`Match.Count`</ph>屬性，以判斷第二個的開始位置行。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The regular expression pattern <ph id="ph1">`^.*$`</ph> is defined as shown in the following table.</source>
          <target state="translated">規則運算式模式 <ph id="ph1">`^.*$`</ph> 的定義如下表所示。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the start of a line.</source>
          <target state="translated">比對行首。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(請注意，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件具現化使用<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph>選項; 否則這個字元類別會只比對輸入字串的開頭。)</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match any character zero or more times.</source>
          <target state="translated">比對任何字元零次以上。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Match the end of a line.</source>
          <target state="translated">比對行尾。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>(Note that the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object was instantiated by using the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option; otherwise, this character class would only match the beginning of the input string.)</source>
          <target state="translated">(請注意，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件具現化使用<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph>選項; 否則這個字元類別會只比對輸入字串的開頭。)</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>The replacement string (<ph id="ph1">`vbCrLf + "$&amp;"`</ph> in Visual Basic, <ph id="ph2">`"\n$&amp;"`</ph> in C#) adds a new line before the matched string.</source>
          <target state="translated">取代字串 (<ph id="ph1">`vbCrLf + "$&amp;"`</ph>在 Visual Basic 中<ph id="ph2">`"\n$&amp;"`</ph>C# 中) 會將新行之前比對的字串。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>Note that <ph id="ph1">`\n`</ph> in the C# example is interpreted as the newline character by the C# compiler; it does not represent a regular expression character escape.</source>
          <target state="translated">請注意，<ph id="ph1">`\n`</ph>在 C# 範例會解譯為新行字元的 C# 編譯器; 它不代表規則運算式字元逸出。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="replacement" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string.</source>
          <target state="translated">取代字串。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">指定的選項會修改符合的作業。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中沒有符合 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 的項目，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">靜態<ph id="ph1">`Replace`</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫的執行個體方法<ph id="ph3">`Replace`</ph>。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 參數指定 <ph id="ph2">`options`</ph>，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph>參數指定的字串來取代中的每個相符項目<ph id="ph2">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 可以包含常值文字的任何組合和<bpt id="p1">[</bpt>替代<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">例如，取代模式<ph id="ph1">`a*${test}b`</ph>插入的字串"*"後面接著所比對的子字串<ph id="ph2">`test`</ph>擷取群組，如果有的話，後面接著字串"b"。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 字元無法辨識為中繼字元取代模式內。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">替代是在取代模式中才能辨識的只是規則運算式語言項目。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">所有其他規則運算式語言項目，包括<bpt id="p1">[</bpt>字元逸出<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>、 可只在規則運算式模式中，而且無法辨識取代模式中。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法以取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer, and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">規則運算式會使用<ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph>屬性，以包括在本機電腦的名稱和<ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph>方法，將包含邏輯磁碟的名稱。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>All regular expression string comparisons are case-insensitive.</source>
          <target state="translated">所有的規則運算式的字串比較不區分大小寫。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">若要成功執行此範例，您應該以您本機電腦的名稱取代常值字串"MyMachine"。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">下列的運算式所定義的規則運算式模式：</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">比對兩個連續反斜線 (<ph id="ph1">`\`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">反斜線字元解譯為逸出字元，因此每個反斜線必須逸出與另一個反斜線。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">所傳回的字串相符<ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">比對句號 (<ph id="ph1">`.`</ph>) 字元後面接著一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">此比對可以發生零次以上。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">不會擷取相符子運算式。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">符合反斜線 (<ph id="ph1">`\`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">比對的字元類別包含的個別磁碟機代號。</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">此項比對是第一個擷取子運算式。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">比對常值的貨幣符號 (<ph id="ph1">`$`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">取代模式<ph id="ph1">`$1`</ph>整個相符項目取代為第一個擷取子運算式。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">也就是說，它會取代 UNC 電腦和磁碟機名稱的磁碟機代號。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph><ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which it is called.</source>
          <target state="translated">這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for replacing a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，取代模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">在指定的輸入字串中，使用 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 委派所傳回的字串來取代所有符合指定之規則運算式的字串。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">指定的選項會修改符合的作業。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中沒有符合 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 的項目，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match in if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>方法適合用來取代規則運算式相符項目中的，如果下列任何一個狀況成立：</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">規則運算式取代模式中無法隨時可以指定取代字串。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">取代字串會因某些處理對相符的字串。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">條件式處理取代字串結果。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">此方法相當於呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>方法並傳遞每個<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>在傳回的物件<ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>集合<ph id="ph4">`evaluator`</ph>委派。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph>參數是您定義的自訂方法的委派，會檢查每個符合項目。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">自訂的方法必須具有下列簽章，以符合<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">您的自訂方法會傳回字串，以取代相符的輸入。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 參數指定 <ph id="ph2">`options`</ph>，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated">如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">下列範例會使用規則運算式從字串擷取個別文字，然後再使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派以呼叫方法，名為<ph id="ph2">`WordScramble`</ph>，將金鑰加密在 word 中個別的字母。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">若要這樣做，<ph id="ph1">`WordScramble`</ph>方法會建立陣列，其中包含在比對的字元。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">它也會建立使用隨機浮點數值的它所擴展的平行陣列。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">陣列會依照呼叫<ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph>方法和已排序的陣列提供做為引數<ph id="ph2">&lt;xref:System.String&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">然後傳回此新建立的字串<ph id="ph1">`WordScramble`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\w+`</ph>比對一個或多個文字字元，規則運算式引擎會繼續將字元加入至比對，直到遇到非文字字元，例如空格字元。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法包含<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph>選項，讓規則運算式模式中的註解<ph id="ph3">`\w+  # Matches all the characters in a word.`</ph>會忽略規則運算式引擎。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph><ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The maximum number of times the replacement will occur.</source>
          <target state="translated">取代將發生的最多次數。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The character position in the input string where the search begins.</source>
          <target state="translated">在輸入字串中開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">在指定的輸入子字串中，使用 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">規則運算式取代模式中無法隨時可以指定取代字串。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from some processing done on the matched string.</source>
          <target state="translated">取代字串會因某些處理對相符的字串。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The replacement string results from conditional processing.</source>
          <target state="translated">條件式處理取代字串結果。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passing the first <ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph5">`evaluator`</ph> delegate.</source>
          <target state="translated">此方法相當於呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法並傳遞第一個<ph id="ph2">`count`</ph><ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>中傳回的物件<ph id="ph4">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>集合<ph id="ph5">`evaluator`</ph>委派。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The regular expression is the pattern defined by the constructor for the current <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object.</source>
          <target state="translated">規則運算式是目前的建構函式所定義的模式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph>參數是您定義的自訂方法的委派，會檢查每個符合項目。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">自訂的方法必須具有下列簽章，以符合<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">您的自訂方法會傳回字串，以取代相符的輸入。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the replacement operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">如果取代作業的執行時間超出 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> 建構函式所指定的逾時間隔，就會擲回 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> 例外狀況。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="evaluator" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement string.</source>
          <target state="translated">取代字串。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</source>
          <target state="translated">在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中沒有符合 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 的項目，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The static <ph id="ph1">`Replace`</ph> methods are equivalent to constructing a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with the specified regular expression pattern and calling the instance method <ph id="ph3">`Replace`</ph>.</source>
          <target state="translated">靜態<ph id="ph1">`Replace`</ph>方法相當於建構<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>物件與指定的規則運算式模式，並呼叫的執行個體方法<ph id="ph3">`Replace`</ph>。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 參數指定 <ph id="ph2">`options`</ph>，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`replacement`</ph> parameter specifies the string that is to replace each match in <ph id="ph2">`input`</ph>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph>參數指定的字串來取代中的每個相符項目<ph id="ph2">`input`</ph>。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`replacement`</ph> can consist of any combination of literal text and <bpt id="p1">[</bpt>substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated"><ph id="ph1">`replacement`</ph> 可以包含常值文字的任何組合和<bpt id="p1">[</bpt>替代<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the replacement pattern <ph id="ph1">`a*${test}b`</ph> inserts the string "a*" followed by the substring that is matched by the <ph id="ph2">`test`</ph> capturing group, if any, followed by the string "b".</source>
          <target state="translated">例如，取代模式<ph id="ph1">`a*${test}b`</ph>插入的字串"*"後面接著所比對的子字串<ph id="ph2">`test`</ph>擷取群組，如果有的話，後面接著字串"b"。</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The * character is not recognized as a metacharacter within a replacement pattern.</source>
          <target state="translated">* 字元無法辨識為中繼字元取代模式內。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Substitutions are the only regular expression language elements that are recognized in a replacement pattern.</source>
          <target state="translated">替代是在取代模式中才能辨識的只是規則運算式語言項目。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All other regular expression language elements, including <bpt id="p1">[</bpt>character escapes<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>, are allowed in regular expression patterns only and are not recognized in replacement patterns.</source>
          <target state="translated">所有其他規則運算式語言項目，包括<bpt id="p1">[</bpt>字元逸出<ept id="p1">](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)</ept>、 可只在規則運算式模式中，而且無法辨識取代模式中。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph>參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>和<bpt id="p2">[</bpt>回溯<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">如果該時間間隔中找到相符項目，方法會擲回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph> method to replace the local machine and drive names in a UNC path with a local file path.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29&gt;</ph>方法以取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression uses the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property to include the name of the local computer and the <ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph> method to include the names of the logical drives.</source>
          <target state="translated">規則運算式會使用<ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph>屬性，以包括本機電腦的名稱和<ph id="ph2">&lt;xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType&gt;</ph>方法，將包含邏輯磁碟的名稱。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>All regular expression string comparisons are case-insensitive, and any single replacement operation times out if a match cannot be found in 0.5 second.</source>
          <target state="translated">所有的規則運算式的字串比較會區分大小寫，和任何單一的取代作業逾時，如果 0.5 秒內找不到相符項目。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To run the example successfully, you should replace the literal string "MyMachine" with your local machine name.</source>
          <target state="translated">若要成功執行此範例，您應該以您本機電腦的名稱取代常值字串"MyMachine"。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern is defined by the following expression:</source>
          <target state="translated">下列的運算式所定義的規則運算式模式：</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following table shows how the regular expression pattern is interpreted.</source>
          <target state="translated">下表顯示規則運算式模式的解譯方式。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Pattern</source>
          <target state="translated">模式</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match two consecutive backslash (<ph id="ph1">`\`</ph>) characters.</source>
          <target state="translated">比對兩個連續反斜線 (<ph id="ph1">`\`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the backslash character is interpreted as the escape character, each backslash must be escaped with another backslash.</source>
          <target state="translated">反斜線字元解譯為逸出字元，因此每個反斜線必須逸出與另一個反斜線。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the string that is returned by the <ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">所傳回的字串相符<ph id="ph1">&lt;xref:System.Environment.MachineName%2A?displayProperty=nameWithType&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the period (<ph id="ph1">`.`</ph>) character followed by one or more word characters.</source>
          <target state="translated">比對句號 (<ph id="ph1">`.`</ph>) 字元後面接著一個或多個文字字元。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match can occur zero or more times.</source>
          <target state="translated">此比對可以發生零次以上。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The matched subexpression is not captured.</source>
          <target state="translated">不會擷取相符子運算式。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match a backslash (<ph id="ph1">`\`</ph>) character.</source>
          <target state="translated">符合反斜線 (<ph id="ph1">`\`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the character class that consists of the individual drive letters.</source>
          <target state="translated">比對的字元類別包含的個別磁碟機代號。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This match is the first captured subexpression.</source>
          <target state="translated">此項比對是第一個擷取子運算式。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Match the literal dollar sign (<ph id="ph1">`$`</ph>) character.</source>
          <target state="translated">比對常值的貨幣符號 (<ph id="ph1">`$`</ph>) 字元。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The replacement pattern <ph id="ph1">`$1`</ph> replaces the entire match with the first captured subexpression.</source>
          <target state="translated">取代模式<ph id="ph1">`$1`</ph>整個相符項目取代為第一個擷取子運算式。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>That is, it replaces the UNC machine and drive name with the drive letter.</source>
          <target state="translated">也就是說，它會取代 UNC 電腦和磁碟機名稱的磁碟機代號。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph><ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="replacement" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to search for a match.</source>
          <target state="translated">用來搜尋比對的字串。</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A custom method that examines each match and returns either the original matched string or a replacement string.</source>
          <target state="translated">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> delegate.</source>
          <target state="translated">在指定的輸入字串中，使用 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.MatchEvaluator" /&gt;</ph> 委派所傳回的字串來取代所有符合指定之規則運算式的子字串。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</source>
          <target state="translated">與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> is not matched in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">如果在目前的執行個體中沒有符合 <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 的項目，則方法傳回未變更的目前執行個體。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is useful for replacing a regular expression match if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>方法適合用來取代規則運算式相符項目，如果下列任何一個狀況成立：</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string cannot readily be specified by a regular expression replacement pattern.</source>
          <target state="translated">規則運算式取代模式中無法輕易地加以指定取代字串。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from some processing performed on the matched string.</source>
          <target state="translated">如果是取代字串得到的某些處理執行比對的字串。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the replacement string results from conditional processing.</source>
          <target state="translated">如果是取代字串而產生的條件式處理。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The method is equivalent to calling the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method and passing each <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object in the returned <ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> collection to the <ph id="ph4">`evaluator`</ph> delegate.</source>
          <target state="translated">此方法相當於呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph>方法並傳遞每個<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph>在傳回的物件<ph id="ph3">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph>集合<ph id="ph4">`evaluator`</ph>委派。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`evaluator`</ph> parameter is the delegate for a custom method that you define and that examines each match.</source>
          <target state="translated"><ph id="ph1">`evaluator`</ph>參數是您定義的自訂方法的委派，會檢查每個符合項目。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The custom method must have the following signature to match the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate.</source>
          <target state="translated">自訂的方法必須具有下列簽章，以符合<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Your custom method returns a string that replaces the matched input.</source>
          <target state="translated">您的自訂方法會傳回字串，以取代相符的輸入。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you specify <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> for the <ph id="ph2">`options`</ph> parameter, the search for matches begins at the end of the input string and moves left; otherwise, the search begins at the start of the input string and moves right.</source>
          <target state="translated">如果為 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> 參數指定 <ph id="ph2">`options`</ph>，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to "stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph>參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯，從顯示的規則運算式 」 停止回應時，它們會處理輸入，其中包含相符項目附近。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>和<bpt id="p2">[</bpt>回溯<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">如果該時間間隔中找到相符項目，方法會擲回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the method returns <ph id="ph1">`input`</ph> unchanged if there is no match, you can use the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method to determine whether the method has made any replacements to the input string.</source>
          <target state="translated">因為此方法會傳回<ph id="ph1">`input`</ph>保持不變，如果沒有相符項目，您可以使用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>來決定方法是否有任何取代項目與輸入字串的方法。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses a regular expression to extract the individual words from a string, and then uses a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph> delegate to call a method named <ph id="ph2">`WordScramble`</ph> that scrambles the individual letters in the word.</source>
          <target state="translated">下列範例會使用規則運算式從字串擷取個別文字，然後再使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchEvaluator&gt;</ph>委派以呼叫方法，名為<ph id="ph2">`WordScramble`</ph>，將金鑰加密在 word 中個別的字母。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To do this, the <ph id="ph1">`WordScramble`</ph> method creates an array that contains the characters in the match.</source>
          <target state="translated">若要這樣做，<ph id="ph1">`WordScramble`</ph>方法會建立陣列，其中包含在比對的字元。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>It also creates a parallel array that it populates with random floating-point numbers.</source>
          <target state="translated">它也會建立使用隨機浮點數值的它所擴展的平行陣列。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The arrays are sorted by calling the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method, and the sorted array is provided as an argument to a <ph id="ph2">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">陣列會依照呼叫<ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph>方法和已排序的陣列提供做為引數<ph id="ph2">&lt;xref:System.String&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This newly created string is then returned by the <ph id="ph1">`WordScramble`</ph> method.</source>
          <target state="translated">然後傳回此新建立的字串<ph id="ph1">`WordScramble`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern <ph id="ph1">`\w+`</ph> matches one or more word characters; the regular expression engine will continue to add characters to the match until it encounters a non-word character, such as a white-space character.</source>
          <target state="translated">規則運算式模式<ph id="ph1">`\w+`</ph>比對一個或多個文字字元，規則運算式引擎會繼續將字元加入至比對，直到遇到非文字字元，例如空格字元。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> method includes the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph> option so that the comment in the regular expression pattern <ph id="ph3">`\w+  # Matches all the characters in a word.`</ph> is ignored by the regular expression engine.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph>方法包含<ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType&gt;</ph>選項，讓規則運算式模式中的註解<ph id="ph3">`\w+  # Matches all the characters in a word.`</ph>會忽略規則運算式引擎。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph>, <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph><ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="evaluator" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source>Gets a value that indicates whether the regular expression searches from right to left.</source>
          <target state="translated">取得值，指出規則運算式是否由右至左搜尋。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the regular expression searches from right to left; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果規則運算式由右至左搜尋，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Regex.RightToLeft">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> is <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> instance was created with the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.RightToLeft%2A&gt;</ph> 是<ph id="ph2">`true`</ph>如果<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph>建立執行個體與<ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexOptions.RightToLeft&gt;</ph>選項。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="F:System.Text.RegularExpressions.Regex.roptions">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Regex">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression match.</source>
          <target state="translated">在規則運算式比對所定義的位置，將輸入字串分割成子字串陣列。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string to split.</source>
          <target state="translated">要分隔的字串。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">在 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式中指定之規則運算式模式所定義的位置，將輸入字串分隔成子字串的陣列。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>An array of strings.</source>
          <target state="translated">字串的陣列。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法都是類似於<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法，不同處在於<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>分割在規則運算式，而不是一組字元所決定的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">將字串分割為許多次。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no delimiter is found, the return value contains one element whose value is the original input string.</source>
          <target state="translated">如果不找到任何分隔符號，則傳回的值會包含一個項目，其值為原始的輸入的字串。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">如果多個相符項目彼此相鄰的、 空字串會插入至陣列。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">例如，分割上的單一連字號的字串會造成傳回的陣列，其中兩個相鄰的連字號找不到，下列程式碼所示的位置包含空字串。</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">下列範例會使用規則運算式模式<ph id="ph1">`\d+`</ph>分割輸入的字串的數字字元。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">因為字串開始和結尾相符的字元數值，傳回的陣列的第一個和最後一個項目的值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">如果擷取括號中使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>運算式中，任何擷取的文字是否包含在產生的字串陣列。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">如果規則運算式可以比對空字串，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%29&gt;</ph>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For example:</source>
          <target state="translated">例如: </target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">請注意，傳回的陣列也會包含空字串開頭和結尾的陣列。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>如果 split 作業的執行時間超過指定的逾時間隔，會擲回例外狀況<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">要分隔的字串。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">分隔作業可以發生的最多次數。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">在 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">字串的陣列。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法都是類似於<ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>方法，不同處在於<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>分割在規則運算式，而不是一組字元所決定的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string can be split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated"><ph id="ph1">`count`</ph>參數會指定到其中的子字串的最大數目<ph id="ph2">`input`</ph>可以分割成字串; 最後一個字串包含 unsplit 的字串的其餘部分。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">A<ph id="ph1">`count`</ph>為零的值會提供分割成許多次越好的預設行為。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If multiple matches are adjacent to one another or if a match is found at the beginning or end of <ph id="ph1">`input`</ph>, and the number of matches found is at least two less than <ph id="ph2">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">如果多個相符項目彼此相鄰或開頭或結尾找到相符<ph id="ph1">`input`</ph>，而且找到符合項目數目至少兩個小於<ph id="ph2">`count`</ph>，空字串插入到陣列。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>That is, empty strings that result from adjacent matches or from matches at the beginning or end of the input string are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">也就是說，從相鄰的相符項目或開頭或結尾的輸入字串的相符項目會造成的空字串會算入判斷是否數目比對的子字串等於<ph id="ph1">`count`</ph>。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`/d+`</ph> is used to split an input string that includes one or more decimal digits into a maximum of three substrings.</source>
          <target state="translated">在下列範例中，規則運算式<ph id="ph1">`/d+`</ph>用來分割輸入的字串成最多三個子字串包含一個或多個十進位數字。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the beginning of the input string matches the regular expression pattern, the first array element contains <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, the second contains the first set of alphabetic characters in the input string, and the third contains the remainder of the string that follows the third match.</source>
          <target state="translated">輸入字串的開頭比對規則運算式模式，因為第一個陣列元素包含<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>、 第二個包含字母字元，輸入字串中第一個集合，而第三個包含字串的其餘部分一節的第三個相符項目。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">如果規則運算式中使用擷取括號，就會分隔字串的陣列中包含任何擷取的文字。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">不過，任何陣列元素包含擷取的文字不會包含在判斷是否相符項目數目已達到<ph id="ph1">`count`</ph>。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, splitting the string "apple-apricot-plum-pear-banana" into a maximum of four substrings results in a seven-element array, as the following code shows.</source>
          <target state="translated">例如，顯示分割成最多四個的子字串結果七個元素陣列，如以下程式碼中的"apple-apricot-梅紅-西洋梨-香蕉"字串。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>In the .NET Framework 1.0 and 1.1, only captured text from the first set of capturing parentheses is included in the returned array.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，只擷取的文字第一個集合擷取括號會包含傳回陣列中。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is added to the returned array.</source>
          <target state="translated">從.NET Framework 2.0 開始，所有擷取的文字加入至傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>However, elements in the returned array that contain captured text are not counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">不過，在傳回陣列中包含擷取的文字的項目不會計算在決定是否數目比對的子字串等於<ph id="ph1">`count`</ph>。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For example, in the following code, a regular expression uses two sets of capturing parentheses to extract the elements of a date from a date string.</source>
          <target state="translated">例如，下列程式碼，規則運算式會使用日期的項目擷取的日期字串兩組擷取括號。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> method then specifies a maximum of two elements in the returned array.</source>
          <target state="translated">若要呼叫<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph>方法然後傳回陣列中指定最多兩個項目。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, the method returns a two-element string array.</source>
          <target state="translated">如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，則方法會傳回兩個元素的字串陣列。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If it is compiled and run under the .NET Framework 2.0 or later versions, the method returns a three-element string array.</source>
          <target state="translated">如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，方法會傳回三個元素的字串陣列。</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">如果規則運算式可以比對空字串，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29&gt;</ph>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as there are in the input string.</source>
          <target state="translated">下列範例分割成字串 「 字元 」，因為輸入字串中有許多項目。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>Because the null string matches the beginning of the input string, a null string is inserted at the beginning of the returned array.</source>
          <target state="translated">由於 null 字串比對輸入字串的開頭，則傳回的陣列的開頭插入的 null 字串。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>This causes the tenth element to consist of the two characters at the end of the input string.</source>
          <target state="translated">這會造成要在輸入字串結尾處的兩個字元所組成的第十個項目。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>如果 split 作業的執行時間超過指定的逾時間隔，會擲回例外狀況<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The string to split.</source>
          <target state="translated">要分隔的字串。</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</source>
          <target state="translated">在規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>An array of strings.</source>
          <target state="translated">字串的陣列。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法都是類似於<ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>方法，不同處在於<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>分割在規則運算式，而不是一組字元所決定的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`input`</ph> string is split as many times as possible.</source>
          <target state="translated"><ph id="ph1">`input`</ph>字串分割成許多次越好。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If <ph id="ph1">`pattern`</ph> is not found in the <ph id="ph2">`input`</ph> string, the return value contains one element whose value is the original <ph id="ph3">`input`</ph> string.</source>
          <target state="translated">如果<ph id="ph1">`pattern`</ph>中找不到<ph id="ph2">`input`</ph>字串，傳回的值包含一個項目，其值是原始<ph id="ph3">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">編譯為靜態的呼叫中使用的規則運算式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法會自動快取。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">若要自行管理編譯的規則運算式的存留期，使用 執行個體<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">如果多個相符項目彼此相鄰的、 空字串會插入至陣列。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found, as the following code shows.</source>
          <target state="translated">例如，分割上的單一連字號的字串會造成傳回的陣列，其中兩個相鄰的連字號找不到，下列程式碼所示的位置包含空字串。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`\d+`</ph> to split an input string on numeric characters.</source>
          <target state="translated">下列範例會使用規則運算式模式<ph id="ph1">`\d+`</ph>分割輸入的字串的數字字元。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Because the string begins and ends with matching numeric characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">因為字串開始和結尾相符的字元數值，傳回的陣列的第一個和最後一個項目的值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">如果擷取括號中使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>運算式中，任何擷取的文字是否包含在產生的字串陣列。</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">如果規則運算式可以比對空字串，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For example:</source>
          <target state="translated">例如: </target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>Note that the returned array also includes an empty string at the beginning and end of the array.</source>
          <target state="translated">請注意，傳回的陣列也會包含空字串開頭和結尾的陣列。</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>如果 split 作業的執行時間超過逾時間隔，此方法會呼叫的應用程式定義域指定，會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">此方法等於呼叫該方法的應用程式定義域的預設逾時值一段時間後逾時。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，來分割文字模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The string to be split.</source>
          <target state="translated">要分隔的字串。</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The maximum number of times the split can occur.</source>
          <target state="translated">分隔作業可以發生的最多次數。</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The character position in the input string where the search will begin.</source>
          <target state="translated">在輸入字串中要開始搜尋的字元位置。</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> constructor.</source>
          <target state="translated">在 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The search for the regular expression pattern starts at a specified character position in the input string.</source>
          <target state="translated">規則運算式模式從輸入字串中指定的字元位置開始搜尋。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>An array of strings.</source>
          <target state="translated">字串的陣列。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法都是類似於<ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>方法，不同處在於<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>分割在規則運算式，而不是一組字元所決定的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter specifies the maximum number of substrings into which the <ph id="ph2">`input`</ph> string is split; the last string contains the unsplit remainder of the string.</source>
          <target state="translated"><ph id="ph1">`count`</ph>參數會指定到其中的子字串的最大數目<ph id="ph2">`input`</ph>字串分割; 最後一個字串包含 unsplit 的字串的其餘部分。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A <ph id="ph1">`count`</ph> value of zero provides the default behavior of splitting as many times as possible.</source>
          <target state="translated">A<ph id="ph1">`count`</ph>為零的值會提供分割成許多次越好的預設行為。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startat`</ph> parameter defines the point at which the search for the first delimiter begins (this can be used for skipping leading white space).</source>
          <target state="translated"><ph id="ph1">`startat`</ph>參數定義的第一個分隔符號搜尋開始的點 （這可以用來略過前置空白字元）。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no matches are found from the <ph id="ph1">`count`</ph>+1 position in the string, the method returns a one-element array that contains the <ph id="ph2">`input`</ph> string.</source>
          <target state="translated">如果沒有符合的項目從<ph id="ph1">`count`</ph>+ 1 定位在字串中，方法會傳回一個項目陣列，包含<ph id="ph2">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If one or more matches are found, the first element of the returned array contains the first portion of the string from the first character up to one character before the match.</source>
          <target state="translated">如果找不到一或多個相符項目，傳回的陣列的第一個元素包含從第一個字元，最多前比對一個字元字串的第一個部分。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If multiple matches are adjacent to one another and the number of matches found is at least two less than <ph id="ph1">`count`</ph>, an empty string is inserted into the array.</source>
          <target state="translated">如果多個相符項目彼此相鄰，而且找到符合項目數目是至少兩個小於<ph id="ph1">`count`</ph>，空字串插入到陣列。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Similarly, if a match is found at <ph id="ph1">`startat`</ph>, which is the first character in the string, the first element of the returned array is an empty string.</source>
          <target state="translated">同樣地，如果在找到相符項目<ph id="ph1">`startat`</ph>，是在字串中的第一個字元，傳回之陣列的第一個項目為空字串。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>That is, empty strings that result from adjacent matches are counted in determining whether the number of matched substrings equals <ph id="ph1">`count`</ph>.</source>
          <target state="translated">也就是空的字串所產生的相鄰的相符項目會計算在決定是否數目比對的子字串等於<ph id="ph1">`count`</ph>。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In the following example, the regular expression <ph id="ph1">`\d+`</ph> is used to find the starting position of the first substring of numeric characters in a string, and then to split the string a maximum of three times starting at that position.</source>
          <target state="translated">在下列範例中，規則運算式<ph id="ph1">`\d+`</ph>用來尋找數字字元的第一個子字串的開始位置在字串中，然後再將字串分割最多三次起始該位置。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the regular expression pattern matches the beginning of the input string, the returned string array consists of an empty string, a five-character alphabetic string, and the remainder of the string,</source>
          <target state="translated">由於規則運算式模式比對輸入字串的開頭，傳回的字串陣列包含空字串、 五個字元的英數字字串，以及字串的其餘部分</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If capturing parentheses are used in a regular expression, any captured text is included in the array of split strings.</source>
          <target state="translated">如果規則運算式中使用擷取括號，就會分隔字串的陣列中包含任何擷取的文字。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, any array elements that contain captured text are not counted in determining whether the number of matches has reached <ph id="ph1">`count`</ph>.</source>
          <target state="translated">不過，任何陣列元素包含擷取的文字不會包含在判斷是否相符項目數目已達到<ph id="ph1">`count`</ph>。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, splitting the string '"apple-apricot-plum-pear-pomegranate-pineapple-peach" into a maximum of four substrings beginning at character 15 in the string results in a seven-element array, as the following code shows.</source>
          <target state="translated">例如，分割字串 '"apple-apricot-plum-pear-pomegranate-pineapple-peach 」 成四個最多的子字串開始於 15 字元字串中的結果七個元素的陣列，如下列程式碼所示。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>In .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the individual words in a string.</source>
          <target state="translated">例如，下列程式碼會使用兩組擷取括號來擷取個別的文字字串中。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the vertical bar.</source>
          <target state="translated">第一組擷取括號會擷取連字號，和第二個集合擷取的垂直列。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the vertical bar characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除垂直列字元;如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">如果規則運算式可以比對空字串，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The following example splits the string "characters" into as many elements as the input string contains, starting with the character "a".</source>
          <target state="translated">下列範例會分割成多的項目字串 「 字元 」 包含輸入的字串，以字元當做開頭為"a"。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>Because the null string matches the end of the input string, a null string is inserted at the end of the returned array.</source>
          <target state="translated">因為 null 字串比對輸入字串的結尾，傳回的陣列結尾處插入的 null 字串。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>如果 split 作業的執行時間超過指定的逾時間隔，會擲回例外狀況<ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If you do not set a time-out interval when you call the constructor, the exception is thrown if the operation exceeds any time-out value established for the application domain in which the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object is created.</source>
          <target state="translated">呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>If no time-out is defined in the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> constructor call or in the application domain's properties, or if the time-out value is <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown</source>
          <target state="translated">如果在 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> is less than zero or greater than the length of <ph id="ph2">&lt;paramref name="input" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startat" /&gt;</ph> 小於零或大於 <ph id="ph2">&lt;paramref name="input" /&gt;</ph> 的長度。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string to split.</source>
          <target state="translated">要分隔的字串。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Specified options modify the matching operation.</source>
          <target state="translated">指定的選項會修改符合的作業。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>An array of strings.</source>
          <target state="translated">字串的陣列。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法都是類似於<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法，不同處在於<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>分割在規則運算式，而不是一組字元所決定的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">將字串分割為許多次。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">如果不找到任何分隔符號，則傳回值包含一個項目，其值是原始<ph id="ph1">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">編譯為靜態的呼叫中使用的規則運算式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法會自動快取。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">若要自行管理編譯的規則運算式的存留期，使用 執行個體<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">如果多個相符項目彼此相鄰的、 空字串會插入至陣列。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">例如，分割上的單一連字號的字串會造成傳回的陣列中找到兩個相鄰的連字號的位置包含空字串。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">下列範例會使用規則運算式模式<ph id="ph1">`[a-z]+`</ph>分割輸入的字串的大寫或小寫字母的字元。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">因為字串開始和結尾相符的字母字元，則傳回的陣列的第一個和最後一個項目的值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">如果擷取括號中使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>運算式中，任何擷取的文字是否包含在產生的字串陣列。</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">如果規則運算式可以比對空字串，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception is thrown if the execution time of the split operation exceeds the time-out interval specified for the application domain in which the method is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>如果 split 作業的執行時間超過逾時間隔，此方法會呼叫的應用程式定義域指定，會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If no time-out is defined in the application domain's properties, or if the time-out value is <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType&gt;</ph>，則不擲回任何例外狀況。</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>This method times out after an interval that is equal to the default time-out value of the application domain in which the method is called.</source>
          <target state="translated">此方法等於呼叫該方法的應用程式定義域的預設逾時值一段時間後逾時。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>If a time-out value has not been defined for the application domain, the value <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, which prevents the method from timing out, is used.</source>
          <target state="translated">如果未針對應用程式定義域定義逾時值，則使用值 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，使方法不會逾時。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
          <source>The recommended static method for splitting text on a pattern match is <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>, which lets you set the time-out interval.</source>
          <target state="translated">建議的靜態方法，來分割文字模式比對是<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" /&gt;</ph>，可讓您設定的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string to split.</source>
          <target state="translated">要分隔的字串。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The regular expression pattern to match.</source>
          <target state="translated">要比對的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A bitwise combination of the enumeration values that provide options for matching.</source>
          <target state="translated">列舉值的位元組合，提供用於比對的選項。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out interval, or <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph> to indicate that the method should not time out.</source>
          <target state="translated">間隔，若要表示此方法不會逾時則為 <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern.</source>
          <target state="translated">在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</source>
          <target state="translated">如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A string array.</source>
          <target state="translated">字串陣列。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> methods are similar to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method, except that <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> splits the string at a delimiter determined by a regular expression instead of a set of characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>方法都是類似於<ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法，不同處在於<ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>分割在規則運算式，而不是一組字元所決定的分隔符號字串。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The string is split as many times as possible.</source>
          <target state="translated">將字串分割為許多次。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no delimiter is found, the return value contains one element whose value is the original <ph id="ph1">`input`</ph> string.</source>
          <target state="translated">如果不找到任何分隔符號，則傳回值包含一個項目，其值是原始<ph id="ph1">`input`</ph>字串。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Compiled regular expressions used in calls to static <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods are automatically cached.</source>
          <target state="translated">編譯為靜態的呼叫中使用的規則運算式<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法會自動快取。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>To manage the lifetime of compiled regular expressions yourself, use the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> methods.</source>
          <target state="translated">若要自行管理編譯的規則運算式的存留期，使用 執行個體<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If multiple matches are adjacent to one another, an empty string is inserted into the array.</source>
          <target state="translated">如果多個相符項目彼此相鄰的、 空字串會插入至陣列。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, splitting a string on a single hyphen causes the returned array to include an empty string in the position where two adjacent hyphens are found.</source>
          <target state="translated">例如，分割上的單一連字號的字串會造成傳回的陣列中找到兩個相鄰的連字號的位置包含空字串。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If a match is found at the beginning or the end of the input string, an empty string is included at the beginning or the end of the returned array.</source>
          <target state="translated">如果找到符合的開頭或輸入字串的結尾，空字串就會包含開頭或結尾傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The following example uses the regular expression pattern <ph id="ph1">`[a-z]+`</ph> to split an input string on any uppercase or lowercase alphabetic character.</source>
          <target state="translated">下列範例會使用規則運算式模式<ph id="ph1">`[a-z]+`</ph>分割輸入的字串的大寫或小寫字母的字元。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Because the string begins and ends with matching alphabetic characters, the value of the first and last element of the returned array is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">因為字串開始和結尾相符的字母字元，則傳回的陣列的第一個和最後一個項目的值是<ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If capturing parentheses are used in a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> expression, any captured text is included in the resulting string array.</source>
          <target state="translated">如果擷取括號中使用<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph>運算式中，任何擷取的文字是否包含在產生的字串陣列。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, if you split the string "plum-pear" on a hyphen placed within capturing parentheses, the returned array includes a string element that contains the hyphen.</source>
          <target state="translated">比方說，如果您分割字串"梅紅-西洋梨 」 上連字號放在擷取括號時，傳回的陣列會包含字串項目，其中包含連字號。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, when the regular expression pattern includes multiple sets of capturing parentheses, the behavior of this method depends on the version of the .NET Framework.</source>
          <target state="translated">不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>In the .NET Framework 1.0 and 1.1, if a match is not found within the first set of capturing parentheses, captured text from additional capturing parentheses is not included in the returned array.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 中，如果第一組擷取括號內找不到相符項目包含擷取的文字其他擷取括號不是傳回陣列中。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>Starting with the .NET Framework 2.0, all captured text is also added to the returned array.</source>
          <target state="translated">從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For example, the following code uses two sets of capturing parentheses to extract the elements of a date, including the date delimiters, from a date string.</source>
          <target state="translated">例如，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The first set of capturing parentheses captures the hyphen, and the second set captures the forward slash.</source>
          <target state="translated">第一個集合擷取括號會擷取連字號，和第二個集合擷取正斜線。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the example code is compiled and run under the .NET Framework 1.0 or 1.1, it excludes the slash characters; if it is compiled and run under the .NET Framework 2.0 or later versions, it includes them.</source>
          <target state="translated">如果編譯範例程式碼，並在.NET Framework 1.0 或 1.1 之下執行，它會排除斜線字元。如果它是編譯，而且.NET Framework 2.0 或更新版本底下執行，它會包含它們。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If the regular expression can match the empty string, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph> will split the string into an array of single-character strings because the empty string delimiter can be found at every location.</source>
          <target state="translated">如果規則運算式可以比對空字串，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A&gt;</ph>會將字串分割成單一字元字串陣列，因為在每個位置找不到空字串分隔符號。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>The <ph id="ph1">`matchTimeout`</ph> parameter specifies how long a pattern matching method should try to find a match before it times out. Setting a time-out interval prevents regular expressions that rely on excessive backtracking from appearing to stop responding when they process input that contains near matches.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph>參數會指定如何長模式比對方法應嘗試尋找相符項目，即會逾時。設定逾時間隔可避免依賴大量回溯出現停止回應時，它們會處理輸入的規則運算式，其中包含相符項目附近。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Regular Expressions<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept> and <bpt id="p2">[</bpt>Backtracking<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>規則運算式的最佳作法<ept id="p1">](~/docs/standard/base-types/best-practices.md)</ept>和<bpt id="p2">[</bpt>回溯<ept id="p2">](~/docs/standard/base-types/backtracking-in-regular-expressions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If no match is found in that time interval, the method throws a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
          <target state="translated">如果該時間間隔中找到相符項目，方法會擲回<ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>例外狀況。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">`matchTimeout`</ph> overrides any default time-out value defined for the application domain in which the method executes.</source>
          <target state="translated"><ph id="ph1">`matchTimeout`</ph> 覆寫任何方法執行於其中的應用程式定義域定義的預設逾時值。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A regular expression parsing error occurred.</source>
          <target state="translated">發生規則運算式剖析錯誤。</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="input" /&gt;</ph> or <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="input" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> 為 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a valid bitwise combination of <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.RegexOptions" /&gt;</ph> 值的有效位元組合。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> is negative, zero, or greater than approximately 24 days.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> 為負數、零或大約大於 24 天。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>A time-out occurred.</source>
          <target state="translated">發生逾時。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>For more information about time-outs, see the Remarks section.</source>
          <target state="translated">如需逾時的詳細資訊，請參閱＜備註＞一節。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>We recommend that you set the <ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph> parameter to an appropriate value, such as two seconds.</source>
          <target state="translated">我們建議您將<ph id="ph1">&lt;paramref name="matchTimeout" /&gt;</ph>參數，以適當的值，例如兩秒。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>If you disable time-outs by specifying <ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>, the regular expression engine offers slightly better performance.</source>
          <target state="translated">如果您停用逾時指定<ph id="ph1">&lt;see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /&gt;</ph>，規則運算式引擎會提供稍微較佳的效能。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>However, you should disable time-outs only under the following conditions:</source>
          <target state="translated">不過，您應該停用逾時，只有在下列情況下：</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the input processed by a regular expression is derived from a known and trusted source or consists of static text.</source>
          <target state="translated">當規則運算式所處理的輸入衍生自已知且受信任的來源，或包含靜態文字。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>This excludes text that has been dynamically input by users.</source>
          <target state="translated">這不包括已動態使用者所輸入的文字。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern has been thoroughly tested to ensure that it efficiently handles matches, non-matches, and near matches.</source>
          <target state="translated">當規則運算式模式已徹底測試以確保它有效率地處理符合，不符合，不久符合。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)">
          <source>When the regular expression pattern contains no language elements that are known to cause excessive backtracking when processing a near match.</source>
          <target state="translated">當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to populate with serialization information.</source>
          <target state="translated">要使用序列化資訊來填入的物件。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The place to store and retrieve serialized data.</source>
          <target state="translated">要儲存並擷取序列化資料的位置。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This parameter is reserved for future use.</source>
          <target state="translated">這個參數保留給未來的版本使用。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with the data necessary to deserialize the current <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object.</source>
          <target state="translated">將還原序列化目前 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 物件所需的資料填入 (Populate) <ph id="ph2">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>Returns the regular expression pattern that was passed into the <ph id="ph1">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated">傳回傳遞至 <ph id="ph1">&lt;see langword="Regex" /&gt;</ph> 建構函式中的規則運算式模式。</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> parameter that was passed into the <ph id="ph2">&lt;see langword="Regex" /&gt;</ph> constructor.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pattern" /&gt;</ph> 參數，傳遞至 <ph id="ph2">&lt;see langword="Regex" /&gt;</ph> 建構函式。</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>The <ph id="ph1">`pattern`</ph> parameter consists of regular expression language elements that symbolically describe the string to match.</source>
          <target state="translated"><ph id="ph1">`pattern`</ph> 參數包含規則運算式語言項目，以透過符號描述要比對的字串。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>For more information about regular expressions, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept> and <bpt id="p2">[</bpt>Regular Expression Language - Quick Reference<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>.</source>
          <target state="translated">如需有關規則運算式的詳細資訊，請參閱<bpt id="p1">[</bpt>.NET Framework 規則運算式<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>和<bpt id="p2">[</bpt>規則運算式語言-快速參考<ept id="p2">](~/docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> is the base class of regular expressions created by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 基底類別所建立的規則運算式的<ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>These compiled regular expressions use the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> implementation of the base class.</source>
          <target state="translated">這些編譯規則運算式使用<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph>基底類別的實作。</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.ToString">
          <source>If called from a derived class, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph> method returns the string that was passed to the <ph id="ph2">&lt;paramref name="pattern" /&gt;</ph> parameter of the <ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph> class constructor that was used to define the regular expression.</source>
          <target state="translated">如果已從衍生類別呼叫<ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Regex.ToString" /&gt;</ph>方法會傳回字串傳遞給<ph id="ph2">&lt;paramref name="pattern" /&gt;</ph>參數<ph id="ph3">&lt;see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /&gt;</ph>類別建構函式是用來定義規則運算式。</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The input string containing the text to convert.</source>
          <target state="translated">輸入字串，包含要轉換的文字。</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>Converts any escaped characters in the input string.</source>
          <target state="translated">轉換輸入字串中任何逸出的字元。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>A string of characters with any escaped characters converted to their unescaped form.</source>
          <target state="translated">字元字串，其中任何逸出字元轉換成其未逸出格式。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method performs one of the following two transformations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph>方法會執行下列兩個轉換的其中一個：</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It reverses the transformation performed by the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph> method by removing the escape character ("<ph id="ph2">\\</ph>") from each character escaped by the method.</source>
          <target state="translated">它會反轉所執行的轉換<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Escape%2A&gt;</ph>方法藉由移除逸出字元 ("<ph id="ph2">\\</ph>」) 從逸出方法的每個字元。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>These include the <ph id="ph1">\\</ph>, *, +, ?, &amp;#124;, {, [, (,), ^, $,., #, and white space characters.</source>
          <target state="translated">這些包括<ph id="ph1">\\</ph>，*，+，？， &amp;#124;，{，[，（、）、 ^、 $、。，# 和空白字元。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method unescapes the closing bracket (]) and closing brace (}) characters.</source>
          <target state="translated">此外，<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph>右括號 (]) 和關閉括號 （}） 字元不逸出方法。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> cannot reverse an escaped string perfectly because it cannot deduce precisely which characters were escaped,</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> 無法回復的逸出的字串完全無法推算精確哪些字元不逸出因為</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>It replaces the representation of unprintable characters with the characters themselves.</source>
          <target state="translated">它會將不可列印字元的表示法取代字元本身。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>For example, it replaces \a with \x07.</source>
          <target state="translated">例如，它會取代 \a \x07。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>The character representations it replaces are \a, \b, \e, \n, \r, \f, \t, and \v.</source>
          <target state="translated">它會取代的字元表示為 \a、 \b、 \e、 \n、 \r、 \f、 \t 和 \v。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph> method encounters other escape sequences that it cannot convert, such as \w or \s, it throws an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Unescape%2A&gt;</ph>方法遇到其他逸出序列，它無法轉換，例如 \w 或 \s，就會擲回<ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> includes an unrecognized escape sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> 包含無法辨認的逸出序列。</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.Unescape(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionC">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> 屬性包含 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /&gt;</ph> 選項，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source>Used by a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> object generated by the <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> method.</source>
          <target state="translated">由 <ph id="ph2">&lt;see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /&gt;</ph> 方法所產生的 <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Regex" /&gt;</ph> 物件使用。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.UseOptionR">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> property contains the <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> option; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="P:System.Text.RegularExpressions.Regex.Options" /&gt;</ph> 屬性包含 <ph id="ph3">&lt;see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /&gt;</ph> 選項，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>The time-out interval to check.</source>
          <target state="translated">要檢查的逾時間隔。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)">
          <source>Checks whether a time-out interval is within an acceptable range.</source>
          <target state="translated">檢查逾時間隔是否在可接受的範圍內。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>