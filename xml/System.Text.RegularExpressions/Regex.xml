<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8343c9ced2feab91007390d6cfdd6abc852b525f" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53230685" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示不變的規則運算式 (Regular Expression)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>類別代表.NET Framework 規則運算式引擎。 它可用來快速剖析大量文字以尋找特定的字元模式;若要擷取、 編輯、 取代或刪除文字子字串;並將擷取的字串新增至集合，以便產生報表。  
  
> [!NOTE]
>  如果您的主要興趣是要判斷它是否符合特定模式來驗證字串中，您可以使用<xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType>類別。  
  
 若要使用規則運算式，您會定義您想要使用所述的語法來識別文字資料流中的模式[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 接下來，您可以選擇性地具現化<xref:System.Text.RegularExpressions.Regex>物件。 最後，您可以呼叫執行某項作業，例如取代符合規則運算式模式的文字，或識別模式比對的方法。  
  
> [!NOTE]
>  一些常見的規則運算式模式，請參閱 <<c0> [ 規則運算式範例](~/docs/standard/base-types/regular-expression-examples.md)。 另外還有幾個的線上程式庫的規則運算式模式，例如在[一般 Expressions.info](https://www.regular-expressions.info/examples.html)。  
  
<a name="remarks"></a> 如需有關使用<xref:System.Text.RegularExpressions.Regex>類別，請參閱本主題中的下列章節：  
  
-   [Regex vs。字串方法](#regex_vs_string)  
  
-   [靜態與執行個體方法](#static_vs_instance)  
  
-   [執行規則運算式作業](#regex_ops)  
  
-   [定義的逾時值](#define_timeout)  
  
 如需規則運算式語言的詳細資訊，請參閱[規則運算式語言 - 快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)，或下載並列印下列其中一本小手冊：  
  
 [Word (.docx) 格式的快速參考](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [PDF (.pdf) 格式的快速參考](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex vs。字串方法  
 <xref:System.String?displayProperty=nameWithType>類別包含數個搜尋和比較方法，您可以使用執行模式比對文字。 例如， <xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.EndsWith%2A?displayProperty=nameWithType>，和<xref:System.String.StartsWith%2A?displayProperty=nameWithType>判斷方法的字串執行個體是否包含指定的子字串; 和<xref:System.String.IndexOf%2A?displayProperty=nameWithType>， <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>， <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>，和<xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType>方法傳回的起始在字串中指定的子字串的位置。 使用的方法<xref:System.String?displayProperty=nameWithType>類別，在您要搜尋特定字串。 使用<xref:System.Text.RegularExpressions.Regex>類別，在您要搜尋特定的模式字串中。 如需詳細資訊和範例，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)。  
  
 [回到 < 備註 >](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>靜態與執行個體方法  
 定義規則運算式模式之後，您可以提供規則運算式引擎在兩種方式之一：  
  
-   藉由執行個體化<xref:System.Text.RegularExpressions.Regex>代表規則運算式的物件。 若要這樣做，您會傳遞至規則運算式模式<xref:System.Text.RegularExpressions.Regex.%23ctor%2A>建構函式。 A<xref:System.Text.RegularExpressions.Regex>物件是不可變，當您具現化<xref:System.Text.RegularExpressions.Regex>物件的規則運算式物件的規則運算式不能變更。  
  
-   提供規則運算式和要搜尋的文字`static`(`Shared` Visual Basic 中)<xref:System.Text.RegularExpressions.Regex>方法。 這可讓您使用規則運算式，而不需要明確建立<xref:System.Text.RegularExpressions.Regex>物件。  
  
 所有<xref:System.Text.RegularExpressions.Regex>模式識別方法包含兩個靜態和執行個體的多載。  
  
 規則運算式引擎必須編譯特定模式，才能使用此模式。 因為<xref:System.Text.RegularExpressions.Regex>物件是不可變，這樣一來，就會發生的一次性程序時<xref:System.Text.RegularExpressions.Regex>呼叫類別建構函式或靜態方法。 若要排除不需要進行重複編譯單一規則運算式，規則運算式引擎會快取已編譯的規則運算式的靜態方法呼叫中使用。 如此一來，規則運算式模式比對方法會提供相當的效能，若為靜態和執行個體方法。  
  
> [!IMPORTANT]
>  在.NET Framework 1.0 和 1.1 中，所有已編譯規則運算式，它們是否已使用執行個體或靜態方法中呼叫，快取。 從.NET Framework 2.0 開始，只有在靜態方法呼叫中使用的規則運算式會快取。  
  
 不過，快取可能會影響效能，在下列兩種情況：  
  
-   當您使用靜態方法呼叫，且含有大量的規則運算式。 根據預設，規則運算式引擎會快取 15 的最近使用過靜態規則運算式。 如果您的應用程式會使用 15 個以上的靜態規則運算式，就必須重新編譯一些規則運算式。 若要避免此重新編譯，您可以增加<xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>屬性。  
  
-   當您具現化新<xref:System.Text.RegularExpressions.Regex>使用先前已編譯的規則運算式的物件。 例如，下列程式碼會定義規則運算式，以在文字資料流中找出重複的文字。 雖然此範例會使用單一規則運算式，它會具現化新<xref:System.Text.RegularExpressions.Regex>物件來處理每一行文字。 這會導致重新編譯的規則運算式與迴圈的每個反覆項目。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     若要避免重新編譯，您應該具現化一個<xref:System.Text.RegularExpressions.Regex>是可存取所有的程式碼時需要它，如下列重寫範例所示的物件。  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [回到 < 備註 >](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>執行規則運算式作業  
 您是否決定具現化<xref:System.Text.RegularExpressions.Regex>物件並呼叫其方法或呼叫靜態方法，<xref:System.Text.RegularExpressions.Regex>類別提供下列的模式比對功能：  
  
-   驗證的相符項目。 您呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法，以判斷是否有相符項目。  
  
-   擷取單一相符項目。 您呼叫<xref:System.Text.RegularExpressions.Regex.Match%2A>方法來擷取<xref:System.Text.RegularExpressions.Match>物件，表示字串中或部分字串的第一個相符項目。 可以藉由呼叫擷取後續相符項目的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。  
  
-   擷取所有相符項目。 您呼叫<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法來擷取<xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType>物件，表示為字串或字串的部分所找到的所有相符項目。  
  
-   取代相符的文字。 您呼叫<xref:System.Text.RegularExpressions.Regex.Replace%2A>來取代相符的文字的方法。 取代文字也可以定義規則運算式。 此外，某些<xref:System.Text.RegularExpressions.Regex.Replace%2A>方法包括<xref:System.Text.RegularExpressions.MatchEvaluator>參數，可讓您以程式設計方式定義的替代文字。  
  
-   建立的字串陣列，由輸入字串的一部分。 您呼叫<xref:System.Text.RegularExpressions.Regex.Split%2A>方法來分割輸入的字串的規則運算式所定義的位置。  
  
 其模式比對的方法，除了<xref:System.Text.RegularExpressions.Regex>類別包含數個特殊用途的方法：  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A>方法會逸出任何可能會解譯為規則運算式或輸入的字串中的規則運算式運算子的字元。  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法會移除這些逸出字元。  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會建立包含預先定義的規則運算式的組件。 .NET Framework 包含這些特殊用途的組件中的範例<xref:System.Web.RegularExpressions?displayProperty=nameWithType>命名空間。  
  
 [回到 < 備註 >](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>定義的逾時值  
 .NET Framework 支援完整的規則運算式語言提供大幅的功能與彈性在模式比對。 不過，支援與彈性是有代價： 效能不佳的風險。 執行效能不佳的規則運算式是非常容易建立。 在某些情況下，依賴大量回溯規則運算式作業似乎停止回應時它們會處理幾乎符合規則運算式模式的文字。 如需有關.NET Framework 規則運算式引擎的詳細資訊，請參閱 <<c0> [ 規則運算式行為的詳細資料](~/docs/standard/base-types/details-of-regular-expression-behavior.md)。 如需有關大量回溯的詳細資訊，請參閱 <<c0> [ 回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。  
  
 從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，您可以定義逾時間隔，規則運算式相符項目。 如果規則運算式引擎無法識別此時間間隔內的相符項目，比對作業會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 在大部分情況下，這可防止規則運算式引擎嘗試比對幾乎符合規則運算式模式的文字所浪費的處理能力。 它也可能表示，不過，，已設定的逾時間隔太低，或目前的電腦負載的效能，導致整體效能降低。  
  
 處理例外狀況的方式，取決於例外狀況的原因。 如果因為逾時間隔設得太低，就會發生例外狀況，或因為過多的電腦工作負載，您可以增加逾時間隔並重試比對的作業。 如果規則運算式依賴大量回溯，就會發生例外狀況，您可以假設相符項目不存在，而且 （選擇性） 您可以在此記錄可協助您修改規則運算式模式的資訊。  
  
 您可以藉由呼叫設定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式，當您具現化規則運算式物件。 對於靜態方法，您可以設定逾時間隔，藉由呼叫的比對方法的多載`matchTimeout`參數。 如果您未明確設定的逾時值，預設的逾時值是以下列方式決定：  
  
-   使用整個應用程式的逾時的值，如果有一個存在。 這可以是應用程式定義域，適用於任何逾時值<xref:System.Text.RegularExpressions.Regex>物件具現化或靜態方法呼叫。 您可以藉由呼叫設定整個應用程式的逾時值<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法，以指派的字串表示<xref:System.TimeSpan>"REGEX_DEFAULT_MATCH_TIMEOUT"屬性值。  
  
-   使用值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>，如果已不設定任何全應用程式的逾時值。  
  
> [!IMPORTANT]
>  我們建議您所有的規則運算式模式比對作業中設定的逾時值。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)。  
  
 [回到 < 備註 >](#remarks)  
  
   
  
## Examples  
 下列範例會使用規則運算式，檢查有重複出現的文字字串中。 規則運算式`\b(?<word>\w+)\s+(\k<word>)\b`可以解譯為下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`(?<word>\w+)`|比對到字邊界的一或多個文字字元。 此擷取的群組命名為`word`。|  
|`\s+`|比對一或多個空格字元。|  
|`(\k<word>)`|比對擷取的群組，稱為`word`。|  
|`\b`|比對字邊界。|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 下列範例說明如何使用規則運算式，以檢查是否為字串表示貨幣值，或者具有正確的格式來表示貨幣值。 在此情況下，規則運算式，會動態建立從<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>使用者目前的文化特性的屬性。 如果系統的目前文化特性是 EN-US，產生的規則運算式是`^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`。 下表所示，可以解譯這個規則運算式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|字串的開頭開始。|  
|`\s*`|比對零個以上的空白字元。|  
|`[\+-]?`|比對零個或一個出現的正號或負號。|  
|`\s?`|比對零個或一個空白字元。|  
|`\$?`|比對零個或一個出現的貨幣符號。|  
|`\s?`|比對零個或一個空白字元。|  
|`\d*`|比對零個或多個十進位數字。|  
|`\.?`|比對零個或一個小數點符號。|  
|`\d{2}?`|比對兩個十進位數字零或一次。|  
|`(\d*\.?\d{2}?){1}`|比對整數和小數的位數，小數點符號來分隔至少一次的模式。|  
|`$`|比對字串的結尾。|  
  
 在此情況下，規則運算式假設有效貨幣字串不包含群組分隔符號，而且它有沒有小數位數或目前的文化特性所定義的小數位數數目<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>屬性。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 由於動態建置規則運算式，在此範例中，我們不知道在設計階段是否目前文化特性的貨幣符號、 小數符號或正的和負號可能會被錯誤解譯為一般的規則運算式引擎運算式語言的運算子。 若要避免任何的錯譯，範例會傳遞至每個動態產生的字串<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" />類別是不可變 （唯讀） 和安全執行緒。 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件可以在任何執行緒上建立與執行緒之間共用。 如需詳細資訊，請參閱 &lt;&lt;c0&gt; [ 的執行緒安全](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)。</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">.NET Framework 規則運算式</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">規則運算式 - 快速參考 (以 Word 格式下載)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">規則運算式 - 快速參考 (以 PDF 格式下載)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，受到這個建構函式;它只由衍生自的類別呼叫<xref:System.Text.RegularExpressions.Regex>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>為指定的規則運算式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。  
  
 呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29>建構函式相當於呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式值是<xref:System.Text.RegularExpressions.RegexOptions.None>如`options`引數。  
  
 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的也就是說，它可以僅適用於您在建立時定義的比對模式。 不過，它可以使用任意數目的時間，而不需要重新編譯。  
  
 這個建構函式會嘗試定義中的任何字母字元的區分大小寫比對規則運算式物件具現化`pattern`。 不區分大小寫的比對中，使用<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>建構函式。  
  
   
  
## Examples  
 下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的字組"a"或"t"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 請注意，規則運算式模式無法符合這個字"The"開頭的文字，因為預設區分大小寫比較。 如需範例的不區分大小寫的比較，請參閱<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>這個建構函式會建立<see cref="T:System.Text.RegularExpressions.Regex" />會使用預設的逾時值，在其中建立應用程式定義域的物件。 如果應用程式定義域中，尚未定義的逾時值<see cref="T:System.Text.RegularExpressions.Regex" />物件會使用值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，這樣就不會逾時的作業。建立建議建構函式<see cref="T:System.Text.RegularExpressions.Regex" />物件是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">包含序列化模式和 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 資訊的物件。</param>
        <param name="context">這個序列化的目的端。 (不使用這個參數；請指定 <see langword="null" />)。</param>
        <summary>使用序列化的資料，初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 包含的模式為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> 包含無效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 旗標。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會修改規則運算式。</param>
        <summary>使用會修改模式的選項，為指定的規則運算式初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。  
  
 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的也就是說，它可以僅適用於您在建立時定義的比對參數。 不過，它可以使用任意數目的時間，而不需要重新編譯。  
  
   
  
## Examples  
 下列範例說明如何使用這個建構函式來具現化規則運算式比對任何以字母開頭的字組"a"或"t"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 請注意，比對集合包含的文字"The"開頭的文字，因為`options`已定義參數不區分大小寫的比較。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 包含無效的旗標。</exception>
        <block subset="none" type="usage"><para>這個建構函式會建立<see cref="T:System.Text.RegularExpressions.Regex" />會使用預設的逾時值，在其中建立應用程式定義域的物件。 如果應用程式定義域中，尚未定義的逾時值<see cref="T:System.Text.RegularExpressions.Regex" />物件會使用值<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，這樣就不會逾時的作業。建立建議建構函式<see cref="T:System.Text.RegularExpressions.Regex" />物件是<see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會修改規則運算式。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>針對指定的規則運算式，使用修改模式的選項，以及指定在逾時前模式比對方法應該嘗試比對的時間長度的值，初始化 <see cref="T:System.Text.RegularExpressions.Regex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)主題。  
  
 A<xref:System.Text.RegularExpressions.Regex>物件是不可變的也就是說，它可以僅適用於您定義當您建立比對模式。 不過，它可以使用任意數目的時間，而不需要重新編譯。  
  
 `matchTimeout`參數會指定多久模式比對方法應該嘗試逾時之前，尋找相符項目。如果沒有相符項目位於該時間間隔，模式比對的方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫應用程式定義域中定義任何預設的逾時值<xref:System.Text.RegularExpressions.Regex>建立物件。 執行個體模式比對方法觀察`matchTimeout`逾時間隔包括下列：  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 若要設定合理的逾時間隔，請考慮下列因素：  
  
-   長度和複雜度的規則運算式模式。 時間更長、 更複雜的規則運算式需要更多的時間比比較簡短而簡單的項目。  
  
-   預期的電腦工作負載。 處理會有 CPU 和記憶體使用率過高的系統上的更多的時間。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式來具現化<xref:System.Text.RegularExpressions.Regex>逾時值為一秒的物件。 規則運算式模式 `(a+)+$`會在行尾比對一個或多個 "a" 字元的一個或多個序列，並且受限於大量回溯。 如果<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>會擲回，則範例會增加逾時值，最多三秒的最大值。 否則，它會放棄嘗試比對模式。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">回溯</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定在已編譯規則運算式目前靜態快取中項目的最大數目。</summary>
        <value>靜態快取中項目的最大數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex>類別會負責維護內部的靜態方法呼叫中使用的已編譯規則運算式快取。 如果在設定作業中指定的值小於目前的快取大小，快取項目都會被捨棄，直到快取大小是否等於指定的值。  
  
 根據預設，快取會儲存 15 個已編譯的靜態規則運算式。 您的應用程式通常不會修改快取的大小。 使用<xref:System.Text.RegularExpressions.Regex.CacheSize%2A>只有當您想要關閉 快取，或當您有非常大的快取的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定作業中的值小於零。</exception>
        <block subset="none" type="usage"><para>在.NET Framework 之前[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]、 規則運算式用於這兩個靜態和快取執行個體方法呼叫。 開頭為[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]、 一般只會快取靜態方法呼叫中使用的運算式。</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字典，對應具名擷取群組及其索引值。</summary>
        <value>對應具名擷取群組及其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，這個屬性會受到保護;它只能從衍生自的類別存取<xref:System.Text.RegularExpressions.Regex>類別。  
  
 設定作業會嘗試將指派給屬性的值<xref:System.Collections.Hashtable>物件; 如果這項轉換會失敗，則會呼叫<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">在設定作業中指派給 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 的屬性值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字典，對應編號的擷取群組及其索引值。</summary>
        <value>對應編號的擷取群組及其索引值的字典。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，這個屬性會受到保護;它只能從衍生自的類別存取<xref:System.Text.RegularExpressions.Regex>類別。  
  
 設定作業會嘗試將指派給屬性的值<xref:System.Collections.Hashtable>物件; 如果這項轉換會失敗，則會呼叫<xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">在設定作業中指派給 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 的屬性值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>編譯規則運算式並將它們以單一組件 (Assembly) 儲存至磁碟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

在.NET Core 上呼叫`Regex.CompileToAssembly`方法擲回<xref:System.PlatformNotSupportedException>; 不支援寫出組件。
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">陣列，描述要編譯的規則運算式。</param>
        <param name="assemblyname">組件的檔案名稱。</param>
        <summary>將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件編譯為具名組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>方法會產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由一個類別。 一般而言，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>從個別的應用程式所產生的已編譯的規則運算式的組件呼叫方法。 每個組件中包含的規則運算式具有下列特性：  
  
-   它衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
-   它指派所定義的完整限定的名稱`fullnamespace`並`name`對應的參數<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。  
  
-   它有預設值 （或無參數） 建構函式。  
  
 一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。  
  
   
  
## Examples  
 下列範例會建立名為 RegexLib.dll 組件。 組件包含兩個已編譯的規則運算式。 第一天， `Utilities.RegularExpressions.DuplicatedString`，比對兩個相同的連續文字。 第二個， `Utilities.RegularExpressions.EmailAddress`，檢查字串是否具有正確格式的電子郵件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 檢查重複的文字字串的規則運算式然後具現化，並使用下列的範例。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立的組件） 的參考加入至專案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。  
  
-或- 
<paramref name="regexinfos" /> 中一個或多個物件的規則運算式模式包含無效的語法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</exception>
        <block subset="none" type="usage"><para>如果您正在開發的系統上，具有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或其點發行版本安裝目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法用來建立包含的組件編譯的規則運算式。 嘗試使用其中一個規則運算式，因為在系統上的組件具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]會擲回例外狀況。 若要解決這個問題，您可以執行下列任何一項操作： 
-組建包含的系統上，已編譯的規則運算式的組件[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安裝的更新版本。  
  
-而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />並從組件中擷取已編譯的規則運算式，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">編譯和重複使用</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">陣列，描述要編譯的規則運算式。</param>
        <param name="assemblyname">組件的檔案名稱。</param>
        <param name="attributes">陣列，定義要套用至組件的屬性。</param>
        <summary>將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件編譯為具有指定之屬性的具名組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>方法會產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由一個類別。 一般而言，<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>從個別的應用程式所產生的已編譯的規則運算式的組件呼叫方法。 每個組件中包含的規則運算式具有下列特性：  
  
-   它衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
-   它指派所定義的完整限定的名稱`fullnamespace`並`name`對應的參數<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。  
  
-   它有預設值 （或無參數） 建構函式。  
  
 一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。  
  
 因為<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會產生.NET Framework 組件，而不是使用特定語言的類別定義關鍵字的方法呼叫 (例如`class`在 C# 或`Class`...`End Class` 在 Visual Basic 中)，它不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。 `attributes`參數提供的替代方法來定義將套用至組件的屬性。 針對每個您想要套用至組件的屬性，執行下列作業：  
  
1.  建立陣列<xref:System.Type>代表您想要呼叫的屬性建構函式的參數類型的物件。  
  
2.  擷取<xref:System.Type>物件，表示您想要套用至新的組件的屬性類別。  
  
3.  呼叫<xref:System.Type.GetConstructor%2A>屬性的方法<xref:System.Type>物件來擷取<xref:System.Reflection.ConstructorInfo>物件，表示您想要呼叫的屬性建構函式。 傳遞<xref:System.Type.GetConstructor%2A>方法的陣列的<xref:System.Type>表示建構函式的參數類型的物件。  
  
4.  建立<xref:System.Object>陣列，定義要傳遞給屬性的建構函式的參數。  
  
5.  具現化<xref:System.Reflection.Emit.CustomAttributeBuilder>物件，並傳遞其建構函式<xref:System.Reflection.ConstructorInfo>擷取在步驟 3 中的物件和<xref:System.Object>步驟 4 中建立的陣列。  
  
 然後，您就可以傳遞這些陣列<xref:System.Reflection.Emit.CustomAttributeBuilder>而不是物件`attributes`參數來<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會建立名為 RegexLib.dll 組件，並套用<xref:System.Reflection.AssemblyTitleAttribute>屬性。 組件包含兩個已編譯的規則運算式。 第一天， `Utilities.RegularExpressions.DuplicatedString`，比對兩個相同的連續文字。 第二個， `Utilities.RegularExpressions.EmailAddress`，檢查字串是否具有正確格式的電子郵件地址。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 您可以確認<xref:System.Reflection.AssemblyTitleAttribute>藉由檢查它的資訊清單，使用反映公用程式，例如 ILDasm 屬性套用至組件。  
  
 檢查重複的文字字串的規則運算式然後具現化，並使用下列的範例。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 成功編譯此第二個範例需要的 RegexLib.dll （第一個範例所建立的組件） 的參考加入至專案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。  
  
-或- 
<paramref name="regexinfos" /> 中一個或多個物件的規則運算式模式包含無效的語法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</exception>
        <block subset="none" type="usage"><para>如果您正在開發的系統上，具有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或其點發行版本安裝目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法用來建立包含的組件編譯的規則運算式。 嘗試使用其中一個規則運算式，因為在系統上的組件具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]會擲回例外狀況。 若要解決這個問題，您可以執行下列任何一項操作： 
-組建包含的系統上，已編譯的規則運算式的組件[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安裝的更新版本。  
  
-而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />並從組件中擷取已編譯的規則運算式，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">編譯和重複使用</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">陣列，描述要編譯的規則運算式。</param>
        <param name="assemblyname">組件的檔案名稱。</param>
        <param name="attributes">陣列，定義要套用至組件的屬性。</param>
        <param name="resourceFile">要包括在組件中的 Win32 資源檔的名稱。</param>
        <summary>將一個或多個指定的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件和指定的資源檔編譯為具有指定之屬性的具名組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [\]，組件名稱、 CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 方法會產生.NET Framework 組件中定義的每個規則運算式中`regexinfos`陣列由一個類別。 一般而言，[\]，組件名稱、 CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 會從個別的應用程式所產生的已編譯的規則運算式的組件呼叫方法。 每個組件中包含的規則運算式具有下列特性：  
  
-   它衍生自<xref:System.Text.RegularExpressions.Regex>類別。  
  
-   它指派所定義的完整限定的名稱`fullnamespace`並`name`對應的參數<xref:System.Text.RegularExpressions.RegexCompilationInfo>物件。  
  
-   它有預設值 （或無參數） 建構函式。  
  
 一般情況下，組件或應用程式分開建立組件的程式碼中找到的程式碼會具現化，並使用已編譯的規則運算式。  
  
 因為<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>方法會產生.NET Framework 組件，而不是使用特定語言的類別定義關鍵字的方法呼叫 (例如`class`在 C# 或`Class`...`End Class` 在 Visual Basic 中)，它不允許使用的開發語言的標準屬性語法來指派給組件的.NET Framework 屬性。 `attributes`參數提供的替代方法來定義將套用至組件的屬性。 針對每個您想要套用至組件的屬性，執行下列作業：  
  
1.  建立陣列<xref:System.Type>代表您想要呼叫的屬性建構函式的參數類型的物件。  
  
2.  擷取<xref:System.Type>物件，表示您想要套用至新的組件的屬性類別。  
  
3.  呼叫<xref:System.Type.GetConstructor%2A>屬性的方法<xref:System.Type>物件來擷取<xref:System.Reflection.ConstructorInfo>物件，表示您想要呼叫的屬性建構函式。 傳遞<xref:System.Type.GetConstructor%2A>方法的陣列的<xref:System.Type>表示建構函式的參數類型的物件  
  
4.  建立<xref:System.Object>陣列，定義要傳遞給屬性的建構函式的參數。  
  
5.  具現化<xref:System.Reflection.Emit.CustomAttributeBuilder>物件，並傳遞其建構函式<xref:System.Reflection.ConstructorInfo>擷取在步驟 3 中的物件和<xref:System.Object>步驟 4 中建立的陣列。  
  
 然後，您就可以傳遞這些陣列<xref:System.Reflection.Emit.CustomAttributeBuilder>而不是物件`attributes`參數，以 [\]，組件名稱、 CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 參數的 <see cref="P:System.Reflection.AssemblyName.Name" /> 屬性值為空字串或 null 字串。  
  
-或- 
<paramref name="regexinfos" /> 中一個或多個物件的規則運算式模式包含無效的語法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 或 <paramref name="regexinfos" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> 參數指定不正確的 Win32 資源檔。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="resourceFile" /> 參數所指定的檔案。</exception>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援為編譯的規則運算式建立其組件。</exception>
        <block subset="none" type="usage"><para>如果您正在開發的系統上，具有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或其點發行版本安裝目標[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，而且您使用<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />方法用來建立包含的組件編譯的規則運算式。 嘗試使用其中一個規則運算式，因為在系統上的組件具有[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]會擲回例外狀況。 若要解決這個問題，您可以執行下列任何一項操作： 
-組建包含的系統上，已編譯的規則運算式的組件[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]而不是安裝的更新版本。  
  
-而不是呼叫<see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />並從組件中擷取已編譯的規則運算式，使用靜態或執行個體<see cref="T:System.Text.RegularExpressions.Regex" />方法使用<see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />選項，當您具現化<see cref="T:System.Text.RegularExpressions.Regex" />物件或呼叫規則運算式模式比對方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">編譯和重複使用</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">輸入字串，包含要轉換的文字。</param>
        <summary>以逸出程式碼取代字元 (\\、*、+、?、|、{、[、(、)、^、$、.、# 和空白字元) 的最小集合，以便逸出這些字元。 這樣會指示規則運算式引擎將這些字元解譯為常值，而非解譯為中繼字元。</summary>
        <returns>字元字串，其中中繼字元已轉換為逸出格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 將字串轉換，讓規則運算式引擎會解譯為字元常值可能包含任何中繼字元。 例如，請考慮規則運算式是設計用來擷取所直接左右方括號 （[和]） 從文字分隔的註解。 在下列範例中，規則運算式 「 [(.*?)]"會解譯為字元類別。 而不是比對輸入文字中內嵌的註解，規則運算式比對每個左或右括號、 句號、 星號或問號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 不過，如果左括號會逸出，傳遞至<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法中，規則運算式成功比對輸入字串中內嵌的註解。 下列範例將說明這點。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 在所使用的靜態文字定義規則運算式中，會被解譯字面意義，而不是為中繼字元的字元可以逸出前加上反斜線符號 (\\) 以及透過呼叫<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法。 以動態方式使用在設計階段未知的字元定義的規則運算式中呼叫<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法是特別重要，以確保該規則運算式引擎會解譯個別字元做為常值而不是比為中繼字元。  
  
> [!NOTE]
>  如果規則運算式模式包含數字符號 （#） 或常值空白字元，則必須逸出如果輸入的文字會剖析與<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>啟用的選項。  
  
 雖然<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法會逸出直接開啟括號 ([])，並開啟括號 （{}） 字元，它不會逸出其對應的結尾字元 (] 和})。 在大部分情況下，逸出這些不需要。 如果右括號或大括號前面並沒有其對應的開頭字元，規則運算式引擎會將它解譯常值。 如果開啟 braket 或大括號會解譯為中繼字元中，規則運算式引擎會解譯第一個對應的結尾字元做為中繼字元。 如果不想要的行為，右括號或大括號應該逸出明確前面加上反斜線 (\\) 字元。 如需圖例，請參閱 < 範例 > 一節。  
  
   
  
## Examples  
 下列範例會從文字擷取註解。 它會假設註解以開始註解符號並選取使用者結束註解符號分隔。 註解符號要解譯為常值，因為它們會傳遞至<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法，以確保，它們無法被錯誤解譯為中繼字元。 此外，範例明確檢查使用者輸入的結尾註解符號是右括號 (]) 或大括號 （}）。 如果是，反斜線字元 (\\) 前面加上括號或大括號，因此它解譯為常值。 請注意，此範例也會使用<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>顯示註解，而不是其開頭和結尾的註解符號以及註解的集合。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">在規則運算式中執行字元逸出</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>這個成員會覆寫 <see cref="M:System.Object.Finalize" />，您可以在該主題中找到更完整的文件。

在記憶體回收 (GC) 回收 <see cref="T:System.Object" /> 前，允許 <see cref="T:System.Object" /> 嘗試釋放資源並執行其他清除作業。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回規則運算式的擷取群組名稱的陣列。</summary>
        <returns>群組名稱的字串陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 群組名稱的集合包含一組用來在運算式中的擷取群組命名的字串。 即使沒有明確命名的擷取群組，它們會自動指派數值名稱 （"0"、"1"、"2"、"3"，等等）。 "0"具名群組代表規則運算式模式所比對的所有文字。 編號的群組的前面明確具名的群組是在集合中，而具名的群組會出現在規則運算式模式中定義的順序。  
  
 您可以使用<xref:System.Array.Length%2A>屬性在這個方法來判斷規則運算式中的群組數目所傳回的陣列。  
  
   
  
## Examples  
 下列範例會定義一般用途`ShowMatches`方法，以顯示群組的名稱的規則運算式，其相符的文字。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 在此情況下，規則運算式模式`\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})`旨在剖析簡單的句子，並識別其第一個字，最後一個字，並結束的標點符號。 下表顯示規則運算式模式的解譯方式：  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`(?<FirstWord>\w+)`|比對一個或多個文字字元。 這是`FirstWord`具名群組。|  
|\s？|比對零個或一個空白字元。|  
|(\w+)|比對一個或多個文字字元。 這是第二個擷取群組。|  
|\s|比對空白字元。|  
|((\w+)\s)*|比對一或多個文字字元後面接著空白字元的零或多個發生次數。 這是第一個擷取群組。|  
|(?\<LastWord > \w+)？|比對零個或一個出現的一或多個文字字元。 這是`LastWord`具名群組。|  
|(?\<標點符號 > \p{Po})|比對的字元的 Unicode 分類為標點符號，其他。 這是`Punctuation`具名群組。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">規則運算式中的群組建構</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回對應陣列中群組名稱的擷取群組編號的陣列。</summary>
        <returns>群組編號的整數陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未具名和具名擷取群組可以存取數字。 未具名的群組是從左到 1 開始由左至右編號。 （索引 0 （零） 中的擷取群組會代表比對整個）。具名的群組則從左編號開始由左至右的數字大一比數目未具名擷取群組。  
  
 依字串名稱參考它的號碼，而不是由群組可以提供更快速的存取。  
  
   
  
## Examples  
 下列範例會定義規則運算式， `\b((?<word>\w+)\s*)+(?<end>[.?!])`，會比對的句子。 規則運算式包含三個擷取群組： 擷取個別的字，以及空格字元可能會在它後面; 未命名的群組群組名稱`word`，會擷取在句子; 中的個別文字，並群組命名為`end`，捕捉結尾的句子的標點符號。 此範例會呼叫<xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A>方法來取得所有擷取的數字分組，並接著會顯示其擷取的字串。 颾魤 ㄛ<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法用來指出特定編號的群組是否對應至具名的群組。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 規則運算式模式的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`(?<word>\w+)`|比對一或多個文字字元，並將相符的字串指派給群組，名為`word`。|  
|`\s*`|比對零個以上的空白字元。|  
|`((?<word>\w+)\s*)`|指派`word`後面接著任何的擷取的群組所擷取的第一個擷取群組的空格字元。|  
|`((?<word>\w+)\s*)+`|比對後面接著任何泛空白字元一或多次的一或多個文字字元的模式。|  
|`(?<end>[.?!])`|比對句號、問號或驚嘆號。 指派要比對的字元`end`擷取群組。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">規則運算式中的群組建構</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">要轉換至對應群組名稱的群組編號。</param>
        <summary>取得對應指定群組編號的群組名稱。</summary>
        <returns>字串，含有與指定群組編號相關聯的群組名稱。 如果沒有對應 <paramref name="i" /> 的群組名稱，方法會傳回 <see cref="F:System.String.Empty" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。 編號的群組會分隔語法 (*subexpression*)，系統會指派數字，根據在規則運算式中的順序。 具名的群組語法分隔 (？`<`*名稱*`>`*subexpression*) 或 (？ '*名稱*'*subexpression*)，其中*名稱*是子運算式會識別的名稱。 (如需詳細資訊，請參閱[群組建構](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。)<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法識別命名的群組和編號的群組，由其規則運算式中的序數位置。 序數位置 0 一律代表整個規則運算式。 所有已編號群組都會計算在內具名群組，不論它們在規則運算式模式中的實際位置之前。  
  
 如果`i`是數字的具名群組，方法會傳回群組的名稱。 如果`i`是數字的未命名的群組，方法會傳回數字的字串表示。 例如，如果`i`為 1，則方法會傳回"1"。 如果`i`不是數字的擷取群組，此方法會傳回<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 如果找到模式比對，則這個方法所傳回的值然後用來擷取<xref:System.Text.RegularExpressions.Group>物件，表示從擷取的群組<xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType>屬性。 <xref:System.Text.RegularExpressions.GroupCollection>物件由<xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>屬性。  
  
   
  
## Examples  
 下列範例會定義符合包含美國城市名稱、 狀態名稱和郵遞區號地址的規則運算式模式。 此範例會使用<xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>方法來擷取的擷取群組的名稱。 然後會使用這些名稱擷取對應的擷取的群組相符的項目。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|比對一或多個字母或空格字元。 將這個擷取的群組名稱的指派`city`。|  
|`,`|比對後面接著空白字元的逗號 （，）。|  
|`(?<state>[A-Za-z]{2})`|比對兩個字母的字元。 將這個擷取的群組名稱的指派`state`。 此群組必須緊接著空格字元。|  
|`(?<zip>\d{5}(-\d{4})?)`|比對後面接著連字號後面接著四個數字的零個或一個出現的五個字。 將這個擷取的群組名稱的指派`zip`。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">群組建構</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">群組名稱，要轉換至對應群組編號的。</param>
        <summary>傳回對應指定群組名稱的群組編號。</summary>
        <returns>對應指定群組名稱的群組編號；如果 <paramref name="name" /> 不是有效的群組名稱，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 規則運算式模式可能會包含具名或編號擷取群組，其中描述在模式比對的子運算式。 編號的群組會分隔語法 (*subexpression*)，系統會指派數字，根據在規則運算式中的順序。 具名的群組語法分隔 (？`<`*名稱*`>`*subexpression*) 或 (？ '*名稱*'*subexpression*)，其中*名稱*是子運算式會識別的名稱。 (如需詳細資訊，請參閱[群組建構](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。)<xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A>方法識別命名的群組和編號的群組，由其規則運算式中的序數位置。 序數位置 0 一律代表整個規則運算式。 所有已編號群組都會計算在內具名群組，不論它們在規則運算式模式中的實際位置之前。  
  
 如果`name`出現在規則運算式模式中，此方法將傳回的數字的群組編號的字串表示法。 如果`name`對應具名擷取群組會出現在規則運算式模式，此方法會傳回其對應的數字。 比較`name`與群組名稱會區分大小寫。 如果`name`未對應至擷取群組的名稱或數目的擷取群組，此方法的字串表示法傳回-1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">群組建構</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定模式比對作業不應逾時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>類別建構函式和靜態比對的方法使用一些<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常數，表示嘗試尋找模式比對應該逾時。  
  
> [!WARNING]
>  將規則運算式引擎的逾時值設定為<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>可能會造成規則運算式依賴大量回溯，才會出現停止回應時處理幾乎符合規則運算式模式的文字。 如果您停用逾時，您應該確定您的規則運算式不需要大量使用回溯和它處理幾乎符合規則運算式模式的文字。  
>   
>  如需有關處理回溯的詳細資訊，請參閱[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>常數可以提供的值為`matchTimeout`下列成員的引數：  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">參考已初始化。</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在作業逾時之前可在模式比對作業中流逝的最長時間。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示規則運算式是否在輸入字串中尋找比對。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <summary>表示 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式是否要在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>方法來判斷字串是否為有效的組件數目。 規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。 第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須為數值。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 規則運算式模式為：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|開始在一行的開頭比對。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`\d{2}`|比對兩個數字字元。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對剛好三個數值字元。|  
|`(-\d{3}){2}`|尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`$`|結束比對一行的結尾。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="startat">要開始搜尋的字元位置。</param>
        <summary>表示 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中所指定的規則運算式，是否要從字串中指定的起始位置開始，在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法來判斷字串是否為有效的組件數目。 它會搜尋後面的冒號 （:） 字元在字串中的零件編號。 <xref:System.String.IndexOf%28System.Char%29>方法來判別的冒號字元，然後傳遞至位置<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>方法。 規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。 第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須為數值。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 規則運算式模式為：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`\d{2}`|比對兩個數字字元。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對剛好三個數值字元。|  
|`(-\d{3}){2}`|尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`$`|結束比對一行的結尾。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>表示指定的規則運算式是否在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>所指定的規則運算式模式的物件`pattern`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。 這個規則運算式模式的規則運算式引擎會快取供快速擷取。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法來判斷字串是否為有效的組件數目。 規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。 第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須為數值。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 規則運算式模式為：  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|開始在一行的開頭比對。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`\d{2}`|比對兩個數字字元。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對剛好三個數值字元。|  
|`(-\d{3}){2}`|尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。|  
|`[a-zA-Z0-9]`|比對單一字母字元 (`a`經由`z`或是`A`透過`Z`) 或數字字元。|  
|`$`|結束比對一行的結尾。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>此方法等於呼叫該方法的應用程式定義域的預設逾時值的間隔之後逾時。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，驗證模式比對是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>表示指定的規則運算式是否使用指定的比對選項，在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>所指定的規則運算式模式的物件`pattern`及所指定的規則運算式選項`options`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。 這個規則運算式模式的規則運算式引擎會快取供快速擷取。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法來判斷字串是否為有效的組件數目。 規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。 第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須為數值。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 規則運算式模式為：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|從字串的開頭開始比對。|  
|`[A-Z0-9]`|比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。|  
|`\d{2}`|比對兩個數字字元。|  
|`[A-Z0-9]`|比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對剛好三個數值字元。|  
|`(-\d{3}){2}`|尋找後面接著三個的數字字元、 連字號，並符合此模式的兩個項目...|  
|`[A-Z0-9]`|比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。|  
|`$`|在字串的結尾結束比對。|  
  
 呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法`options`參數設為<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>就相當於定義下列規則運算式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 相較之下，請參閱範例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，驗證模式比對是<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>指出指定的規則運算式是否使用指定的比對選項和逾時間隔，在指定的輸入字串中尋找相符項目。</summary>
        <returns>如果規則運算式尋找到符合項目，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>方法通常用來驗證字串，或確保字串符合特定模式而未擷取做後續操作該字串。 如果要判斷是否有一個或多個字串符合規則運算式模式，然後再擷取做後續操作，請呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 或 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>所指定的規則運算式模式的物件`pattern`及所指定的規則運算式選項`options`，然後呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>執行個體方法。 這個規則運算式模式的規則運算式引擎會快取供快速擷取。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來判斷字串是否為有效的組件數目。 規則運算式假設特定的格式，其中包含三個集合的連字號分隔字元的零件編號。 第一個集合，其中包含四個字元，必須包含後面接著兩個數字字元，後面接著英數字元的英數字元。 第二個集合，其中包含三個字元，必須為數值。 第三個集合，其中包含四個字元，必須有三個數字字元，後面接著英數字元。 比對規則運算式模式，應該牽涉到最少搜尋整個輸入字串中，因此方法設定 500 毫秒的逾時間隔。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 規則運算式模式為：  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|從字串的開頭開始比對。|  
|`[A-Z0-9]`|比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。|  
|`\d{2}`|比對兩個數字字元。|  
|`[A-Z0-9]`|比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。|  
|`-`|比對連字號。|  
|`\d{3}`|比對剛好三個數值字元。|  
|`(-\d{3}){2}`|尋找後面接著三個的數字字元、 連字號，且符合此模式的兩個項目。|  
|`[A-Z0-9]`|比對任何字母的單一字元，從`A`透過`Z`，或任何數字字元。|  
|`$`|在字串的結尾結束比對。|  
  
 呼叫<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法`options`參數設為<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>就相當於定義下列規則運算式：  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 相較之下，請參閱範例<xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是有效的 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在輸入字串搜尋規則運算式的項目，並傳回正確結果為單一 <see cref="T:System.Text.RegularExpressions.Match" /> 物件。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <summary>在指定的輸入字串中，搜尋符合 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中所指定規則運算式的第一個項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。 用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子`input`符合規則運算式模式。 您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例會尋找在字串中，符合規則運算式模式，然後列出相符群組、 擷取和擷取位置。  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 規則運算式模式`(\w+)\s+(car)`比對以及字組前面的"car"這個字的項目。 它被解譯為下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`(\w+)`|比對一個或多個文字字元。 這是第一個擷取群組。|  
|`\s+`|比對一或多個空格字元。|  
|(car)|比對常值字串"car"。 這是第二個擷取群組。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="startat">要開始搜尋之以零為起始的字元位置。</param>
        <summary>從字串中指定的開始位置開始，在輸入字串中搜尋規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法會傳回符合規則運算式模式，開始在或之後的第一個子字串`startat`字元輸入字串中的位置。 用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以使用，以選擇性地指定字串中的起始位置`startat`參數。 當規則運算式引擎會剖析從左到右 （預設值） 時，比對和掃描移動 rightward，開始中指定的字元`startat`。 當規則運算式引擎會剖析從右到左 (規則運算式模式使用的建構時<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>選項)，比對和掃描的相反的方向移動和開頭處的字元`startat`-1。 如果您未指定的開始位置，則會搜尋的預設值`startat`位置。 如果規則運算式搜尋從左到右，預設值`startat`位置位於左側`input`; 如果它會搜尋由右至左，預設值`startat`位置位於右端的`input`。  
  
 如果您想要限制相符項目，使它在字串中特定的字元位置開始，並比對規則運算式引擎不會掃描字串的其餘部分，錨定的為規則運算式`\G`（左邊的左到右模式中，或從右至左模式右邊)。 這會限制比對，因此它必須剛好在啟動`startat`。  
  
 您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回找到在或之後的第一個子字串`startat`字元在位置`input`符合規則運算式模式。 您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 如果當您呼叫建構函式時，您不會設定逾時間隔，若作業 exeeds 所在的應用程式定義域建立任何逾時值，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex>建立物件。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>在指定的輸入字串中搜尋所指定規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。 用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。 在此情況下，規則運算式引擎會快取規則運算式模式。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子`input`符合規則運算式模式。 您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>方法來尋找包含至少一個的第一個單字`z`字元，然後再呼叫<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法來尋找任何其他的相符項目。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 規則運算式模式 `\b\w*z+\w*\b` 的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w*`|比對零個、 一個或多個文字字元。|  
|`z+`|比對的一或多個相符項目`z`字元。|  
|`\w*`|比對零個、 一個或多個文字字元。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法來擷取模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，可讓您設定的逾時間隔。</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="beginning">定義要搜尋的最左邊位置的輸入字串中以零為起始的字元位置。</param>
        <param name="length">子字串中要包含在搜尋中的字元數。</param>
        <summary>從指定的開始位置開始並且僅搜尋指定數目的字元，在輸入字串中搜尋規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會傳回第一個符合子字串的規則運算式模式中，輸入字串的一部分。 用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會搜尋的部份`input`所定義`beginning`和`length`規則運算式模式的參數。 `beginning` 一定會定義要包含在搜尋中，最左邊字元的索引和`length`定義要搜尋的字元數目上限。 在一起，它們會定義搜尋範圍。 如果搜尋會從左到右 （預設值），規則運算式引擎會搜尋的索引處的字元`beginning`中的索引處的字元`beginning`  +  `length` -1。 如果規則運算式引擎使用具現化<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>選項，讓搜尋會由右至左，規則運算式引擎會搜尋的索引處的字元`beginning`  +  `length` -1 到中的索引處的字元`beginning`。 這個方法會傳回此範圍內找到的第一個相符項目。 您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>方法。  
  
 您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 如果比對作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 如果您未設定逾時值，當您呼叫建構函式時，如果作業超過任何逾時值應用程式定義域中，會擲回例外狀況<xref:System.Text.RegularExpressions.Regex>建立物件。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" /> 小於零或大於 <paramref name="input" /> 的長度。  
  
-或- 
 <paramref name="length" /> 小於零或大於 <paramref name="input" /> 的長度。  
  
-或- 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> 識別 <paramref name="input" /> 範圍之外的位置。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>使用指定的比對選項，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。 用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>建構函式和呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子字串中找到`input`符合規則運算式模式。 您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。  
  
 如果比對作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
   
  
## Examples  
 下列範例會定義規則運算式比對文字開頭為字母"a"。 它會使用<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>選項，以確保規則運算式會找出開頭的單字這兩個以大寫"a"和小寫"a"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 規則運算式模式 `\ba\w*\b` 的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`a`|比對字元"a"。|  
|`\w*`|比對零個、 一個或多個文字字元。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法來擷取模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />，可讓您設定的逾時間隔。</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的比對選項和逾時間隔，在輸入字串中搜尋所指定規則運算式的第一個相符項目。</summary>
        <returns>物件，包含符合之項目的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法會傳回符合規則運算式模式中的，輸入字串中的第一個子字串。 用來建立規則運算式語言項目的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 靜態<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法就相當於建構<xref:System.Text.RegularExpressions.Regex>物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>建構函式和呼叫執行個體<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 您可以判斷是否有已規則運算式模式至輸入字串中找到檢查傳回的值<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Group.Success%2A>屬性。 如果找到符合的項目，則所傳回 <xref:System.Text.RegularExpressions.Match> 物件的 <xref:System.Text.RegularExpressions.Capture.Value%2A> 屬性會包含符合規則運算式模式之 `input` 的子字串。 如果找到相符項目，則該值會是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 這個方法會傳回第一個子字串中找到`input`符合規則運算式模式。 您可以重複呼叫傳回，以便擷取後續相符項目的<xref:System.Text.RegularExpressions.Match>物件的<xref:System.Text.RegularExpressions.Match.NextMatch%2A>方法。 您也可以藉由呼叫來擷取單一方法呼叫中的所有相符項目<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法。  
  
 `matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在輸入字串中搜尋規則運算式的所有項目，並傳回所有符合項目。</summary>
        <block subset="none" type="usage"><para>在比對嘗試藉由呼叫的重複當<see cref="Overload:System.Text.RegularExpressions.Regex.Matches" />方法，規則運算式引擎會提供空白比對特殊處理。 通常，規則運算式引擎開始搜尋下一個相符項目，並完全先前比對停止的地方。 不過之後在空白比對，, 規則運算式引擎前移一個字元之前嘗試下一個相符項目。 此行為可確保規則運算式引擎將循序進行的字串。 否則，在空白比對不會導致任何順向移動，因為下一個相符項目會在上一個相符項目完全相同的位置開始，而且它將會重複比對相同的空字串。  
  
在下列範例中，規則運算式模式<c>*</c>搜尋零或多個出現字母"a"，"abaabb"的字串。 此範例將示範，產生的輸出<see cref="T:System.Text.RegularExpressions.MatchCollection" />物件包含六個<see cref="T:System.Text.RegularExpressions.Match" />物件。 第一的比對嘗試尋找第一個"a"。 在完全其中第一個符合結束，第一次的 b; 之前的第二個相符項目啟動它會尋找"a"的零個項目，並傳回空字串。 第三個相符項目不會開始完全第二個比對結束的位置，因為第二個相符項目會傳回空字串。 相反地，它會更新版本中之後第一個"b", 開始一個字元。 第三個相符項目尋找兩個"a"，並傳回"aa"。 第四個比對嘗試開始位置的第三個相符項目之前已結束，第二個"b"，並傳回空字串。 第五個比對嘗試一次前進一個字元，使其開始之前第三個"b"，並傳回空字串。 第六個的相符項目開始之後最後一個"b"，並再次傳回空字串。  
  
[！ 的程式碼 csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [！ 的程式碼 vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <summary>在指定的輸入字串搜尋規則運算式的所有項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 集合包含唯一的相符項目，並終止於第一個不相符。  
  
 規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，在執行作業時會擲回例外狀況<xref:System.Text.RegularExpressions.MatchCollection>在這個方法所傳回的物件<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和比對的作業超過逾時間隔。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>方法，以識別任何句子中的文字"es"結尾。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="startat">在輸入字串中開始搜尋的字元位置。</param>
        <summary>自字串中指定的開始位置開始，在指定的輸入字串搜尋規則運算式的所有項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 規則運算式模式，為其<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法會搜尋由呼叫其中一個定義<xref:System.Text.RegularExpressions.Regex>類別建構函式。 如需詳細的項目，可構成規則運算式模式的詳細資訊，請參閱[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，在執行作業時會擲回例外狀況<xref:System.Text.RegularExpressions.MatchCollection>在這個方法所傳回的物件<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性不是<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>和比對的作業超過逾時間隔...  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法來尋找在句子結尾為"es"，然後再呼叫中的第一個字<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>方法，以找出以"es"結尾的任何其他文字。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>在指定的輸入字串搜尋所指定規則運算式的所有相符項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Matches`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，會擲回例外狀況上執行的操作<xref:System.Text.RegularExpressions.MatchCollection>如果目前的應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的逾時間隔，這個方法中，所傳回的物件超過此逾時間隔。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法，以識別在"es"結尾的句子中的任何字。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，針對擷取多個模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，這可讓您指定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會指定用於比對的選項。</param>
        <summary>使用指定的比對選項在指定的輸入字串中，搜尋所指定規則運算式的所有相符項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Matches`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，會擲回例外狀況上執行的操作<xref:System.Text.RegularExpressions.MatchCollection>如果目前的應用程式定義域和比對作業的 「 REGEX_DEFAULT_MATCH_TIMEOUT"屬性所定義的逾時間隔，這個方法中，所傳回的物件超過此逾時間隔。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>方法，以識別在句子結尾為"es"，然後再呼叫中的任何字組<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法來執行不區分大小寫的模式與輸入字串的比較。 如輸出所示，兩個方法會傳回不同的結果。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，針對擷取多個模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，這些值會指定用於比對的選項。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>使用指定的比對選項和逾時間隔，在指定的輸入字串中搜尋所指定規則運算式的所有相符項目。</summary>
        <returns>搜尋之後找到的 <see cref="T:System.Text.RegularExpressions.Match" /> 物件集合。 如果找不到相符的項目，此方法會傳回空集合物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法是類似於<xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>輸入字串中，而不是單一的相符項目中找到的方法，但是它會傳回所有相符項目的相關資訊。 相當於下列程式碼：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 靜態`Matches`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Matches`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A>方法會使用延遲評估來填入傳回<xref:System.Text.RegularExpressions.MatchCollection>物件。 存取這個集合的成員 (例如 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>) 會導致立即填入集合。 若要充分利用延遲評估，您應該逐一查看集合所使用的建構，例如`foreach`在 C# 和`For Each`...`Next` 在 Visual Basic 中。  
  
 其延遲評估，因為呼叫<xref:System.Text.RegularExpressions.Regex.Matches%2A>方法並不會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 不過，在執行作業時會擲回例外狀況<xref:System.Text.RegularExpressions.MatchCollection>如果比對的作業超過此所指定的逾時間隔，這個方法中，所傳回的物件`matchTimeout`參數。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法，以執行比對任何字在"es"結尾的句子中的區分大小寫比較。 然後它會呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來執行不區分大小寫的模式與輸入字串的比較。 在這兩種情況下，逾時間隔設為一秒。 如輸出所示，兩個方法會傳回不同的結果。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 規則運算式模式 `\b\w+es\b` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\b`|開始字緣比對。|  
|`\w+`|比對一個或多個文字字元。|  
|`es`|比對常值字串"es"。|  
|`\b`|結束字緣比對。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行個體的逾時間隔。</summary>
        <value>在<see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />擲回之前，可在模式比對作業中流逝的最大時間間隔，或者為<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />（如果停用逾時）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>屬性會定義大約最大時間間隔<xref:System.Text.RegularExpressions.Regex>作業逾時之前執行單一比對作業的執行個體。規則運算式引擎會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>經過逾時間隔之後其下一步 計時檢查期間的例外狀況。 這可防止規則運算式引擎處理需要大量回溯的輸入的字串。 如需詳細資訊，請參閱 <<c0> [ 回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)並[規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)。  
  
 這個屬性是唯讀的。 您可以將其值設定個別的明確<xref:System.Text.RegularExpressions.Regex>藉由呼叫物件<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式，您可以將其值設定為所有<xref:System.Text.RegularExpressions.Regex>比對應用程式定義域中的作業，藉由呼叫<xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>方法，並提供<xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT"屬性值，如下列範例所示。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 如果您沒有明確設定的逾時間隔，預設值<xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>是使用和比對作業執行逾時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得傳入 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式的選項。</summary>
        <value><see cref="T:System.Text.RegularExpressions.RegexOptions" /> 列舉的一個或多個成員，代表傳遞至 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式的選項</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Text.RegularExpressions.Regex.Options%2A>屬性所組成的一或多個成員<xref:System.Text.RegularExpressions.RegexOptions>列舉型別。 如果沒有選項中未定義<xref:System.Text.RegularExpressions.Regex>類別建構函式，其值是<xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>。 可用的選項會詳細討論[Regular Expression Options](~/docs/standard/base-types/regular-expression-options.md)主題。  
  
 請注意，<xref:System.Text.RegularExpressions.Regex.Options%2A>屬性不會反映在規則運算式中定義的內嵌選項模式本身。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 所建立的規則運算式的基底類別<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。 這些已編譯的規則運算式使用的基底類別實作<see cref="P:System.Text.RegularExpressions.Regex.Options" />屬性。 如果從衍生類別中，呼叫<see cref="P:System.Text.RegularExpressions.Regex.Options" />屬性會傳回已傳遞給的選項<paramref name="options" />參數<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />類別建構函式用來定義規則運算式。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">規則運算式選項</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的字串。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="replacement">取代字串。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的所有字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相符的項目是搜尋開始的開頭`input`字串。 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元的取代模式內。  
  
> [!NOTE]
>  替代是取代模式中可以辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例會定義規則運算式， `\s+`，符合一或多個空格字元。 取代字串""，將它們取代為單一空格字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 下列範例會定義規則運算式中， `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`，並取代模式中， `$2`，從數字的值中移除前置或尾端的貨幣符號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 規則運算式的解譯方式如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\p{Sc}`|比對貨幣符號。 `{Sc}` 表示 Unicode Symbol，Currency 分類隸屬的任何字元。|  
|`\s?`|比對零個或一個空白字元。|  
|`(\p{Sc}\s?)?`|比對零個或一個出現的貨幣符號且後面接著零個或一個空白字元的組合。 這是第一個擷取群組。|  
|`\d+`|比對一個或多個十進位數字。|  
|`\.?`|比對零個或一個出現的期間，（作為小數分隔符號字元）。|  
|`((?<=\.)\d+)?`|如果句號前一個字元，符合一或多個十進位數字。 此模式可以比對零或一次。|  
|`(\d+\.?((?<=\.)\d+)?)`|比對一或多個十進位數字後面接著選擇性的期間和其他十進位數字的模式。 這是第二個擷取群組。 若要呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29>方法會將整個相符項目取代此擷取群組的值。|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|如果第一個擷取的群組存在，則比對空字串。 否則，比對零個或一個空格字元，後面接著貨幣符號。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <summary>在指定的輸入字串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串，取代所有與指定之規則運算式相符的字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：  
  
-   取代字串不能輕易地指定規則運算式取代模式。  
  
-   取代字串會產生從相符的字串上進行一些處理。  
  
-   取代字串的條件式處理結果。  
  
 此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，取代相符的輸入。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列程式碼範例會顯示為原始字串、 比對原始字串中的每個字，將已轉換的字串轉換為大寫，然後顯示每個符合結果的第一個字元。  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="replacement">取代字串。</param>
        <param name="count">取代作業可以發生的最多次數。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相符的項目是搜尋開始的開頭`input`字串。 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。 如果`count`是負數，字串的結尾繼續取代項目。 如果`count`超過的相符項目數，會取代所有相符項目。  
  
 `replacement`參數指定的字串來取代第一個`count`中的比對`input`。 `replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元的取代模式內。  
  
> [!NOTE]
>  替代是取代模式中可以辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例會將前五個出現重複的字元取代單一字元。 規則運算式模式`(\w)\1`比對單一字元的連續項目，並將第一個相符項目指派給第一個擷取群組。 取代模式`$1`整個相符項目取代為第一個擷取群組。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="replacement">取代字串。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Replace`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 相符的項目是搜尋開始的開頭`input`字串。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元的取代模式內。  
  
> [!NOTE]
>  替代是取代模式中可以辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例會定義規則運算式， `\s+`，符合一或多個空格字元。 取代字串""，將它們取代為單一空格字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法來取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。 使用規則運算式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法來包含邏輯磁碟機的名稱。 若要成功執行範例，您應該以您的本機電腦名稱來取代常值字串"MyMachine"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|比對兩個連續的反斜線 (`\`) 字元。 因為反斜線字元會解譯為逸出字元，則必須逸出每個反斜線與另一個反斜線。|  
|`(?i:" + Environment.MachineName + ")`|執行不區分大小寫的比對所傳回的字串<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。|  
|`(?:\.\w+)*`|比對句號 (`.`) 字元後面接著一或多個文字字元。 此種比對可能是零或多次。 不會擷取相符子運算式。|  
|`\\`|比對反斜線 (`\`) 字元。|  
|`((?i:[" + driveNames + "]))`|執行不區分大小寫的比對的個別磁碟機 lettters 所組成的字元類別。 此相符項目是第一個擷取的子運算式。|  
|`\$`|比對常值貨幣符號 (`$`) 字元。|  
  
 取代模式`$1`整個相符項目取代為第一個擷取的子運算式。 也就是說，它會取代 UNC 機器和磁碟機名稱的磁碟機代號。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /><paramref name="pattern" /> 或 <paramref name="replacement" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，來取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <summary>在指定的輸入字串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串，取代所有與指定之規則運算式相符的字串。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：  
  
-   取代字串不能輕易地指定規則運算式取代模式。  
  
-   取代字串會產生從相符的字串上進行一些處理。  
  
-   取代字串的條件式處理結果。  
  
 此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，取代相符的輸入。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例使用規則運算式從字串中，擷取個別文字，然後使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派来呼叫一個名為`WordScramble`，將金鑰加密的文字中個別的字母。 若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。 它也會使用隨機浮點數建立平行的陣列，它會填入。 藉由呼叫排序陣列<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，並已排序的陣列做為引數提供<xref:System.String>類別建構函式。 然後傳回此新建立的字串`WordScramble`方法。 規則運算式模式`\w+`符合一或多個文字字元，規則運算式引擎會繼續將字元加入至相符項目，直到遇到非文字字元，例如空格字元。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /><paramref name="pattern" /> 或 <paramref name="evaluator" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，用於評估和取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="count">取代將發生的最多次數。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：  
  
-   取代字串不能輕易地指定規則運算式取代模式。  
  
-   取代字串會產生從相符的字串上進行一些處理。  
  
-   取代字串的條件式處理結果。  
  
 此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>方法並傳遞第一個`count`<xref:System.Text.RegularExpressions.Match>中所傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，取代相符的輸入。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例會使用規則運算式，刻意拼錯一半的清單中的文字。 它會使用規則運算式`\w*(ie|ei)\w*`比對包含 「 ie 」 或 「 ei"字元的文字。 它會傳遞第一個符合的單字，下半`ReverseLetter`方法，這個方法會接著使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法，以反轉"i"和"e"相符的字串。 其餘的字維持不變。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 規則運算式 `\w*(ie|ei)\w*` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`\w*`|比對零個或多個文字字元。|  
|<code>(ie&#124;ei)</code>|符合 「 ie 」 或 「 ei"。|  
|`\w*`|比對零個或多個文字字元。|  
  
 規則運算式模式`([ie])([ie])`在`ReverseLetter`方法中 diphthong 「 ie 」 或 「 ei 」 比對的第一個"i"或"e"，並將字母指派給第一個擷取群組。 它符合第二個"i"或"e"，並將代號指派給第二個擷取群組。 藉由呼叫接著會反轉兩個字元<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>方法取代模式`$2$1`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="replacement">取代字串。</param>
        <param name="count">取代可以發生的最多次數。</param>
        <param name="startat">在輸入字串中開始搜尋的字元位置。</param>
        <summary>在指定的輸入子字串中，使用指定的取代字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜尋符合項目以啟動`input`所指定位置的字串`startat`參數。 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。 如果`count`是負數，字串的結尾繼續取代項目。 如果`count`超過的相符項目數，會取代所有相符項目。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元的取代模式內。  
  
> [!NOTE]
>  替代是取代模式中可以辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例 double-spaces 以外的所有字串的第一行。 它會定義規則運算式模式中， `^.*$`，符合一行文字，呼叫<xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>方法來比對的字串，並使用第一行`Match.Index`和`Match.Count`屬性，以判斷第二個的開始位置行。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 規則運算式模式 `^.*$` 的定義如下表所示。  
  
|模式|描述|  
|-------------|-----------------|  
|`^`|比對行首。 (請注意，<xref:System.Text.RegularExpressions.Regex>物件具現化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>選項; 否則此字元類別會只比對輸入字串的開頭。)|  
|`.*`|比對任何字元零或多次。|  
|`$`|比對一行的結尾。 (請注意，<xref:System.Text.RegularExpressions.Regex>物件具現化使用<xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>選項; 否則此字元類別會只比對輸入字串的開頭。)|  
  
 取代字串 (`vbCrLf + "$&"`在 Visual Basic 中`"\n$&"`C# 中) 將加入新的一行之前相符的字串。 請注意，`\n`在 C# 範例會解譯為新行字元與 C# 編譯器; 它不代表規則運算式字元逸出。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="replacement">取代字串。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。 指定的選項會修改符合的作業。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Replace`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元的取代模式內。  
  
> [!NOTE]
>  替代是取代模式中可以辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>方法來取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。 使用規則運算式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法來包含邏輯磁碟機的名稱。 所有的規則運算式的字串比較不區分大小寫。 若要成功執行範例，您應該以您的本機電腦名稱來取代常值字串"MyMachine"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|比對兩個連續的反斜線 (`\`) 字元。 因為反斜線字元會解譯為逸出字元，則必須逸出每個反斜線與另一個反斜線。|  
|`+ Environment.MachineName +`|所傳回的字串相符<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。|  
|`(?:\.\w+)*`|比對句號 (`.`) 字元後面接著一或多個文字字元。 此種比對可能是零或多次。 不會擷取相符子運算式。|  
|`\\`|比對反斜線 (`\`) 字元。|  
|`([" + driveNames + "])`|比對的字元類別，其中包含的個別磁碟機代號。 此相符項目是第一個擷取的子運算式。|  
|`\$`|比對常值貨幣符號 (`$`) 字元。|  
  
 取代模式`$1`整個相符項目取代為第一個擷取的子運算式。 也就是說，它會取代 UNC 機器和磁碟機名稱的磁碟機代號。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>這個方法的逾時間隔等於呼叫這個方法的應用程式定義域的預設逾時值。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，來取代模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>在指定的輸入字串中，使用由 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串，取代所有與指定之規則運算式相符的字串。 指定的選項會修改符合的作業。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目中的，如果下列任一條件成立：  
  
-   取代字串不能輕易地指定規則運算式取代模式。  
  
-   取代字串會產生從相符的字串上進行一些處理。  
  
-   取代字串的條件式處理結果。  
  
 此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，取代相符的輸入。  
  
 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 如果取代作業的執行時間超出為呼叫方法的應用程式定義域指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例使用規則運算式從字串中，擷取個別文字，然後使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派来呼叫一個名為`WordScramble`，將金鑰加密的文字中個別的字母。 若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。 它也會使用隨機浮點數建立平行的陣列，它會填入。 藉由呼叫排序陣列<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，並已排序的陣列做為引數提供<xref:System.String>類別建構函式。 然後傳回此新建立的字串`WordScramble`方法。 規則運算式模式`\w+`符合一或多個文字字元，規則運算式引擎會繼續將字元加入至相符項目，直到遇到非文字字元，例如空格字元。 在呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包含<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>選項，讓規則運算式模式中的註解`\w+  # Matches all the characters in a word.`會忽略規則運算式引擎。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="count">取代將發生的最多次數。</param>
        <param name="startat">在輸入字串中開始搜尋的字元位置。</param>
        <summary>在指定的輸入子字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串來取代符合規則運算式模式的指定最大字串數目。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果規則運算式模式在目前執行個體中沒有符合項目，方法會傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：  
  
-   取代字串不能輕易地指定規則運算式取代模式。  
  
-   取代字串會產生從相符的字串上進行一些處理。  
  
-   取代字串的條件式處理結果。  
  
 此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法並傳遞第一個`count`<xref:System.Text.RegularExpressions.Match>中所傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 規則運算式是目前的建構函式所定義的模式<xref:System.Text.RegularExpressions.Regex>物件。  
  
 `evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，取代相符的輸入。  
  
 如果取代作業的執行時間超出 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 建構函式所指定的逾時間隔，就會擲回 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 例外狀況。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="replacement">取代字串。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的輸入字串中，使用指定的取代字串來取代符合指定之規則運算式的所有字串。 如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態`Replace`方法相當於建構<xref:System.Text.RegularExpressions.Regex>物件與指定的規則運算式模式，並呼叫方法的執行個體`Replace`。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 `replacement`參數指定的字串來取代中的每個相符項目`input`。 `replacement` 可以包含常值文字的任意組合並[替代項目](~/docs/standard/base-types/substitutions-in-regular-expressions.md)。 比方說，取代模式`a*${test}b`插入字串"*"後面接著所比對的子字串`test`擷取群組，如果有的話，後面接著字串"b"。 * 字元無法辨識為中繼字元的取代模式內。  
  
> [!NOTE]
>  替代是取代模式中可以辨識的只是規則運算式語言項目。 所有其他規則運算式語言項目，包括[字元逸出](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)，允許只在規則運算式模式中，而且無法辨識取代模式中。  
  
 `matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>方法來取代本機檔案路徑的 UNC 路徑中的本機電腦和磁碟機名稱。 使用規則運算式<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性，以包括本機電腦的名稱和<xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>方法來包含邏輯磁碟機的名稱。 所有的規則運算式的字串比較會區分大小寫，而任何單一的取代作業會逾時，如果 0.5 秒內找不到相符項目。 若要成功執行範例，您應該以您的本機電腦名稱來取代常值字串"MyMachine"。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 下列的運算式所定義的規則運算式模式：  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 下表顯示規則運算式模式的解譯方式。  
  
|模式|描述|  
|-------------|-----------------|  
|`\\\\`|比對兩個連續的反斜線 (`\`) 字元。 因為反斜線字元會解譯為逸出字元，則必須逸出每個反斜線與另一個反斜線。|  
|`+ Environment.MachineName +`|所傳回的字串相符<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性。|  
|`(?:\.\w+)*`|比對句號 (`.`) 字元後面接著一或多個文字字元。 此種比對可能是零或多次。 不會擷取相符子運算式。|  
|`\\`|比對反斜線 (`\`) 字元。|  
|`([" + driveNames + "])`|比對的字元類別，其中包含的個別磁碟機代號。 此相符項目是第一個擷取的子運算式。|  
|`\$`|比對常值貨幣符號 (`$`) 字元。|  
  
 取代模式`$1`整個相符項目取代為第一個擷取的子運算式。 也就是說，它會取代 UNC 機器和磁碟機名稱的磁碟機代號。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="replacement" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">回溯</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">在 .NET Framework 中使用規則運算式的最佳作法</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">用來搜尋比對的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="evaluator">檢查每個符合項目並傳回原始符合字串或取代字串的自訂方法。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的輸入字串中，使用 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 委派所傳回的字串，取代所有與指定之規則運算式相符的子字串。 如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</summary>
        <returns>與輸入字串相同的新字串 (不同之處是取代字串會取代每一個相符的字串)。 如果在目前的執行個體中沒有符合 <paramref name="pattern" /> 的項目，則方法傳回未變更的目前執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法適合用來取代規則運算式相符項目，如果下列任一條件成立：  
  
-   如果無法輕易地規則運算式取代模式所指定取代字串。  
  
-   如果取代字串而產生的一些處理會在相符字串上執行。  
  
-   如果取代字串而產生的條件式處理。  
  
 此方法就相當於呼叫<xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>方法並傳遞每<xref:System.Text.RegularExpressions.Match>在傳回的物件<xref:System.Text.RegularExpressions.MatchCollection>集合`evaluator`委派。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 `evaluator`參數是您定義的自訂方法的委派，並可檢查每個符合項目。 自訂的方法必須具有下列簽章，以符合<xref:System.Text.RegularExpressions.MatchEvaluator>委派。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 您的自訂方法會傳回字串，取代相符的輸入。  
  
 如果為 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 參數指定 `options`，搜尋符合項目會從輸入字串結尾開始向左移動，否則，搜尋會從輸入字串開頭開始向右移動。  
  
 `matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止規則運算式依賴大量回溯不會出現以"停止回應時它們會處理輸入，其中包含相符項目附近。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。  
  
 因為此方法會傳回`input`保持不變，如果沒有相符項目，您可以使用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法，以判斷方法是否有任何取代項目與輸入字串。  
  
   
  
## Examples  
 下列範例使用規則運算式從字串中，擷取個別文字，然後使用<xref:System.Text.RegularExpressions.MatchEvaluator>委派来呼叫一個名為`WordScramble`，將金鑰加密的文字中個別的字母。 若要這樣做，`WordScramble`方法會建立陣列，其中包含在比對的字元。 它也會使用隨機浮點數建立平行的陣列，它會填入。 藉由呼叫排序陣列<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>方法，並已排序的陣列做為引數提供<xref:System.String>類別建構函式。 然後傳回此新建立的字串`WordScramble`方法。 規則運算式模式`\w+`符合一或多個文字字元，規則運算式引擎會繼續將字元加入至相符項目，直到遇到非文字字元，例如空格字元。 在呼叫<xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29>方法包含<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>選項，讓規則運算式模式中的註解`\w+  # Matches all the characters in a word.`會忽略規則運算式引擎。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />、<paramref name="pattern" /> 或 <paramref name="evaluator" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">替代</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">回溯</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">在 .NET Framework 中使用規則運算式的最佳作法</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出規則運算式是否由右至左搜尋。</summary>
        <value>如果規則運算式由右至左搜尋，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> 已`true`如果<xref:System.Text.RegularExpressions.Regex>執行個體經由<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>選項。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在規則運算式比對所定義的位置，將輸入字串分割成子字串陣列。</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <summary>在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定之規則運算式模式所定義的位置，將輸入字串分隔成子字串的陣列。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。 將字串分割為盡可能多次。 如果不找到任何分隔符號，則傳回值就會包含其值是原始的輸入的字串的一個項目。  
  
 如果多個相符項目彼此相鄰，空字串會插入陣列中。 例如，分割上單一連字號的字串會導致傳回的陣列，其中兩個相鄰的連字號找不到，如下列程式碼所示的位置中包含空字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。 下列範例會使用規則運算式模式`\d+`分割輸入的字串的數字的字元。 因為字串開頭和結尾相符的數字的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%29>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。 例如：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 請注意，傳回的陣列也會包含空字串的開頭和結尾的陣列。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>擲回例外狀況是 split 作業的執行時間超過所指定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="count">分隔作業可以發生的最多次數。</param>
        <summary>在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。 `count`參數會指定在其中的子字串的最大數目`input`可以分割字串; 的最後一個字串包含 unsplit 的其餘部分的字串。 A`count`為零的值會提供分割作業當作盡可能多次的預設行為。  
  
 如果多個相符項目彼此相鄰，或是開頭或結尾找到符合`input`，而且找到相符項目數目至少兩個小於`count`，空字串插入到陣列。 也就是造成相鄰的比對或比對的開頭或結尾的輸入字串的空字串會計算在決定是否數目比對的子字串等於`count`。 在下列範例中，規則運算式`/d+`用來分割成三個的子字串的最多包含一個或多個十進位數字的輸入的字串。 因為輸入字串的開頭比對規則運算式模式，第一個陣列元素包含<xref:System.String.Empty?displayProperty=nameWithType>、 第二個包含字母字元在輸入字串中，第一個集合，而第三個包含字串的其餘部分會遵循第三個相符項目。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 如果規則運算式中擷取括號，就會分割字串的陣列中包含任何擷取的文字。 不過，包含擷取的文字的任何陣列元素不會計入判斷是否已到達的相符項目數`count`。 例如，顯示分割成最多四個七個元素陣列，如以下程式碼中的子字串結果的"apple-apricot-梅紅-西洋梨-banana"字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，只擷取的文字從第一個集合擷取括號包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字會加入至傳回的陣列。 不過，傳回陣列中包含擷取的文字的項目不會計算在決定是否數目比對的子字串等於`count`。 比方說，下列程式碼中，規則運算式會使用兩組擷取括號從日期字串中擷取日期的項目。 第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。 若要呼叫<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>方法則指定最多兩個項目中傳回的陣列。 如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，方法會傳回兩個項目的字串陣列。 如果進行編譯和.NET Framework 2.0 或更新版本下執行，則方法會傳回三個項目的字串陣列。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。 下列範例中，將字串"字元 」 分割成因為有許多項目是在輸入字串。 因為 null 字串比對輸入字串的開頭，會傳回陣列的開頭插入 null 字串。 這會導致要在輸入字串結尾處的兩個字元所組成的第十個項目。  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>擲回例外狀況是 split 作業的執行時間超過所指定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <summary>在規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。 `input`字串分割為盡可能多次。 如果`pattern`中找不到`input`字串，傳回值會包含一個項目，其值是原始`input`字串。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  編譯的規則運算式對靜態呼叫中使用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。 若要自行管理的已編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多個相符項目彼此相鄰，空字串會插入陣列中。 例如，分割上單一連字號的字串會導致傳回的陣列，其中兩個相鄰的連字號找不到，如下列程式碼所示的位置中包含空字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。 下列範例會使用規則運算式模式`\d+`分割輸入的字串的數字的字元。 因為字串開頭和結尾相符的數字的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。 例如：  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 請注意，傳回的陣列也會包含空字串的開頭和結尾的陣列。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過逾時間隔的方法呼叫的應用程式定義域指定，會擲回例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>此方法等於呼叫該方法的應用程式定義域的預設逾時值的間隔之後逾時。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，來分割文字模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="count">分隔作業可以發生的最多次數。</param>
        <param name="startat">在輸入字串中要開始搜尋的字元位置。</param>
        <summary>在 <see cref="T:System.Text.RegularExpressions.Regex" /> 建構函式中指定的規則運算式所定義的位置，以指定的最大次數來將輸入字串分隔成子字串的陣列。 規則運算式模式從輸入字串中指定的字元位置開始搜尋。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。 `count`參數會指定在其中的子字串的最大數目`input`字串分割; 的最後一個字串包含 unsplit 的其餘部分的字串。 A`count`為零的值會提供分割作業當作盡可能多次的預設行為。 `startat`參數定義的第一個分隔符號搜尋開始處的點 （這可以用來略過前置空白字元）。  
  
 如果沒有符合的項目從`count`+ 1 位置字串中，方法會傳回一個元素的陣列，其中包含`input`字串。 如果找不到一或多個相符項目，傳回的陣列的第一個元素會包含最多前比對一個字元的第一個字元字串的第一個部分。  
  
 如果多個相符項目是彼此相鄰，而且找到相符項目數目是至少兩個小於`count`，空字串插入到陣列。 同樣地，如果找到符合的`startat`字串中的第一個字元，則傳回的陣列的第一個項目為空字串。 也就是空的字串所產生的相鄰的相符項目會計算在決定是否數目比對的子字串等於`count`。 在下列範例中，規則運算式`\d+`用來尋找數字字元的第一個子字串的開始位置在字串中，然後將字串分割最多三次起始該位置。 由於規則運算式模式比對輸入字串的開頭，傳回的字串陣列是空字串、 五個字元的字母字串和組成的字串，其餘部分  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 如果規則運算式中擷取括號，就會分割字串的陣列中包含任何擷取的文字。 不過，包含擷取的文字的任何陣列元素不會計入判斷是否已到達的相符項目數`count`。 例如，分割字串 '"apple-apricot-plum-pear-pomegranate-pineapple-peach 」 成四個最多的子字串開頭 15 字元字串會產生一個七個元素的陣列，如下列程式碼所示。  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 比方說，下列程式碼會使用兩組擷取括號來擷取個別文字字串中。 第一組擷取括號會擷取連字號，和第二個集合擷取的垂直列。 如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除垂直列的字元，如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。 下列範例會分割成多個項目字串 「 字元 」 因為輸入的字串包含，開頭為字元"a"。 因為 null 字串比對輸入字串的結尾，會傳回陣列結尾處插入 null 字串。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>擲回例外狀況是 split 作業的執行時間超過所指定的逾時間隔<xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>建構函式。 呼叫建構函式時若未設定逾時間隔，則如果作業超過為建立 <xref:System.Text.RegularExpressions.Regex> 物件的應用程式定義域設定的任何逾時值，就會擲回例外狀況。 如果在 <xref:System.Text.RegularExpressions.Regex> 建構函式呼叫或應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> 小於零或大於 <paramref name="input" /> 的長度。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <summary>在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。 指定的選項會修改符合的作業。</summary>
        <returns>字串的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。 將字串分割為盡可能多次。 如果不找到任何分隔符號，則傳回值會包含一個項目，其值是原始`input`字串。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  編譯的規則運算式對靜態呼叫中使用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。 若要自行管理的已編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多個相符項目彼此相鄰，空字串會插入陣列中。 例如，分割上單一連字號的字串會導致傳回的陣列，包含空字串中找到兩個相鄰的連字號的位置。  
  
 如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。 下列範例會使用規則運算式模式`[a-z]+`分割輸入的字串的任何大寫或小寫的字母字元。 因為字串開頭和結尾相符的是英文字母的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>如果 split 作業的執行時間超過逾時間隔的方法呼叫的應用程式定義域指定，會擲回例外狀況。 如果在應用程式定義域的屬性中未定義任何逾時，或逾時值是 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，則不擲回任何例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>此方法等於呼叫該方法的應用程式定義域的預設逾時值的間隔之後逾時。 如果未針對應用程式定義域定義逾時值，則使用值 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，使方法不會逾時。 建議的靜態方法，來分割文字模式比對是<see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />，可讓您設定的逾時間隔。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">要分隔的字串。</param>
        <param name="pattern">要比對的規則運算式模式。</param>
        <param name="options">列舉值的位元組合，提供用於比對的選項。</param>
        <param name="matchTimeout">逾時間隔，若要表示此方法不應逾時則為 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />。</param>
        <summary>在指定的規則運算式模式所定義的位置，將輸入字串分割成子字串陣列。 如果沒有找到相符項目，其他參數會指定修改比對作業的選項和逾時間隔。</summary>
        <returns>字串陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>方法很類似<xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>方法，不同之處在於<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>分割字串的分隔符號，而不是一組字元的規則運算式所決定。 將字串分割為盡可能多次。 如果不找到任何分隔符號，則傳回值會包含一個項目，其值是原始`input`字串。  
  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
> [!IMPORTANT]
>  編譯的規則運算式對靜態呼叫中使用<xref:System.Text.RegularExpressions.Regex.Split%2A>方法會自動快取。 若要自行管理的已編譯的規則運算式的存留期，使用 執行個體<xref:System.Text.RegularExpressions.Regex.Split%2A>方法。  
  
 如果多個相符項目彼此相鄰，空字串會插入陣列中。 例如，分割上單一連字號的字串會導致傳回的陣列，包含空字串中找到兩個相鄰的連字號的位置。  
  
 如果找到符合的開頭或輸入字串的結尾，空字串是陣列的包含開頭或結尾傳回。 下列範例會使用規則運算式模式`[a-z]+`分割輸入的字串的任何大寫或小寫的字母字元。 因為字串開頭和結尾相符的是英文字母的字元數，傳回之陣列的第一個和最後一個項目的值是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 如果擷取括號中使用<xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>運算式中，任何擷取的文字是否包含在產生的字串陣列。 比方說，如果您將分割的字串"梅紅-西洋梨 」 上連字號放擷取括號內，傳回的陣列會包含字串項目，其中包含連字號。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 不過，當規則運算式模式包含多組擷取括號時，此方法的行為取決於.NET Framework 版本。 在.NET Framework 1.0 和 1.1 中，擷取括號，第一個集合中找不到相符項目時擷取的文字，其他擷取括號是不會包含傳回陣列中。 從.NET Framework 2.0 開始，所有擷取的文字也會加入至傳回的陣列。 比方說，下列程式碼會使用兩組擷取括號來擷取日期，包括日期分隔符號，從日期字串的項目。 第一組擷取括號會擷取連字號，和第二個集合擷取正斜線。 如果編譯範例程式碼，並執行.NET Framework 1.0 或 1.1，它會排除的斜線字元;如果進行編譯和.NET Framework 2.0 或更新版本下執行，它會包含它們。  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 如果規則運算式可以符合空字串，<xref:System.Text.RegularExpressions.Regex.Split%2A>因為可以在每個位置上找到的空字串分隔符號，將分割字串成單一字元字串的陣列。  
  
 `matchTimeout`參數會指定如何長模式比對方法應該嘗試逾時之前，尋找相符項目。將逾時間隔可防止依賴大量回溯不會出現停止回應時它們會處理輸入的規則運算式，其中包含相符項目附近。 如需詳細資訊，請參閱 <<c0> [ 規則運算式的最佳做法](~/docs/standard/base-types/best-practices.md)並[回溯](~/docs/standard/base-types/backtracking-in-regular-expressions.md)。 如果該時間間隔中找到相符項目，方法會擲回<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>例外狀況。 `matchTimeout` 覆寫任何方法會執行的應用程式定義域所定義的預設逾時值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">發生規則運算式剖析錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 或 <paramref name="pattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> 不是 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 值的有效位元組合。  
  
-或- 
 <paramref name="matchTimeout" /> 為負數、零或約大於 24 天。</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">發生逾時。 如需逾時的詳細資訊，請參閱＜備註＞一節。</exception>
        <block subset="none" type="usage"><para>我們建議您設定<paramref name="matchTimeout" />參數設為適當的值，例如兩秒。 如果您停用逾時指定<see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />，規則運算式引擎可讓您稍微提升效能。 不過，您應該停用逾時，只有在下列情況下： 
-當規則運算式所處理的輸入來自已知且受信任的來源，或包含靜態文字。 這會排除已動態由使用者輸入的文字。  
  
-當規則運算式模式徹底測試以確保有效率地處理符合時，不符合，而且不久符合。  
  
-當規則運算式模式包含已知會造成大量回溯處理接近的相符項目時沒有語言項目。</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言項目</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">要使用序列化資訊來填入的物件。</param>
        <param name="context">要儲存並擷取序列化資料的位置。 這個參數保留給未來的版本使用。</param>
        <summary>將還原序列化目前 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件所需的資料填入 (Populate) <see cref="T:System.Text.RegularExpressions.Regex" /> 物件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回傳遞至 <see langword="Regex" /> 建構函式中的規則運算式模式。</summary>
        <returns><paramref name="pattern" /> 參數，傳遞至 <see langword="Regex" /> 建構函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 參數包含規則運算式語言項目，以透過符號描述要比對的字串。 如需有關規則運算式的詳細資訊，請參閱 < [.NET Framework 規則運算式](~/docs/standard/base-types/regular-expressions.md)並[規則運算式語言-快速參考](~/docs/standard/base-types/regular-expression-language-quick-reference.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 所建立的規則運算式的基底類別<see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />方法。 這些編譯規則運算式使用<see cref="M:System.Text.RegularExpressions.Regex.ToString" />基底類別的實作。 如果從衍生類別中，呼叫<see cref="M:System.Text.RegularExpressions.Regex.ToString" />方法會傳回字串傳遞給<paramref name="pattern" />參數<see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />類別建構函式用來定義規則運算式。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">輸入字串，包含要轉換的文字。</param>
        <summary>轉換輸入字串中任何逸出的字元。</summary>
        <returns>字元字串，其中任何逸出字元轉換成其未逸出格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法會執行下列兩個轉換的其中一個：  
  
-   它會反轉所執行的轉換<xref:System.Text.RegularExpressions.Regex.Escape%2A>方法，藉由移除逸出字元 ("\\」) 從逸出方法的每個字元。 其中包括\\，*，+，？， &#124;，{，[，（、）、 ^、 $、。，# 和空白字元。 颾魤 ㄛ<xref:System.Text.RegularExpressions.Regex.Unescape%2A>右括號 (]) 和結尾括號 （}） 字元，不逸出方法。  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 無法回復的逸出的字串完全無法推算精確已逸出字元因為  
  
-   它會取代實際的可列印字元加上逐字字串常值中的十六進位值。 例如，它會取代@"\x07""\a"、 使用或@"\x0A"以 「 \n 」。 它會將支援的逸出字元，例如 \a、 \b、 \e、 \n、 \r、 \f、 \t、 \v，以及英數字元。
  
 如果<xref:System.Text.RegularExpressions.Regex.Unescape%2A>方法遇到其他逸出序列無法轉換，例如 \w 或 \s，就會擲回<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> 包含無法辨認的逸出序列。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">規則運算式語言 - 快速參考</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 屬性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 選項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 方法所產生的 <see cref="T:System.Text.RegularExpressions.Regex" /> 物件使用。</summary>
        <returns>如果 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 屬性包含 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 選項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">要檢查的逾時間隔。</param>
        <summary>檢查逾時間隔是否在可接受的範圍內。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>