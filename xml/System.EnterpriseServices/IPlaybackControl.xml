<Type Name="IPlaybackControl" FullName="System.EnterpriseServices.IPlaybackControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1d7e688218f9e4d155f0f11867ab1dd115b8742" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37655112" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPlaybackControl" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPlaybackControl" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.IPlaybackControl" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPlaybackControl" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPlaybackControl" />
  <TypeSignature Language="F#" Value="type IPlaybackControl = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("51372AFD-CAE7-11CF-BE81-00AA00A2FA25")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9b028-101">異常處理之佇列元件中的函式 (這個異常處理用於佇列傳遞機制中的伺服器端播放錯誤及用戶端失敗)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9b028-101">Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b028-102">針對 COM + 目錄中的元件會實作所定義的例外狀況類別<xref:System.EnterpriseServices.IPlaybackControl>和原始類別的介面。</span><span class="sxs-lookup"><span data-stu-id="9b028-102">The exception class defined for the component in the COM+ catalog implements both <xref:System.EnterpriseServices.IPlaybackControl> and the interface for the original class.</span></span> <span data-ttu-id="9b028-103">原始的類別介面的方法實作用來執行失敗的方法在類別本身中處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9b028-103">The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.</span></span> <span data-ttu-id="9b028-104">將會呼叫後<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>或<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>處理例外狀況的原始呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="9b028-104">They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called.</span></span>  
  
 <span data-ttu-id="9b028-105">已排入佇列元件播放程式呼叫的方法<xref:System.EnterpriseServices.IPlaybackControl>通知即將要放在最後的上來或寄不出信件佇列訊息的例外狀況處理常式物件。</span><span class="sxs-lookup"><span data-stu-id="9b028-105">The Queued Components Player calls the methods of <xref:System.EnterpriseServices.IPlaybackControl> to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.</span></span> <span data-ttu-id="9b028-106">已排入佇列元件播放程式然後會呼叫原始方法呼叫中失敗的例外狀況處理常式物件中的相同的方法。</span><span class="sxs-lookup"><span data-stu-id="9b028-106">The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.</span></span> <span data-ttu-id="9b028-107">例外狀況處理常式物件可以實作替代方式，例如收集問題的診斷資訊，或產生的物件或訊息，告知用戶端的問題。</span><span class="sxs-lookup"><span data-stu-id="9b028-107">The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.</span></span> <span data-ttu-id="9b028-108">如果應用程式不會實作<xref:System.EnterpriseServices.IPlaybackControl>，有害訊息置於最終上來或寄不出信件佇列時排入佇列元件播放程式耗盡所有重試。</span><span class="sxs-lookup"><span data-stu-id="9b028-108">If the application does not implement <xref:System.EnterpriseServices.IPlaybackControl>, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.</span></span>  
  
 <span data-ttu-id="9b028-109">有害訊息是不能因為發生問題的伺服器或佇列的系統因為某種原因，可能是處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="9b028-109">A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.</span></span> <span data-ttu-id="9b028-110">交易已回復，與有害訊息會進入佇列頂端。</span><span class="sxs-lookup"><span data-stu-id="9b028-110">The transaction is rolled back, and the poison message goes to the top of the queue.</span></span> <span data-ttu-id="9b028-111">訊息已從佇列清除一次，就會發生相同的條件。</span><span class="sxs-lookup"><span data-stu-id="9b028-111">When the message is dequeued again, the same condition occurs.</span></span> <span data-ttu-id="9b028-112">此訊息可以繼續迴圈項目為了修正此問題之前，無限期。</span><span class="sxs-lookup"><span data-stu-id="9b028-112">This message can continue looping indefinitely until something is done to correct the problem.</span></span> <span data-ttu-id="9b028-113">已排入佇列元件服務會使用一系列的重試次數，以處理有害訊息。</span><span class="sxs-lookup"><span data-stu-id="9b028-113">The Queued Components service handles the poison message by using a series of retries.</span></span> <span data-ttu-id="9b028-114">後幾個失敗的重試，訊息會移至最終的休止佇列。</span><span class="sxs-lookup"><span data-stu-id="9b028-114">After several unsuccessful retries, the message is moved to a final resting queue.</span></span> <span data-ttu-id="9b028-115">有害訊息會保留在之前使用已排入佇列的元件訊息 Mover 工具手動移動的休止佇列。</span><span class="sxs-lookup"><span data-stu-id="9b028-115">Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.</span></span>  
  
 <span data-ttu-id="9b028-116">有害訊息的情況下可以也會解析以程式設計的方式，使用<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>; 方法來通知伺服器端元件作者所播放的延遲啟動過程的所有嘗試都失敗。</span><span class="sxs-lookup"><span data-stu-id="9b028-116">The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.</span></span>  
  
 <span data-ttu-id="9b028-117">如果您發現有害訊息時，您可以快速解決問題的根本原因。</span><span class="sxs-lookup"><span data-stu-id="9b028-117">If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.</span></span> <span data-ttu-id="9b028-118">例如，如果伺服器已離線的因為某些原因，您可以將伺服器恢復連線。</span><span class="sxs-lookup"><span data-stu-id="9b028-118">For example, if the server was offline for some reason, you can bring the server back online.</span></span> <span data-ttu-id="9b028-119">如果您不能快速解決問題，您可以自動產生的通知要求者的交易不會發生另一個交易。</span><span class="sxs-lookup"><span data-stu-id="9b028-119">If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.</span></span> <span data-ttu-id="9b028-120">要求者接著可以反轉已經認可交易的補償交易。</span><span class="sxs-lookup"><span data-stu-id="9b028-120">The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="FinalClientRetry">
      <MemberSignature Language="C#" Value="public void FinalClientRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalClientRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalClientRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalClientRetry();" />
      <MemberSignature Language="F#" Value="abstract member FinalClientRetry : unit -&gt; unit" Usage="iPlaybackControl.FinalClientRetry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9b028-121">通知用戶端例外狀況處理元件，嘗試傳遞訊息至伺服器的所有訊息佇列都遭到拒絕，以及訊息已在用戶端 Xact Dead Letter 佇列上結束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9b028-121">Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b028-122">當訊息送達 Xact Dead Letter 佇列，COM + 嘗試叫用相關的伺服器類別，來傳遞這項通知的用戶端例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="9b028-122">As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.</span></span> <span data-ttu-id="9b028-123">其作法是先呼叫<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>，然後呼叫該例外狀況處理版本之失敗的方法中的例外狀況處理常式物件。</span><span class="sxs-lookup"><span data-stu-id="9b028-123">It does so by first calling <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>, then calling the exception-handling version of the failed method in the exception-handler object.</span></span> <span data-ttu-id="9b028-124">這個例外狀況的方法可以做出一些例外狀況回應，例如記錄失敗、 傳送的電子郵件訊息給系統管理員，或採取用戶端 （反轉先前交易的效果） 的補償動作。</span><span class="sxs-lookup"><span data-stu-id="9b028-124">This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</span></span> <span data-ttu-id="9b028-125">如果例外狀況的方法不成功，訊息就會留在 Xact Dead Letter 佇列上。</span><span class="sxs-lookup"><span data-stu-id="9b028-125">If the exception method is not successful, the message is left on the Xact Dead Letter queue.</span></span>  
  
 <span data-ttu-id="9b028-126">在 Microsoft Message Queue (MSMQ) 總管 中，您可以檢視 Xact Dead Letter 佇列。</span><span class="sxs-lookup"><span data-stu-id="9b028-126">The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FinalServerRetry">
      <MemberSignature Language="C#" Value="public void FinalServerRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalServerRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalServerRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalServerRetry();" />
      <MemberSignature Language="F#" Value="abstract member FinalServerRetry : unit -&gt; unit" Usage="iPlaybackControl.FinalServerRetry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9b028-127">通知伺服器端例外狀況類別實作，所有嘗試播放對伺服器的延遲啟動過程都已經失敗，而訊息將會搬移至其最終的休止佇列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9b028-127">Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b028-128">當訊息送達 Xact Dead Letter 佇列上時，COM + 嘗試叫用伺服器類別，來傳遞這項通知的相關伺服器端例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="9b028-128">As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.</span></span> <span data-ttu-id="9b028-129">其作法是先呼叫<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>，則呼叫例外狀況處理的例外狀況處理常式物件中失敗的方法版本。</span><span class="sxs-lookup"><span data-stu-id="9b028-129">It does so by first calling <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>, then calling the exception handling version of the failed method in the exception handler object.</span></span> <span data-ttu-id="9b028-130">這個例外狀況的方法可以做出一些例外狀況回應，例如記錄失敗、 傳送的電子郵件訊息給系統管理員，或採取用戶端 （反轉先前交易的效果） 的補償動作。</span><span class="sxs-lookup"><span data-stu-id="9b028-130">This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</span></span> <span data-ttu-id="9b028-131">伺服器物件應該盡所有努力順利完成此交易。</span><span class="sxs-lookup"><span data-stu-id="9b028-131">The server object should make every effort to complete this transaction successfully.</span></span> <span data-ttu-id="9b028-132">否則，請手動介入的情況下，才能重新處理訊息。</span><span class="sxs-lookup"><span data-stu-id="9b028-132">Otherwise, manual intervention is required to reprocess the message.</span></span> <span data-ttu-id="9b028-133">如果例外狀況方法失敗，訊息會移至最終的休止佇列。</span><span class="sxs-lookup"><span data-stu-id="9b028-133">If the exception method is not successful, the message is moved to the final resting queue.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>