<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IPlaybackControl.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac554fcf7590327e9d2356fc883bfae633d190f6a78.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">54fcf7590327e9d2356fc883bfae633d190f6a78</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.</source>
          <target state="translated">異常處理之佇列元件中的函式 (這個異常處理用於佇列傳遞機制中的伺服器端播放錯誤及用戶端失敗)。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The exception class defined for the component in the COM+ catalog implements both <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph> and the interface for the original class.</source>
          <target state="translated">同時實作 COM + 目錄中的元件中定義的例外狀況類別<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph>和原始類別的介面。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.</source>
          <target state="translated">原始的類別介面方法的實作用來執行的例外狀況處理類別本身中失敗的方法。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>They will be called after <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph> to process exceptions for the method originally called.</source>
          <target state="translated">將會呼叫之後<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph>處理初次呼叫方法的例外狀況。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The Queued Components Player calls the methods of <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph> to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.</source>
          <target state="translated">排入佇列元件播放程式呼叫的方法<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph>通知訊息即將置於最終或是寄不出信件佇列的例外狀況處理常式物件。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.</source>
          <target state="translated">排入佇列元件播放程式依序呼叫原始方法呼叫中失敗的例外狀況處理常式物件相同的方法。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.</source>
          <target state="translated">例外狀況處理常式物件可以實作的替代方式，例如收集問題的診斷資訊，或產生物件或訊息，通知用戶端的問題。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>If the application does not implement <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph>, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.</source>
          <target state="translated">如果應用程式不會實作<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl&gt;</ph>，有害訊息放置最終或是寄不出信件佇列時排入佇列元件播放程式耗盡所有重試。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.</source>
          <target state="translated">有害訊息是無法處理的某些原因，可能是因為有問題的伺服器或佇列的系統訊息。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The transaction is rolled back, and the poison message goes to the top of the queue.</source>
          <target state="translated">交易已回復，而且有害訊息會進入佇列的上方。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>When the message is dequeued again, the same condition occurs.</source>
          <target state="translated">當訊息從佇列中清除一次時，就會發生同樣的狀況。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>This message can continue looping indefinitely until something is done to correct the problem.</source>
          <target state="translated">這則訊息可以繼續迴圈直到設法修正問題。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The Queued Components service handles the poison message by using a series of retries.</source>
          <target state="translated">排入佇列元件服務會使用一系列的重試次數，以處理有害訊息。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>After several unsuccessful retries, the message is moved to a final resting queue.</source>
          <target state="translated">數個失敗的重試之後, 的訊息移到最後靜止佇列。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.</source>
          <target state="translated">有害訊息保留在休止的佇列，直到以手動方式移動是利用排入佇列的元件訊息 Mover 工具。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The poison message situation can also be resolved programmatically, using the <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.</source>
          <target state="translated">有害訊息的情況下可以也使用來解決程式設計角度而言，<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph>方法，它會通知播放延後的啟動的所有嘗試都失敗，伺服器端元件作者。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.</source>
          <target state="translated">如果您發現有害訊息時，您可以快速解決問題的根本原因。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>For example, if the server was offline for some reason, you can bring the server back online.</source>
          <target state="translated">比方說，如果基於某些原因，伺服器已離線，您可以讓伺服器重新在線上。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.</source>
          <target state="translated">如果您不能快速解決問題，您可以自動產生的通知要求者的交易不會發生另一個交易。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.EnterpriseServices.IPlaybackControl">
          <source>The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.</source>
          <target state="translated">要求者來進行補償交易的回復已經認可的交易造成影響。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.</source>
          <target state="translated">通知用戶端例外狀況處理元件，嘗試傳遞訊息至伺服器的所有訊息佇列都遭到拒絕，以及訊息已在用戶端 Xact Dead Letter 佇列上結束。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.</source>
          <target state="translated">當訊息送達 Xact 寄不出的信件佇列中時，COM + 嘗試叫用與伺服器類別，來傳遞此通知相關的用戶端例外狀況處理常式。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>It does so by first calling <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph>, then calling the exception-handling version of the failed method in the exception-handler object.</source>
          <target state="translated">它會先呼叫<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A&gt;</ph>，然後呼叫該例外狀況處理版本的失敗的方法中的例外狀況處理常式物件。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</source>
          <target state="translated">這個例外狀況的方法可以採取例外狀況動作，例如記錄失敗、 郵件訊息傳送給系統管理員，或採取任何行動用戶端補償 （反向先前交易的效果）。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>If the exception method is not successful, the message is left on the Xact Dead Letter queue.</source>
          <target state="translated">如果不成功的例外狀況的方法時，訊息就能肯定的交易的寄不出信件佇列中。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry">
          <source>The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.</source>
          <target state="translated">在 Microsoft Message Queue (MSMQ) 總管 中，您可以檢視能肯定的交易的寄不出信件佇列。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.</source>
          <target state="translated">通知伺服器端例外狀況類別實作，所有嘗試播放對伺服器的延遲啟動過程都已經失敗，而訊息將會搬移至其最終的休止佇列。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.</source>
          <target state="translated">當訊息到達 Xact 寄不出的信件佇列，COM + 嘗試叫用與伺服器類別，來傳遞此通知相關的伺服器端例外狀況處理常式。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>It does so by first calling <ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph>, then calling the exception handling version of the failed method in the exception handler object.</source>
          <target state="translated">它會先呼叫<ph id="ph1">&lt;xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A&gt;</ph>，然後呼叫例外狀況處理失敗的方法中的例外狀況處理常式物件的版本。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</source>
          <target state="translated">這個例外狀況的方法可以採取例外狀況動作，例如記錄失敗、 郵件訊息傳送給系統管理員，或採取任何行動用戶端補償 （反向先前交易的效果）。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>The server object should make every effort to complete this transaction successfully.</source>
          <target state="translated">伺服器物件應該請致力將順利完成此交易。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>Otherwise, manual intervention is required to reprocess the message.</source>
          <target state="translated">否則，需要手動介入，重新處理訊息。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry">
          <source>If the exception method is not successful, the message is moved to the final resting queue.</source>
          <target state="translated">如果不成功的例外狀況的方法時，訊息會移到最後靜止的佇列。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>