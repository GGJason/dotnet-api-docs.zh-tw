<Type Name="IPlaybackControl" FullName="System.EnterpriseServices.IPlaybackControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="54fcf7590327e9d2356fc883bfae633d190f6a78" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30408882" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPlaybackControl" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPlaybackControl" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.IPlaybackControl" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPlaybackControl" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPlaybackControl" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("51372AFD-CAE7-11CF-BE81-00AA00A2FA25")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>異常處理之佇列元件中的函式 (這個異常處理用於佇列傳遞機制中的伺服器端播放錯誤及用戶端失敗)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同時實作 COM + 目錄中的元件中定義的例外狀況類別<xref:System.EnterpriseServices.IPlaybackControl>和原始類別的介面。 原始的類別介面方法的實作用來執行的例外狀況處理類別本身中失敗的方法。 將會呼叫之後<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>或<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>處理初次呼叫方法的例外狀況。  
  
 排入佇列元件播放程式呼叫的方法<xref:System.EnterpriseServices.IPlaybackControl>通知訊息即將置於最終或是寄不出信件佇列的例外狀況處理常式物件。 排入佇列元件播放程式依序呼叫原始方法呼叫中失敗的例外狀況處理常式物件相同的方法。 例外狀況處理常式物件可以實作的替代方式，例如收集問題的診斷資訊，或產生物件或訊息，通知用戶端的問題。 如果應用程式不會實作<xref:System.EnterpriseServices.IPlaybackControl>，有害訊息放置最終或是寄不出信件佇列時排入佇列元件播放程式耗盡所有重試。  
  
 有害訊息是無法處理的某些原因，可能是因為有問題的伺服器或佇列的系統訊息。 交易已回復，而且有害訊息會進入佇列的上方。 當訊息從佇列中清除一次時，就會發生同樣的狀況。 這則訊息可以繼續迴圈直到設法修正問題。 排入佇列元件服務會使用一系列的重試次數，以處理有害訊息。 數個失敗的重試之後, 的訊息移到最後靜止佇列。 有害訊息保留在休止的佇列，直到以手動方式移動是利用排入佇列的元件訊息 Mover 工具。  
  
 有害訊息的情況下可以也使用來解決程式設計角度而言，<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>方法，它會通知播放延後的啟動的所有嘗試都失敗，伺服器端元件作者。  
  
 如果您發現有害訊息時，您可以快速解決問題的根本原因。 比方說，如果基於某些原因，伺服器已離線，您可以讓伺服器重新在線上。 如果您不能快速解決問題，您可以自動產生的通知要求者的交易不會發生另一個交易。 要求者來進行補償交易的回復已經認可的交易造成影響。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="FinalClientRetry">
      <MemberSignature Language="C#" Value="public void FinalClientRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalClientRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalClientRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalClientRetry();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知用戶端例外狀況處理元件，嘗試傳遞訊息至伺服器的所有訊息佇列都遭到拒絕，以及訊息已在用戶端 Xact Dead Letter 佇列上結束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當訊息送達 Xact 寄不出的信件佇列中時，COM + 嘗試叫用與伺服器類別，來傳遞此通知相關的用戶端例外狀況處理常式。 它會先呼叫<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>，然後呼叫該例外狀況處理版本的失敗的方法中的例外狀況處理常式物件。 這個例外狀況的方法可以採取例外狀況動作，例如記錄失敗、 郵件訊息傳送給系統管理員，或採取任何行動用戶端補償 （反向先前交易的效果）。 如果不成功的例外狀況的方法時，訊息就能肯定的交易的寄不出信件佇列中。  
  
 在 Microsoft Message Queue (MSMQ) 總管 中，您可以檢視能肯定的交易的寄不出信件佇列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FinalServerRetry">
      <MemberSignature Language="C#" Value="public void FinalServerRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalServerRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalServerRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalServerRetry();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知伺服器端例外狀況類別實作，所有嘗試播放對伺服器的延遲啟動過程都已經失敗，而訊息將會搬移至其最終的休止佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當訊息到達 Xact 寄不出的信件佇列，COM + 嘗試叫用與伺服器類別，來傳遞此通知相關的伺服器端例外狀況處理常式。 它會先呼叫<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>，然後呼叫例外狀況處理失敗的方法中的例外狀況處理常式物件的版本。 這個例外狀況的方法可以採取例外狀況動作，例如記錄失敗、 郵件訊息傳送給系統管理員，或採取任何行動用戶端補償 （反向先前交易的效果）。 伺服器物件應該請致力將順利完成此交易。 否則，需要手動介入，重新處理訊息。 如果不成功的例外狀況的方法時，訊息會移到最後靜止的佇列。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>