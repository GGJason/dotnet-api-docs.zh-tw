<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c8d93b898d628b70967d33278c8cd9f33a66bf" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36479604" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>抽象基底類別，定義安全性權杖服務 (STS) 的屬性和方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立您必須衍生自 STS<xref:System.IdentityModel.SecurityTokenService>類別。 在您的自訂類別必須，至少覆寫<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>和<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法。 這些覆寫時，STS 建立使用所有其他方法的類別中定義的預設實作是能夠發出安全性權杖，以回應安全性權杖要求 (RST)。 也就是說，會實作 Ws-trust 規格中定義的問題繫結。 這個繫結中實作<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。 無其他 1.1、WS-Trust 繫結 （更新、 Cancel 和驗證） 的實作在預設案例中，而且如果遇到對應至其中一個繫結 RST，將會傳回給呼叫端的適當的錯誤。 您當然可以覆寫適當的方法 (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>， <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>，和<xref:System.IdentityModel.SecurityTokenService.Validate%2A>) 將在 STS 中實作這些繫結。  
  
> [!IMPORTANT]
>  實作可實際執行的 STS 時，需要仔細規劃和相當多的資源，以減少在公開這類服務固有的潛在安全性風險。 大部分的開發人員使用 Windows Identity Foundation (WIF) 會將開發外包到 STS，身分識別管理的應用程式而開發 STS 本身。 WIF 提供 Visual Studio 擴充功能，可協助開發人員在開發環境中測試解決方案的身分識別和存取 Visual Studio 2012 的工具。 此工具包含 STS， `LocalSTS`，您可以設定為可提供給您正在開發的應用程式的特定宣告。 如需身分識別和存取工具的詳細資訊，請參閱[Identity and Access Tool for Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md)。 在某些情況下，`LocalSTS`可能不會提供適當地測試您的應用程式所需的功能; 例如，涉及的案例中開發使用的自訂權杖處理常式的應用程式。 在這些情況下，您可以從衍生<xref:System.IdentityModel.SecurityTokenService>建立一或多個簡單 Sts，，可以部署在您的開發環境，而且，可用來測試您的應用程式中的這類功能。 本節的其餘部分著重於所公開的方法<xref:System.IdentityModel.SecurityTokenService>類別可讓您實作簡單的 STS 和延伸的權杖發行管線。  
  
 下列清單會提供給開發人員在測試或開發環境中使用的方法，其中最重要的簡短概觀。  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> 方法 這個方法會傳回<xref:System.IdentityModel.Scope>包含 RP 的相關資訊的物件。 此物件會在權杖發行管線的其餘部分，並包含在回應中，使用 簽署和加密認證的相關資訊，以及`AppliesTo`和`ReplyTo`（如有必要） 位址。 您必須覆寫這個方法。  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> 方法 這個方法會傳回<xref:System.Security.Claims.ClaimsIdentity>物件，其中包含要傳回給 RP 的宣告。 您必須覆寫這個方法。  
  
-   <xref:System.IdentityModel.SecurityTokenService.Issue%2A> 方法 這個方法會實作權杖要求管線中，處理傳入安全性權杖的要求 (RST)，並傳回呼叫者，其中包含可用來向 RP 的權杖回應 (RSTR)。 中定義的其他方法的許多<xref:System.IdentityModel.SecurityTokenService>類別會呼叫這個方法，包括<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>和<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法。 您沒有覆寫這個方法，但了解權杖要求管線，它會實作可能會很有幫助。  
  
 透過設定 STS<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration>類別。  
  
   
  
## Examples  
 中所使用的程式碼範例<xref:System.IdentityModel.SecurityTokenService>取自主題`Custom Token`範例。 此範例提供自訂的類別，可讓處理的簡單 Web 權杖 (SWT)，並包含被動 STS 的實作，能夠為 SWT 權杖。 如需如何實作主動式 STS 的範例，您可以參閱`Federation Metadata`範例。 如需這些範例和其他可用的範例為 WIF 以及其下載位置，請參閱[WIF 程式碼範例索引](~/docs/framework/security/wif-code-sample-index.md)。 下列程式碼顯示被動 STS 的實作使用<xref:System.IdentityModel.SecurityTokenService>類別。  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 下列程式碼示範如何叫用自訂的被動 STS，以處理 WS-同盟要求，藉由呼叫<xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType>背後的程式碼中的方法`default.aspx.cs`檔案。  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>您必須同時覆寫<see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />而<see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />方法。</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">
          <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />，包含 STS 的設定。</param>
        <summary>使用指定的組態設定，從衍生類別呼叫以初始化 <see cref="T:System.IdentityModel.SecurityTokenService" /> 類別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個建構函式來初始化的領域提供者和權杖簽發者憑證。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收完成非同步取消作業的通知。</param>
        <param name="state">包含與非同步取消作業相關聯之狀態資訊的物件。</param>
        <summary>在衍生類別中覆寫時，開始非同步 WS-Trust 取消要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，這個物件會參考非同步取消作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" />，其中包含與要求相關聯之信賴憑證者的相關資訊。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收完成非同步作業的通知。</param>
        <param name="state">包含與非同步作業相關聯之狀態資訊的物件。</param>
        <summary>在衍生類別中覆寫時，開始非同步呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> 方法。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，這個項目會參考非同步作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收完成非同步作業的通知。</param>
        <param name="state">包含與非同步作業相關聯之狀態資訊的物件。</param>
        <summary>在衍生類別中覆寫時，開始 <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> 方法的非同步呼叫。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，這個物件會參考非同步取消作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收完成非同步核發作業的通知。</param>
        <param name="state">包含與非同步發行作業相關聯之狀態資訊的物件。</param>
        <summary>在衍生類別中覆寫時，開始非同步 WS-Trust 發行要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，會參考非同步核發作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，這個委派會接收完成非同步更新作業的通知。</param>
        <param name="state">包含與非同步更新作業相關聯之狀態資訊的物件。</param>
        <summary>在衍生類別中覆寫時，開始非同步 WS-Trust 更新要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，會參考非同步更新作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" />　委派，這個委派會接收完成非同步驗證作業的通知。</param>
        <param name="state">包含與非同步驗證作業相關聯之狀態資訊的物件。</param>
        <summary>在衍生類別中覆寫時，開始非同步 WS-Trust 驗證要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，會參考非同步驗證作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <summary>在衍生類別中覆寫時，處理 WS-Trust 取消要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">連入的權杖要求。</param>
        <param name="scope">從 <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> 傳回的 <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> 物件。</param>
        <summary>建立 <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" /> 的執行個體。</summary>
        <returns>
          <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在之後的權杖發行期間叫用<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="scope" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，在呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法時所傳回。</param>
        <summary>在衍生類別中覆寫時，完成非同步 WS-Trust 取消要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，在呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> 方法時所傳回。</param>
        <summary>在衍生類別中覆寫時，完成非同步呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> 方法。</summary>
        <returns>包含將放入已發行安全性權杖之宣告集合的 <see cref="T:System.Security.Claims.ClaimsIdentity" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，在呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法時所傳回。</param>
        <summary>在衍生類別中覆寫時，完成非同步呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法。</summary>
        <returns>封裝與 <see cref="T:System.IdentityModel.Scope" /> 方法呼叫中指定要求 (RST) 相關聯之信賴憑證者 (RP) 資訊的 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，在呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法時所傳回。</param>
        <summary>在衍生類別中覆寫時，完成非同步 WS-Trust 發行要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，在呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法時所傳回。</param>
        <summary>在衍生類別中覆寫時，完成非同步 WS-Trust 更新要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，在呼叫 <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法時所傳回。</param>
        <summary>在衍生類別中覆寫時，完成非同步 WS-Trust 驗證要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得安全性權杖服務 (STS) 的名稱。</summary>
        <returns>簽發者名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從權杖的發行管線中實作的預設會呼叫這個方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 預設實作會傳回<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A>屬性設定透過存取從<xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" />，其中包含與要求相關聯之信賴憑證者的相關資訊。 這是 <see cref="T:System.IdentityModel.Scope" /> 方法所傳回的 <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> 物件。</param>
        <summary>在衍生類別中覆寫，這個方法會傳回包含在已發行權杖中的輸出主體集合。</summary>
        <returns>包含將放入已發行安全性權杖之宣告集合的 <see cref="T:System.Security.Claims.ClaimsIdentity" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法從權杖發行管線中，藉由呼叫<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。 它會傳回<xref:System.Security.Claims.ClaimsIdentity>，其中包含要納入發行的安全性權杖的權杖要求者為基礎的宣告 (`principal`參數)，傳入的 RST (`request`參數)，而權杖的信賴憑證者合作對象 （`scope`參數)。 這個方法中的邏輯的主要考量回答下列問題：  
  
-   **根據其適用的 RP 回應中時，應該會包含哪個宣告類型？** 通常這會決定所需的每個 RP 的宣告型別的清單中的每個 RP 基礎或在個別要求基礎上藉由檢查<xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A>要求的屬性。 不過，邏輯和詳細資料，來判斷要包含在回應中的宣告會完全實作。  
  
-   **哪個宣告值都應該指派給回應中的宣告？** 身分識別提供者 (IP STS) 這通常表示要求者的中使用一或多個宣告<xref:System.Security.Claims.ClaimsPrincipal>(由`principal`參數) 來存取存放區 （或其他實體） 來傳回必要的宣告類型的值。 同盟提供者 (R STS) 這通常表示要求者的連入宣告，以滿足要求; 上執行某種類型的處理也可能會提供要求者，並傳遞其他人透過未修改某些宣告上進行篩選或轉換。 當然，例決定要包含在回應中的宣告的詳細資料和邏輯如何決定這些宣告的值是由您的實作。  
  
   
  
## Examples  
 使用本主題中的程式碼範例取自`Custom Token`範例。 此範例提供自訂的類別，可讓處理的簡單 Web 權杖 (SWT)，並包含被動 STS 的實作，能夠為 SWT 權杖。 如需如何實作主動式 STS 的範例，您可以參閱`Federation Metadata`範例。 如需這些範例和其他可用的範例為 WIF 以及其下載位置，請參閱[WIF 程式碼範例索引](~/docs/framework/security/wif-code-sample-index.md)。 下列程式碼示範如何覆寫<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法來傳回宣告 sts。 在此範例中，會忽略該要求安全性權杖 (RST) 訊息，就會傳回根據使用者通過驗證後在 STS 的宣告集合。  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您必須覆寫這個方法的實作中<see cref="T:System.IdentityModel.SecurityTokenService" />類別。</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">表示傳入權杖要求 (RST) 的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />。</param>
        <param name="scope">會封裝信賴憑證者的相關資訊的<see cref="T:System.IdentityModel.Scope" />執行個體。</param>
        <summary>取得要包含在回應 (RSTR) 的證明權杖。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" />，表示新建立的證明描述元。 證明描述元可以是非對稱式證明描述元、對稱式證明描述元，或<see langword="null" />（在持有人權杖的情況下）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從權杖的發行管線中實作的預設會呼叫這個方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 預設實作會傳回證明描述元，則會擲回適當的例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="scope" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">表示傳入權杖要求 (RST) 的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />。</param>
        <summary>取得要求者的證明加密認證。</summary>
        <returns>表示要求者之加密認證的 <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從呼叫<xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A>方法。  
  
 預設實作會執行下列作業。 傳回`null`不是否有任何要求中指定的加密語彙基元 (<xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType>屬性是`null`)。 否則，如果它可以取得語彙基元<xref:System.IdentityModel.Tokens.X509SecurityToken>，它會傳回根據該語彙基元的認證。 如果無法解析語彙基元<xref:System.IdentityModel.Tokens.X509SecurityToken>、<xref:System.IdentityModel.RequestFailedException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">包含權杖要求的 RST。</param>
        <param name="tokenDescriptor">權杖描述元，其中包含要用於已發行的權杖的資訊。</param>
        <summary>使用指定的要求 (RST) 和安全性權杖描述元，建立包含核發之權杖的回應 (RSTR)。</summary>
        <returns>回應 (RSTR)，如果無法從指定的要求和權杖描述元建立回應則為 <see langword="null" />。 如果 <paramref name="tokenDescriptor" /> 參數為 <see langword="null" />，則預設實作會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A>方法，會從權杖發行管線中，藉由呼叫的最後一個步驟<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。 建立並使用原始的連入要求 (RST) 和權杖發行管線中的上一個步驟期間所建立的權杖描述元傳回回應 (RSTR)。  
  
 預設實作會建立傳遞 RST 的要求參數中指定的 RSTR<xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType>建構函式、 叫用<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType>方法，在 權杖描述元傳遞至<xref:System.IdentityModel.SecurityTokenService.GetResponse%2A>套用其屬性，以新建立 RSTR，設定<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A>屬性上使用 RSTR<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A>屬性上的權杖描述元，以及最後設定<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A>RSTR 根據下表中的屬性：  
  
|`RST.ReplyTo` 屬性|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType> 屬性。|`RSTR.ReplyTo` 屬性|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|設定|未設定|未設定|  
|設定|設定|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|未設定|設定|未設定|  
|未設定|未設定|未設定|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示提出要求的用戶端。</param>
        <param name="request">表示傳入要求 (RST) 的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />。</param>
        <summary>取得 <see cref="T:System.IdentityModel.Scope" /> 物件，其中包含與所指定的要求 (RST) 相關聯之信賴憑證者 (RP) 的相關資訊。 您必須在 <see cref="T:System.IdentityModel.SecurityTokenService" /> 類別的實作中覆寫此方法。</summary>
        <returns>封裝與要求相關聯之 RP 資訊的 <see cref="T:System.IdentityModel.Scope" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法呼叫從權杖發行管線之後<xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法，而且應該傳回<xref:System.IdentityModel.Scope>設定連入要求的物件。 (權杖發行管線中實作<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。)<xref:System.IdentityModel.Scope>物件封裝 RP 與安全性權杖要求 (RST) 相關聯的相關資訊。 這包括用於 RP 和要加密任何發行的權杖和/或回應中的對稱金鑰的加密和簽署認證的相關資訊。 在執行某些一般工作<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法：  
  
-   判斷語彙基元適用的 RP 是可辨識的 RP。 如何完成此作業取決於您的實作。 如果預期的 RP 不是有效的 RP 此 sts，則這個方法應該擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
-   判斷回應 (RSTR) 中使用和設定簽署認證<xref:System.IdentityModel.Scope.SigningCredentials%2A>屬性據此。  
  
-   決定是否應該加密回應和/或任何包含的對稱金鑰，以及要用於加密的認證。 設定<xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>， <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>，和<xref:System.IdentityModel.Scope.EncryptingCredentials%2A>屬性據此。  
  
    > [!IMPORTANT]
    >  根據預設，<xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>並<xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>屬性會設定`true`防止 STS 發出權杖，並不安全。 我們建議您永遠不會設定為這些屬性`false`在生產環境中。  
  
-   決定應該要傳回的回應的位址。 設定<xref:System.IdentityModel.Scope.AppliesToAddress%2A>或<xref:System.IdentityModel.Scope.ReplyToAddress%2A>屬性據此。  
  
   
  
## Examples  
 使用本主題中的程式碼範例取自`Custom Token`範例。 此範例提供自訂的類別，可讓處理的簡單 Web 權杖 (SWT)，並包含被動 STS 的實作，能夠為 SWT 權杖。 如需如何實作主動式 STS 的範例，您可以參閱`Federation Metadata`範例。 如需這些範例和其他可用的範例為 WIF 以及其下載位置，請參閱[WIF 程式碼範例索引](~/docs/framework/security/wif-code-sample-index.md)。  
  
 下列程式碼範例示範 <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> 方法的實作。 此實作可讓您確認，RP 能辨識的 STS，驗證<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A>要求與集合中的地址<xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType>屬性據此，和設定簽署和加密憑證以搭配 RP 依據憑證在檔案中，是硬式編碼。  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您必須覆寫這個方法的實作中<see cref="T:System.IdentityModel.SecurityTokenService" />類別。</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">包含要求之語彙基元型別 URI 的字串。</param>
        <summary>取得適當的安全性權杖處理常式，以發出指定之類型的安全性權杖。</summary>
        <returns>表示要用於建立所發行安全性權杖之權杖處理常式的 <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />。 如果不支援要求的語彙基元類型 (沒有為指定的語彙基元類型設定的處理常式)，則傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在預設實作中如果`requestedTokenType`是`null`或空字串，在使用語彙基元的型別，從設定的預設值。 這由<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A>經由 STS 組態物件屬性<xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A>屬性。  
  
 從權杖的發行管線中實作的預設會呼叫這個方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />，表示要求的存留期。</param>
        <summary>取得已發行權杖的存留期。</summary>
        <returns>表示授與之存留期的 <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 RST 中到達的存留期通常呼叫這個方法。 在預設實作中，依下表被計算權杖的存留期。  
  
|建立 (in)|到期 (in)|建立 (in)|到期 (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 從權杖的發行管線中實作的預設會呼叫這個方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <summary>發行安全性權杖。</summary>
        <returns>包含已發行安全性權杖的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作 Ws-trust 規格中定義的問題繫結。 預設實作<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法處理連入要求 (RST) 權杖的發行 （宣告發行） 管線，並傳回其中一個回應 (RSTR，其中包含安全性權杖來驗證的適當宣告)RP 或適當的例外狀況的要求者。 權杖發行管線中的預設實作是由下列方法的呼叫所組成 (的<xref:System.IdentityModel.SecurityTokenService>類別)。  
  
1.  <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法以驗證要求 (RST)。  
  
2.  <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法來取得<xref:System.IdentityModel.Scope>包含信賴憑證者 (RP) 與要求相關聯的相關資訊的物件。 您必須覆寫這個方法。 如果<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>會傳回`null`、<xref:System.InvalidOperationException>就會擲回。  
  
3.  <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A>方法來傳回安全性權杖描述元會根據 RST 和<xref:System.IdentityModel.Scope>上一個步驟傳回的物件。 安全性權杖描述元 (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) 包含可由權杖處理常式的表單中要求的相關資訊。 <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType>屬性設定為呼叫所傳回的描述元。 如果`null`會傳回或如果<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A>屬性的描述元是`null`、<xref:System.InvalidOperationException>就會擲回。 如果例外狀況也擲回<xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType>屬性是`true`但<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A>傳回描述元上的屬性是`null`。  
  
4.  <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A>方法來取得適當的權杖處理常式會根據要求的語彙基元的類型。 如果`null`會傳回<xref:System.NotImplementedException>就會擲回。  
  
5.  <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A>方法來取得權杖的簽發者名稱。 會擲回<xref:System.InvalidOperationException>名稱是否`null`或空的; 否則會將<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A>描述元上的屬性。  
  
6.  <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A>方法來取得的權杖並將設定的存留期<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A>描述元上的屬性。  
  
7.  <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A>方法來取得要包含在發行的權杖和集合中的證明權杖<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A>描述元上的屬性。  
  
8.  <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法來取得要包含在集與發行的權杖中宣告<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A>描述元上的屬性。 您必須覆寫這個方法。  
  
9. <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A>方法用來建立包含核發之權杖的回應 (RSTR)。  
  
 您可以覆寫<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法，以實作自訂權杖的發行管線，不過這通常是不必要的大部份的自訂實作的開發和測試環境中<xref:System.IdentityModel.SecurityTokenService>是類別。 在大多數的情況下您覆寫<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>並<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法，並選擇性地覆寫<xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法，以提供可自行維修的 STS，為您的環境。 如果自訂需要進一步通常可以將它覆寫方法實作上面所列的權杖發行管線的預設值的每個階段中提供。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與目前執行個體相關聯的主體。</summary>
        <value>表示目前主體的 <see cref="T:System.Security.Claims.ClaimsPrincipal" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <summary>在衍生類別中覆寫時，處理 WS-Trust 更新要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與目前執行個體相關聯的安全性權杖要求 (RST)。</summary>
        <value>包含要求的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與目前執行個體相關聯的範圍。</summary>
        <value>表示權杖發佈要求組態的 <see cref="T:System.IdentityModel.Scope" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與目前執行個體相關聯的 <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" />。</summary>
        <value>與目前執行個體相關聯的安全性權杖描述元。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">嘗試將屬性設為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得擁有者組態執行個體。</summary>
        <value>
          <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />，包含目前執行個體的組態。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示權杖要求者的身分識別。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全性權杖要求。 這包括要求訊息，以及其他用戶端的相關資訊，例如授權內容。</param>
        <summary>在衍生類別中覆寫時，處理 WS-Trust 驗證要求。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />，表示要傳回至呼叫端的 RSTR。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的預設實作會擲回<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">表示要求的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />。</param>
        <summary>驗證此執行個體封裝的安全性權杖要求 (RST)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法呼叫從權杖發行管線 (<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法) 來驗證傳入的 RST。 RST 為驗證依據之 sts 的需求 （原則），如果無效，會擲回適當的例外狀況。  
  
 預設實作<xref:System.IdentityModel.SecurityTokenService>類別支援 RST RSTR 模式和僅問題的繫結的 Ws-trust 規格 (<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A>要求的屬性必須設定為<xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>)。 這個方法的預設實作會強制執行這些需求 （和其他例外狀況的一節所述）。 如果您必須強制執行不同的驗證需求，自訂 sts，您可以覆寫這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> 為 <see langword="null" />。  
  
-或- 
要求的 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> 屬性不是設為 <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />。  
  
-或- 
此要求的<see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" />屬性不是<see langword="null" />或<see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" />類別中所定義的其中一個常數。  
  
-或- 
此要求的 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> 是 <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" />，且 <see langword="KeySize" /> 項目存在，但它的值不等於零。</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">STS 不支援要求的權杖型別 (依據要求的<see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" />屬性的值)。</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>