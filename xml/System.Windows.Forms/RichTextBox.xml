<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6bc4582e825296fa306e1a8f5b9ad0a64930707" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36516160" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示 Windows Rich Text Box 控制項。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 與<xref:System.Windows.Forms.RichTextBox>控制項，使用者可以輸入和編輯文字。 控制項也提供更進階的格式化功能，比標準<xref:System.Windows.Forms.TextBox>控制項。 文字可以直接指派給控制項，或可以載入從 rtf 格式 (RTF) 或純文字檔。 字元和段落格式，可以指派內控制項的文字。  
  
 <xref:System.Windows.Forms.RichTextBox>控制項提供許多可用來將格式套用到控制項中文字的任何部分的屬性。 若要變更的文字格式，您必須先選擇。 字元和段落格式，可以指派只有選取的文字。 一旦設定對選取的文字區段，會選取所有文字輸入之後變更設定之前，使用相同的設定也格式化選取項目或控制項的文件的其他部分。 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>屬性可讓您將粗體或斜體的文字。 您也可以使用這個屬性來變更文字的字體和大小。 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>屬性可讓您變更文字的色彩。 若要建立您可以使用的項目符號清單<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>屬性。 您也可以調整設定格式化的段落<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>， <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>屬性。  
  
 <xref:System.Windows.Forms.RichTextBox>控制項提供開啟和儲存檔案提供功能的方法。 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法可讓您將現有的 RTF 或 ASCII 文字檔案載入控制項。 您也可以從已開啟的資料流載入資料。 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A>可讓您將檔案儲存至 RTF 或 ASCII 文字。 類似於<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，您也可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法，將儲存到開啟的資料流。 <xref:System.Windows.Forms.RichTextBox>控制項也提供功能來尋找文字字串。 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法是多載來尋找文字的這兩個字串內控制項的文字以及為特定的字元。  
  
 您也可以初始化<xref:System.Windows.Forms.RichTextBox>儲存在記憶體中資料的控制項。 例如，您可以初始化<xref:System.Windows.Forms.RichTextBox.Rtf%2A>屬性設為包含文字顯示，包括 RTF 碼，以決定應如何格式化文字的字串。  
  
 如果控制項內的文字包含連結，例如連結至網站，您可以使用<xref:System.Windows.Forms.RichTextBox.DetectUrls%2A>可適當地將連結顯示在控制項中的文字中的屬性。 然後您可以處理<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件以執行與連結相關聯的工作。 <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A>屬性可讓您防止使用者操作的控制項內的文字。 與受保護的文字在控制項中，您可以處理<xref:System.Windows.Forms.RichTextBox.Protected>事件，以判斷當使用者嘗試修改受保護的文字，並請警告使用者，受保護的文字，或是使用者提供的標準方式來管理受保護的文字。  
  
 已使用的應用程式<xref:System.Windows.Forms.TextBox>控制項可以輕鬆地調整以讓使用<xref:System.Windows.Forms.RichTextBox>控制項。 不過，<xref:System.Windows.Forms.RichTextBox>控制項沒有相同的 64k 字元容量限制<xref:System.Windows.Forms.TextBox>控制項。 <xref:System.Windows.Forms.RichTextBox>通常用來提供操作文字，並顯示類似於文書處理應用程式，例如 Microsoft Word 的功能。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType>方法不適用於<xref:System.Windows.Forms.Control.KeyPress>或<xref:System.Windows.Forms.Control.TextChanged>事件。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Windows.Forms.RichTextBox>控制項，可將 RTF 檔載入控制項，然後搜尋第一個執行個體的 word 「 文字 」。 然後，程式碼變更字型樣式、 字型大小和所選取文字的字型色彩，並將變更儲存回原始的檔案。 加入控制項的範例程式碼完成其<xref:System.Windows.Forms.Form>。 這個範例需要在此範例程式碼中建立方法會加入至<xref:System.Windows.Forms.Form>類別，並從表單的建構函式呼叫。 這個範例也需要將 RTF 檔建立的根目錄中的 C 磁碟機，包含單字 「 文字 」。  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.RichTextBox" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，<xref:System.Windows.Forms.TextBoxBase.Multiline%2A>控制項的屬性設定為`true`。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Windows.Forms.RichTextBox>控制項，可將 RTF 檔載入控制項，然後搜尋第一個執行個體的 word 「 文字 」。 然後，程式碼變更字型樣式、 字型大小和所選取文字的字型色彩，並將變更儲存回原始的檔案。 加入控制項的範例程式碼完成其<xref:System.Windows.Forms.Form>。 這個範例需要在此範例程式碼中建立方法會加入至<xref:System.Windows.Forms.Form>類別，並從表單的建構函式呼叫。 這個範例也需要將 RTF 檔建立的根目錄中的 C 磁碟機，包含單字 「 文字 」。  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出控制項是否啟用拖放作業。</summary>
        <value>如果控制項內已啟用拖放，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何執行拖放作業使用<xref:System.Windows.Forms.ListBox>控制項，其中包含項目並放入<xref:System.Windows.Forms.RichTextBox>控制項。 將表單的建構函式<xref:System.Windows.Forms.RichTextBox.AllowDrop%2A>屬性`true`若要啟用拖放作業在發生<xref:System.Windows.Forms.RichTextBox>。 此範例會使用<xref:System.Windows.Forms.Control.MouseDown>事件<xref:System.Windows.Forms.ListBox>開始拖曳作業藉由呼叫<xref:System.Windows.Forms.Control.DoDragDrop%2A>方法。 此範例會使用<xref:System.Windows.Forms.Control.DragEnter>事件，以判斷項目拖曳至<xref:System.Windows.Forms.RichTextBox>是有效的資料類型。 <xref:System.Windows.Forms.Control.DragDrop>事件執行的拖曳的項目到實際的卸除<xref:System.Windows.Forms.RichTextBox>控制項內的目前游標位置<xref:System.Windows.Forms.RichTextBox>。 這個範例需要<xref:System.Windows.Forms.Control.DragDrop>和<xref:System.Windows.Forms.Control.DragEnter>事件已連接至範例中定義的事件處理常式。  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個屬性與這個類別無關。</summary>
        <value>如果已啟用，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   這個屬性與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否啟用自動文字選取。</summary>
        <value>如果啟用自動文字選取，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為`true`，選取任何部分文字控制項中選取整個字詞。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立<xref:System.Windows.Forms.RichTextBox>放大文字，會自動選取文字中控制項的文字時文字行首，且控制項的用戶端區域右邊界。 如果<xref:System.Windows.Forms.RichTextBox>控制項具有較小的寬度，使用下列程式碼會建立<xref:System.Windows.Forms.RichTextBox>所在的那一行顯示每個文字字元。 在 此垂直顯示的位置，文字的任何部分按一下將選取的文字會以垂直方式顯示的事實不論 word 的所有字元。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個屬性與這個類別無關。</summary>
        <value>在控制項中顯示的背景影像。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> 屬性的值變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個屬性與這個類別無關。</summary>
        <value>控制項中顯示之背景影像的配置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> 屬性的值變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當項目符號樣式套用於文字時，取得或設定用於 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項中的縮排。</summary>
        <value>插入項目符號後面做為縮排的像素數目。 預設值是零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將項目符號樣式套用至一段文字，設定<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>屬性`true`，然後設定<xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>文字應該會縮排的像素數目的屬性。 在一段必須套用至它與指定的項目符號之後的縮排數量的項目符號樣式。 這個屬性只會影響目前的段落內控制項的文字和項目符號項目清單中目前選取的項目符號。 若要將不同的縮排層級套用至整個清單的項目符號項目，必須選取項目符號的所有文字內容，才能設定<xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>屬性<xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>， <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>， <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>屬性，以建立分項清單中的<xref:System.Windows.Forms.RichTextBox>控制項。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`表單上建立。  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的縮排小於零。</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">其中一個 <see cref="T:System.Windows.Forms.DataFormats.Format" /> 值。</param>
        <summary>判斷是否可以將資訊從剪貼簿貼入指定的資料格式中。</summary>
        <returns>如果可以將資訊從剪貼簿貼入指定的資料格式中，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法來判斷目前剪貼簿的內容是否以指定的剪貼簿資料格式中，啟用使用者貼上到的資訊之前<xref:System.Windows.Forms.RichTextBox>控制項。 例如，您可以建立事件處理常式<xref:System.Windows.Forms.MenuItem.Popup>貼上命令的事件<xref:System.Windows.Forms.MenuItem>並使用這個方法來判斷是否貼上<xref:System.Windows.Forms.MenuItem>應該根據剪貼簿中的資料類型啟用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法，以貼上至點陣圖<xref:System.Windows.Forms.RichTextBox>控制項。 在開啟之後點陣圖檔案，此範例會使用<xref:System.Windows.Forms.Clipboard.SetDataObject%2A>的點陣圖複製到 Windows 剪貼簿的方法。 最後，此範例將擷取的格式<xref:System.Drawing.Bitmap>物件，使用<xref:System.Windows.Forms.RichTextBox.CanPaste%2A>方法以驗證格式，可以貼到<xref:System.Windows.Forms.RichTextBox>控制項，然後再使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>貼上資料的方法。  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否有可以再套用的動作發生於 <see cref="T:System.Windows.Forms.RichTextBox" /> 內。</summary>
        <value>如果有已復原而可以再套用於控制項內容的作業，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個屬性來判斷是否最後一項作業中復原<xref:System.Windows.Forms.RichTextBox>可以使用重新套用<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>和<xref:System.Windows.Forms.RichTextBox.RedoActionName%2A>屬性，而<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，來限制刪除的文字除外的任何動作的重做作業。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制且內某項作業<xref:System.Windows.Forms.RichTextBox>執行和復原在此範例中的程式碼會在呼叫之前。  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於控制項中的內容調整大小時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.ContentsResized>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.ContentsResized>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>建立控制代碼時，取得必要的建立參數。</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" />，包含建立控制項之控制代碼時所需的建立參數。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立 <see langword="IRichEditOleCallback" /> 可相容物件，以處理 Rich Edit 回呼 (Callback) 作業。</summary>
        <returns>實作 <see langword="IRichEditOleCallback" /> 介面的物件。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫者呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>您可以存取基礎 rich 編輯功能，以便您衍生類別中覆寫這個方法。如果您覆寫這個方法，將不會引發所有拖放事件。如此一來，您必須提供自己的支援拖放作業。如需有關<see langword="IRichEditOleCallback" />介面，請參閱 Platform SDK 文件，網址http://msdn.microsoft.com。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項的預設大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> 值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出 <see cref="T:System.Windows.Forms.RichTextBox" /> 是否會在將統一資源定位器 (URL) 輸入控制項時自動加以格式化。</summary>
        <value>如果 <see cref="T:System.Windows.Forms.RichTextBox" /> 會在將 URL 輸入控制項做為連結時加以格式化，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為`true`，取決於控制項中輸入任何文字<xref:System.Windows.Forms.RichTextBox>是 URL 會自動格式化為連結。 您可以建立事件處理常式<xref:System.Windows.Forms.RichTextBox.LinkClicked>按一下控制項中的事件，以處理所有的連結。 <xref:System.Windows.Forms.LinkClickedEventArgs>加入事件處理常式提供<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件提供可讓您判斷哪一個連結已在控制項中按下以處理連結的資料。  
  
   
  
## Examples  
 下列程式碼範例包含的事件處理常式<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件。 事件處理常式處理的文件內連結點選<xref:System.Windows.Forms.RichTextBox>控制，並啟動預設瀏覽器的執行個體 (使用<xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType>方法)，顯示已按下連結的頁面。 這個範例需要的事件處理常式已連線至<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者完成拖放時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於將物件拖曳至控制項邊框時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.DragEnter>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.DragEnter>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於將物件拖出控制項界限時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件與這個類別無關。 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於將物件拖曳至控制項邊框上方時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件與這個類別無關。 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">
          <see cref="T:System.Drawing.Bitmap" />。</param>
        <param name="targetBounds">
          <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>這個方法與這個類別無關。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，以便在文字、圖片及其他資料上進行拖放作業。</summary>
        <value>
          <see langword="true" /> 表示啟用拖放作業，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜尋 <see cref="T:System.Windows.Forms.RichTextBox" /> 內容中的文字。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">要搜尋的字元陣列。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項的文字中搜尋字元清單中字元的第一個執行個體。</summary>
        <returns>在控制項內找到搜尋字元的位置，但如果找不到搜尋字元或 <paramref name="char" /> 參數中指定空的搜尋字元集，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋第一個執行個體，從清單中所指定字元的字元`characterSet`參數並傳回字元的位置。 例如，您傳遞字元，其中包含字元 'Q' 的陣列。 如果控制項包含文字"快速 Brown Fox"，<xref:System.Windows.Forms.RichTextBox.Find%2A>方法會傳回四個值。 為大寫字母和小寫字元會視為不同的值，在搜尋。  
  
 屬性會傳回負數值，如果要搜尋的字元是內找不到控制項的內容。 您可以使用這個方法來搜尋一組控制項中的字元。 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法需要包含控制項中的整個文件會搜尋的字元。 如果從提供的方法中的字元清單的字元`characterSet`找不到參數，這個方法所傳回的值為控制項中的字元位置的以零為起始索引。 空格會被視為字元方法所決定的字元位置時。  
  
   
  
## Examples  
 下列程式碼範例會搜尋的內容<xref:System.Windows.Forms.RichTextBox>會傳遞至方法中的字元`text`參數。 如果內容`text`陣列位於<xref:System.Windows.Forms.RichTextBox>方法會傳回找到; 否則為值的索引，則傳回-1。 這個範例需要這個方法會放置在類別中的<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`和<xref:System.Windows.Forms.Button>控制項，名為`button1`，也就是連接到`Click`中定義的事件處理常式此範例中。  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要在控制項中搜尋的文字。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項中的文字搜尋字串。</summary>
        <returns>在控制項內找到搜尋文字的位置，但如果找不到搜尋字串或 <paramref name="str" /> 參數中指定空的搜尋字串，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋中指定的文字`str`參數並傳回控制項中的第一個字元的位置。 屬性會傳回負數值，如果要搜尋的文字字串找不到控制項的內容中。 您可以使用這個方法來建立，可供使用者控制項的搜尋功能。 您也可以使用這個方法來搜尋的文字取代特定的格式。 例如，如果使用者控制項中輸入日期，您可以使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜尋文件中的所有日期，並以適當的格式取代之前使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>控制項的方法。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法接受`string`參數找不到包含在多行文字方塊內文字的文字為<xref:System.Windows.Forms.RichTextBox>。 執行這類搜尋將傳回負一 (-1)。  
  
   
  
## Examples  
 下列程式碼範例會搜尋的整個內容<xref:System.Windows.Forms.RichTextBox>搜尋字串的第一個執行個體傳遞至方法的文字參數。 如果搜尋字串中找到<xref:System.Windows.Forms.RichTextBox>，方法會傳回值為`true`並反白顯示搜尋文字，否則它會傳回`false`。 這個範例需要這個方法會放置在類別中的<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">要搜尋的字元陣列。</param>
        <param name="start">控制項文字中要開始搜尋的位置。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項的文字中，從特定的起點開始，搜尋字元清單中字元的第一個執行個體。</summary>
        <returns>控制項中找到搜尋字元的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋第一個執行個體，從清單中所指定字元的字元`characterSet`參數和傳回的字元位置。 例如，您傳遞字元，其中包含字元 'Q' 的陣列。 如果控制項包含文字"快速 Brown Fox"，<xref:System.Windows.Forms.RichTextBox.Find%2A>方法會傳回四個值。 為大寫字母和小寫字元會視為不同的值，在搜尋。  
  
 屬性會傳回負數值，如果要搜尋的字元是內找不到控制項的內容。 您可以使用這個方法來搜尋一組控制項中的字元。 如果從提供的方法中的字元清單的字元`characterSet`找不到參數，這個方法所傳回的值為控制項中的字元位置的以零為起始索引。 空格會被視為字元方法所決定的字元位置時。  
  
 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法可讓您搜尋所指定的值從控制項文字內指定的開始位置設定字元`start`參數。 零表示搜尋應該從控制項的文件的開頭開始。 您可以使用這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，以縮小搜尋範圍，以避免您已了解的文字不包含您要搜尋或並不重要，在搜尋中指定的字元。  
  
   
  
## Examples  
 下列程式碼範例會搜尋的內容<xref:System.Windows.Forms.RichTextBox>會傳遞至方法中的字元`text`參數。 從內的位置開始搜尋<xref:System.Windows.Forms.RichTextBox>所指定`start`參數`FindMyText`方法。 如果文字為陣列的內容會位於<xref:System.Windows.Forms.RichTextBox>方法會傳回找到; 否則為值的索引，則傳回-1。 這個範例需要這個方法會放置在類別中的<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`和<xref:System.Windows.Forms.Button>控制項，名為`button1`已連接<xref:System.Windows.Forms.Control.Click>中定義的事件處理常式範例。  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">要在控制項中搜尋的文字。</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 值的位元組合。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項的文字中，以特定選項進行搜尋字串。</summary>
        <returns>控制項中找到搜尋文字的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋中指定的文字`str`參數並傳回控制項中的第一個字元的位置。 屬性會傳回負數值，如果要搜尋的文字字串找不到控制項的內容中。 您可以使用這個方法來建立，可供使用者控制項的搜尋功能。 您也可以使用這個方法來搜尋的文字取代特定的格式。 例如，如果使用者控制項中輸入日期，您可以使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜尋文件中的所有日期，並以適當的格式取代之前使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>控制項的方法。  
  
 與此版本<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，您可以指定選項，可讓您展開或縮小搜尋範圍。 您可以指定可讓您以符合大小寫的搜尋文字，或整個文字，而不是部分文字搜尋選項。 藉由指定`RichTextBoxFinds.Reverse`中的列舉`options`參數，您可以搜尋文件底部到頂端，而不是預設頂端到底部搜尋方法的文字。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法接受`string`參數找不到包含在多行文字方塊內文字的文字為<xref:System.Windows.Forms.RichTextBox>。 執行這類搜尋將傳回負一 (-1)。  
  
   
  
## Examples  
 下列程式碼範例會搜尋的整個內容<xref:System.Windows.Forms.RichTextBox>搜尋字串的第一個執行個體傳遞至方法的文字參數。 如果搜尋字串中找到<xref:System.Windows.Forms.RichTextBox>，方法會傳回值為`true`並反白顯示文字; 否則它會傳回`false`。 此範例也會指定選項中搜尋符合指定的搜尋字串的大小寫。 這個範例需要這個方法會放置在類別中的<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">要搜尋的字元陣列。</param>
        <param name="start">控制項文字中要開始搜尋的位置。</param>
        <param name="end">控制項文字中要結束搜尋的位置。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項內的文字範圍中搜尋字元清單中字元的第一個執行個體。</summary>
        <returns>控制項中找到搜尋字元的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋第一個執行個體，從清單中所指定字元的字元`characterSet`參數並傳回字元的位置。 例如，您傳遞字元，其中包含字元 'Q' 的陣列。 如果控制項包含文字"快速 Brown Fox"，<xref:System.Windows.Forms.RichTextBox.Find%2A>方法會傳回四個值。 為大寫字母和小寫字元會視為不同的值，在搜尋。  
  
 屬性會傳回負數值，如果要搜尋的字元是內找不到控制項的內容。 您可以使用這個方法來搜尋一組控制項中的字元。 如果從提供的方法中的字元清單的字元`characterSet`找不到參數，這個方法所傳回的值是以零為起始的字元位置，在控制項中的索引。 空格會被視為字元方法所決定的字元位置時。  
  
 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法可讓您搜尋所指定的值從控制項中的文字範圍的設定字元`start`和`end`參數。 的值為零`start`參數表示搜尋應該從控制項的文件的開頭開始。 值為-1`end`參數表示搜尋應該在控制項中文字的結尾結束。 您可以使用這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>來縮小搜尋範圍，以特定的控制項，以避免搜尋文件不是重要的應用程式需求的區域內的文字範圍的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="characterSet" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> 小於零或大於控制項中文字的長度。</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">要在控制項中搜尋的文字。</param>
        <param name="start">控制項文字中要開始搜尋的位置。</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 值的位元組合。</param>
        <summary>在控制項內的特定位置搜尋 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項文字中的字串，並採用特定的選項進行搜尋。</summary>
        <returns>控制項中找到搜尋文字的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋中指定的文字`str`參數，並傳回控制項中的字串搜尋的第一個字元的位置。 屬性會傳回負數值，如果要搜尋的文字字串找不到控制項的內容中。 您可以使用這個方法來建立，可供使用者控制項的搜尋功能。 您也可以使用這個方法來搜尋的文字取代特定的格式。 例如，如果使用者控制項中輸入日期，您可以使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜尋文件中的所有日期，並以適當的格式取代之前使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>控制項的方法。  
  
 與此版本<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，您可以指定選項，可讓您展開或縮小搜尋範圍。 您可以指定可讓您以符合大小寫的搜尋文字，或整個文字，而不是部分文字搜尋選項。 藉由指定`RichTextBoxFinds.Reverse`中的列舉`options`參數，您可以搜尋文件底部到頂端，而不是預設頂端到底部搜尋方法的文字。 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法也可讓您選取特定的開始位置，控制項的文字內縮小搜尋的文字。 這項功能可讓您避免使用文字，可能已經被搜尋，或在其中指定您要搜尋的文字已知不存在。 當`RichTextBoxFinds.Reverse`該值會以指定`options`參數、 值`start`參數表示的位置，因為文件的底部會開始搜尋 時使用這個版本的反向搜尋將會結束的位置<xref:System.Windows.Forms.RichTextBox.Find%2A>方法。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法接受`string`參數找不到包含在多行文字方塊內文字的文字為<xref:System.Windows.Forms.RichTextBox>。 執行這類搜尋將傳回負一 (-1)。  
  
   
  
## Examples  
 下列程式碼範例會搜尋的整個內容<xref:System.Windows.Forms.RichTextBox>搜尋字串的第一個執行個體傳遞至方法的文字參數。 搜尋開始位置是由開始參數指定的方法。 如果搜尋字串中找到<xref:System.Windows.Forms.RichTextBox>，方法會傳回找到的文字的第一個字元的索引位置，並反白顯示找到的文字; 否則它會傳回-1 值。 此範例也會指定選項中搜尋符合指定的搜尋字串的大小寫。 這個範例需要這個方法會放置在類別中的<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>名為`richTextBox1`。 您可以使用此範例執行 「 尋找下一個 」 類型的作業。 一旦找到搜尋文字的執行個體，您可以變更的值來尋找文字的其他執行個體`start`搜尋位置超過目前的相符項目位置的參數。  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">要在控制項中搜尋的文字。</param>
        <param name="start">控制項文字中要開始搜尋的位置。</param>
        <param name="end">控制項文字中要結束搜尋的位置。 這個值等於 -1，或者大於或等於 <c>start</c> 參數。</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 值的位元組合。</param>
        <summary>在控制項內的文字範圍搜尋 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項文字中的字串，並採用特定的選項進行搜尋。</summary>
        <returns>控制項中找到搜尋文字的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法會搜尋中指定的文字`str`參數，並傳回控制項中的字串搜尋的第一個字元的位置。 屬性會傳回負數值，如果要搜尋的文字字串找不到控制項的內容中。 您可以使用這個方法來建立，可供使用者控制項的搜尋功能。 您也可以使用這個方法來搜尋的文字取代特定的格式。 例如，如果使用者控制項中輸入日期，您可以使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜尋文件中的所有日期，並以適當的格式取代之前使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>控制項的方法。  
  
 與此版本<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，您可以指定選項，可讓您展開或縮小搜尋範圍。 您可以指定可讓您以符合大小寫的搜尋文字，或整個文字，而不是部分文字搜尋選項。 藉由指定`RichTextBoxFinds.Reverse`中的列舉`options`參數，您可以搜尋文件底部到頂端，而不是預設頂端到底部搜尋方法的文字。 這個版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法也可讓您選取特定的開始和結束位置的控制項文字內縮小搜尋的文字。 這項功能可讓您限制搜尋範圍到特定的控制項的文字區段。 如果負一 (-1) 指派給`end`參數，該方法會搜尋中的文字的結尾<xref:System.Windows.Forms.RichTextBox>一般搜尋。 反向搜尋的值的負一 (-1) 指派給`end`參數會指出文字搜尋的文字 （下方） 的結尾時所定義的位置`start`參數。 當`start`和`end`參數會提供一般搜尋會搜尋整個控制項的相同值。 反向搜尋，會搜尋整個控制項，但搜尋開始於文件的底部，然後搜尋至文件的頂端。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法接受`string`參數找不到包含在多行文字方塊內文字的文字為<xref:System.Windows.Forms.RichTextBox>。 執行這類搜尋將傳回負一 (-1)。  
  
   
  
## Examples  
 下列程式碼範例會搜尋中的文字區段<xref:System.Windows.Forms.RichTextBox>的搜尋字串的第一個執行個體傳遞至`searchText`方法的參數。 要搜尋的文字在控制項中的所指定的範圍`searchStart`和`searchEnd`方法的參數。 如果搜尋字串中找到<xref:System.Windows.Forms.RichTextBox>，方法會傳回找到的文字的第一個字元的索引位置，並反白顯示找到的文字; 否則它會傳回-1 值。 此範例也會使用`options`參數<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，以指定找到的文字應該符合搜尋字串的大小寫。 這個範例需要這個方法會放置在類別中的<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。 第一個之後的搜尋字串執行個體已發現，您可以使用此範例中，尋找文字中的其他執行個體。  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="end" /> 參數小於 <paramref name="start" /> 參數。</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項顯示之文字字型。</summary>
        <value>要套用至控制項顯示之文字的 <see cref="T:System.Drawing.Font" />。 預設值為 <see cref="P:System.Windows.Forms.Control.DefaultFont" /> 屬性的值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項的前景色彩。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，表示控制項的前景色彩。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">要搜尋的位置。</param>
        <summary>擷取最接近指定位置之字元的索引。</summary>
        <returns>指定位置處的以零為起始的字元索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回最接近指定位置的字元索引`pt`參數。 字元索引為起始的索引中的控制項，包括空格的文字。 您可以使用這個方法，以判斷其中文字中的使用者將滑鼠移過將滑鼠座標傳遞至這個方法。 這可以是如果您想要執行的工作，使用者將滑鼠指標置於控制項的文字中的字時很有用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A>方法<xref:System.Windows.Forms.RichTextBox.Find%2A>方法來搜尋特定的字串內<xref:System.Windows.Forms.RichTextBox>控制，並顯示找到的字串所在位置內的字元索引<xref:System.Windows.Forms.RichTextBox>控制項。 範例搜尋控制項的內容中的"brown"這個字，並傳回位於搜尋字串的字元索引位置。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，其中包含文字。 它也需要確認此範例中的程式碼已連線至<xref:System.Windows.Forms.Control.MouseDown>事件<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要搜尋的字元索引位置。</param>
        <summary>從 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項文字內的指定字元位置擷取行號。</summary>
        <returns>字元索引所在處的以零為起始的行號。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓您判斷在指定的字元索引為基礎的行號`index`方法的參數。 控制項中文字的第一行會傳回值為零。 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>方法傳回的實體的行號索引的字元所在控制項中。 例如，如果第一個邏輯程式敘述行中的文字部分控制項換行至下一行，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>方法會傳回 1，如果第二個實體的行換行字元的指定的索引處的字元。 如果<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>設`false`、 行的任何部分換行至下一步，而且方法會傳回 0，表示指定的字元索引。 您可以使用這個方法來判斷哪一行特定的字元索引位於內。 例如，在呼叫之後<xref:System.Windows.Forms.RichTextBox.Find%2A>方法來搜尋的文字，您可以取得找到的搜尋結果的字元索引。 您可以呼叫這個方法所傳回的字元索引與<xref:System.Windows.Forms.RichTextBox.Find%2A>找不到方法，以判斷這行文字。  
  
 在某些情況下，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>沒有擲回例外狀況時`index`參數是無效的值。 例如:   
  
-   如果`index`參數是<xref:System.Int32.MinValue>則為-1，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>傳回 0。  
  
-   如果`index`參數是文字長度或<xref:System.Int32.MaxValue>，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>傳回的最後一行文字，不一定是相同的數目為`Lines.Length-1`上的值，取決於<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>屬性。  
  
 在這些情況下，驗證的輸入，然後再呼叫<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>。  
  
> [!NOTE]
>  如果在指定的字元索引`index`參數超出可用的控制項中包含的行數，會傳回最後一個行號。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>方法。 若要執行範例時，將下列程式碼貼中表單，其中包含<xref:System.Windows.Forms.RichTextBox>控制項，名為`RichTextBox1`，名為按鈕`Button1`和名為兩個文字方塊`TextBox1`和`TextBox2`。 當執行範例時，輸入搜尋字串中的`TextBox2`按一下按鈕，以取得搜尋結果。  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要擷取位置的字元索引。</param>
        <summary>擷取控制項內指定之字元索引的位置。</summary>
        <returns>指定字元的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓您判斷在控制項中特定的字元索引所在位置。 您可以使用這個方法針對在控制項中顯示快顯功能表項目或說明資訊 word 等工作。 例如，如果您想要向使用者顯示選項功能表，當使用者以滑鼠右鍵按一下控制項中文字時，可以使用此方法判斷才能正確顯示文字的位置<xref:System.Windows.Forms.ContextMenu>控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於拖曳作業時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者按一下控制項的水平捲軸時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.HScroll>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.HScroll>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者在亞洲版 Windows 作業系統上切換輸入法時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.ImeChange>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.ImeChange>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示輸入法 (IME) 和亞洲語言支援的 <see cref="T:System.Windows.Forms.RichTextBox" /> 設定。</summary>
        <value>其中一個 <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" /> 值。 預設值為 <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者按一下控制項文字內的連結時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以建立處理連結已經在控制項中按下此事件的事件處理常式。 使用事件處理常式所提供的資訊，您可以判斷哪一個連結已按下文件中。  
  
> [!IMPORTANT]
>  根據預設，連結會顯示為文字而不可點選。 若要使其可點按組<xref:System.Windows.Forms.RichTextBox.DetectUrls%2A>屬性`true`。  
  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例包含的事件處理常式<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件。 事件處理常式處理的文件內連結點選<xref:System.Windows.Forms.RichTextBox>控制，並啟動預設瀏覽器的執行個體 (使用<xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType>方法)，顯示已按下連結的頁面。 這個範例需要的事件處理常式已連線至<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案內容載入 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要載入控制項的檔案的名稱和位置。</param>
        <summary>將 Rich Text Format (RTF) 或標準的 ASCII 文字檔載入 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 載入的檔案時<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，載入檔案的內容取代的整個內容<xref:System.Windows.Forms.RichTextBox>控制項。 這會導致值<xref:System.Windows.Forms.TextBoxBase.Text%2A>和<xref:System.Windows.Forms.RichTextBox.Rtf%2A>屬性來變更。 您可以使用這個方法將先前建立的文字或 RTF 文件載入操作的控制項。 如果您想要儲存檔案，您可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法。  
  
> [!NOTE]
>  與此版本<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，如果所載入的檔案不是 RTF 文件中，會發生例外狀況。 若要載入不同類型的檔案，例如 ASCII 文字檔案，請使用 接受的值，這個方法的其他版本<xref:System.Windows.Forms.RichTextBoxStreamType>列舉型別做為參數。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法不會開啟檔案，直到針對建立控制代碼<xref:System.Windows.Forms.RichTextBox>。 請確定已建立的控制項控點，再呼叫<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例會開啟至 RTF 檔<xref:System.Windows.Forms.RichTextBox>控制項。 此範例會使用<xref:System.Windows.Forms.OpenFileDialog>類別，以顯示對話方塊，以向使用者要求的檔案。 接著，程式碼檔案，假設是 RTF 的載入文件檔案。 如果檔案不是，範例程式碼將會擲回例外狀況。 這個範例需要的程式碼放在<xref:System.Windows.Forms.Form>類別具有<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">在將檔案載入控制項時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">所載入的檔案不是一個 RTF 格式的文件。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">開啟檔案。 列舉型別相關聯：<see langword="Read" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">要載入 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項中的資料流。</param>
        <param name="fileType">其中一個 <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值。</param>
        <summary>將現有資料流的內容載入 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以載入<xref:System.Windows.Forms.RichTextBox>資料從現有的資料流的資料。 資料載入至控制項的整個內容取代<xref:System.Windows.Forms.RichTextBox>控制項。 這會導致值<xref:System.Windows.Forms.TextBoxBase.Text%2A>和<xref:System.Windows.Forms.RichTextBox.Rtf%2A>屬性來變更。 您可以使用這個方法將已開啟的檔案載入資料流操作的控制項。 如果您想要將控制項的內容儲存回資料流，您可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法可接受<xref:System.IO.Stream>物件做為參數。  
  
 這個版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法也可讓您指定的正被載入控制項的資料類型。 這項功能可讓您使用 rtf 格式 (RTF) 的文件以外的資料包含在控制項的資料流。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法不會開啟檔案，直到針對建立控制代碼<xref:System.Windows.Forms.RichTextBox>。 請確定已建立的控制項控點，再呼叫<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>和<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>資料流的方法。 它也示範如何使用<xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>，和<xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType>成員。  
  
 這是完整的範例，準備好要執行時將它複製到您的專案。  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">在將檔案載入控制項時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">所載入的檔案不是一個 RTF 格式的文件。</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">要載入控制項的檔案的名稱和位置。</param>
        <param name="fileType">其中一個 <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值。</param>
        <summary>將特定類型的檔案載入 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 載入的檔案時<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，載入檔案的內容取代的整個內容<xref:System.Windows.Forms.RichTextBox>控制項。 這會導致值<xref:System.Windows.Forms.TextBoxBase.Text%2A>和<xref:System.Windows.Forms.RichTextBox.Rtf%2A>屬性來變更。 您可以使用這個方法將先前建立的文字或 rtf 文字格式 (RTF) 文件載入操作的控制項。 如果您想要儲存檔案，您可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法。  
  
 您可以使用這個版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，以指定所載入的檔案的檔案類型。 這項功能可讓您將 RTF 文件 以外的檔案載入控制項。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法不會開啟檔案，直到針對建立控制代碼<xref:System.Windows.Forms.RichTextBox>。 請確定已建立的控制項控點，再呼叫<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例會開啟至文字檔<xref:System.Windows.Forms.RichTextBox>控制項。 此範例會使用<xref:System.Windows.Forms.OpenFileDialog>類別，以顯示對話方塊，以向使用者要求的檔案。 程式碼，然後載入該檔案<xref:System.Windows.Forms.RichTextBox>控制項。 此範例會使用這個版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，以指定檔案以 ASCII 文字檔案，而不是標準的 rtf 文字格式開啟。 這個範例需要的程式碼放在<xref:System.Windows.Forms.Form>類別具有<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">在將檔案載入控制項時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">所載入的檔案不是一個 RTF 格式的文件。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">開啟檔案。 列舉型別相關聯：<see langword="Read" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定使用者能夠輸入或貼入 Rich Text Box 控制項中的最大字元數。</summary>
        <value>可以輸入控制項中的字元數。 預設值為 <see cref="F:System.Int32.MaxValue" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為 0 時，您可以輸入控制項中文字的最大長度為 64 KB 的字元。 這個屬性通常是使用當<xref:System.Windows.Forms.RichTextBox>用來顯示單行文字 rtf 文字格式 (RTF)。 您可以使用這個屬性，或限制的輸入資料時資料庫中輸入的文字長度來限制在控制項中輸入的值，例如郵遞區號和電話號碼、 文字的長度。 您可以限制的最大長度，在資料庫中對應欄位的輸入控制項的文字。  
  
> [!NOTE]
>  在程式碼中，您可以設定的值<xref:System.Windows.Forms.TextBoxBase.Text%2A>屬性值的長度大於所指定的值，這個值以<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>屬性。 這個屬性只會影響執行階段輸入控制項的文字。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.MaxLength%2A>屬性來判斷如果被指派文字給<xref:System.Windows.Forms.RichTextBox>控制項指派給的值大於<xref:System.Windows.Forms.RichTextBox.MaxLength%2A>屬性。 如果文字不是較大，此範例會使用<xref:System.Windows.Forms.RichTextBox.SelectedText%2A>屬性指派給控制項的文字。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已新增至表單，搭配文字貼到控制項的參數來提供此範例中的方法呼叫的。 這個範例也需要<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>限制文字項目插入屬性設定為值<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指派給屬性的值小於 0。</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出這是否為多行 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項。</summary>
        <value>如果此控制項為多行 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.HScroll" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.ImeChange" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.LinkClickedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.Protected" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.RichTextBox.VScroll" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">剪貼簿格式，其中的資料應從剪貼簿取得。</param>
        <summary>以指定的剪貼簿格式貼上剪貼簿的內容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將資料從剪貼簿貼到控制項，您可以使用這個方法。 這個版本的<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法是從不同<xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType>方法，因為它可讓您將只會將文字貼上指定的剪貼簿格式。 您可以使用<xref:System.Windows.Forms.RichTextBox.CanPaste%2A>方法，以判斷剪貼簿內的資料是否為指定的剪貼簿格式。 接著，您可以呼叫這一版的<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法，以確保使用適當的資料格式，進行貼上作業。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法，以貼上至點陣圖<xref:System.Windows.Forms.RichTextBox>控制項。 在開啟之後點陣圖檔案，此範例會使用<xref:System.Windows.Forms.Clipboard.SetDataObject%2A>的點陣圖複製到 Windows 剪貼簿的方法。 最後，此範例將擷取的格式<xref:System.Drawing.Bitmap>物件、 驗證格式，可以貼到<xref:System.Windows.Forms.RichTextBox>控制項，並使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>貼上資料的方法。  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用於讀取從剪貼簿。 列舉型別相關聯：<see langword="AllClipboard" />值<see cref="T:System.Security.Permissions.UIPermissionClipboard" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">由參考所傳遞的 <see cref="T:System.Windows.Forms.Message" />，代表要處理的視窗訊息。</param>
        <param name="keyData">其中一個 <see cref="T:System.Windows.Forms.Keys" /> 值，表示要處理的按鍵。</param>
        <summary>處理命令按鍵。</summary>
        <returns>如果字元已由控制項處理，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者嘗試修改控制項中保護的文字時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以建立此事件的事件處理常式，在您的應用程式，以判斷當使用者嘗試修改已標示為受保護控制項中的文字。 可以用事件處理常式，以通知受保護的文字使用者正嘗試修改的使用者或顯示對話方塊，讓使用者可以進行適當的變更的文字。 例如，如果受保護的區域是日期，您可以顯示對話方塊，讓使用者選擇日期，並接著可套用至控制項的文字。  
  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.Protected>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.Protected>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個事件與這個類別無關。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新套用上次在控制項中被復原的作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然後您可以使用<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，以重新套用控制項在前一個復原操作。 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A>方法可讓您判斷是否已在復原使用者最後一項作業可以重新套用到控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>和<xref:System.Windows.Forms.RichTextBox.RedoActionName%2A>屬性，而<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，來限制刪除的文字除外的任何動作的重做作業。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制且內某項作業<xref:System.Windows.Forms.RichTextBox>執行和復原在此範例中的程式碼會在呼叫之前。  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得呼叫 <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 方法時可以再套用到控制項的動作的名稱。</summary>
        <value>字串，表示呼叫 <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 方法時會被執行的動作名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性會傳回空字串 ("")，就可以再套用到控制項沒有作業。 您可以使用這個方法來判斷復原中的最後一個動作<xref:System.Windows.Forms.RichTextBox>控制項，然後被重新套用到控制項時，呼叫<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法進行。 您可以判斷是否有任何作業，重新套用至控制項使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>和<xref:System.Windows.Forms.RichTextBox.RedoActionName%2A>屬性，而<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，來限制刪除的文字除外的任何動作的重做作業。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制且內某項作業<xref:System.Windows.Forms.RichTextBox>執行和復原在此範例中的程式碼會在呼叫之前。  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個屬性與這個類別無關。</summary>
        <value>如果已啟用快速鍵，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與這個類別無關。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項內單行文字的大小。</summary>
        <value>控制項內單行文字的大小，以像素為單位。 預設值是零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大於零的值輸入控制項，看不見的邊界會從控制項左側的像素數目指定控制項中。 超過這個邊界輸入任何文字會放在控制項中文字的下一行。 這個屬性會影響目前輸入控制項，以及任何其他文字輸入控制項，此屬性設定之後的所有文字。 您可以使用這個屬性來指定所有文字方塊中輸入文字的最大線條寬度<xref:System.Windows.Forms.RichTextBox>控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立<xref:System.Windows.Forms.RichTextBox>放大文字，會自動選取文字中控制項的文字時文字行首，且控制項的用戶端區域右邊界。 如果<xref:System.Windows.Forms.RichTextBox>控制項具有較小的寬度，使用下列程式碼會建立<xref:System.Windows.Forms.RichTextBox>所在的那一行顯示每個文字字元。 在 此垂直顯示的位置，文字的任何部分按一下將選取的文字會以垂直方式顯示的事實不論 word 的所有字元。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的值小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項的文字，包括所有 Rich Text Format (RTF) 程式碼在內。</summary>
        <value>RTF 格式的控制項文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示或擷取控制項的文字與的指定 RTF 格式控制項的文字中所定義，您可以使用這個屬性，以將 RTF 格式化文字在控制項。 這個屬性通常是當您要從另一個 RTF 來源，例如 Microsoft Word 或 Windows WordPad 指派 RTF 文字控制項時。  
  
 如果您變更<xref:System.Windows.Forms.Control.RightToLeft%2A>會保留在執行階段，但不含格式只未經處理的文字屬性。  
  
 RTF 代碼，請參閱"rich text format (RTF) 規格，1.6 版"在 MSDN library 中http://msdn.microsoft.com/library。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Windows.Forms.RichTextBox" /> 的內容儲存至檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要儲存的檔案的名稱和位置。</param>
        <summary>將 <see cref="T:System.Windows.Forms.RichTextBox" /> 的內容儲存至 Rich Text Format (RTF) 檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法可讓您將控制項的整個內容儲存至可供其他程式，例如 Microsoft Word 及 Windows WordPad RTF 檔案。 如果檔案名稱傳遞給`path`參數已經存在於指定的目錄中，將會覆寫該檔案，恕不另行通知。 您可以使用<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以載入的檔案內容<xref:System.Windows.Forms.RichTextBox>。  
  
> [!NOTE]
>  若要將控制項的內容儲存至不同類型的檔案格式，例如 ASCII 文字，使用 接受的值，這個方法的其他版本<xref:System.Windows.Forms.RichTextBoxStreamType>列舉型別做為參數。  
  
   
  
## Examples  
 下列程式碼範例會將儲存的內容<xref:System.Windows.Forms.RichTextBox>RTF 檔的控制。 此範例會使用<xref:System.Windows.Forms.SaveFileDialog>類別，以顯示對話方塊，以儲存要求來自使用者、 路徑和檔案的檔案名稱。 程式碼，然後儲存假設在 rich text 格式內容的檔案。 如果檔案已經存在，則會自動覆寫。 這個範例需要的程式碼放在<xref:System.Windows.Forms.Form>類別具有<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">將控制項內容儲存至檔案時發生錯誤。</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">含有要儲存之檔案的資料流。</param>
        <param name="fileType">其中一個 <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值。</param>
        <summary>將 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項的內容儲存至開啟的資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法可讓您將控制項的整個內容儲存至已開啟的資料流。 資料流然後可以將資訊儲存至檔案。 您可以使用<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以載入的檔案內容<xref:System.Windows.Forms.RichTextBox>。  
  
 這個版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法也可讓您指定的資料格式，將會傳送到的資訊<xref:System.IO.Stream>物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>和<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>資料流的方法。 它也示範如何使用<xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>，和<xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType>成員。  
  
 這是完整的範例，準備好要執行時將它複製到您的專案。  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileType" /> 參數指定的檔案類型無效。</exception>
        <exception cref="T:System.IO.IOException">將控制項內容儲存至檔案時發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">建立或修改檔案。 列舉型別相關聯：<see langword="Write" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">要儲存的檔案的名稱和位置。</param>
        <param name="fileType">其中一個 <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值。</param>
        <summary>將 <see cref="T:System.Windows.Forms.RichTextBox" /> 的內容儲存至特定的檔案類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法可讓您將控制項的整個內容儲存至可供其他程式，例如 Microsoft Word 及 Windows WordPad RTF 檔案。 如果檔案名稱傳遞給`path`參數已經存在於指定的目錄中，將會覆寫該檔案，恕不另行通知。 您可以使用<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以載入的檔案內容<xref:System.Windows.Forms.RichTextBox>。  
  
 這個版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法可讓您指定要將控制項的內容儲存的檔案類型。 您可以使用這項功能，以確保檔案會儲存在適當的格式，依據控制項的內容。 比方說，如果您的文件不有任何差異字型樣式或著色，您可以儲存檔案為 ASCII 文字檔案設定`fileType`參數`RichTextBoxStreamType.PlainText`。  
  
   
  
## Examples  
 下列程式碼範例會將儲存的內容<xref:System.Windows.Forms.RichTextBox>成一個 ASCII 文字檔。 此範例會使用<xref:System.Windows.Forms.SaveFileDialog>類別，以顯示對話方塊，以向使用者要求的路徑和檔案名稱。 然後，程式碼會將控制項的內容儲存至該檔案。 此範例會使用這個版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法，以指定的檔案會儲存為 ASCII 文字檔案，而不是標準的 rich text 格式。 這個範例需要的程式碼放在<xref:System.Windows.Forms.Form>類別具有<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileType" /> 參數指定的檔案類型無效。</exception>
        <exception cref="T:System.IO.IOException">將控制項內容儲存至檔案時發生錯誤。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">建立或修改檔案。 列舉型別相關聯：<see langword="Write" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項中要顯示的捲軸類型。</summary>
        <value>其中一個 <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 值。 預設值為 <see langword="RichTextBoxScrollBars.Both" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您的使用者提供水平和垂直捲軸<xref:System.Windows.Forms.RichTextBox>控制項，讓控制項超出實體控制項的維度內捲動文字。 您也可以使用這個屬性，以移除限制捲動控制項的內容控制項的捲軸。  
  
> [!NOTE]
>  水平捲軸不會顯示如果<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>是`true`，不論值的<xref:System.Windows.Forms.RichTextBox.ScrollBars%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值未在 <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 列舉型別中定義。</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項中目前選取的 Rich Text Format (RTF) 格式化文字。</summary>
        <value>控制項中選取的 RTF 文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您取得所選的文字在控制項中，包括 RTF 格式化程式碼。 您可以使用這個屬性從您的控制項複製文字、 完整的格式和貼上接受 RTF 其他應用程式中的文字格式化的文字，例如 Microsoft Word 及 Windows WordPad。 若要取得選取的文字，而不 RTF 格式化程式碼，使用<xref:System.Windows.Forms.TextBoxBase.SelectedText%2A>屬性。  
  
 如果沒有目前選取文字，這個屬性中指定的文字會插入在插入點。 如果選取的文字，指派給這個屬性的任何文字取代選取的文字。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Forms.RichTextBox" /> 中選取的文字。</summary>
        <value>表示控制項中選取文字的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>屬性<xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>， <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>屬性，以建立分項清單中的<xref:System.Windows.Forms.RichTextBox>控制項。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`表單上建立。  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定套用於目前選取範圍或插入點的對齊方式。</summary>
        <value>其中一個 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有選取的段落控制項中，設定這個屬性適用於對齊設定在其中插入點還會顯示有對齊屬性設定的段落之後建立的段落。 例如，如果有兩個段落中的<xref:System.Windows.Forms.RichTextBox>控制項和插入點位於第二個段落內。 如果您設定<xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A>屬性`HorizontalAlignment.Center`，控制項中置中的插入點的段落。 如果第二個段落後建立的第三個段落時，它也會對齊控制項的中央。  
  
 如果控制項內已建立的選取範圍，當屬性設定，所有選取的段落對齊根據此屬性設定。 您可以使用這個屬性所建立的文件中的段落的對齊<xref:System.Windows.Forms.RichTextBox>。 例如，如果您想要置中的文件中的所有段落時，您可以選取控制項中的所有段落和設定<xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A>屬性`HorizontalAlignment.Center`。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 傳回`SelectionAlignment.Left`當文字選取範圍包含混合的對齊多個段落。  
  
   
  
## Examples  
 下列程式碼範例示範如何對齊文字方塊<xref:System.Windows.Forms.RichTextBox>。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已加入至表單。  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值不是 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 類別中定義的其中一個值。</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定選取 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項中的文字時，該文字的色彩。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，表示選取文字時的文字色彩。 預設值為 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 屬性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>要取得或設定中的選取文字的色彩<xref:System.Windows.Forms.RichTextBox>。 如果目前不選取任何文字，<xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>屬性會套用至目前插入號位置。 輸入從該位置的字元具有指定<xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出項目符號樣式是否套用於目前選取範圍或插入點。</summary>
        <value>如果項目符號樣式套用於目前選取範圍或插入點，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未不選取任何文字，則項目符號樣式會套用至目前的插入點和所有使用者輸入之後插入點的段落。 項目符號樣式會套用至控制項的文字插入點移為止，或當使用者按下 Enter 鍵空白的項目符號項目上。  
  
 如果控制項內選取的文字，當設定這個屬性時，所有選取的文字段落會轉換成項目符號清單中的項目符號項目。 您可以使用這個屬性來建立您在中建立的文件內的項目符號清單<xref:System.Windows.Forms.RichTextBox>控制項。  
  
 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>屬性可讓您指定要套用項目符號與項目符號項目文字的縮排數量。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>屬性<xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>， <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>屬性，以建立分項清單中的<xref:System.Windows.Forms.RichTextBox>控制項。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`表單上建立。  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於控制項中文字的選取範圍變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以建立此事件，以判斷當使用者變更控制項中的文字選取範圍的事件處理常式。 此事件的事件處理常式可以用來保留使用者已完成應用程式中的工作，才選取的文字。  
  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.SelectionChanged>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.SelectionChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項中的文字是否出現於基礎上做為上標，或者出現於基礎下方做為下標。</summary>
        <value>指定字元位移 (Offset) 的數字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值必須是介於-2000年到 2000年之間。  
  
 如果這個屬性設定為零，基準上會顯示文字。 如果是正數，數字會指定所要依據選取的文字，高於基準的像素數目。 如果是負數，此數字指定像素的數目所依據的下標的文字選取範圍。 您可以使用這個屬性來指定上標和下標的文字。  
  
 如果未不選取任何文字，則位移會套用至目前的插入點和使用者類型在插入點後的所有文字。 直到屬性變更為不同的值或插入點移至控制項中的其他部分之前，適用於字元位移。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 您可以使用這個屬性來建立此類應用程式為算術運算式上標和下標的文字。  
  
   
  
## Examples  
 下列程式碼範例示範如何指定上標和下標的文字內<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A>屬性。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已加入至表單。  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的值小於 -2000 或大於 2000。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前文字選取範圍或插入點的文字色彩。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，表示套用於目前文字選取範圍或輸入於插入點後文字的色彩。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前文字選取範圍有多個指定的色彩，則這個屬性會傳回`Color.Empty`。 如果目前不選取任何文字，這個屬性中指定的文字色彩會套用至目前的插入點，並輸入控制項的插入點之後的所有文字。 文字色彩的設定會套用直到屬性變更為不同的色彩，或插入點移至控制項中的不同區段為止。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 您可以使用這個屬性，若要變更文字色彩<xref:System.Windows.Forms.RichTextBox>。  
  
 要在控制項中粗體文字，請使用<xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>指派新字型有指定的粗體字樣式屬性。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Windows.Forms.ColorDialog>給使用者，以便指定目前文字選取範圍或目前的插入後輸入文字的色彩點<xref:System.Windows.Forms.RichTextBox>控制項。 這個範例需要在範例中定義的方法加入至<xref:System.Windows.Forms.Form>類別，其中包含<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前文字選取範圍或插入點的字型。</summary>
        <value>
          <see cref="T:System.Drawing.Font" />，表示套用於目前文字選取範圍或輸入於插入點之後的文字的字型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前文字選取範圍有多個指定的字型，這個屬性是`null`。 如果目前不選取任何文字，這個屬性中指定的字型會套用至目前的插入點，並輸入控制項的插入點之後的所有文字。 字型設定會套用直到屬性變更為不同的字型，或插入點移至控制項中的不同區段為止。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 您可以使用這個屬性，若要變更文字的字型樣式<xref:System.Windows.Forms.RichTextBox>。 您可以使文字控制項中的粗體、 斜體和底線。 您也可以變更文字及套用至文字的字型的大小。  
  
 若要變更控制項中文字的色彩，請使用<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會變更文字選取範圍或輸入之後的插入點內的文字設定的目前字型粗體樣式<xref:System.Windows.Forms.RichTextBox>控制項。 這個範例需要在方法內包含的程式碼<xref:System.Windows.Forms.Form>。 這個範例也需要<xref:System.Windows.Forms.RichTextBox>具名`richTextBox1`，已新增至<xref:System.Windows.Forms.Form>。  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定選取段落中第一行文字的左邊緣和同段落中其他各行左邊緣間的距離。</summary>
        <value>套用於目前文字選取範圍或插入點的首行縮排距離 (以像素為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前不選取任何文字，首行縮排會套用的插入點所在的段落，並輸入控制項的插入點之後的所有文字。 首行縮排設定會套用直到屬性變更為不同的值或插入點移至其他控制項內段落為止。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 您可以使用這個屬性套用至段落首行縮排。  
  
 若要設定的段落之選取範圍的第一行縮排，使用<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何指定首行縮排內<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>屬性。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已加入至表單。  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定開始選取的行縮排長度 (以像素為單位)。</summary>
        <value>套用於目前文字選取範圍或插入點後的縮排的目前距離 (以像素為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前不選取任何文字，縮排設定會套用的插入點所在的段落，並輸入控制項的插入點之後的所有文字。 縮排設定會套用直到屬性變更為不同的值或插入點移至其他控制項內段落為止。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 您可以使用這個屬性來縮排段落中的文件包含<xref:System.Windows.Forms.RichTextBox>。 您可以使用這個屬性搭配<xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>建立顯示在段落的段落。  
  
 若要建立之段落首行縮排在控制項中，使用<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何指定縮排的文字內<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>屬性。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已加入至表單。  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項中選取的字元數。</summary>
        <value>文字方塊中所選取的字元數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個屬性來判斷是否任何字元中目前所選取文字方塊控制項之前選取的文字上執行的作業。 您也可以使用這個屬性來判斷的總字元數 （包括空間） 中執行單一字元的工作時選取`for`迴圈。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.RichTextBox.SelectionLength%2A>屬性來判斷是否中選取文字<xref:System.Windows.Forms.RichTextBox>。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已加入至表單。 這個範例也需要`richTextBox1`包含控制項中選取的文字。  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出目前文字選取範圍是否受到保護。</summary>
        <value>如果目前選取範圍的內容不可變更，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前不選取任何文字，插入點所在的段落，並在插入點後輸入控制項的所有文字，會套用的保護設定。 保護設定會套用直到屬性變更為不同的值或插入點移至其他控制項內段落為止。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 若要防止使用者修改控制項中的文字區段，您可以使用這個屬性。  
  
 如果這個屬性設定為`true`、<xref:System.Windows.Forms.RichTextBox.Protected>使用者嘗試變更目前文字選取範圍時，就會引發事件。  
  
> [!NOTE]
>  這個屬性會傳回`true`只有當整個選取範圍，在控制項中的包含受保護的內容。  
  
   
  
## Examples  
 下列程式碼範例示範如何指定受保護的文字內<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A>屬性。 這個範例需要<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，已新增至表單，而且<xref:System.Windows.Forms.RichTextBox>控制項的文字新增至其中會包含單字"RichTextBox。 」  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項右邊緣和選取文字或加入目前插入點的文字右邊緣之間的距離 (以像素為單位)。</summary>
        <value>目前選取範圍或插入點右邊的縮排空間 (以像素為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前不選取任何文字，縮排設定會套用的插入點所在的段落，並輸入控制項的插入點之後的所有文字。 縮排設定會套用直到屬性變更為不同的值或插入點移至其他控制項內段落為止。  
  
 如果控制項內選取的文字，將選取的文字和任何文字後，輸入文字選取範圍將會套用這個屬性的值。 您可以使用這個屬性來縮排段落中的文件包含<xref:System.Windows.Forms.RichTextBox>。 您可以使用這個屬性搭配<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>建立顯示在段落的段落。  
  
 若要建立之段落首行縮排在控制項中，使用<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立在右邊界<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>屬性。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`，並從表單的類別內的事件的範例程式碼呼叫。  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Forms.RichTextBox" /> 控制項中的絕對定位停駐點 (Tab Stop) 位置。</summary>
        <value>陣列，其中的每個成員指定定位點位移 (以像素為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性可讓您取得陣列，其中包含目前文字選取範圍內的每個索引標籤的間距<xref:System.Windows.Forms.RichTextBox>控制項。 您接著可以使用這個屬性，來調整大小，每個索引標籤的文字選取範圍內。 例如，如果您想要調整 索引標籤內的空間文件，您可以選取整份文件，並取得的索引標籤使用的空間清單<xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A>屬性。 您可以調整它們到新的值，並將它們重新指派給這個屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此陣列中的元素超過 32 個元素的上限。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項內選取項目的類型。</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" /> 值的位元組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個屬性來判斷目前選取才能執行目前的選取範圍上的控制項內的工作時正確地處理選取項目在控制項中的資料類型。 屬性可以代表任何的組合值<xref:System.Windows.Forms.RichTextBoxSelectionTypes>列舉，代表物件目前的選取範圍中的許多類型。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出選取區邊界是否顯示於 <see cref="T:System.Windows.Forms.RichTextBox" /> 中。</summary>
        <value>如果在控制項中啟用選取區邊界，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個屬性，讓使用者輕鬆地選取中的文字行<xref:System.Windows.Forms.RichTextBox>。 選取範圍邊界會加入至左下方<xref:System.Windows.Forms.RichTextBox>。 此邊界，方便使用者選取控制項左邊開頭的文字。 使用者可以按一下來選取單行文字選取範圍邊界，或按兩下即可選取整個段落中包含某一行的。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A>屬性設定為`true`，設定<xref:System.Windows.Forms.RichTextBox.ScrollBars%2A>屬性`RichTextBoxScrollBars.Horizontal`， `RichTextBoxScrollBars.Vertical`，或`RichTextBoxScrollBars.Both`不會顯示捲軸。 若要顯示捲軸時<xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A>屬性設定為`true`，將<xref:System.Windows.Forms.RichTextBox.ScrollBars%2A>屬性`RichTextBoxScrollBars.ForcedHorizontal`， `RichTextBoxScrollBars.ForcedVertical`，或`RichTextBoxScrollBars.ForcedBoth`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Rich Text Box 中目前的文字。</summary>
        <value>顯示於控制項中的文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要顯示多行文字中<xref:System.Windows.Forms.RichTextBox>，將<xref:System.Windows.Forms.TextBoxBase.Multiline%2A>屬性`true`。 若要讀取或設定多行文字方塊的文字，請使用<xref:System.Windows.Forms.TextBoxBase.Lines%2A>屬性。 <xref:System.Windows.Forms.RichTextBox.Text%2A>屬性未傳回任何資訊的內容所套用的格式<xref:System.Windows.Forms.RichTextBox>。 若要取得 rtf 格式 (RTF) 代碼，請使用<xref:System.Windows.Forms.RichTextBox.Rtf%2A>屬性。 您可以在輸入的文字數量<xref:System.Windows.Forms.RichTextBox>控制項只會受到可用的系統記憶體。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項中文字的長度。</summary>
        <value>包含在控制項文字中的字元數目。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得呼叫 <see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> 方法時可以在控制項中復原的動作名稱。</summary>
        <value>可以復原的動作的文字名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您決定了可以復原在控制項中的最後一個動作。 您可以使用這個屬性來限制控制使用者能夠復原作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者按一下控制項的垂直捲軸時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.RichTextBox.VScroll>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.RichTextBox>名為`RichTextBox1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.RichTextBox.VScroll>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Windows 訊息物件。</param>
        <summary>處理 Windows 訊息。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Forms.RichTextBox" /> 的目前縮放層級。</summary>
        <value>縮放控制項內容的因數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值可以介於 1/64 (0.015625) 和 64.0 之間，不含。 值為 1.0 表示不縮放，會套用至控制項。 當文件包含 TrueType 字型縮放功能會以最佳方式執行。 不是 TrueType 字型使用的控制項，在文件中時<xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A>屬性將會使用最接近的整數值。 您可以使用這個屬性，讓使用者的<xref:System.Windows.Forms.RichTextBox>控制項來縮放文件太小，若要檢視或加寬的檢視，以啟用多個要在螢幕上檢視的文件的章節。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立<xref:System.Windows.Forms.RichTextBox>放大文字，會自動選取文字中控制項的文字時文字行首，且控制項的用戶端區域右邊界。 如果<xref:System.Windows.Forms.RichTextBox>控制項具有較小的寬度，使用下列程式碼會建立<xref:System.Windows.Forms.RichTextBox>所在的那一行顯示每個文字字元。 在 此垂直顯示的位置，文字的任何部分按一下將選取的文字會以垂直方式顯示的事實不論 word 的所有字元。 這個範例需要您有包含表單的<xref:System.Windows.Forms.RichTextBox>控制項，名為`richTextBox1`。  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的縮放因數並不在允許的範圍內。</exception>
      </Docs>
    </Member>
  </Members>
</Type>