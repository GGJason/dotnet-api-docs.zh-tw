<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24faab7220b703ca01fba4fff8dce9e4e7d58f2a" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037949" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 <see langword="static" /> 方法和屬性以管理應用程式，例如使用方法啟動或停止應用程式、處理 Windows 訊息，以及使用屬性取得有關應用程式的資訊。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>類別具有啟動和停止應用程式和執行緒，以及處理 Windows 訊息，如下所示的方法：  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 目前的執行緒上啟動應用程式訊息迴圈，並選擇性地讓表單成為可見。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> 或<xref:System.Windows.Forms.Application.ExitThread%2A>停止訊息迴圈。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> 您的程式時在迴圈中處理訊息。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> 將訊息篩選條件加入至應用程式訊息幫浦來監視 Windows 訊息。  
  
-   <xref:System.Windows.Forms.IMessageFilter> 可讓您停止引發事件或執行特殊作業之前叫用事件處理常式。  
  
 這個類別具有<xref:System.Windows.Forms.Application.CurrentCulture%2A>和<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>屬性來取得或設定文化特性的目前執行緒的資訊。  
  
 您無法建立此類別的執行個體。  
  
   
  
## Examples  
 下列程式碼範例會列出在表單上的清單方塊中的數字。 每次您按一下`button1`，應用程式會將另一個數字加入至清單。  
  
 `Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，會建立表單，`listBox1`和`button1`。 當使用者按一下`button1`、`button1_Click`方法顯示<xref:System.Windows.Forms.MessageBox>。 如果使用者按一下`No`上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法會將數字加入至清單。 如果使用者按一下`Yes`，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>處理所有剩餘的訊息佇列中，然後結束。  
  
> [!NOTE]
>  若要呼叫<xref:System.Windows.Forms.Application.Exit%2A>在部分信任中將會失敗。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">您想要安裝的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 介面實作。</param>
        <summary>加入訊息篩選器，以在 Windows 訊息被傳送到它們的目的地時加以監視。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免引發特定事件或執行特殊作業之前它會傳遞至事件處理常式的事件，請使用訊息篩選條件。 訊息篩選條件均是獨一無二特定執行緒。  
  
 若要防止訊息分派，`value`傳遞給這個方法的參數執行個體必須覆寫<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>方法的程式碼，以處理訊息。 此方法必須傳回 `false`。  
  
> [!CAUTION]
>  將訊息篩選條件加入至應用程式的訊息幫浦，可能會降低效能。  
  
   
  
## Examples  
 下列程式碼範例會建立訊息篩選條件呼叫`TestMessageFilter`。 此篩選條件區塊與滑鼠左的按鈕相關的所有訊息。 您可以使用訊息篩選條件之前，您必須提供實作<xref:System.Windows.Forms.IMessageFilter>介面。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫者呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示呼叫端是否可以終止這個應用程式。</summary>
        <value>
          如果呼叫端可以終止這個應用程式，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`false`如果它從呼叫<xref:System.Windows.Forms.Control>裝載 Web 瀏覽器中。 因此，<xref:System.Windows.Forms.Control>無法結束<xref:System.Windows.Forms.Application>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在應用程式即將關閉時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須將附加事件處理常式，<xref:System.Windows.Forms.Application.Exit%2A>事件以執行未處理，應用程式停止執行之前的必要工作。 您可以關閉此應用程式或處置的物件記憶體回收沒有收回所開啟的檔案。  
  
 因為這是靜態事件，您必須中斷連結附加至這個事件中任何事件處理常式<xref:System.Windows.Forms.Application.ApplicationExit>本身的事件處理常式。 如果您不是這些處理常式的中斷連結，它們會維持附加至事件，並繼續消耗記憶體。  
  
   
  
## Examples  
 下列程式碼範例會顯示兩種形式，並結束應用程式，這兩個表單關閉時。 當應用程式啟動，並結束時，會記住每個表單的位置。 這個範例示範如何使用<xref:System.Windows.Forms.Application.ApplicationExit>事件，以瞭解當表單位置應該保存至檔案，以及當`FileStream`應該關閉。  
  
 類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>並追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。 類別在它關閉時，會記住每個表單的位置。 當<xref:System.Windows.Forms.Application.ApplicationExit>事件發生時，類別會寫入檔案中的每個使用者的位置。 表單位置的資料儲存在檔案標題為`appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。  
  
 此程式碼是摘錄自中顯示的範例<xref:System.Windows.Forms.ApplicationContext>類別概觀。 請參閱<xref:System.Windows.Forms.ApplicationContext>整個程式碼清單。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得所有使用者之間共用之應用程式資料的路徑。</summary>
        <value>所有使用者之間共用之應用程式資料的路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路徑不存在，會以下列格式建立一個：  
  
 *基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 第一個查詢，包含主要可執行檔的組件是否具有`AssemblyInformationalVersion`在其上的屬性。 如果這個屬性存在，它同時用於<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果這個屬性不存在，這兩個屬性改為使用可執行檔的版本。  
  
 路徑會根據在 Windows Forms 應用程式是否部署使用不同[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 應用程式會儲存在 C:\Documents and Settings 中的每個使用者應用程式快取\\*username*目錄。 如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得所有使用者之間共用之應用程式資料的登錄機碼。</summary>
        <value>
          <see cref="T:Microsoft.Win32.RegistryKey" />，代表所有使用者之間共用之應用程式資料的登錄機碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果索引鍵不存在，就會建立以下列格式：  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與應用程式關聯的公司名稱。</summary>
        <value>公司名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前執行緒的文化特性資訊。</summary>
        <value>
          <see cref="T:System.Globalization.CultureInfo" />，代表目前執行緒的文化特性資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要設定此屬性的所有視窗。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前執行緒的目前輸入語言。</summary>
        <value>
          <see cref="T:System.Windows.Forms.InputLanguage" />，代表目前執行緒的目前輸入語言。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫者呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>處理目前在訊息佇列中的所有 Windows 訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您執行 Windows Form 時，它會建立新的表單中，然後等候處理的事件。 表單處理事件時，每次它處理與該事件相關聯的所有程式碼。 在佇列中等候所有其他事件。 當您的程式碼處理事件時，您的應用程式沒有回應。 例如，視窗不會重新繪製如果拖曳至另一個視窗頂端。  
  
 如果您呼叫<xref:System.Windows.Forms.Application.DoEvents%2A>程式碼，在您的應用程式可以處理其他事件。 例如，如果您有將資料加入至表單<xref:System.Windows.Forms.ListBox>並加入<xref:System.Windows.Forms.Application.DoEvents%2A>至程式碼，您的表單會重新繪製其拖曳至另一個視窗時。 如果您移除<xref:System.Windows.Forms.Application.DoEvents%2A>從程式碼中，您的表單將不重新繪製按鈕的 click 事件處理常式完成之前執行。 如需有關訊息的詳細資訊，請參閱[Windows Form 中的使用者輸入](~/docs/framework/winforms/user-input-in-windows-forms.md)。  
  
 與不同的是 Visual Basic 6.0<xref:System.Windows.Forms.Application.DoEvents%2A>方法不會呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。  
  
 一般而言，您可以使用這個方法來處理訊息迴圈中。  
  
> [!CAUTION]
>  呼叫這個方法會導致所有等候的視窗訊息都處理時，暫止目前的執行緒。 如果訊息導致觸發事件，可能會執行的應用程式程式碼其他區域。 這會造成您的應用程式發生非預期的行為很難進行偵錯。 如果您執行作業或需要長時間的計算，通常最好是執行新的執行緒上的那些作業。 如需有關非同步程式設計的詳細資訊，請參閱[非同步程式設計模型 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Application.DoEvents%2A>方法。 此範例執行時，使用者可以選取從圖形檔<xref:System.Windows.Forms.OpenFileDialog>。 選取的檔案會顯示在表單中。 <xref:System.Windows.Forms.Application.DoEvents%2A>方法會強制重新繪製的每個圖形開啟的檔案格式。 若要執行此範例中，貼上下列程式碼中表單，其中包含<xref:System.Windows.Forms.PictureBox>名為`PictureBox1`、<xref:System.Windows.Forms.OpenFileDialog>名為`OpenFileDialog1`，和名為按鈕`fileButton`。 呼叫`InitializePictureBox`和`InitializeOpenFileDialog`從表單的建構函式的方法或`Load`方法。  
  
> [!NOTE]
>  在 Visual Studio 中，如果您將加入<xref:System.Windows.Forms.OpenFileDialog>至您使用拖放作業的表單，您就必須修改下列`InitializeOpenFileDialog`方法藉由移除建立的新執行個體的行<xref:System.Windows.Forms.OpenFileDialog>。  
  
 這個範例也需要<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>事件<xref:System.Windows.Forms.Button>控制項和<xref:System.Windows.Forms.FileDialog.FileOk>事件<xref:System.Windows.Forms.OpenFileDialog>連線到範例中定義的事件處理常式。 執行範例時，請按一下按鈕顯示對話方塊。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為應用程式啟用視覺化樣式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓應用程式的視覺化樣式。 視覺化樣式，則色彩、 字型和其他視覺化項目形成作業系統佈景主題。 如果控制項與作業系統支援，會使用視覺化樣式繪製控制項。 產生的效果，<xref:System.Windows.Forms.Application.EnableVisualStyles>必須先呼叫才能建立應用程式; 中的任何控制項通常<xref:System.Windows.Forms.Application.EnableVisualStyles>中的第一行`Main`函式。 不需要個別的資訊清單呼叫時，啟用視覺化樣式<xref:System.Windows.Forms.Application.EnableVisualStyles>。  
  
> [!NOTE]
>  在.NET Framework 2.0 中前,`FlatStyle`部分控制項，例如衍生自控制項的屬性<xref:System.Windows.Forms.ButtonBase>，必須設定為<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>若要使用視覺化樣式繪製控制項的順序。 在以.NET Framework 2.0 撰寫的應用程式，這是不再需要。  
  
> [!NOTE]
>  這個方法不會影響的控制項裝載於 Internet Explorer。  
  
   
  
## Examples  
 下列程式碼範例示範呼叫<xref:System.Windows.Forms.Application.EnableVisualStyles%2A>中`Main`函式來啟用應用程式的視覺化樣式。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在應用程式即將進入強制回應狀態時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.EnterThreadModal>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到 Windows Form 並確認事件處理常式關聯<xref:System.Windows.Forms.Application.EnterThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />接聽事件的權限。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得啟動應用程式的可執行檔路徑，包括檔名。</summary>
        <value>啟動應用程式的可執行檔路徑和檔名。  
  
 這個路徑會依據是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 來部署 Windows Forms 應用程式而有所不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 應用程式會儲存在 C:\Documents and Settings 中的每個使用者應用程式快取\\*username*目錄。 如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">取得路徑。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A>方法會停止所有執行緒上的所有執行訊息迴圈，並關閉應用程式的所有視窗。 這個方法不一定會強制結束應用程式。 <xref:System.Windows.Forms.Application.Exit%2A>方法通常從呼叫內的訊息迴圈，並強制<xref:System.Windows.Forms.Application.Run%2A>傳回。 若要結束目前執行緒的訊息迴圈，請呼叫<xref:System.Windows.Forms.Application.ExitThread%2A>。  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 會引發下列事件，並執行相關聯的條件動作：  
  
-   A<xref:System.Windows.Forms.Form.FormClosing>引發由每個表單<xref:System.Windows.Forms.Application.OpenForms%2A>屬性。 這個事件可以藉由設定取消<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性其<xref:System.Windows.Forms.FormClosingEventArgs>參數`true`。  
  
-   如果一或多個處理常式會取消事件，然後<xref:System.Windows.Forms.Application.Exit%2A>傳回不需要進一步動作。 否則，<xref:System.Windows.Forms.Form.FormClosed>就會引發事件，每個開啟的表單，則會關閉所有正在執行訊息迴圈和表單。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A>方法不會引發<xref:System.Windows.Forms.Form.Closed>和<xref:System.Windows.Forms.Form.Closing>事件，也就是過時的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。  
  
   
  
## Examples  
 下列程式碼範例會列出在表單上的清單方塊中的數字。 每次您按一下`button1`，應用程式會將另一個數字加入至清單。  
  
 `Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，會建立表單， `listBox1`，和`button1`。 當使用者按一下`button1`、`button1_Click`方法將數字一到三個清單方塊中，並顯示<xref:System.Windows.Forms.MessageBox>。 如果使用者按一下**否**上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法會將另一個數字加入至清單。 如果使用者按一下**是**，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>，來處理所有剩餘的訊息佇列中，然後結束。  
  
 這個範例需要`listBox1`和`button1`具現化並放置在表單上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫者呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">傳回在應用程式內是否有任何 <see cref="T:System.Windows.Forms.Form" /> 取消結束。</param>
        <summary>通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">結束正在執行的權限的應用程式執行緒。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束目前執行緒的訊息迴圈，並關閉執行緒上的所有視窗。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法來結束目前執行緒的訊息迴圈。 這個方法會導致呼叫<xref:System.Windows.Forms.Application.Run%2A>傳回目前的執行緒。 若要結束整個應用程式，請呼叫<xref:System.Windows.Forms.Application.Exit%2A>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫者呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">要篩選的 Windows 事件訊息。</param>
        <summary>針對視窗訊息執行任何篩選條件，並傳回已修改訊息的複本。</summary>
        <returns>
          如果已處理篩選，則為 <see langword="True" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在應用程式處理完畢並即將進入閒置 (Idle) 狀態時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您有必須執行的工作在執行緒閒置之前，將它們附加至這個事件。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.Idle>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到 Windows Form，並確定事件處理常式都與<xref:System.Windows.Forms.Application.Idle>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在應用程式即將離開強制回應狀態時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到 Windows Form 並確認事件處理常式關聯<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得本機非漫遊使用者的應用程式資料路徑。</summary>
        <value>本機非漫遊使用者的應用程式資料路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本機使用者，是其使用者設定檔儲存在使用者登入所在系統上。 如果路徑不存在，會以下列格式建立一個：  
  
 *基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 典型的基底路徑是 C:\Documents and Settings\\*username*\Local Settings\Application 資料。 這個路徑可能會不同，不過，如果在 Windows Forms 應用程式部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 建立自己的應用程式資料目錄，且與所有其他應用程式隔離。 如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下列程式碼範例會顯示兩種形式，並結束應用程式，這兩個表單關閉時。 當應用程式啟動，並結束時，會記住每個表單的位置。 雖然此範例示範如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>屬性來儲存使用者的應用程式資料<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>可改為使用。  
  
 `MyApplicationContext`類別繼承自<xref:System.Windows.Forms.ApplicationContext>和會持續追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。 類別會儲存使用者的每個表單的位置。 表單位置的資料儲存在檔案標題為`Appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。  
  
 此程式碼是摘錄自中顯示的範例<xref:System.Windows.Forms.ApplicationContext>類別概觀。 為了簡潔起見，不會顯示一些程式碼。 請參閱<xref:System.Windows.Forms.ApplicationContext>整個程式碼清單。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示訊息迴圈是否存在於這個執行緒。</summary>
        <value>
          如果訊息迴圈存在，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在其他環境，例如未受管理的應用程式中裝載 Windows Form 時一律會傳回這個屬性`false`。 使用<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>指示 Windows Form 裝載環境如果仍有作用中的訊息迴圈。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化目前執行緒上的 OLE。</summary>
        <returns>其中一個 <see cref="T:System.Threading.ApartmentState" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫任何`Microsoft.Win32`需要 OLE 的方法。 <xref:System.Windows.Forms.Application.OleRequired%2A> 第一次檢查目前的執行緒上的 OLE 是否尚未初始化。 如果沒有，它會在執行緒初始化 ole。  
  
> [!NOTE]
>  執行緒會直接呼叫 OLE 方法，除非您不需要呼叫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">
          <see cref="T:System.Exception" />，代表擲回的例外狀況。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Application.ThreadException" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Windows.Forms.Application.OnThreadException%2A>引發例外狀況，將會暫止處理的應用程式。  
  
 <xref:System.Windows.Forms.Application>類別具有<xref:System.Windows.Forms.Application.ThreadException>事件。 您可以將事件處理常式附加至這個事件，進行任何自訂處理，您需要的未處理例外狀況。 如果您不要附加事件處理常式，<xref:System.Windows.Forms.Application.OnThreadException%2A>會執行預設行為，這牽涉到顯示對話方塊通知使用者已經發生錯誤。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> 只會在 Windows Form 所擁有的執行緒上實作，會發生未處理例外狀況的預設例外狀況行為。 在其他執行緒的未處理例外狀況會由<xref:System.AppDomain.UnhandledException>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式所擁有之開啟表單的集合。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormCollection" />，包含所有由這個應用程式所擁有而目前已開啟的表單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A>屬性表示應用程式所擁有之表單的唯讀集合。 此集合可供搜尋，依索引位置，或由<xref:System.Windows.Forms.Control.Name%2A>的<xref:System.Windows.Forms.Form>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">呼叫端必須具有存取所有的 windows 權限所定義<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />值<see cref="T:System.Security.Permissions.UIPermissionWindow" />列舉型別。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個應用程式關聯的產品名稱。</summary>
        <value>產品名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 取自包含目前應用程式的主要表單的組件的中繼資料。 您可以設定來設定<xref:System.Reflection.AssemblyProductAttribute>內組件資訊清單。 如需詳細資訊，請參閱[組件資訊清單](~/docs/framework/app-domains/assembly-manifest.md)。  
  
   
  
## Examples  
 下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個應用程式關聯的產品版本。</summary>
        <value>產品版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，版本號碼會顯示為*主要號碼*。*次要號碼*。*組建編號*。*私用部分號碼*。 您可以將其明確地設定您的組件資訊清單中的組件版本。 如需詳細資訊，請參閱[組件資訊清單](~/docs/framework/app-domains/assembly-manifest.md)。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 第一個查詢，包含主要可執行檔的組件是否具有`AssemblyInformationalVersion`在其上的屬性。 如果這個屬性存在，它同時用於<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果這個屬性不存在，這兩個屬性改為使用可執行檔的版本。  
  
   
  
## Examples  
 下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">傳遞至 <see cref="T:System.EventArgs" /> 事件的 <see cref="E:System.Windows.Forms.Application.Idle" /> 物件。</param>
        <summary>引發裝載案例中的 <see cref="E:System.Windows.Forms.Application.Idle" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 裝載 Windows Form 中另一個環境，例如 unmanaged 應用程式時，會使用這個方法。 您應該呼叫<xref:System.Windows.Forms.Application.RaiseIdle%2A>裝載的應用程式時進入閒置狀態。 這可讓某些 Windows Form 控制項和元件來執行重要的背景工作，而不在使用者與應用程式互動。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">方法，用於在 Windows Form 需要檢查裝載環境是否仍在傳送訊息時呼叫。</param>
        <summary>註冊回呼 (Callback)，以檢查訊息迴圈是否在裝載環境中執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 裝載 Windows Form 中另一個環境，例如 unmanaged 應用程式時，會使用這個方法。 在裝載環境中，<xref:System.Windows.Forms.Application.MessageLoop%2A>屬性永遠會傳回 false，如果不在 Windows Form 處理訊息。 使用這個回呼來告訴 Windows Form 是否裝載環境仍在處理訊息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要從應用程式中移除之 <see cref="T:System.Windows.Forms.IMessageFilter" /> 的實作。</param>
        <summary>從應用程式的訊息幫浦移除訊息篩選器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您不再想要再分派這些擷取 Windows 訊息時，您可以移除訊息篩選條件。  
  
   
  
## Examples  
 您可以使用訊息篩選條件之前，您必須提供實作<xref:System.Windows.Forms.IMessageFilter>介面。 下列類別會建立訊息篩選條件呼叫`TestMessageFilter`。 此篩選條件區塊與滑鼠左的按鈕相關的所有訊息。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，設定目前的應用程式是否以視覺化樣式繪製控制項。</summary>
        <value>
          如果已在應用程式視窗的工作區中為控制項啟用視覺化樣式，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您要繪製的自訂控制項，請使用這個屬性來決定是否要繪製的控制項，不論視覺化樣式，使其外觀與應用程式中其他控制項一致。  
  
 下表顯示四個條件必須存在<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A>傳回`true`。  
  
|條件|描述|  
|---------------|-----------------|  
|作業系統支援視覺化樣式|若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 類別的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 屬性。|  
|使用者已啟用作業系統中的視覺化樣式|若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 類別的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 屬性。|  
|應用程式中啟用視覺化樣式|您可以呼叫 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用應用程式資訊清單 (其中指定使用 ComCtl32.dll 6 (含) 以後版本來繪製控制項)，以啟用應用程式中的視覺化樣式。|  
|視覺化樣式正被用來繪製的應用程式視窗的工作區|若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.Application> 類別的 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 屬性，並驗證該屬性具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType> 值。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉應用程式並立即啟動新的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的原因，用於呼叫`Restart`是啟動新版本的應用程式，您已透過下載[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]使用`Update`或`UpdateAsync`方法。  
  
 應用程式會在其中在最初執行的內容中重新啟動。 使用直接指向應用程式的主要可執行檔的 URL 來啟動您的應用程式時，它會重新啟動使用相同的 URL。 如果您的應用程式是[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]應用程式，它將會重新啟動使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。  
  
 如果當它第一次執行時，您的應用程式原本提供的命令列選項<xref:System.Windows.Forms.Application.Restart%2A>將會啟動應用程式，再次以相同的選項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您的程式碼不是 Windows Form 應用程式。 您不能在這個內容中呼叫這個方法。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />權限。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始執行目前執行緒的標準應用程式訊息迴圈。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始執行目前執行緒的標準應用程式訊息迴圈，而不需表單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 win32 或 Windows Form 應用程式訊息迴圈是處理使用者事件，例如按一下滑鼠和鍵盤按鍵的程式碼中的常式。 每個執行的 Windows 架構應用程式需要使用中的訊息迴圈，稱為主要訊息迴圈。 當關閉主要訊息迴圈時，就會結束應用程式。 在 Windows Form 中此迴圈時是否關閉<xref:System.Windows.Forms.Application.Exit%2A>呼叫方法時，或當<xref:System.Windows.Forms.Application.ExitThread%2A>正在執行主要訊息迴圈的執行緒上呼叫方法。  
  
 大部分的 Windows Form 開發人員就不需要使用這個版本的方法。 您應該使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>，讓應用程式終止主要表單關閉時，主要表單，以啟動應用程式的多載。 對於所有其他情況下，使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>多載，可支援提供<xref:System.Windows.Forms.ApplicationContext>以便更有效控制應用程式的存留期的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主訊息迴圈已經在這個執行緒上執行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">執行應用程式的 <see cref="T:System.Windows.Forms.ApplicationContext" />。</param>
        <summary>以 <see cref="T:System.Windows.Forms.ApplicationContext" /> 開始執行目前執行緒的標準應用程式訊息迴圈。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息迴圈會執行直到<xref:System.Windows.Forms.Application.Exit%2A>或<xref:System.Windows.Forms.Application.ExitThread%2A>稱為或<xref:System.Windows.Forms.Application.ThreadExit>物件上引發事件。  
  
   
  
## Examples  
 此範例會顯示兩種形式，這兩個表單關閉時，請結束應用程式。 當應用程式啟動，並結束時，會記住每個表單的位置。 這個範例示範如何使用<xref:System.Windows.Forms.ApplicationContext>，連同`Application.Run(context)`方法，以在應用程式啟動時顯示多個表單。  
  
 類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>和會持續追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。 類別會儲存使用者的每個表單的位置。 表單位置的資料儲存在檔案標題為`Appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。  
  
 程式碼`AppForm1`和`AppForm2`表單不會顯示為了簡潔起見。 請參閱<xref:System.Windows.Forms.ApplicationContext>在整個程式碼清單的類別概觀。  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主訊息迴圈已經在這個執行緒上執行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">
          <see cref="T:System.Windows.Forms.Form" />，代表要成為可見的表單。</param>
        <summary>開始執行目前執行緒上的標準應用程式訊息迴圈，並顯示指定的表單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，應用程式的 main 函式會呼叫這個方法，並將主視窗的應用程式傳遞給它。  
  
 這個方法會加入事件處理常式`mainForm`參數<xref:System.Windows.Forms.Form.Closed>事件。 事件處理常式呼叫<xref:System.Windows.Forms.Application.ExitThread%2A>清除應用程式。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A>方法<xref:System.Windows.Forms.Form>類別會呼叫這個方法傳回之前。  
  
   
  
## Examples  
 下列程式碼範例會列出在表單上的清單方塊中的數字。 每次您按一下`button1`，應用程式會將另一個數字加入至清單。  
  
 `Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，會建立表單， `listBox1`，和`button1`。 當使用者按一下`button1`、`button1_Click`方法將數字一到三個清單方塊中，並顯示<xref:System.Windows.Forms.MessageBox>。 如果使用者按一下**否**上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法會將另一個數字加入至清單。 如果使用者按一下**是**，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>處理所有剩餘的訊息佇列中，然後結束。  
  
 這個範例需要`listBox1`和`button1`已建立並在表單上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主訊息迴圈已經正在目前執行緒中執行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當它們以警告橫幅顯示時，取得或設定格式字串以套用至最上層視窗標題。</summary>
        <value>套用至最上層視窗標題的格式字串。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要設定此屬性的所有視窗。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">用於新控制項的預設值。 如果為 <see langword="true" />，則支援 <c>UseCompatibleTextRendering</c> 的新控制項會使用以 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 為基礎的 <see cref="T:System.Drawing.Graphics" /> 類別來呈現文字，如果為 <see langword="false" />，則新控制項會使用以 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 為基礎的 <see cref="T:System.Windows.Forms.TextRenderer" /> 類別。</param>
        <summary>為部分控制項上定義的 <c>UseCompatibleTextRendering</c> 屬性設定應用程式範圍的預設值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定的 Windows Form 控制項，可以使用其文字呈現<xref:System.Windows.Forms.TextRenderer>類別，根據[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]圖形文件庫，或<xref:System.Drawing.Graphics>類別，根據[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]圖形文件庫。 此變更為了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]因為發生效能和當地語系化問題而[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 使用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>設定的預設值`UseCompatibleTextRendering`支援它的控制項屬性。  
  
 `UseCompatibleTextRendering`屬性為了提供 visual Windows Form 控制項之間的相容性呈現文字使用<xref:System.Windows.Forms.TextRenderer>類別和[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]和[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]應用程式，執行自訂文字轉譯使用<xref:System.Drawing.Graphics>類別。 在大部分情況下，如果您的應用程式未從升級[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]或[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，建議您保持`UseCompatibleTextRendering`設定的預設值為`false`。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]基礎<xref:System.Windows.Forms.TextRenderer>類別中引進了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]為了提升效能，讓文字看起來比較好，並改善的國際字型支援。 在舊版的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]基礎<xref:System.Drawing.Graphics>類別用來執行所有的文字轉譯。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 計算字元間距和自動換行以不同的方式從[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 在 Windows Form 應用程式中使用<xref:System.Drawing.Graphics>類別來呈現文字中，這可能會導致使用的控制項的文字<xref:System.Windows.Forms.TextRenderer>出現不同的應用程式中的其他文字。 若要解決此不相容，您可以設定`UseCompatibleTextRendering`屬性`true`。 若要設定`UseCompatibleTextRendering`至`true`應用程式中所有支援的控制項，呼叫<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>具有參數的方法`true`。  
  
 如果您的 Windows Form 程式碼裝載在另一個應用程式，例如 Internet Explorer 中，您應該永遠不會呼叫這個方法。 只能在獨立的 Windows Form 應用程式中呼叫這個方法。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  若要設定的預設值為`UseCompatibleTextRendering`中[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]或更新版本中，請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>。  
  
 在[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]或更新版本中，呼叫<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>會自動產生的 Program.cs 檔案中。 若要變更文字轉譯預設值，修改產生的程式碼。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您只可以在 Windows Form 應用程式建立第一個視窗之前呼叫這個方法。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Windows.Forms.PowerState" />，表示要轉換至的電源啟動模式。</param>
        <param name="force">
          <see langword="true" /> 表示要立即強制執行暫止模式；<see langword="false" /> 則表示要讓 Windows 向每一個應用程式傳送暫止要求。</param>
        <param name="disableWakeEvent">
          <see langword="true" /> 表示要在喚醒事件上停用將系統的電源狀態還原為作用中；<see langword="false" /> 則表示要在喚醒事件上啟用將系統的電源狀態還原為作用中。</param>
        <summary>讓系統暫止或休眠，或要求讓系統暫止或休眠。</summary>
        <returns>
          如果系統正處於暫止狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果應用程式不會在 20 秒內回應暫停要求，則 Windows 會判斷它處於非回應狀態，和應用程式可能已設定進入睡眠狀態或已結束。 一旦應用程式回應暫停要求，不過，可能需要清除資源，並關閉使用中處理序需要的間隔時間。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示應用程式如何回應未處理的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。  
  
 這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">
          <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述如果未攔截到擲回的例外狀況時，應用程式的行為方式。</param>
        <summary>指示應用程式如何回應未處理的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常不是可攔截所有的 Windows Form 所擲回的例外狀況。 使用此方法，您可以指示您的應用程式應該攔截所有未處理的 Windows Form 元件所擲回的例外狀況並繼續作業，還是應該將它們公開給使用者並暫止執行。  
  
 呼叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>您具現化您的應用程式使用的主要表單之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 攔截無法建立執行緒中發生例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。  
  
 這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您不能在應用程式建立了第一個視窗之後，再設定例外狀況模式。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">
          <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述如果未攔截到擲回的例外狀況時，應用程式的行為方式。</param>
        <param name="threadScope">
          若為 <see langword="true" />，則會設定執行緒例外狀況模式，否則為 <see langword="false" />。</param>
        <summary>指示應用程式如何回應未處理例外狀況，並選擇性地套用執行緒專屬的行為。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常不是可攔截所有的 Windows Form 所擲回的例外狀況。 使用此方法，您可以指示您的應用程式應該攔截所有未處理的 Windows Form 元件所擲回的例外狀況並繼續作業，還是應該將它們公開給使用者並暫止執行。  
  
 呼叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>您具現化您的應用程式使用的主要表單之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 當`threadScope`是`true`，設定執行緒例外狀況模式。 如果執行緒例外狀況模式覆寫應用程式例外狀況模式`mode`未設定為<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>。  
  
 當`threadScope`是`false`，應用程式例外狀況模式設定。 應用程式例外狀況模式用於具有的所有執行緒<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>模式。 設定應用程式例外狀況模式不會影響目前執行緒的設定。  
  
 攔截無法建立執行緒中發生例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。  
  
 這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您不能在應用程式建立了第一個視窗之後，再設定例外狀況模式。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得啟動應用程式的可執行檔路徑，不包括檔名。</summary>
        <value>啟動應用程式的可執行檔路徑。  
  
 這個路徑會依據是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 來部署 Windows Forms 應用程式而有所不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 應用程式會儲存在 C:\Documents and Settings 中的每個使用者應用程式快取\\*username*目錄。 如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">取得路徑。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於未被截取的執行緒擲回例外狀況 (Exception) 時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可讓 Windows Forms 應用程式至 Windows Form 執行緒中發生的控制代碼為未處理的例外狀況。 附加至事件處理常式<xref:System.Windows.Forms.Application.ThreadException>事件，以處理這些例外狀況會保留您的應用程式處於未知狀態。 可能的話，應該由結構化例外狀況處理區塊中處理例外狀況。  
  
 您可以變更此回呼由未處理的 Windows Forms 執行緒例外狀況設定是否<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。 攔截無法建立執行緒中發生例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。  
  
> [!NOTE]
>  若要保證沒有啟用此事件會遺失，您必須將附加的處理常式呼叫之前<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。  
  
 這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼加入此事件處理常式時立即呼叫者。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在執行緒即將關閉時。 當應用程式的主執行緒即將關閉時，會先引發這個事件，接著是 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須將附加事件處理常式，<xref:System.Windows.Forms.Application.ThreadExit>事件以執行任何未處理、 執行緒停止執行之前的必要工作。 關閉這個執行緒或處置的記憶體回收行程未回收的物件所開啟的檔案。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.ThreadExit>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到 Windows Form 並確認事件處理常式關聯<xref:System.Windows.Forms.Application.ThreadExit>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除註冊 <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> 所進行的訊息迴圈回呼。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得使用者的應用程式資料路徑。</summary>
        <value>使用者的應用程式資料路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路徑不存在，會以下列格式建立一個：  
  
 *基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 資料儲存在這個路徑是啟用漫遊使用者設定檔的一部分。 漫遊使用者適用於在網路中的多部電腦。 漫遊使用者的使用者設定檔會保留在網路上的伺服器上時，則載入系統在使用者登入。 考量漫遊使用者設定檔的作業系統必須支援漫遊設定檔，必須啟用。  
  
 典型的基底路徑是 C:\Documents and Settings\\*username*\Application 資料。 這個路徑可能會不同，不過，如果在 Windows Forms 應用程式部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 建立自己的應用程式資料目錄，且與所有其他應用程式隔離。 如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下列程式碼範例會顯示兩種形式，並結束應用程式，這兩個表單關閉時。 當應用程式啟動，並結束時，會記住每個表單的位置。 這個範例示範如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>屬性來儲存使用者的應用程式資料。  
  
 類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>和會持續追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。 類別會儲存使用者的每個表單的位置。 表單位置的資料儲存在檔案標題為`Appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。  
  
 此程式碼是摘錄自中顯示的範例<xref:System.Windows.Forms.ApplicationContext>類別概觀。 為了簡潔起見，不會顯示一些程式碼。 請參閱<xref:System.Windows.Forms.ApplicationContext>整個程式碼清單。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得使用者之應用程式資料的登錄機碼。</summary>
        <value>
          <see cref="T:Microsoft.Win32.RegistryKey" /> 代表使用者專用之應用程式資料的登錄機碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果索引鍵不存在，就會建立以下列格式：  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 資料儲存在這個索引鍵是已啟用漫遊使用者設定檔的一部分。 漫遊使用者適用於在網路中的多部電腦。 漫遊使用者的使用者設定檔會保留在網路上的伺服器上時，則載入系統在使用者登入。 考量漫遊使用者設定檔的作業系統必須支援漫遊設定檔，必須啟用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式的所有開啟表單是否都要使用等待游標。</summary>
        <value>
          如果所有已開啟表單都使用等待游標，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為`true`、<xref:System.Windows.Forms.Control.UseWaitCursor%2A>的應用程式中的所有開啟表單的屬性會設定為`true`。 直到所有表單上已設定這個屬性，將不會傳回此呼叫。 當您有長時間執行的作業，而且想要在所有應用程式表單表示作業仍在處理時，請使用這個屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指定視覺化樣式套用至應用程式視窗的方式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的位元組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這<xref:System.Windows.Forms.Application.VisualStyleState%2A>屬性會決定用戶端區域或應用程式視窗的非工作區中是否已啟用視覺化樣式。 一般而言，應該設定這個屬性主要表單的建構函式內或<xref:System.Windows.Forms.Form.Load>事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Windows.Forms.Application.VisualStyleState%2A>屬性設為其中的<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>值內<xref:System.Windows.Forms.Control.Click>事件處理常式<xref:System.Windows.Forms.Button>控制項。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>列舉型別。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>