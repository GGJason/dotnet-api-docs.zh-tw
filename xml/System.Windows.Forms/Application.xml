<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fb5a42730ceec2161b81c946cda56d790062bd5d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37516305" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides <see langword="static" /> methods and properties to manage an application, such as methods to start and stop an application, to process Windows messages, and properties to get information about an application. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>類別有方法來啟動和停止應用程式、 執行緒和處理 Windows 訊息，如下所示：  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 目前的執行緒上啟動應用程式訊息迴圈，並選擇性地使表單出現。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> 或<xref:System.Windows.Forms.Application.ExitThread%2A>停止的訊息迴圈。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> 在迴圈中您的程式時，請處理訊息。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> 將應用程式訊息幫浦，以監視 Windows 訊息的訊息篩選條件。  
  
-   <xref:System.Windows.Forms.IMessageFilter> 可讓您停止引發事件或叫用事件處理常式之前執行特殊的作業。  
  
 這個類別具有<xref:System.Windows.Forms.Application.CurrentCulture%2A>和<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>屬性來取得或設定文化特性的目前執行緒的資訊。  
  
 您無法建立此類別的執行個體。  
  
   
  
## Examples  
 下列程式碼範例會列出在清單方塊中，在表單上的數字。 每次當您按一下`button1`，應用程式會將清單中的另一個數字。  
  
 `Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，這會建立表單，`listBox1`和`button1`。 當使用者按一下`button1`，則`button1_Click`方法會顯示<xref:System.Windows.Forms.MessageBox>。 如果使用者按一下`No`上<xref:System.Windows.Forms.MessageBox>，則`button1_Click`方法會將數字加入至清單。 如果使用者按一下`Yes`，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>處理佇列中所有剩餘的訊息，然後結束。  
  
> [!NOTE]
>  若要呼叫<xref:System.Windows.Forms.Application.Exit%2A>在部分信任中將會失敗。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> interface you want to install.</param>
        <summary>Adds a message filter to monitor Windows messages as they are routed to their destinations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用訊息篩選條件，來避免引發特定事件或執行特殊作業之前它會傳遞至事件處理常式的事件。 訊息篩選是在特定執行緒的唯一的。  
  
 若要防止訊息在分派`value`您傳遞給此方法的參數執行個體必須覆寫<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>與程式碼來處理訊息的方法。 此方法必須傳回 `false`。  
  
> [!CAUTION]
>  將訊息篩選條件新增至應用程式的訊息幫浦，可能會降低效能。  
  
   
  
## Examples  
 下列程式碼範例會建立名為訊息篩選`TestMessageFilter`。 此篩選器封鎖滑鼠左的按鈕與相關的所有訊息。 您可以使用訊息篩選條件之前，您必須提供實作<xref:System.Windows.Forms.IMessageFilter>介面。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫端呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the caller can quit this application.</summary>
        <value>如果呼叫端可以終止這個應用程式，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`false`如果它從呼叫<xref:System.Windows.Forms.Control>裝載的網頁瀏覽器。 因此，<xref:System.Windows.Forms.Control>無法結束<xref:System.Windows.Forms.Application>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to shut down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須將附加事件處理常式，<xref:System.Windows.Forms.Application.Exit%2A>事件來執行未處理，必要的工作，應用程式停止執行之前。 您可以關閉此應用程式或處置的未回收記憶體回收的物件所開啟的檔案。  
  
 因為這是靜態事件，您必須中斷連結附加至這個事件中任何事件處理常式<xref:System.Windows.Forms.Application.ApplicationExit>本身的事件處理常式。 如果您不是這些處理常式的中斷連結，它們將會附加至事件，並仍繼續耗用記憶體。  
  
   
  
## Examples  
 下列程式碼範例顯示兩種形式，並關閉這兩種形式時，請結束應用程式。 當應用程式啟動，並結束時，則會記住每個表單的位置。 此範例示範如何使用<xref:System.Windows.Forms.Application.ApplicationExit>事件，以瞭解當表單位置應該保存至檔案，以及當`FileStream`應該關閉。  
  
 此類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>並追蹤每個表單關閉後，而且兩者時，結束目前的執行緒。 當關閉時，類別就會記住每個表單的位置。 當<xref:System.Windows.Forms.Application.ApplicationExit>事件發生時，該類別寫入檔案中的每個使用者的位置。 表單位置的資料儲存在名為檔案`appdata.txt`所決定的位置中建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此程式碼是摘錄自範例所示<xref:System.Windows.Forms.ApplicationContext>類別概觀。 請參閱<xref:System.Windows.Forms.ApplicationContext>針對整個程式碼清單。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data that is shared among all users.</summary>
        <value>所有使用者之間共用之應用程式資料的路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路徑不存在，其中會建立以下列格式：  
  
 *基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 若要查看是否包含主要的可執行檔的組件的第一個看起來`AssemblyInformationalVersion`在其上的屬性。 如果此屬性存在，它可用於<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果這個屬性不存在，這兩個屬性會改為使用可執行檔的版本。  
  
 路徑會根據 Windows Forms 應用程式部署使用不同[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 應用程式會儲存在 C:\Documents and Settings 的每個使用者的應用程式快取\\*使用者名稱*目錄。 如需詳細資訊，請參閱 <<c0> [ 存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the registry key for the application data that is shared among all users.</summary>
        <value>
          <see cref="T:Microsoft.Win32.RegistryKey" />，代表所有使用者之間共用之應用程式資料的登錄機碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果索引鍵不存在，則會建立下列格式：  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the company name associated with the application.</summary>
        <value>公司名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性，並顯示其值，在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture information for the current thread.</summary>
        <value>
          <see cref="T:System.Globalization.CultureInfo" />，代表目前執行緒的文化特性資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性，並顯示其值，在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要設定這個屬性的所有視窗。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current input language for the current thread.</summary>
        <value>
          <see cref="T:System.Windows.Forms.InputLanguage" />，代表目前執行緒的目前輸入語言。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性，並顯示其值，在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫端呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Processes all Windows messages currently in the message queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您執行 Windows 表單時，它會建立新的表單中，然後等候處理的事件。 表單處理的事件中，每次它會處理該事件相關聯的所有程式碼。 在佇列中，等候所有其他事件。 當您的程式碼處理事件時，您的應用程式沒有回應。 例如，視窗不會重新繪製視窗如果另一個視窗拖曳至頂端。  
  
 如果您呼叫<xref:System.Windows.Forms.Application.DoEvents%2A>在您的程式碼中，您的應用程式可以處理其他事件。 例如，如果您有將資料加入至表單<xref:System.Windows.Forms.ListBox>並新增<xref:System.Windows.Forms.Application.DoEvents%2A>您的程式碼中，您的表單重新繪製另一個視窗拖曳至其上時。 如果您移除<xref:System.Windows.Forms.Application.DoEvents%2A>從您的程式碼中，您的表單將不重新繪製按鈕的 click 事件處理常式完成之前執行。 如需有關訊息的詳細資訊，請參閱[Windows Forms 中的使用者輸入](~/docs/framework/winforms/user-input-in-windows-forms.md)。  
  
 不同於 Visual Basic 6.0<xref:System.Windows.Forms.Application.DoEvents%2A>方法不會呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。  
  
 一般而言，您可以使用這個方法來處理訊息迴圈中。  
  
> [!CAUTION]
>  呼叫這個方法會導致目前的執行緒，而處理所有等候的視窗訊息被擱置。 如果訊息會造成觸發的事件，則可能執行的應用程式程式碼其他區域。 這會導致您的應用程式造成非預期的行為很難偵錯。 如果您執行作業或需要長時間的計算，它通常最好是執行新的執行緒上作業。 如需有關非同步程式設計的詳細資訊，請參閱 <<c0> [ 非同步程式設計模型 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Application.DoEvents%2A>方法。 此範例執行時，使用者可以選取圖形檔從<xref:System.Windows.Forms.OpenFileDialog>。 選取的檔案會顯示在表單中。 <xref:System.Windows.Forms.Application.DoEvents%2A>方法會強制重新繪製的每個圖形檔案開啟表單。 若要執行此範例中，貼上下列程式碼中表單，其中包含<xref:System.Windows.Forms.PictureBox>名為`PictureBox1`，則<xref:System.Windows.Forms.OpenFileDialog>名為`OpenFileDialog1`，和名為按鈕`fileButton`。 呼叫`InitializePictureBox`並`InitializeOpenFileDialog`從表單的建構函式的方法或`Load`方法。  
  
> [!NOTE]
>  在 Visual Studio 中，如果您加入<xref:System.Windows.Forms.OpenFileDialog>至您使用拖放作業的表單，您就必須修改下列`InitializeOpenFileDialog`方法，藉由移除建立的新執行個體的那一行<xref:System.Windows.Forms.OpenFileDialog>。  
  
 這個範例也需要<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>事件的<xref:System.Windows.Forms.Button>控制項並<xref:System.Windows.Forms.FileDialog.FileOk>事件的<xref:System.Windows.Forms.OpenFileDialog>連接到範例中定義的事件處理常式。 執行範例時，請按一下按鈕顯示的對話方塊。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enables visual styles for the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓應用程式的視覺化樣式。 視覺化樣式是色彩、 字型和其他視覺項目構成作業系統佈景主題。 如果控制項和作業系統支援它，將會繪製具有視覺化樣式的控制項。 若要有效果，請<xref:System.Windows.Forms.Application.EnableVisualStyles>必須在 應用程式; 中建立的任何控制項之前呼叫通常<xref:System.Windows.Forms.Application.EnableVisualStyles>中的第一行`Main`函式。 不需要個別的資訊清單呼叫時啟用視覺化樣式<xref:System.Windows.Forms.Application.EnableVisualStyles>。  
  
> [!NOTE]
>  在.NET Framework 2.0 中前,`FlatStyle`一些控制項，例如衍生自控制項的屬性<xref:System.Windows.Forms.ButtonBase>，必須設定為<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>要繪製具有視覺化樣式的控制項順序。 在.NET Framework 2.0 所撰寫的應用程式，這是不再必要。  
  
> [!NOTE]
>  這個方法不會影響 Internet Explorer 中裝載的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Windows.Forms.Application.EnableVisualStyles%2A>在`Main`函式可讓應用程式的視覺化樣式。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to enter a modal state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.EnterThreadModal>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，請將它貼到 Windows Form，並確保與關聯的事件處理常式<xref:System.Windows.Forms.Application.EnterThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />接聽事件的權限。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the executable file that started the application, including the executable name.</summary>
        <value>啟動應用程式的可執行檔路徑和檔名。  這個路徑會根據 Windows Forms 應用程式部署使用不同 [！INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 應用程式會儲存在 C:\Documents and Settings 的每個使用者的應用程式快取\\* 使用者名稱 * 目錄。 如需詳細資訊，請參閱 [存取本機和遠端 ClickOnce 應用程式中的資料] (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">取得路徑。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A>方法會停止所有執行緒上的所有執行訊息迴圈，並關閉所有 windows 應用程式。 這個方法不一定會強制結束應用程式。 <xref:System.Windows.Forms.Application.Exit%2A>通常呼叫方法內訊息迴圈，並強制<xref:System.Windows.Forms.Application.Run%2A>傳回。 若要結束目前執行緒的訊息迴圈，請呼叫<xref:System.Windows.Forms.Application.ExitThread%2A>。  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 會引發下列事件，並執行相關聯的條件式動作：  
  
-   A<xref:System.Windows.Forms.Form.FormClosing>引發事件所代表的每個表單<xref:System.Windows.Forms.Application.OpenForms%2A>屬性。 這個事件可以藉由設定取消<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性及其<xref:System.Windows.Forms.FormClosingEventArgs>參數來`true`。  
  
-   如果一或多個處理常式會取消事件，然後<xref:System.Windows.Forms.Application.Exit%2A>傳回而不需進一步的動作。 否則，<xref:System.Windows.Forms.Form.FormClosed>每個開啟的表單，會引發事件，然後關閉所有執行的訊息迴圈和表單。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A>方法不會引發<xref:System.Windows.Forms.Form.Closed>並<xref:System.Windows.Forms.Form.Closing>事件，也就是過時的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。  
  
   
  
## Examples  
 下列程式碼範例會列出在清單方塊中，在表單上的數字。 每次當您按一下`button1`，應用程式會將清單中的另一個數字。  
  
 `Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，這會建立表單， `listBox1`，和`button1`。 當使用者按一下`button1`，則`button1_Click`方法會將數字相加一到三個清單方塊中，並顯示<xref:System.Windows.Forms.MessageBox>。 如果使用者按一下**No**上<xref:System.Windows.Forms.MessageBox>，則`button1_Click`方法會將另一個數字加入至清單。 如果使用者按一下 **[是]**，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>，來處理所有剩餘的訊息佇列中，然後結束。  
  
 這個範例需要`listBox1`和`button1`已具現化並放置在表單上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫端呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Returns whether any <see cref="T:System.Windows.Forms.Form" /> within the application cancelled the exit.</param>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">結束正在執行的權限的應用程式執行緒。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the message loop on the current thread and closes all windows on the thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來結束目前執行緒的訊息迴圈。 這個方法會導致呼叫<xref:System.Windows.Forms.Application.Run%2A>返回目前的執行緒。 若要結束的整個應用程式，請呼叫<xref:System.Windows.Forms.Application.Exit%2A>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">立即呼叫端呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">The Windows event message to filter.</param>
        <summary>Runs any filters against a window message, and returns a copy of the modified message.</summary>
        <returns>
          <see langword="True" /> if the filters were processed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application finishes processing and is about to enter the idle state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您有必須執行的工作在執行緒閒置之前，請將它們附加至這個事件。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.Idle>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到 Windows Form，並確定事件處理常式會與相關聯<xref:System.Windows.Forms.Application.Idle>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to leave a modal state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，請將它貼到 Windows Form，並確保與關聯的事件處理常式<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data of a local, non-roaming user.</summary>
        <value>本機非漫遊使用者的應用程式資料路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本機使用者，是其使用者設定檔會儲存在使用者登入的系統。 如果路徑不存在，其中會建立以下列格式：  
  
 *基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 典型的基底路徑是 C:\Documents and Settings\\*使用者名稱*settings\application 資料。 此路徑可能會不同，不過，如果將 Windows Form 應用程式部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 會建立它自己與所有其他應用程式隔離的應用程式資料目錄。 如需詳細資訊，請參閱 <<c0> [ 存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下列程式碼範例顯示兩種形式，並關閉這兩種形式時，請結束應用程式。 當應用程式啟動，並結束時，則會記住每個表單的位置。 雖然此範例示範如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>屬性來儲存使用者的應用程式資料<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>可以改為使用。  
  
 `MyApplicationContext`類別繼承自<xref:System.Windows.Forms.ApplicationContext>並會持續追蹤每個表單關閉後，而且兩者時，結束目前的執行緒。 此類別會儲存每個表單，讓使用者的位置。 表單位置的資料儲存在名為檔案`Appdata.txt`所決定的位置中建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此程式碼是摘錄自範例所示<xref:System.Windows.Forms.ApplicationContext>類別概觀。 為了簡潔起見，不會顯示一些程式碼。 請參閱<xref:System.Windows.Forms.ApplicationContext>針對整個程式碼清單。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a message loop exists on this thread.</summary>
        <value>如果訊息迴圈存在，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在其他環境中，例如未受管理的應用程式，裝載 Windows Form 時一律會傳回這個屬性`false`。 使用<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>，指示 Windows Form 裝載環境如果仍有作用中的訊息迴圈。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes OLE on the current thread.</summary>
        <returns>One of the <see cref="T:System.Threading.ApartmentState" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫任何`Microsoft.Win32`需要 OLE 的方法。 <xref:System.Windows.Forms.Application.OleRequired%2A> 會先檢查以查看目前的執行緒上的 OLE 是否已初始化。 如果沒有，它會在執行緒初始化 ole。  
  
> [!NOTE]
>  執行緒直接呼叫 OLE 方法，除非您不需要呼叫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">An <see cref="T:System.Exception" /> that represents the exception that was thrown.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Windows.Forms.Application.OnThreadException%2A>引發例外狀況，將會中止處理應用程式。  
  
 <xref:System.Windows.Forms.Application>類別具有<xref:System.Windows.Forms.Application.ThreadException>事件。 您可以將事件處理常式附加至這個事件，以執行任何未處理例外狀況所需的自訂處理。 如果您不要附加事件處理常式，<xref:System.Windows.Forms.Application.OnThreadException%2A>會執行預設行為，這牽涉到顯示對話方塊通知使用者已經發生錯誤。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> 在 Windows Form 所擁有的執行緒上，只會實作所發生的未處理例外狀況的預設例外狀況行為。 在其他執行緒上的未處理例外狀況會由<xref:System.AppDomain.UnhandledException>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of open forms owned by the application.</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormCollection" />，包含所有由這個應用程式所擁有而目前已開啟的表單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A>屬性表示由應用程式所擁有表單的唯讀集合。 此集合可搜尋的索引位置，或由<xref:System.Windows.Forms.Control.Name%2A>的<xref:System.Windows.Forms.Form>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">呼叫端必須具有存取所有的 windows 權限，所定義<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />的值<see cref="T:System.Security.Permissions.UIPermissionWindow" />列舉型別。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the product name associated with this application.</summary>
        <value>產品名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 取自包含目前的應用程式的主要表單的組件的中繼資料。 您可以設定來設定<xref:System.Reflection.AssemblyProductAttribute>內您的組件資訊清單。 如需詳細資訊，請參閱 <<c0> [ 組件資訊清單](~/docs/framework/app-domains/assembly-manifest.md)。  
  
   
  
## Examples  
 下列程式碼範例會取得這個屬性，並顯示其值，在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the product version associated with this application.</summary>
        <value>產品版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，版本號碼會顯示成*主要號碼*。*次要號碼*。*組建編號*。*私用部分號碼*。 您可以將它明確地設定您的組件資訊清單內的組件版本。 如需詳細資訊，請參閱 <<c0> [ 組件資訊清單](~/docs/framework/app-domains/assembly-manifest.md)。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 若要查看是否包含主要的可執行檔的組件的第一個看起來`AssemblyInformationalVersion`在其上的屬性。 如果此屬性存在，它可用於<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果這個屬性不存在，這兩個屬性會改為使用可執行檔的版本。  
  
   
  
## Examples  
 下列程式碼範例會取得這個屬性，並顯示其值，在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> objects to pass to the <see cref="E:System.Windows.Forms.Application.Idle" /> event.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Application.Idle" /> event in hosted scenarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 另一個環境，例如未受管理的應用程式中裝載 Windows Form 時，會使用這個方法。 您應該呼叫<xref:System.Windows.Forms.Application.RaiseIdle%2A>當裝載應用程式進入閒置狀態。 這可讓某些 Windows Form 控制項和元件來執行重要的背景工作，而使用者未與應用程式互動。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">The method to call when Windows Forms needs to check if the hosting environment is still sending messages.</param>
        <summary>Registers a callback for checking whether the message loop is running in hosted environments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 另一個環境，例如未受管理的應用程式中裝載 Windows Form 時，會使用這個方法。 在託管環境中，<xref:System.Windows.Forms.Application.MessageLoop%2A>屬性一律會傳回 false，如果 Windows Form 不會處理訊息。 您可以使用這個回呼，告訴 Windows Form 是否裝載環境仍在處理訊息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> to remove from the application.</param>
        <summary>Removes a message filter from the message pump of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您不再想要擷取 Windows 訊息，再將它們分派，您可以移除訊息篩選條件。  
  
   
  
## Examples  
 您可以使用訊息篩選條件之前，您必須提供實作<xref:System.Windows.Forms.IMessageFilter>介面。 下列類別會建立名為訊息篩選`TestMessageFilter`。 此篩選器封鎖滑鼠左的按鈕與相關的所有訊息。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value specifying whether the current application is drawing controls with visual styles.</summary>
        <value>如果已在應用程式視窗的工作區中為控制項啟用視覺化樣式，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要繪製自訂控制項，請使用這個屬性決定是否要繪製控制項中的，不論有沒有視覺化樣式，使其外觀是一致的應用程式中的其他控制項。  
  
 下表顯示四個條件必須存在<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A>傳回`true`。  
  
|條件|描述|  
|---------------|-----------------|  
|作業系統支援視覺化樣式|若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 類別的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 屬性。|  
|使用者已經啟用作業系統中的視覺化樣式|若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 類別的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 屬性。|  
|應用程式中啟用視覺化樣式|您可以呼叫 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用應用程式資訊清單 (其中指定使用 ComCtl32.dll 6 (含) 以後版本來繪製控制項)，以啟用應用程式中的視覺化樣式。|  
|視覺化樣式來繪製應用程式視窗的工作區|若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.Application> 類別的 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 屬性，並驗證該屬性具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType> 值。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shuts down the application and starts a new instance immediately.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫的最常見原因`Restart`是要啟動的應用程式，您已透過下載新版本[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]使用`Update`或`UpdateAsync`方法。  
  
 應用程式會重新啟動，以在最初執行的內容中。 如果您的應用程式已開始使用 URL 直接指向應用程式的主要可執行檔，它會重新啟動使用相同的 URL。 如果您的應用程式[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]應用程式，它將會重新啟動使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。  
  
 如果您的應用程式在第一次執行時，會是原本提供的命令列選項<xref:System.Windows.Forms.Application.Restart%2A>會啟動一次使用的相同選項的應用程式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Your code is not a Windows Forms application. You cannot call this method in this context.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />權限。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins running a standard application message loop on the current thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins running a standard application message loop on the current thread, without a form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Win32 為基礎或以 Windows Forms 應用程式訊息迴圈是處理使用者事件，例如按一下滑鼠和鍵盤按鍵的程式碼中的常式。 每個執行以 Windows 為基礎的應用程式需要的作用中的訊息迴圈，稱為主要訊息迴圈。 關閉主要訊息迴圈時，應用程式就會結束。 在 Windows Forms 中，此迴圈時是否關閉<xref:System.Windows.Forms.Application.Exit%2A>呼叫方法時，或當<xref:System.Windows.Forms.Application.ExitThread%2A>正在執行主要訊息迴圈的執行緒上呼叫方法。  
  
 大部分的 Windows Form 開發人員將不需要使用這個版本的方法。 您應該使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>主表單中，以啟動應用程式，以便在主要表單關閉時，會終止應用程式的多載。 對於所有其他情況下，使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>多載，可支援提供<xref:System.Windows.Forms.ApplicationContext>以便更有效控制應用程式的存留期的物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on this thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">An <see cref="T:System.Windows.Forms.ApplicationContext" /> in which the application is run.</param>
        <summary>Begins running a standard application message loop on the current thread, with an <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息迴圈會執行直到<xref:System.Windows.Forms.Application.Exit%2A>或是<xref:System.Windows.Forms.Application.ExitThread%2A>呼叫或<xref:System.Windows.Forms.Application.ThreadExit>內容物件上引發事件。  
  
   
  
## Examples  
 此範例會顯示兩種形式，並關閉這兩種形式時，請結束應用程式。 當應用程式啟動，並結束時，則會記住每個表單的位置。 此範例示範如何使用<xref:System.Windows.Forms.ApplicationContext>，連同`Application.Run(context)`方法，以在應用程式啟動時顯示多個表單。  
  
 此類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>並會持續追蹤每個表單關閉後，而且兩者時，結束目前的執行緒。 此類別會儲存每個表單，讓使用者的位置。 表單位置的資料儲存在名為檔案`Appdata.txt`所決定的位置中建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 程式碼`AppForm1`和`AppForm2`表單不會顯示為了保持簡潔。 請參閱<xref:System.Windows.Forms.ApplicationContext>在整個程式碼清單的類別概觀。  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on this thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">A <see cref="T:System.Windows.Forms.Form" /> that represents the form to make visible.</param>
        <summary>Begins running a standard application message loop on the current thread, and makes the specified form visible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般而言，應用程式的 main 函式呼叫此方法，並傳遞給它的應用程式的主視窗。  
  
 此方法會將事件處理常式`mainForm`參數<xref:System.Windows.Forms.Form.Closed>事件。 事件處理常式呼叫<xref:System.Windows.Forms.Application.ExitThread%2A>來清除應用程式。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A>方法的<xref:System.Windows.Forms.Form>類別將會呼叫這個方法傳回之前。  
  
   
  
## Examples  
 下列程式碼範例會列出在清單方塊中，在表單上的數字。 每次當您按一下`button1`，應用程式會將清單中的另一個數字。  
  
 `Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，這會建立表單， `listBox1`，和`button1`。 當使用者按一下`button1`，則`button1_Click`方法會將數字相加一到三個清單方塊中，並顯示<xref:System.Windows.Forms.MessageBox>。 如果使用者按一下**No**上<xref:System.Windows.Forms.MessageBox>，則`button1_Click`方法會將另一個數字加入至清單。 如果使用者按一下 **[是]**，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>處理佇列中所有剩餘的訊息，然後結束。  
  
 這個範例需要`listBox1`和`button1`已建立並在表單上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on the current thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the format string to apply to top-level window captions when they are displayed with a warning banner.</summary>
        <value>套用至最上層視窗標題的格式字串。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要設定這個屬性的所有視窗。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">The default value to use for new controls. If <see langword="true" />, new controls that support <c>UseCompatibleTextRendering</c> use the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <see cref="T:System.Drawing.Graphics" /> class for text rendering; if <see langword="false" />, new controls use the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <see cref="T:System.Windows.Forms.TextRenderer" /> class.</param>
        <summary>Sets the application-wide default for the <c>UseCompatibleTextRendering</c> property defined on certain controls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定的 Windows Form 控制項可以呈現其使用的文字<xref:System.Windows.Forms.TextRenderer>類別，此作業取決於[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]圖形程式庫，或有<xref:System.Drawing.Graphics>類別，此作業取決於[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]圖形程式庫。 此變更為了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]因為效能和當地語系化問題而[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 使用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>若要設定的預設值`UseCompatibleTextRendering`支援它之控制項的屬性。  
  
 `UseCompatibleTextRendering`屬性要提供視覺化的相容性，Windows Form 控制項之間呈現文字使用<xref:System.Windows.Forms.TextRenderer>類別和[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]和[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]應用程式，執行自訂的文字轉譯使用<xref:System.Drawing.Graphics>類別。 在大部分情況下，如果您的應用程式不從正在升級[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]或是[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，建議您保持`UseCompatibleTextRendering`設定的預設值為`false`。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]基礎<xref:System.Windows.Forms.TextRenderer>類別中導入[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]為了改善效能，讓文字看起來好，並改善的國際字型支援。 在舊版[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，則[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]基礎<xref:System.Drawing.Graphics>類別用來執行所有的文字呈現。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 計算字元間距] 和 [自動換行以不同的方式從[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 在 Windows Forms 應用程式中使用<xref:System.Drawing.Graphics>類別來呈現文字，這可能會導致使用的控制項的文字<xref:System.Windows.Forms.TextRenderer>出現不同的應用程式中的其他文字。 若要解決此不相容情況，您可以設定`UseCompatibleTextRendering`屬性設`true`。 若要設定`UseCompatibleTextRendering`要`true`針對應用程式中所有支援的控制項，呼叫<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>方法的參數`true`。  
  
 如果您的 Windows Form 程式碼裝載在另一個應用程式，例如 Internet Explorer 中，您應該永遠不會呼叫這個方法。 只有獨立的 Windows Forms 應用程式中呼叫這個方法。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  若要設定的預設值`UseCompatibleTextRendering`中[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]或更新版本，請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>。  
  
 在 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]或更新版本中，呼叫<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>會自動產生的 Program.cs 檔案中。 若要變更預設的文字轉譯，修改產生的程式碼。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You can only call this method before the first window is created by your Windows Forms application.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Forms.PowerState" /> indicating the power activity mode to which to transition.</param>
        <param name="force">
          <see langword="true" /> to force the suspended mode immediately; <see langword="false" /> to cause Windows to send a suspend request to every application.</param>
        <param name="disableWakeEvent">
          <see langword="true" /> to disable restoring the system's power status to active on a wake event, <see langword="false" /> to enable restoring the system's power status to active on a wake event.</param>
        <summary>Suspends or hibernates the system, or requests that the system be suspended or hibernated.</summary>
        <returns>
          <see langword="true" /> if the system is being suspended, otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果應用程式不會在 20 秒內回應的暫止要求，則 Windows 會判斷它處於無回應的狀態，且應用程式可能已設定進入睡眠狀態或已結束。 一旦應用程式回應的暫止要求，不過，可能需要清除資源，並關閉 作用中處理序的間隔時間。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Instructs the application how to respond to unhandled exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會設定 Windows Forms 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓所有的例外狀況會由應用程式，不論應用程式的使用者組態檔案中的設定。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒的例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，範例只會記錄錯誤之前終止應用程式事件記錄檔中。  
  
 這個範例假設您已定義兩個<xref:System.Windows.Forms.Button>控制項`button1`並`button2`，請在您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</param>
        <summary>Instructs the application how to respond to unhandled exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它通常不是可攔截所有的 Windows Form 所擲回的例外狀況。 使用此方法，您可以指示您的應用程式是否應該攔截所有未處理的 Windows Form 元件所擲回的例外狀況並繼續作業，或它是否應該將它們公開給使用者並暫止執行。  
  
 呼叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>您具現化您的應用程式使用的主要表單之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 若要攔截不建立的執行緒中發生的例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定 Windows Forms 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓所有的例外狀況會由應用程式，不論應用程式的使用者組態檔案中的設定。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒的例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，範例只會記錄錯誤之前終止應用程式事件記錄檔中。  
  
 這個範例假設您已定義兩個<xref:System.Windows.Forms.Button>控制項`button1`並`button2`，請在您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You cannot set the exception mode after the application has created its first window.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</param>
        <param name="threadScope">
          <see langword="true" /> to set the thread exception mode; otherwise, <see langword="false" />.</param>
        <summary>Instructs the application how to respond to unhandled exceptions, optionally applying thread-specific behavior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它通常不是可攔截所有的 Windows Form 所擲回的例外狀況。 使用此方法，您可以指示您的應用程式是否應該攔截所有未處理的 Windows Form 元件所擲回的例外狀況並繼續作業，或它是否應該將它們公開給使用者並暫止執行。  
  
 呼叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>您具現化您的應用程式使用的主要表單之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 當`threadScope`是`true`，設定執行緒例外狀況模式。 如果執行緒例外狀況模式覆寫應用程式的例外狀況模式`mode`未設為<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>。  
  
 當`threadScope`是`false`，應用程式例外狀況模式設定。 應用程式的例外狀況模式用於擁有的所有執行緒<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>模式。 設定應用程式的例外狀況模式，不會影響目前執行緒的設定。  
  
 若要攔截不建立的執行緒中發生的例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定 Windows Forms 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓所有的例外狀況會由應用程式，不論應用程式的使用者組態檔案中的設定。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒的例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，範例只會記錄錯誤之前終止應用程式事件記錄檔中。  
  
 這個範例假設您已定義兩個<xref:System.Windows.Forms.Button>控制項`button1`並`button2`，請在您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You cannot set the exception mode after the application has created its first window.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the executable file that started the application, not including the executable name.</summary>
        <value>啟動應用程式的可執行檔路徑。  這個路徑會根據 Windows Forms 應用程式部署使用不同 [！INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 應用程式會儲存在 C:\Documents and Settings 的每個使用者的應用程式快取\\* 使用者名稱 * 目錄。 如需詳細資訊，請參閱 [存取本機和遠端 ClickOnce 應用程式中的資料] (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會取得這個屬性，並顯示其值，在文字方塊中。 這個範例需要`textBox1`已放在表單上。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">取得路徑。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an untrapped thread exception is thrown.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可讓您的 Windows Forms 應用程式，會發生在 Windows Forms 執行緒的控制代碼則未處理的例外狀況。 附加至事件處理常式<xref:System.Windows.Forms.Application.ThreadException>事件來處理這些例外狀況會離開您的應用程式處於未知狀態。 可能的話，則應該由結構化例外狀況處理區塊處理例外狀況。  
  
 您可以變更此回呼由未處理的 Windows Forms 執行緒例外狀況設定是否<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。 若要攔截不建立的執行緒中發生的例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。  
  
> [!NOTE]
>  若要保證沒有啟用，此事件會遺失，您必須附加處理常式才能呼叫<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定 Windows Forms 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。 它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓所有的例外狀況會由應用程式，不論應用程式的使用者組態檔案中的設定。 它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒的例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。 因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，範例只會記錄錯誤之前終止應用程式事件記錄檔中。  
  
 這個範例假設您已定義兩個<xref:System.Windows.Forms.Button>控制項`button1`並`button2`，請在您<xref:System.Windows.Forms.Form>類別。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼，將處理常式加入至這個事件時立即呼叫端。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread is about to shut down. When the main thread for an application is about to be shut down, this event is raised first, followed by an <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須將附加事件處理常式，<xref:System.Windows.Forms.Application.ThreadExit>事件，以執行任何未處理、 執行緒停止執行之前所需的工作。 關閉此執行緒或處置的記憶體回收行程未回收的物件所開啟的檔案。  
  
> [!CAUTION]
>  因為這是靜態事件，您必須在您的應用程式已處置，或會造成記憶體流失時中斷連結事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.ThreadExit>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，請將它貼到 Windows Form，並確保與關聯的事件處理常式<xref:System.Windows.Forms.Application.ThreadExit>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unregisters the message loop callback made with <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data of a user.</summary>
        <value>使用者的應用程式資料路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路徑不存在，其中會建立以下列格式：  
  
 *基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 這個路徑中所儲存的資料是已啟用漫遊使用者設定檔的一部分。 漫遊使用者適用於在網路中的多部電腦。 漫遊使用者的使用者設定檔會保留在網路上的伺服器上，並且在使用者登入載入到系統。 使用者設定檔才會被視為漫遊，作業系統必須支援漫遊設定檔，並必須啟用它。  
  
 典型的基底路徑是 C:\Documents and Settings\\*使用者名稱*\Application Data。 此路徑可能會不同，不過，如果將 Windows Form 應用程式部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 會建立它自己與所有其他應用程式隔離的應用程式資料目錄。 如需詳細資訊，請參閱 <<c0> [ 存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下列程式碼範例顯示兩種形式，並關閉這兩種形式時，請結束應用程式。 當應用程式啟動，並結束時，則會記住每個表單的位置。 此範例示範如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>儲存使用者的應用程式資料的屬性。  
  
 此類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>並會持續追蹤每個表單關閉後，而且兩者時，結束目前的執行緒。 此類別會儲存每個表單，讓使用者的位置。 表單位置的資料儲存在名為檔案`Appdata.txt`所決定的位置中建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法呼叫`Application.Run(context)`啟動應用程式提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此程式碼是摘錄自範例所示<xref:System.Windows.Forms.ApplicationContext>類別概觀。 為了簡潔起見，不會顯示一些程式碼。 請參閱<xref:System.Windows.Forms.ApplicationContext>針對整個程式碼清單。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the registry key for the application data of a user.</summary>
        <value>
          <see cref="T:Microsoft.Win32.RegistryKey" /> 代表使用者專用之應用程式資料的登錄機碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果索引鍵不存在，則會建立下列格式：  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 資料儲存在這個索引鍵是已啟用漫遊使用者設定檔的一部分。 漫遊使用者適用於在網路中的多部電腦。 漫遊使用者的使用者設定檔會保留在網路上的伺服器上，並且在使用者登入載入到系統。 使用者設定檔才會被視為漫遊，作業系統必須支援漫遊設定檔，並必須啟用它。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the wait cursor is used for all open forms of the application.</summary>
        <value>如果所有已開啟表單都使用等待游標，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為`true`，則<xref:System.Windows.Forms.Control.UseWaitCursor%2A>的應用程式中的所有開啟表單的屬性會設定為`true`。 這個呼叫不會傳回，直到所有的表單上已設定這個屬性。 當您有長時間執行的作業，而且想要在所有的應用程式表單中指出的作業仍在處理時，請使用這個屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that specifies how visual styles are applied to application windows.</summary>
        <value>
          <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的位元組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這<xref:System.Windows.Forms.Application.VisualStyleState%2A>屬性會決定是否在用戶端區域或應用程式視窗的非工作區中啟用視覺化樣式。 一般而言，這個屬性應該設定在主要表單的建構函式或<xref:System.Windows.Forms.Form.Load>事件處理常式。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Windows.Forms.Application.VisualStyleState%2A>屬性的其中一個<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>值內<xref:System.Windows.Forms.Control.Click>事件處理常式<xref:System.Windows.Forms.Button>控制項。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>列舉型別。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>