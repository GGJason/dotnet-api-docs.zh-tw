<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24faab7220b703ca01fba4fff8dce9e4e7d58f2a" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037949" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="690c6-101">提供 <see langword="static" /> 方法和屬性以管理應用程式，例如使用方法啟動或停止應用程式、處理 Windows 訊息，以及使用屬性取得有關應用程式的資訊。</span>
      <span class="sxs-lookup">
        <span data-stu-id="690c6-101">Provides <see langword="static" /> methods and properties to manage an application, such as methods to start and stop an application, to process Windows messages, and properties to get information about an application.</span>
      </span>
      <span data-ttu-id="690c6-102">這個類別無法被繼承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="690c6-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-103"><xref:System.Windows.Forms.Application>類別具有啟動和停止應用程式和執行緒，以及處理 Windows 訊息，如下所示的方法：</span><span class="sxs-lookup"><span data-stu-id="690c6-103">The <xref:System.Windows.Forms.Application> class has methods to start and stop applications and threads, and to process Windows messages, as follows:</span></span>  
  
-   <span data-ttu-id="690c6-104"><xref:System.Windows.Forms.Application.Run%2A> 目前的執行緒上啟動應用程式訊息迴圈，並選擇性地讓表單成為可見。</span><span class="sxs-lookup"><span data-stu-id="690c6-104"><xref:System.Windows.Forms.Application.Run%2A> starts an application message loop on the current thread and, optionally, makes a form visible.</span></span>  
  
-   <span data-ttu-id="690c6-105"><xref:System.Windows.Forms.Application.Exit%2A> 或<xref:System.Windows.Forms.Application.ExitThread%2A>停止訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="690c6-105"><xref:System.Windows.Forms.Application.Exit%2A> or <xref:System.Windows.Forms.Application.ExitThread%2A> stops a message loop.</span></span>  
  
-   <span data-ttu-id="690c6-106"><xref:System.Windows.Forms.Application.DoEvents%2A> 您的程式時在迴圈中處理訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-106"><xref:System.Windows.Forms.Application.DoEvents%2A> processes messages while your program is in a loop.</span></span>  
  
-   <span data-ttu-id="690c6-107"><xref:System.Windows.Forms.Application.AddMessageFilter%2A> 將訊息篩選條件加入至應用程式訊息幫浦來監視 Windows 訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-107"><xref:System.Windows.Forms.Application.AddMessageFilter%2A> adds a message filter to the application message pump to monitor Windows messages.</span></span>  
  
-   <span data-ttu-id="690c6-108"><xref:System.Windows.Forms.IMessageFilter> 可讓您停止引發事件或執行特殊作業之前叫用事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-108"><xref:System.Windows.Forms.IMessageFilter> lets you stop an event from being raised or perform special operations before invoking an event handler.</span></span>  
  
 <span data-ttu-id="690c6-109">這個類別具有<xref:System.Windows.Forms.Application.CurrentCulture%2A>和<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>屬性來取得或設定文化特性的目前執行緒的資訊。</span><span class="sxs-lookup"><span data-stu-id="690c6-109">This class has <xref:System.Windows.Forms.Application.CurrentCulture%2A> and <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> properties to get or set culture information for the current thread.</span></span>  
  
 <span data-ttu-id="690c6-110">您無法建立此類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="690c6-110">You cannot create an instance of this class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-111">下列程式碼範例會列出在表單上的清單方塊中的數字。</span><span class="sxs-lookup"><span data-stu-id="690c6-111">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="690c6-112">每次您按一下`button1`，應用程式會將另一個數字加入至清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-112">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="690c6-113">`Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，會建立表單，`listBox1`和`button1`。</span><span class="sxs-lookup"><span data-stu-id="690c6-113">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1` and `button1`.</span></span> <span data-ttu-id="690c6-114">當使用者按一下`button1`、`button1_Click`方法顯示<xref:System.Windows.Forms.MessageBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-114">When the user clicks `button1`, the `button1_Click` method displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="690c6-115">如果使用者按一下`No`上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法會將數字加入至清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-115">If the user clicks `No` on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds a number to the list.</span></span> <span data-ttu-id="690c6-116">如果使用者按一下`Yes`，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>處理所有剩餘的訊息佇列中，然後結束。</span><span class="sxs-lookup"><span data-stu-id="690c6-116">If the user clicks `Yes`, the application calls <xref:System.Windows.Forms.Application.Exit%2A> to process all remaining messages in the queue and then to quit.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-117">若要呼叫<xref:System.Windows.Forms.Application.Exit%2A>在部分信任中將會失敗。</span><span class="sxs-lookup"><span data-stu-id="690c6-117">The call to <xref:System.Windows.Forms.Application.Exit%2A> will fail in partial trust.</span></span>  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="690c6-118">您想要安裝的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 介面實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-118">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> interface you want to install.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-119">加入訊息篩選器，以在 Windows 訊息被傳送到它們的目的地時加以監視。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-119">Adds a message filter to monitor Windows messages as they are routed to their destinations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-120">若要避免引發特定事件或執行特殊作業之前它會傳遞至事件處理常式的事件，請使用訊息篩選條件。</span><span class="sxs-lookup"><span data-stu-id="690c6-120">Use a message filter to prevent specific events from being raised or to perform special operations for an event before it is passed to an event handler.</span></span> <span data-ttu-id="690c6-121">訊息篩選條件均是獨一無二特定執行緒。</span><span class="sxs-lookup"><span data-stu-id="690c6-121">Message filters are unique to a specific thread.</span></span>  
  
 <span data-ttu-id="690c6-122">若要防止訊息分派，`value`傳遞給這個方法的參數執行個體必須覆寫<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>方法的程式碼，以處理訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-122">To prevent a message from being dispatched, the `value` parameter instance that you pass to this method must override the <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> method with the code to handle the message.</span></span> <span data-ttu-id="690c6-123">此方法必須傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="690c6-123">The method must return `false`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-124">將訊息篩選條件加入至應用程式的訊息幫浦，可能會降低效能。</span><span class="sxs-lookup"><span data-stu-id="690c6-124">Adding message filters to the message pump for an application can degrade performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-125">下列程式碼範例會建立訊息篩選條件呼叫`TestMessageFilter`。</span><span class="sxs-lookup"><span data-stu-id="690c6-125">The following code example creates a message filter called `TestMessageFilter`.</span></span> <span data-ttu-id="690c6-126">此篩選條件區塊與滑鼠左的按鈕相關的所有訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-126">This filter blocks all messages relating to the left mouse button.</span></span> <span data-ttu-id="690c6-127">您可以使用訊息篩選條件之前，您必須提供實作<xref:System.Windows.Forms.IMessageFilter>介面。</span><span class="sxs-lookup"><span data-stu-id="690c6-127">Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.</span></span>  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-128">立即呼叫者呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-128">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="690c6-129">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-129">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-130">取得值，表示呼叫端是否可以終止這個應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-130">Gets a value indicating whether the caller can quit this application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-131">如果呼叫端可以終止這個應用程式，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-131">
              <see langword="true" /> if the caller can quit this application; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-132">這個屬性會傳回`false`如果它從呼叫<xref:System.Windows.Forms.Control>裝載 Web 瀏覽器中。</span><span class="sxs-lookup"><span data-stu-id="690c6-132">This property returns `false` if it is called from a <xref:System.Windows.Forms.Control> being hosted within a Web browser.</span></span> <span data-ttu-id="690c6-133">因此，<xref:System.Windows.Forms.Control>無法結束<xref:System.Windows.Forms.Application>。</span><span class="sxs-lookup"><span data-stu-id="690c6-133">Thus, the <xref:System.Windows.Forms.Control> cannot quit the <xref:System.Windows.Forms.Application>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-134">發生在應用程式即將關閉時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-134">Occurs when the application is about to shut down.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-135">您必須將附加事件處理常式，<xref:System.Windows.Forms.Application.Exit%2A>事件以執行未處理，應用程式停止執行之前的必要工作。</span><span class="sxs-lookup"><span data-stu-id="690c6-135">You must attach the event handlers to the <xref:System.Windows.Forms.Application.Exit%2A> event to perform unhandled, required tasks before the application stops running.</span></span> <span data-ttu-id="690c6-136">您可以關閉此應用程式或處置的物件記憶體回收沒有收回所開啟的檔案。</span><span class="sxs-lookup"><span data-stu-id="690c6-136">You can close files opened by this application, or dispose of objects that garbage collection did not reclaim.</span></span>  
  
 <span data-ttu-id="690c6-137">因為這是靜態事件，您必須中斷連結附加至這個事件中任何事件處理常式<xref:System.Windows.Forms.Application.ApplicationExit>本身的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-137">Because this is a static event, you must detach any event handlers attached to this event in the <xref:System.Windows.Forms.Application.ApplicationExit> event handler itself.</span></span> <span data-ttu-id="690c6-138">如果您不是這些處理常式的中斷連結，它們會維持附加至事件，並繼續消耗記憶體。</span><span class="sxs-lookup"><span data-stu-id="690c6-138">If you do not detach these handlers, they will remain attached to the event and continue to consume memory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-139">下列程式碼範例會顯示兩種形式，並結束應用程式，這兩個表單關閉時。</span><span class="sxs-lookup"><span data-stu-id="690c6-139">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="690c6-140">當應用程式啟動，並結束時，會記住每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-140">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="690c6-141">這個範例示範如何使用<xref:System.Windows.Forms.Application.ApplicationExit>事件，以瞭解當表單位置應該保存至檔案，以及當`FileStream`應該關閉。</span><span class="sxs-lookup"><span data-stu-id="690c6-141">This example demonstrates using the <xref:System.Windows.Forms.Application.ApplicationExit> event to know when the form positions should be persisted to the file, and when the `FileStream` should be closed.</span></span>  
  
 <span data-ttu-id="690c6-142">類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>並追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="690c6-142">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track of when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="690c6-143">類別在它關閉時，會記住每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-143">The class remembers the position of each form when it is closed.</span></span> <span data-ttu-id="690c6-144">當<xref:System.Windows.Forms.Application.ApplicationExit>事件發生時，類別會寫入檔案中的每個使用者的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-144">When the <xref:System.Windows.Forms.Application.ApplicationExit> event occurs, the class writes the positions of each for the user to the file.</span></span> <span data-ttu-id="690c6-145">表單位置的資料儲存在檔案標題為`appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-145">The form position data is stored in a file titled `appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="690c6-146">`Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。</span><span class="sxs-lookup"><span data-stu-id="690c6-146">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="690c6-147">此程式碼是摘錄自中顯示的範例<xref:System.Windows.Forms.ApplicationContext>類別概觀。</span><span class="sxs-lookup"><span data-stu-id="690c6-147">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="690c6-148">請參閱<xref:System.Windows.Forms.ApplicationContext>整個程式碼清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-148">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-149">取得所有使用者之間共用之應用程式資料的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-149">Gets the path for the application data that is shared among all users.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-150">所有使用者之間共用之應用程式資料的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-150">The path for the application data that is shared among all users.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-151">如果路徑不存在，會以下列格式建立一個：</span><span class="sxs-lookup"><span data-stu-id="690c6-151">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="690c6-152">*基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="690c6-152">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>  
  
 <span data-ttu-id="690c6-153"><xref:System.Windows.Forms.Application.ProductVersion%2A> 第一個查詢，包含主要可執行檔的組件是否具有`AssemblyInformationalVersion`在其上的屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-153"><xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it.</span></span> <span data-ttu-id="690c6-154">如果這個屬性存在，它同時用於<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-154">If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>.</span></span> <span data-ttu-id="690c6-155">如果這個屬性不存在，這兩個屬性改為使用可執行檔的版本。</span><span class="sxs-lookup"><span data-stu-id="690c6-155">If this attribute does not exist, both properties use the version of the executable file instead.</span></span>  
  
 <span data-ttu-id="690c6-156">路徑會根據在 Windows Forms 應用程式是否部署使用不同[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-156">The path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="690c6-157"> 應用程式會儲存在 C:\Documents and Settings 中的每個使用者應用程式快取\\*username*目錄。</span><span class="sxs-lookup"><span data-stu-id="690c6-157"> applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span> <span data-ttu-id="690c6-158">如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</span><span class="sxs-lookup"><span data-stu-id="690c6-158">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-159">取得所有使用者之間共用之應用程式資料的登錄機碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-159">Gets the registry key for the application data that is shared among all users.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-160">
            <see cref="T:Microsoft.Win32.RegistryKey" />，代表所有使用者之間共用之應用程式資料的登錄機碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-160">A <see cref="T:Microsoft.Win32.RegistryKey" /> representing the registry key of the application data that is shared among all users.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-161">如果索引鍵不存在，就會建立以下列格式：</span><span class="sxs-lookup"><span data-stu-id="690c6-161">If the key does not exist, it is created in the following format:</span></span>  
  
 <span data-ttu-id="690c6-162">LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="690c6-162">LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-163">取得與應用程式關聯的公司名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-163">Gets the company name associated with the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-164">公司名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-164">The company name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="690c6-165">下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。</span><span class="sxs-lookup"><span data-stu-id="690c6-165">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="690c6-166">這個範例需要`textBox1`已放在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-166">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-167">取得或設定目前執行緒的文化特性資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-167">Gets or sets the culture information for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-168">
            <see cref="T:System.Globalization.CultureInfo" />，代表目前執行緒的文化特性資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-168">A <see cref="T:System.Globalization.CultureInfo" /> representing the culture information for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="690c6-169">下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。</span><span class="sxs-lookup"><span data-stu-id="690c6-169">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="690c6-170">這個範例需要`textBox1`已放在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-170">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="690c6-171">若要設定此屬性的所有視窗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-171">for all windows to set this property.</span>
          </span>
          <span data-ttu-id="690c6-172">相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-172">Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-173">取得或設定目前執行緒的目前輸入語言。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-173">Gets or sets the current input language for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-174">
            <see cref="T:System.Windows.Forms.InputLanguage" />，代表目前執行緒的目前輸入語言。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-174">An <see cref="T:System.Windows.Forms.InputLanguage" /> representing the current input language for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="690c6-175">下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。</span><span class="sxs-lookup"><span data-stu-id="690c6-175">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="690c6-176">這個範例需要`textBox1`已放在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-176">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-177">立即呼叫者呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-177">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="690c6-178">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-178">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-179">處理目前在訊息佇列中的所有 Windows 訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-179">Processes all Windows messages currently in the message queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-180">當您執行 Windows Form 時，它會建立新的表單中，然後等候處理的事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-180">When you run a Windows Form, it creates the new form, which then waits for events to handle.</span></span> <span data-ttu-id="690c6-181">表單處理事件時，每次它處理與該事件相關聯的所有程式碼。</span><span class="sxs-lookup"><span data-stu-id="690c6-181">Each time the form handles an event, it processes all the code associated with that event.</span></span> <span data-ttu-id="690c6-182">在佇列中等候所有其他事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-182">All other events wait in the queue.</span></span> <span data-ttu-id="690c6-183">當您的程式碼處理事件時，您的應用程式沒有回應。</span><span class="sxs-lookup"><span data-stu-id="690c6-183">While your code handles the event, your application does not respond.</span></span> <span data-ttu-id="690c6-184">例如，視窗不會重新繪製如果拖曳至另一個視窗頂端。</span><span class="sxs-lookup"><span data-stu-id="690c6-184">For example, the window does not repaint if another window is dragged on top.</span></span>  
  
 <span data-ttu-id="690c6-185">如果您呼叫<xref:System.Windows.Forms.Application.DoEvents%2A>程式碼，在您的應用程式可以處理其他事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-185">If you call <xref:System.Windows.Forms.Application.DoEvents%2A> in your code, your application can handle the other events.</span></span> <span data-ttu-id="690c6-186">例如，如果您有將資料加入至表單<xref:System.Windows.Forms.ListBox>並加入<xref:System.Windows.Forms.Application.DoEvents%2A>至程式碼，您的表單會重新繪製其拖曳至另一個視窗時。</span><span class="sxs-lookup"><span data-stu-id="690c6-186">For example, if you have a form that adds data to a <xref:System.Windows.Forms.ListBox> and add <xref:System.Windows.Forms.Application.DoEvents%2A> to your code, your form repaints when another window is dragged over it.</span></span> <span data-ttu-id="690c6-187">如果您移除<xref:System.Windows.Forms.Application.DoEvents%2A>從程式碼中，您的表單將不重新繪製按鈕的 click 事件處理常式完成之前執行。</span><span class="sxs-lookup"><span data-stu-id="690c6-187">If you remove <xref:System.Windows.Forms.Application.DoEvents%2A> from your code, your form will not repaint until the click event handler of the button is finished executing.</span></span> <span data-ttu-id="690c6-188">如需有關訊息的詳細資訊，請參閱[Windows Form 中的使用者輸入](~/docs/framework/winforms/user-input-in-windows-forms.md)。</span><span class="sxs-lookup"><span data-stu-id="690c6-188">For more information on messaging, see [User Input in Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).</span></span>  
  
 <span data-ttu-id="690c6-189">與不同的是 Visual Basic 6.0<xref:System.Windows.Forms.Application.DoEvents%2A>方法不會呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-189">Unlike Visual Basic 6.0, the <xref:System.Windows.Forms.Application.DoEvents%2A> method does not call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="690c6-190">一般而言，您可以使用這個方法來處理訊息迴圈中。</span><span class="sxs-lookup"><span data-stu-id="690c6-190">Typically, you use this method in a loop to process messages.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-191">呼叫這個方法會導致所有等候的視窗訊息都處理時，暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="690c6-191">Calling this method causes the current thread to be suspended while all waiting window messages are processed.</span></span> <span data-ttu-id="690c6-192">如果訊息導致觸發事件，可能會執行的應用程式程式碼其他區域。</span><span class="sxs-lookup"><span data-stu-id="690c6-192">If a message causes an event to be triggered, then other areas of your application code may execute.</span></span> <span data-ttu-id="690c6-193">這會造成您的應用程式發生非預期的行為很難進行偵錯。</span><span class="sxs-lookup"><span data-stu-id="690c6-193">This can cause your application to exhibit unexpected behaviors that are difficult to debug.</span></span> <span data-ttu-id="690c6-194">如果您執行作業或需要長時間的計算，通常最好是執行新的執行緒上的那些作業。</span><span class="sxs-lookup"><span data-stu-id="690c6-194">If you perform operations or computations that take a long time, it is often preferable to perform those operations on a new thread.</span></span> <span data-ttu-id="690c6-195">如需有關非同步程式設計的詳細資訊，請參閱[非同步程式設計模型 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)。</span><span class="sxs-lookup"><span data-stu-id="690c6-195">For more information about asynchronous programming, see [Asynchronous Programming Model (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-196">下列程式碼範例示範如何使用<xref:System.Windows.Forms.Application.DoEvents%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-196">The following code example demonstrates using the <xref:System.Windows.Forms.Application.DoEvents%2A> method.</span></span> <span data-ttu-id="690c6-197">此範例執行時，使用者可以選取從圖形檔<xref:System.Windows.Forms.OpenFileDialog>。</span><span class="sxs-lookup"><span data-stu-id="690c6-197">When the example runs, a user can select graphics files from an <xref:System.Windows.Forms.OpenFileDialog>.</span></span> <span data-ttu-id="690c6-198">選取的檔案會顯示在表單中。</span><span class="sxs-lookup"><span data-stu-id="690c6-198">The selected files are displayed in the form.</span></span> <span data-ttu-id="690c6-199"><xref:System.Windows.Forms.Application.DoEvents%2A>方法會強制重新繪製的每個圖形開啟的檔案格式。</span><span class="sxs-lookup"><span data-stu-id="690c6-199">The <xref:System.Windows.Forms.Application.DoEvents%2A> method forces a repaint of the form for each graphics file opened.</span></span> <span data-ttu-id="690c6-200">若要執行此範例中，貼上下列程式碼中表單，其中包含<xref:System.Windows.Forms.PictureBox>名為`PictureBox1`、<xref:System.Windows.Forms.OpenFileDialog>名為`OpenFileDialog1`，和名為按鈕`fileButton`。</span><span class="sxs-lookup"><span data-stu-id="690c6-200">To run this example, paste the following code in a form containing a <xref:System.Windows.Forms.PictureBox> named `PictureBox1`, an <xref:System.Windows.Forms.OpenFileDialog> named `OpenFileDialog1`, and a button named `fileButton`.</span></span> <span data-ttu-id="690c6-201">呼叫`InitializePictureBox`和`InitializeOpenFileDialog`從表單的建構函式的方法或`Load`方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-201">Call the `InitializePictureBox` and `InitializeOpenFileDialog` methods from the form's constructor or `Load` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-202">在 Visual Studio 中，如果您將加入<xref:System.Windows.Forms.OpenFileDialog>至您使用拖放作業的表單，您就必須修改下列`InitializeOpenFileDialog`方法藉由移除建立的新執行個體的行<xref:System.Windows.Forms.OpenFileDialog>。</span><span class="sxs-lookup"><span data-stu-id="690c6-202">In Visual Studio, if you add an <xref:System.Windows.Forms.OpenFileDialog> to your form by using a drag operation, you will have to modify the following `InitializeOpenFileDialog` method by removing the line that creates a new instance of <xref:System.Windows.Forms.OpenFileDialog>.</span></span>  
  
 <span data-ttu-id="690c6-203">這個範例也需要<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>事件<xref:System.Windows.Forms.Button>控制項和<xref:System.Windows.Forms.FileDialog.FileOk>事件<xref:System.Windows.Forms.OpenFileDialog>連線到範例中定義的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-203">The example also requires that the <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> event of the <xref:System.Windows.Forms.Button> control and the <xref:System.Windows.Forms.FileDialog.FileOk> event of the <xref:System.Windows.Forms.OpenFileDialog> are connected to the event handlers defined in the example.</span></span> <span data-ttu-id="690c6-204">執行範例時，請按一下按鈕顯示對話方塊。</span><span class="sxs-lookup"><span data-stu-id="690c6-204">When the example is running, display the dialog box by clicking the button.</span></span>  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-205">為應用程式啟用視覺化樣式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-205">Enables visual styles for the application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-206">這個方法可讓應用程式的視覺化樣式。</span><span class="sxs-lookup"><span data-stu-id="690c6-206">This method enables visual styles for the application.</span></span> <span data-ttu-id="690c6-207">視覺化樣式，則色彩、 字型和其他視覺化項目形成作業系統佈景主題。</span><span class="sxs-lookup"><span data-stu-id="690c6-207">Visual styles are the colors, fonts, and other visual elements that form an operating system theme.</span></span> <span data-ttu-id="690c6-208">如果控制項與作業系統支援，會使用視覺化樣式繪製控制項。</span><span class="sxs-lookup"><span data-stu-id="690c6-208">Controls will draw with visual styles if the control and the operating system support it.</span></span> <span data-ttu-id="690c6-209">產生的效果，<xref:System.Windows.Forms.Application.EnableVisualStyles>必須先呼叫才能建立應用程式; 中的任何控制項通常<xref:System.Windows.Forms.Application.EnableVisualStyles>中的第一行`Main`函式。</span><span class="sxs-lookup"><span data-stu-id="690c6-209">To have an effect, <xref:System.Windows.Forms.Application.EnableVisualStyles> must be called before creating any controls in the application; typically, <xref:System.Windows.Forms.Application.EnableVisualStyles> is the first line in the `Main` function.</span></span> <span data-ttu-id="690c6-210">不需要個別的資訊清單呼叫時，啟用視覺化樣式<xref:System.Windows.Forms.Application.EnableVisualStyles>。</span><span class="sxs-lookup"><span data-stu-id="690c6-210">A separate manifest is not required to enable visual styles when calling <xref:System.Windows.Forms.Application.EnableVisualStyles>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-211">在.NET Framework 2.0 中前,`FlatStyle`部分控制項，例如衍生自控制項的屬性<xref:System.Windows.Forms.ButtonBase>，必須設定為<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>若要使用視覺化樣式繪製控制項的順序。</span><span class="sxs-lookup"><span data-stu-id="690c6-211">Prior to the .NET Framework 2.0, the `FlatStyle` property of some controls, such as controls that derive from <xref:System.Windows.Forms.ButtonBase>, had to be set to <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> in order for the controls to be drawn with visual styles.</span></span> <span data-ttu-id="690c6-212">在以.NET Framework 2.0 撰寫的應用程式，這是不再需要。</span><span class="sxs-lookup"><span data-stu-id="690c6-212">In applications written with the .NET Framework 2.0, this is no longer necessary.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-213">這個方法不會影響的控制項裝載於 Internet Explorer。</span><span class="sxs-lookup"><span data-stu-id="690c6-213">This method will have no effect for controls hosted in Internet Explorer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-214">下列程式碼範例示範呼叫<xref:System.Windows.Forms.Application.EnableVisualStyles%2A>中`Main`函式來啟用應用程式的視覺化樣式。</span><span class="sxs-lookup"><span data-stu-id="690c6-214">The following code example demonstrates calling <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> in the `Main` function to enable visual styles for the application.</span></span>  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-215">在應用程式即將進入強制回應狀態時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-215">Occurs when the application is about to enter a modal state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-216">因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-216">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-217">下列程式碼範例示範如何使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="690c6-217">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="690c6-218">在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.EnterThreadModal>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-218">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.EnterThreadModal> event.</span></span> <span data-ttu-id="690c6-219">此報表可協助您了解事件發生的時機，並可協助您偵錯。</span><span class="sxs-lookup"><span data-stu-id="690c6-219">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="690c6-220">若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-220">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="690c6-221">若要執行範例程式碼，將它貼到 Windows Form 並確認事件處理常式關聯<xref:System.Windows.Forms.Application.EnterThreadModal>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-221">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.EnterThreadModal> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-222">需要<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />接聽事件的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-222">Requires <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> permission to listen to the event.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-223">取得啟動應用程式的可執行檔路徑，包括檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-223">Gets the path for the executable file that started the application, including the executable name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-224">啟動應用程式的可執行檔路徑和檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-224">The path and executable name for the executable file that started the application.</span>
          </span>
          <span data-ttu-id="690c6-225">這個路徑會依據是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 來部署 Windows Forms 應用程式而有所不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-225">This path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span>
          </span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="690c6-226"> 應用程式會儲存在 C:\Documents and Settings 中的每個使用者應用程式快取\\*username*目錄。</span><span class="sxs-lookup"><span data-stu-id="690c6-226"> applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span><span data-ttu-id="690c6-227">如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</span><span class="sxs-lookup"><span data-stu-id="690c6-227">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="690c6-228">取得路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-228">for getting the path.</span>
          </span>
          <span data-ttu-id="690c6-229">相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-229">Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-230">通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-230">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-231">通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-231">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-232"><xref:System.Windows.Forms.Application.Exit%2A>方法會停止所有執行緒上的所有執行訊息迴圈，並關閉應用程式的所有視窗。</span><span class="sxs-lookup"><span data-stu-id="690c6-232">The <xref:System.Windows.Forms.Application.Exit%2A> method stops all running message loops on all threads and closes all windows of the application.</span></span> <span data-ttu-id="690c6-233">這個方法不一定會強制結束應用程式。</span><span class="sxs-lookup"><span data-stu-id="690c6-233">This method does not necessarily force the application to exit.</span></span> <span data-ttu-id="690c6-234"><xref:System.Windows.Forms.Application.Exit%2A>方法通常從呼叫內的訊息迴圈，並強制<xref:System.Windows.Forms.Application.Run%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="690c6-234">The <xref:System.Windows.Forms.Application.Exit%2A> method is typically called from within a message loop, and forces <xref:System.Windows.Forms.Application.Run%2A> to return.</span></span> <span data-ttu-id="690c6-235">若要結束目前執行緒的訊息迴圈，請呼叫<xref:System.Windows.Forms.Application.ExitThread%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-235">To exit a message loop for the current thread only, call <xref:System.Windows.Forms.Application.ExitThread%2A>.</span></span>  
  
 <span data-ttu-id="690c6-236"><xref:System.Windows.Forms.Application.Exit%2A> 會引發下列事件，並執行相關聯的條件動作：</span><span class="sxs-lookup"><span data-stu-id="690c6-236"><xref:System.Windows.Forms.Application.Exit%2A> raises the following events and performs the associated conditional actions:</span></span>  
  
-   <span data-ttu-id="690c6-237">A<xref:System.Windows.Forms.Form.FormClosing>引發由每個表單<xref:System.Windows.Forms.Application.OpenForms%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-237">A <xref:System.Windows.Forms.Form.FormClosing> event is raised for every form represented by the <xref:System.Windows.Forms.Application.OpenForms%2A> property.</span></span> <span data-ttu-id="690c6-238">這個事件可以藉由設定取消<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性其<xref:System.Windows.Forms.FormClosingEventArgs>參數`true`。</span><span class="sxs-lookup"><span data-stu-id="690c6-238">This event can be canceled by setting the <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> property of their <xref:System.Windows.Forms.FormClosingEventArgs> parameter to `true`.</span></span>  
  
-   <span data-ttu-id="690c6-239">如果一或多個處理常式會取消事件，然後<xref:System.Windows.Forms.Application.Exit%2A>傳回不需要進一步動作。</span><span class="sxs-lookup"><span data-stu-id="690c6-239">If one of more of the handlers cancels the event, then <xref:System.Windows.Forms.Application.Exit%2A> returns without further action.</span></span> <span data-ttu-id="690c6-240">否則，<xref:System.Windows.Forms.Form.FormClosed>就會引發事件，每個開啟的表單，則會關閉所有正在執行訊息迴圈和表單。</span><span class="sxs-lookup"><span data-stu-id="690c6-240">Otherwise, a <xref:System.Windows.Forms.Form.FormClosed> event is raised for every open form, then all running message loops and forms are closed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-241"><xref:System.Windows.Forms.Application.Exit%2A>方法不會引發<xref:System.Windows.Forms.Form.Closed>和<xref:System.Windows.Forms.Form.Closing>事件，也就是過時的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-241">The <xref:System.Windows.Forms.Application.Exit%2A> method does not raise the <xref:System.Windows.Forms.Form.Closed> and <xref:System.Windows.Forms.Form.Closing> events, which are obsolete as of [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-242">下列程式碼範例會列出在表單上的清單方塊中的數字。</span><span class="sxs-lookup"><span data-stu-id="690c6-242">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="690c6-243">每次您按一下`button1`，應用程式會將另一個數字加入至清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-243">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="690c6-244">`Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，會建立表單， `listBox1`，和`button1`。</span><span class="sxs-lookup"><span data-stu-id="690c6-244">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`.</span></span> <span data-ttu-id="690c6-245">當使用者按一下`button1`、`button1_Click`方法將數字一到三個清單方塊中，並顯示<xref:System.Windows.Forms.MessageBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-245">When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="690c6-246">如果使用者按一下**否**上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法會將另一個數字加入至清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-246">If the user clicks **No** on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list.</span></span> <span data-ttu-id="690c6-247">如果使用者按一下**是**，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>，來處理所有剩餘的訊息佇列中，然後結束。</span><span class="sxs-lookup"><span data-stu-id="690c6-247">If the user clicks **Yes**, the application calls <xref:System.Windows.Forms.Application.Exit%2A>, to process all remaining messages in the queue and then to quit.</span></span>  
  
 <span data-ttu-id="690c6-248">這個範例需要`listBox1`和`button1`具現化並放置在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-248">The example requires that `listBox1` and `button1` have been instantiated and placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-249">立即呼叫者呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-249">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="690c6-250">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-250">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="690c6-251">傳回在應用程式內是否有任何 <see cref="T:System.Windows.Forms.Form" /> 取消結束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-251">Returns whether any <see cref="T:System.Windows.Forms.Form" /> within the application cancelled the exit.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-252">通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-252">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">
          <span data-ttu-id="690c6-253">結束正在執行的權限的應用程式執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-253">For permission to terminate a running application thread.</span>
          </span>
          <span data-ttu-id="690c6-254">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-254">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-255">結束目前執行緒的訊息迴圈，並關閉執行緒上的所有視窗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-255">Exits the message loop on the current thread and closes all windows on the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-256">您可以使用這個方法來結束目前執行緒的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="690c6-256">Use this method to exit the message loop of the current thread.</span></span> <span data-ttu-id="690c6-257">這個方法會導致呼叫<xref:System.Windows.Forms.Application.Run%2A>傳回目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="690c6-257">This method causes the call to <xref:System.Windows.Forms.Application.Run%2A> for the current thread to return.</span></span> <span data-ttu-id="690c6-258">若要結束整個應用程式，請呼叫<xref:System.Windows.Forms.Application.Exit%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-258">To exit the entire application, call <xref:System.Windows.Forms.Application.Exit%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-259">立即呼叫者呼叫 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-259">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="690c6-260">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="690c6-261">要篩選的 Windows 事件訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-261">The Windows event message to filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-262">針對視窗訊息執行任何篩選條件，並傳回已修改訊息的複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-262">Runs any filters against a window message, and returns a copy of the modified message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="690c6-263">如果已處理篩選，則為 <see langword="True" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-263">
              <see langword="True" /> if the filters were processed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-264">發生在應用程式處理完畢並即將進入閒置 (Idle) 狀態時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-264">Occurs when the application finishes processing and is about to enter the idle state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-265">如果您有必須執行的工作在執行緒閒置之前，將它們附加至這個事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-265">If you have tasks that you must perform before the thread becomes idle, attach them to this event.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-266">因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-266">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-267">下列程式碼範例示範如何使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="690c6-267">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="690c6-268">在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.Idle>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-268">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.Idle> event.</span></span> <span data-ttu-id="690c6-269">此報表可協助您了解事件發生的時機，並可協助您偵錯。</span><span class="sxs-lookup"><span data-stu-id="690c6-269">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="690c6-270">若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-270">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="690c6-271">若要執行範例程式碼，將它貼到 Windows Form，並確定事件處理常式都與<xref:System.Windows.Forms.Application.Idle>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-271">To run the example code, paste it into a Windows Form and make sure that the event handler is associated with the <xref:System.Windows.Forms.Application.Idle> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-272">在應用程式即將離開強制回應狀態時發生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-272">Occurs when the application is about to leave a modal state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-273">因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-273">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-274">下列程式碼範例示範如何使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="690c6-274">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="690c6-275">在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-275">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.LeaveThreadModal> event.</span></span> <span data-ttu-id="690c6-276">此報表可協助您了解事件發生的時機，並可協助您偵錯。</span><span class="sxs-lookup"><span data-stu-id="690c6-276">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="690c6-277">若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-277">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="690c6-278">若要執行範例程式碼，將它貼到 Windows Form 並確認事件處理常式關聯<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-278">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.LeaveThreadModal> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-279">取得本機非漫遊使用者的應用程式資料路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-279">Gets the path for the application data of a local, non-roaming user.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-280">本機非漫遊使用者的應用程式資料路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-280">The path for the application data of a local, non-roaming user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-281">本機使用者，是其使用者設定檔儲存在使用者登入所在系統上。</span><span class="sxs-lookup"><span data-stu-id="690c6-281">A local user is one whose user profile is stored on the system on which the user logged on.</span></span> <span data-ttu-id="690c6-282">如果路徑不存在，會以下列格式建立一個：</span><span class="sxs-lookup"><span data-stu-id="690c6-282">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="690c6-283">*基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="690c6-283">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 <span data-ttu-id="690c6-284">典型的基底路徑是 C:\Documents and Settings\\*username*\Local Settings\Application 資料。</span><span class="sxs-lookup"><span data-stu-id="690c6-284">A typical base path is C:\Documents and Settings\\*username*\Local Settings\Application Data.</span></span> <span data-ttu-id="690c6-285">這個路徑可能會不同，不過，如果在 Windows Forms 應用程式部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-285">This path will be different, however, if the Windows Forms application is deployed by using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="690c6-286"> 建立自己的應用程式資料目錄，且與所有其他應用程式隔離。</span><span class="sxs-lookup"><span data-stu-id="690c6-286"> creates its own application data directory that is isolated from all other applications.</span></span> <span data-ttu-id="690c6-287">如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</span><span class="sxs-lookup"><span data-stu-id="690c6-287">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-288">下列程式碼範例會顯示兩種形式，並結束應用程式，這兩個表單關閉時。</span><span class="sxs-lookup"><span data-stu-id="690c6-288">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="690c6-289">當應用程式啟動，並結束時，會記住每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-289">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="690c6-290">雖然此範例示範如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>屬性來儲存使用者的應用程式資料<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>可改為使用。</span><span class="sxs-lookup"><span data-stu-id="690c6-290">Although this example demonstrates using the <xref:System.Windows.Forms.Application.UserAppDataPath%2A> property to store application data for the user, the <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> can be used instead.</span></span>  
  
 <span data-ttu-id="690c6-291">`MyApplicationContext`類別繼承自<xref:System.Windows.Forms.ApplicationContext>和會持續追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="690c6-291">The `MyApplicationContext` class inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="690c6-292">類別會儲存使用者的每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-292">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="690c6-293">表單位置的資料儲存在檔案標題為`Appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-293">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="690c6-294">`Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。</span><span class="sxs-lookup"><span data-stu-id="690c6-294">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="690c6-295">此程式碼是摘錄自中顯示的範例<xref:System.Windows.Forms.ApplicationContext>類別概觀。</span><span class="sxs-lookup"><span data-stu-id="690c6-295">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="690c6-296">為了簡潔起見，不會顯示一些程式碼。</span><span class="sxs-lookup"><span data-stu-id="690c6-296">Some code is not shown for the purpose of brevity.</span></span> <span data-ttu-id="690c6-297">請參閱<xref:System.Windows.Forms.ApplicationContext>整個程式碼清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-297">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-298">取得值，表示訊息迴圈是否存在於這個執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-298">Gets a value indicating whether a message loop exists on this thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-299">如果訊息迴圈存在，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-299">
              <see langword="true" /> if a message loop exists; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-300">在其他環境，例如未受管理的應用程式中裝載 Windows Form 時一律會傳回這個屬性`false`。</span><span class="sxs-lookup"><span data-stu-id="690c6-300">When hosting Windows Forms in other environments, such as unmanaged applications, this property will always return `false`.</span></span> <span data-ttu-id="690c6-301">使用<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>指示 Windows Form 裝載環境如果仍有作用中的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="690c6-301">Use <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> to instruct Windows Forms if the hosting environment still has an active message loop.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-302">初始化目前執行緒上的 OLE。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-302">Initializes OLE on the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="690c6-303">其中一個 <see cref="T:System.Threading.ApartmentState" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-303">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-304">呼叫這個方法之前呼叫任何`Microsoft.Win32`需要 OLE 的方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-304">Call this method before calling any `Microsoft.Win32` method that requires OLE.</span></span> <span data-ttu-id="690c6-305"><xref:System.Windows.Forms.Application.OleRequired%2A> 第一次檢查目前的執行緒上的 OLE 是否尚未初始化。</span><span class="sxs-lookup"><span data-stu-id="690c6-305"><xref:System.Windows.Forms.Application.OleRequired%2A> first checks to see if OLE has been initialized on the current thread.</span></span> <span data-ttu-id="690c6-306">如果沒有，它會在執行緒初始化 ole。</span><span class="sxs-lookup"><span data-stu-id="690c6-306">If not, it initializes the thread for OLE.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-307">執行緒會直接呼叫 OLE 方法，除非您不需要呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-307">Unless a thread calls OLE methods directly, you do not need to call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="690c6-308">
            <see cref="T:System.Exception" />，代表擲回的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-308">An <see cref="T:System.Exception" /> that represents the exception that was thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-309">引發 <see cref="E:System.Windows.Forms.Application.ThreadException" /> 事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-309">Raises the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-310">呼叫<xref:System.Windows.Forms.Application.OnThreadException%2A>引發例外狀況，將會暫止處理的應用程式。</span><span class="sxs-lookup"><span data-stu-id="690c6-310">Call <xref:System.Windows.Forms.Application.OnThreadException%2A> to raise an exception that will halt processing of the application.</span></span>  
  
 <span data-ttu-id="690c6-311"><xref:System.Windows.Forms.Application>類別具有<xref:System.Windows.Forms.Application.ThreadException>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-311">The <xref:System.Windows.Forms.Application> class has a <xref:System.Windows.Forms.Application.ThreadException> event.</span></span> <span data-ttu-id="690c6-312">您可以將事件處理常式附加至這個事件，進行任何自訂處理，您需要的未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-312">You can attach an event handler to this event to do whatever custom processing you need for unhandled exceptions.</span></span> <span data-ttu-id="690c6-313">如果您不要附加事件處理常式，<xref:System.Windows.Forms.Application.OnThreadException%2A>會執行預設行為，這牽涉到顯示對話方塊通知使用者已經發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="690c6-313">If you do not attach an event handler, <xref:System.Windows.Forms.Application.OnThreadException%2A> will execute the default behavior, which involves displaying a dialog box to inform the user that there has been an error.</span></span>  
  
 <span data-ttu-id="690c6-314"><xref:System.Windows.Forms.Application.OnThreadException%2A> 只會在 Windows Form 所擁有的執行緒上實作，會發生未處理例外狀況的預設例外狀況行為。</span><span class="sxs-lookup"><span data-stu-id="690c6-314"><xref:System.Windows.Forms.Application.OnThreadException%2A> only implements default exception behavior for unhandled exceptions that occur on threads owned by Windows Forms.</span></span> <span data-ttu-id="690c6-315">在其他執行緒的未處理例外狀況會由<xref:System.AppDomain.UnhandledException>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-315">Unhandled exceptions on other threads are handled by the <xref:System.AppDomain.UnhandledException> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-316">取得應用程式所擁有之開啟表單的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-316">Gets a collection of open forms owned by the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-317">
            <see cref="T:System.Windows.Forms.FormCollection" />，包含所有由這個應用程式所擁有而目前已開啟的表單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-317">A <see cref="T:System.Windows.Forms.FormCollection" /> containing all the currently open forms owned by this application.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-318"><xref:System.Windows.Forms.Application.OpenForms%2A>屬性表示應用程式所擁有之表單的唯讀集合。</span><span class="sxs-lookup"><span data-stu-id="690c6-318">The <xref:System.Windows.Forms.Application.OpenForms%2A> property represents a read-only collection of forms owned by the application.</span></span> <span data-ttu-id="690c6-319">此集合可供搜尋，依索引位置，或由<xref:System.Windows.Forms.Control.Name%2A>的<xref:System.Windows.Forms.Form>。</span><span class="sxs-lookup"><span data-stu-id="690c6-319">This collection can be searched by index position or by the <xref:System.Windows.Forms.Control.Name%2A> of the <xref:System.Windows.Forms.Form>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="690c6-320">呼叫端必須具有存取所有的 windows 權限所定義<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />值<see cref="T:System.Security.Permissions.UIPermissionWindow" />列舉型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-320">Caller must have permission to access all windows, as defined by the <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> value of the <see cref="T:System.Security.Permissions.UIPermissionWindow" /> enumeration.</span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-321">取得與這個應用程式關聯的產品名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-321">Gets the product name associated with this application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-322">產品名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-322">The product name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-323">`ProductName` 取自包含目前應用程式的主要表單的組件的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="690c6-323">`ProductName` is taken from the metadata of the assembly containing the main form of the current application.</span></span> <span data-ttu-id="690c6-324">您可以設定來設定<xref:System.Reflection.AssemblyProductAttribute>內組件資訊清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-324">You can set it by setting <xref:System.Reflection.AssemblyProductAttribute> inside of your assembly manifest.</span></span> <span data-ttu-id="690c6-325">如需詳細資訊，請參閱[組件資訊清單](~/docs/framework/app-domains/assembly-manifest.md)。</span><span class="sxs-lookup"><span data-stu-id="690c6-325">For more information, see [Assembly Manifest](~/docs/framework/app-domains/assembly-manifest.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-326">下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。</span><span class="sxs-lookup"><span data-stu-id="690c6-326">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="690c6-327">這個範例需要`textBox1`已放在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-327">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-328">取得與這個應用程式關聯的產品版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-328">Gets the product version associated with this application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-329">產品版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-329">The product version.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-330">一般而言，版本號碼會顯示為*主要號碼*。*次要號碼*。*組建編號*。*私用部分號碼*。</span><span class="sxs-lookup"><span data-stu-id="690c6-330">Typically, a version number displays as *major number*.*minor number*.*build number*.*private part number*.</span></span> <span data-ttu-id="690c6-331">您可以將其明確地設定您的組件資訊清單中的組件版本。</span><span class="sxs-lookup"><span data-stu-id="690c6-331">You can set it explicitly by setting the assembly version within your assembly manifest.</span></span> <span data-ttu-id="690c6-332">如需詳細資訊，請參閱[組件資訊清單](~/docs/framework/app-domains/assembly-manifest.md)。</span><span class="sxs-lookup"><span data-stu-id="690c6-332">For more information, see [Assembly Manifest](~/docs/framework/app-domains/assembly-manifest.md).</span></span>  
  
 <span data-ttu-id="690c6-333"><xref:System.Windows.Forms.Application.ProductVersion%2A> 第一個查詢，包含主要可執行檔的組件是否具有`AssemblyInformationalVersion`在其上的屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-333"><xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it.</span></span> <span data-ttu-id="690c6-334">如果這個屬性存在，它同時用於<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-334">If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>.</span></span> <span data-ttu-id="690c6-335">如果這個屬性不存在，這兩個屬性改為使用可執行檔的版本。</span><span class="sxs-lookup"><span data-stu-id="690c6-335">If this attribute does not exist, both properties use the version of the executable file instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-336">下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。</span><span class="sxs-lookup"><span data-stu-id="690c6-336">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="690c6-337">這個範例需要`textBox1`已放在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-337">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="690c6-338">傳遞至 <see cref="T:System.EventArgs" /> 事件的 <see cref="E:System.Windows.Forms.Application.Idle" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-338">The <see cref="T:System.EventArgs" /> objects to pass to the <see cref="E:System.Windows.Forms.Application.Idle" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-339">引發裝載案例中的 <see cref="E:System.Windows.Forms.Application.Idle" /> 事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-339">Raises the <see cref="E:System.Windows.Forms.Application.Idle" /> event in hosted scenarios.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-340">裝載 Windows Form 中另一個環境，例如 unmanaged 應用程式時，會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-340">This method is used when hosting Windows Forms in another environment, such as an unmanaged application.</span></span> <span data-ttu-id="690c6-341">您應該呼叫<xref:System.Windows.Forms.Application.RaiseIdle%2A>裝載的應用程式時進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="690c6-341">You should call <xref:System.Windows.Forms.Application.RaiseIdle%2A> when the hosting application enters an idle state.</span></span> <span data-ttu-id="690c6-342">這可讓某些 Windows Form 控制項和元件來執行重要的背景工作，而不在使用者與應用程式互動。</span><span class="sxs-lookup"><span data-stu-id="690c6-342">This enables some Windows Forms controls and components to do important background work while the user is not interacting with the application.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="690c6-343">方法，用於在 Windows Form 需要檢查裝載環境是否仍在傳送訊息時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-343">The method to call when Windows Forms needs to check if the hosting environment is still sending messages.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-344">註冊回呼 (Callback)，以檢查訊息迴圈是否在裝載環境中執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-344">Registers a callback for checking whether the message loop is running in hosted environments.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-345">裝載 Windows Form 中另一個環境，例如 unmanaged 應用程式時，會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-345">This method is used when hosting Windows Forms in another environment, such as an unmanaged application.</span></span> <span data-ttu-id="690c6-346">在裝載環境中，<xref:System.Windows.Forms.Application.MessageLoop%2A>屬性永遠會傳回 false，如果不在 Windows Form 處理訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-346">In hosted environments, the <xref:System.Windows.Forms.Application.MessageLoop%2A> property will always return false if Windows Forms is not processing messages.</span></span> <span data-ttu-id="690c6-347">使用這個回呼來告訴 Windows Form 是否裝載環境仍在處理訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-347">Use this callback to tell Windows Forms if the hosting environment is still processing messages.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="690c6-348">要從應用程式中移除之 <see cref="T:System.Windows.Forms.IMessageFilter" /> 的實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-348">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> to remove from the application.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-349">從應用程式的訊息幫浦移除訊息篩選器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-349">Removes a message filter from the message pump of the application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-350">當您不再想要再分派這些擷取 Windows 訊息時，您可以移除訊息篩選條件。</span><span class="sxs-lookup"><span data-stu-id="690c6-350">You can remove a message filter when you no longer want to capture Windows messages before they are dispatched.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-351">您可以使用訊息篩選條件之前，您必須提供實作<xref:System.Windows.Forms.IMessageFilter>介面。</span><span class="sxs-lookup"><span data-stu-id="690c6-351">Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.</span></span> <span data-ttu-id="690c6-352">下列類別會建立訊息篩選條件呼叫`TestMessageFilter`。</span><span class="sxs-lookup"><span data-stu-id="690c6-352">The following class creates a message filter called `TestMessageFilter`.</span></span> <span data-ttu-id="690c6-353">此篩選條件區塊與滑鼠左的按鈕相關的所有訊息。</span><span class="sxs-lookup"><span data-stu-id="690c6-353">This filter blocks all messages relating to the left mouse button.</span></span>  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-354">取得值，設定目前的應用程式是否以視覺化樣式繪製控制項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-354">Gets a value specifying whether the current application is drawing controls with visual styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-355">如果已在應用程式視窗的工作區中為控制項啟用視覺化樣式，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-355">
              <see langword="true" /> if visual styles are enabled for controls in the client area of application windows; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-356">如果您要繪製的自訂控制項，請使用這個屬性來決定是否要繪製的控制項，不論視覺化樣式，使其外觀與應用程式中其他控制項一致。</span><span class="sxs-lookup"><span data-stu-id="690c6-356">If you are drawing a custom control, use this property to decide whether to draw the control with or without visual styles, so that its appearance is consistent with other controls in the application.</span></span>  
  
 <span data-ttu-id="690c6-357">下表顯示四個條件必須存在<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A>傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="690c6-357">The following table shows the four conditions that must exist for <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> to return `true`.</span></span>  
  
|<span data-ttu-id="690c6-358">條件</span><span class="sxs-lookup"><span data-stu-id="690c6-358">Condition</span></span>|<span data-ttu-id="690c6-359">描述</span><span class="sxs-lookup"><span data-stu-id="690c6-359">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="690c6-360">作業系統支援視覺化樣式</span><span class="sxs-lookup"><span data-stu-id="690c6-360">The operating system supports visual styles</span></span>|<span data-ttu-id="690c6-361">若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 類別的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-361">To verify this condition separately, use the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> property of the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> class.</span></span>|  
|<span data-ttu-id="690c6-362">使用者已啟用作業系統中的視覺化樣式</span><span class="sxs-lookup"><span data-stu-id="690c6-362">The user has enabled visual styles in the operating system</span></span>|<span data-ttu-id="690c6-363">若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 類別的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-363">To verify this condition separately, use the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> property of the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> class.</span></span>|  
|<span data-ttu-id="690c6-364">應用程式中啟用視覺化樣式</span><span class="sxs-lookup"><span data-stu-id="690c6-364">Visual styles are enabled in the application</span></span>|<span data-ttu-id="690c6-365">您可以呼叫 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用應用程式資訊清單 (其中指定使用 ComCtl32.dll 6 (含) 以後版本來繪製控制項)，以啟用應用程式中的視覺化樣式。</span><span class="sxs-lookup"><span data-stu-id="690c6-365">Visual styles can be enabled in an application by calling the <xref:System.Windows.Forms.Application.EnableVisualStyles> method or by using an application manifest that specifies that ComCtl32.dll version 6 or later will be used to draw controls.</span></span>|  
|<span data-ttu-id="690c6-366">視覺化樣式正被用來繪製的應用程式視窗的工作區</span><span class="sxs-lookup"><span data-stu-id="690c6-366">Visual styles are being used to draw the client area of application windows</span></span>|<span data-ttu-id="690c6-367">若要個別驗證這個條件，請使用 <xref:System.Windows.Forms.Application> 類別的 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 屬性，並驗證該屬性具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="690c6-367">To verify this condition separately, use the <xref:System.Windows.Forms.Application.VisualStyleState%2A> property of the <xref:System.Windows.Forms.Application> class and verify that it has the value <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> or <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-368">關閉應用程式並立即啟動新的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-368">Shuts down the application and starts a new instance immediately.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-369">最常見的原因，用於呼叫`Restart`是啟動新版本的應用程式，您已透過下載[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]使用`Update`或`UpdateAsync`方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-369">The most common reason for calling `Restart` is to start a new version of the application that you have downloaded through [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] using the `Update` or `UpdateAsync` method.</span></span>  
  
 <span data-ttu-id="690c6-370">應用程式會在其中在最初執行的內容中重新啟動。</span><span class="sxs-lookup"><span data-stu-id="690c6-370">Applications are restarted in the context in which they were initially run.</span></span> <span data-ttu-id="690c6-371">使用直接指向應用程式的主要可執行檔的 URL 來啟動您的應用程式時，它會重新啟動使用相同的 URL。</span><span class="sxs-lookup"><span data-stu-id="690c6-371">If your application was started using a URL pointing directly to the application's main executable file, it will be restarted using the same URL.</span></span> <span data-ttu-id="690c6-372">如果您的應用程式是[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]應用程式，它將會重新啟動使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-372">If your application is a [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application, it will be restarted using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span>  
  
 <span data-ttu-id="690c6-373">如果當它第一次執行時，您的應用程式原本提供的命令列選項<xref:System.Windows.Forms.Application.Restart%2A>將會啟動應用程式，再次以相同的選項。</span><span class="sxs-lookup"><span data-stu-id="690c6-373">If your application was originally supplied command-line options when it first executed, <xref:System.Windows.Forms.Application.Restart%2A> will launch the application again with the same options.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="690c6-374">您的程式碼不是 Windows Form 應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-374">Your code is not a Windows Forms application.</span>
          </span>
          <span data-ttu-id="690c6-375">您不能在這個內容中呼叫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-375">You cannot call this method in this context.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-376">需要<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-376">Requires <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> permission.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-377">開始執行目前執行緒的標準應用程式訊息迴圈。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-377">Begins running a standard application message loop on the current thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-378">開始執行目前執行緒的標準應用程式訊息迴圈，而不需表單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-378">Begins running a standard application message loop on the current thread, without a form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-379">在 win32 或 Windows Form 應用程式訊息迴圈是處理使用者事件，例如按一下滑鼠和鍵盤按鍵的程式碼中的常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-379">In a Win32-based or Windows Forms application, a message loop is a routine in code that processes user events, such as mouse clicks and keyboard strokes.</span></span> <span data-ttu-id="690c6-380">每個執行的 Windows 架構應用程式需要使用中的訊息迴圈，稱為主要訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="690c6-380">Every running Windows-based application requires an active message loop, called the main message loop.</span></span> <span data-ttu-id="690c6-381">當關閉主要訊息迴圈時，就會結束應用程式。</span><span class="sxs-lookup"><span data-stu-id="690c6-381">When the main message loop is closed, the application exits.</span></span> <span data-ttu-id="690c6-382">在 Windows Form 中此迴圈時是否關閉<xref:System.Windows.Forms.Application.Exit%2A>呼叫方法時，或當<xref:System.Windows.Forms.Application.ExitThread%2A>正在執行主要訊息迴圈的執行緒上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-382">In Windows Forms, this loop is closed when the <xref:System.Windows.Forms.Application.Exit%2A> method is called, or when the <xref:System.Windows.Forms.Application.ExitThread%2A> method is called on the thread that is running the main message loop.</span></span>  
  
 <span data-ttu-id="690c6-383">大部分的 Windows Form 開發人員就不需要使用這個版本的方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-383">Most Windows Forms developers will not need to use this version of the method.</span></span> <span data-ttu-id="690c6-384">您應該使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>，讓應用程式終止主要表單關閉時，主要表單，以啟動應用程式的多載。</span><span class="sxs-lookup"><span data-stu-id="690c6-384">You should use the <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> overload to start an application with a main form, so that the application terminates when the main form is closed.</span></span> <span data-ttu-id="690c6-385">對於所有其他情況下，使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>多載，可支援提供<xref:System.Windows.Forms.ApplicationContext>以便更有效控制應用程式的存留期的物件。</span><span class="sxs-lookup"><span data-stu-id="690c6-385">For all other situations, use the <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> overload, which supports supplying an <xref:System.Windows.Forms.ApplicationContext> object for better control over the lifetime of the application.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="690c6-386">主訊息迴圈已經在這個執行緒上執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-386">A main message loop is already running on this thread.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <span data-ttu-id="690c6-387">執行應用程式的 <see cref="T:System.Windows.Forms.ApplicationContext" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-387">An <see cref="T:System.Windows.Forms.ApplicationContext" /> in which the application is run.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-388">以 <see cref="T:System.Windows.Forms.ApplicationContext" /> 開始執行目前執行緒的標準應用程式訊息迴圈。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-388">Begins running a standard application message loop on the current thread, with an <see cref="T:System.Windows.Forms.ApplicationContext" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-389">訊息迴圈會執行直到<xref:System.Windows.Forms.Application.Exit%2A>或<xref:System.Windows.Forms.Application.ExitThread%2A>稱為或<xref:System.Windows.Forms.Application.ThreadExit>物件上引發事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-389">The message loop runs until <xref:System.Windows.Forms.Application.Exit%2A> or <xref:System.Windows.Forms.Application.ExitThread%2A> is called or the <xref:System.Windows.Forms.Application.ThreadExit> event is raised on the context object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-390">此範例會顯示兩種形式，這兩個表單關閉時，請結束應用程式。</span><span class="sxs-lookup"><span data-stu-id="690c6-390">The example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="690c6-391">當應用程式啟動，並結束時，會記住每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-391">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="690c6-392">這個範例示範如何使用<xref:System.Windows.Forms.ApplicationContext>，連同`Application.Run(context)`方法，以在應用程式啟動時顯示多個表單。</span><span class="sxs-lookup"><span data-stu-id="690c6-392">This example demonstrates how to use an <xref:System.Windows.Forms.ApplicationContext>, along with the `Application.Run(context)` method, to display multiple forms when the application starts.</span></span>  
  
 <span data-ttu-id="690c6-393">類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>和會持續追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="690c6-393">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="690c6-394">類別會儲存使用者的每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-394">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="690c6-395">表單位置的資料儲存在檔案標題為`Appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-395">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="690c6-396">`Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。</span><span class="sxs-lookup"><span data-stu-id="690c6-396">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="690c6-397">程式碼`AppForm1`和`AppForm2`表單不會顯示為了簡潔起見。</span><span class="sxs-lookup"><span data-stu-id="690c6-397">The code for the `AppForm1` and `AppForm2` forms is not shown for the purpose of brevity.</span></span> <span data-ttu-id="690c6-398">請參閱<xref:System.Windows.Forms.ApplicationContext>在整個程式碼清單的類別概觀。</span><span class="sxs-lookup"><span data-stu-id="690c6-398">See the <xref:System.Windows.Forms.ApplicationContext> class overview for the whole code listing.</span></span>  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="690c6-399">主訊息迴圈已經在這個執行緒上執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-399">A main message loop is already running on this thread.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">
          <span data-ttu-id="690c6-400">
            <see cref="T:System.Windows.Forms.Form" />，代表要成為可見的表單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-400">A <see cref="T:System.Windows.Forms.Form" /> that represents the form to make visible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-401">開始執行目前執行緒上的標準應用程式訊息迴圈，並顯示指定的表單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-401">Begins running a standard application message loop on the current thread, and makes the specified form visible.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-402">一般而言，應用程式的 main 函式會呼叫這個方法，並將主視窗的應用程式傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="690c6-402">Typically, the main function of an application calls this method and passes to it the main window of the application.</span></span>  
  
 <span data-ttu-id="690c6-403">這個方法會加入事件處理常式`mainForm`參數<xref:System.Windows.Forms.Form.Closed>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-403">This method adds an event handler to the `mainForm` parameter for the <xref:System.Windows.Forms.Form.Closed> event.</span></span> <span data-ttu-id="690c6-404">事件處理常式呼叫<xref:System.Windows.Forms.Application.ExitThread%2A>清除應用程式。</span><span class="sxs-lookup"><span data-stu-id="690c6-404">The event handler calls <xref:System.Windows.Forms.Application.ExitThread%2A> to clean up the application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-405"><xref:System.Windows.Forms.Control.Dispose%2A>方法<xref:System.Windows.Forms.Form>類別會呼叫這個方法傳回之前。</span><span class="sxs-lookup"><span data-stu-id="690c6-405">The <xref:System.Windows.Forms.Control.Dispose%2A> method of the <xref:System.Windows.Forms.Form> class will be called prior to the return of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-406">下列程式碼範例會列出在表單上的清單方塊中的數字。</span><span class="sxs-lookup"><span data-stu-id="690c6-406">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="690c6-407">每次您按一下`button1`，應用程式會將另一個數字加入至清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-407">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="690c6-408">`Main`方法呼叫<xref:System.Windows.Forms.Application.Run%2A>啟動應用程式，會建立表單， `listBox1`，和`button1`。</span><span class="sxs-lookup"><span data-stu-id="690c6-408">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`.</span></span> <span data-ttu-id="690c6-409">當使用者按一下`button1`、`button1_Click`方法將數字一到三個清單方塊中，並顯示<xref:System.Windows.Forms.MessageBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-409">When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="690c6-410">如果使用者按一下**否**上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法會將另一個數字加入至清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-410">If the user clicks **No** on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list.</span></span> <span data-ttu-id="690c6-411">如果使用者按一下**是**，應用程式會呼叫<xref:System.Windows.Forms.Application.Exit%2A>處理所有剩餘的訊息佇列中，然後結束。</span><span class="sxs-lookup"><span data-stu-id="690c6-411">If the user clicks **Yes**, the application calls <xref:System.Windows.Forms.Application.Exit%2A> to process all remaining messages in the queue and then to quit.</span></span>  
  
 <span data-ttu-id="690c6-412">這個範例需要`listBox1`和`button1`已建立並在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-412">The example requires that `listBox1` and `button1` have been created and placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="690c6-413">主訊息迴圈已經正在目前執行緒中執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-413">A main message loop is already running on the current thread.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-414">當它們以警告橫幅顯示時，取得或設定格式字串以套用至最上層視窗標題。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-414">Gets or sets the format string to apply to top-level window captions when they are displayed with a warning banner.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-415">套用至最上層視窗標題的格式字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-415">The format string to apply to top-level window captions.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="690c6-416">若要設定此屬性的所有視窗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-416">for all windows to set this property.</span>
          </span>
          <span data-ttu-id="690c6-417">相關聯的列舉型別： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-417">Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="690c6-418">用於新控制項的預設值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-418">The default value to use for new controls.</span>
          </span>
          <span data-ttu-id="690c6-419">如果為 <see langword="true" />，則支援 <c>UseCompatibleTextRendering</c> 的新控制項會使用以 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 為基礎的 <see cref="T:System.Drawing.Graphics" /> 類別來呈現文字，如果為 <see langword="false" />，則新控制項會使用以 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 為基礎的 <see cref="T:System.Windows.Forms.TextRenderer" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-419">If <see langword="true" />, new controls that support <c>UseCompatibleTextRendering</c> use the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <see cref="T:System.Drawing.Graphics" /> class for text rendering; if <see langword="false" />, new controls use the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <see cref="T:System.Windows.Forms.TextRenderer" /> class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-420">為部分控制項上定義的 <c>UseCompatibleTextRendering</c> 屬性設定應用程式範圍的預設值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-420">Sets the application-wide default for the <c>UseCompatibleTextRendering</c> property defined on certain controls.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-421">特定的 Windows Form 控制項，可以使用其文字呈現<xref:System.Windows.Forms.TextRenderer>類別，根據[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]圖形文件庫，或<xref:System.Drawing.Graphics>類別，根據[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]圖形文件庫。</span><span class="sxs-lookup"><span data-stu-id="690c6-421">Certain Windows Forms controls can render their text using either the <xref:System.Windows.Forms.TextRenderer> class, which is based on the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] graphics library, or the <xref:System.Drawing.Graphics> class, which is based on the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] graphics library.</span></span> <span data-ttu-id="690c6-422">此變更為了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]因為發生效能和當地語系化問題而[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-422">This change was made in the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] because of performance and localization issues with [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)].</span></span> <span data-ttu-id="690c6-423">使用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>設定的預設值`UseCompatibleTextRendering`支援它的控制項屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-423">Use <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> to set the default value of the `UseCompatibleTextRendering` property for controls that support it.</span></span>  
  
 <span data-ttu-id="690c6-424">`UseCompatibleTextRendering`屬性為了提供 visual Windows Form 控制項之間的相容性呈現文字使用<xref:System.Windows.Forms.TextRenderer>類別和[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]和[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]應用程式，執行自訂文字轉譯使用<xref:System.Drawing.Graphics>類別。</span><span class="sxs-lookup"><span data-stu-id="690c6-424">The `UseCompatibleTextRendering` property is intended to provide visual compatibility between Windows Forms controls that render text using the <xref:System.Windows.Forms.TextRenderer> class and [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] and [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] applications that perform custom text rendering using the <xref:System.Drawing.Graphics> class.</span></span> <span data-ttu-id="690c6-425">在大部分情況下，如果您的應用程式未從升級[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]或[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，建議您保持`UseCompatibleTextRendering`設定的預設值為`false`。</span><span class="sxs-lookup"><span data-stu-id="690c6-425">In most cases, if your application is not being upgraded from [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] or [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], it is recommended that you leave `UseCompatibleTextRendering` set to the default value of `false`.</span></span>  
  
 <span data-ttu-id="690c6-426">[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]基礎<xref:System.Windows.Forms.TextRenderer>類別中引進了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]為了提升效能，讓文字看起來比較好，並改善的國際字型支援。</span><span class="sxs-lookup"><span data-stu-id="690c6-426">The [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <xref:System.Windows.Forms.TextRenderer> class was introduced in the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] to improve performance, make text look better, and improve support for international fonts.</span></span> <span data-ttu-id="690c6-427">在舊版的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]基礎<xref:System.Drawing.Graphics>類別用來執行所有的文字轉譯。</span><span class="sxs-lookup"><span data-stu-id="690c6-427">In earlier versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <xref:System.Drawing.Graphics> class was used to perform all text rendering.</span></span> [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]<span data-ttu-id="690c6-428"> 計算字元間距和自動換行以不同的方式從[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-428"> calculates character spacing and word wrapping differently from [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)].</span></span> <span data-ttu-id="690c6-429">在 Windows Form 應用程式中使用<xref:System.Drawing.Graphics>類別來呈現文字中，這可能會導致使用的控制項的文字<xref:System.Windows.Forms.TextRenderer>出現不同的應用程式中的其他文字。</span><span class="sxs-lookup"><span data-stu-id="690c6-429">In a Windows Forms application that uses the <xref:System.Drawing.Graphics> class to render text, this could cause the text for controls that use <xref:System.Windows.Forms.TextRenderer> to appear different from the other text in the application.</span></span> <span data-ttu-id="690c6-430">若要解決此不相容，您可以設定`UseCompatibleTextRendering`屬性`true`。</span><span class="sxs-lookup"><span data-stu-id="690c6-430">To resolve this incompatibility, you can set the `UseCompatibleTextRendering` property to `true`.</span></span> <span data-ttu-id="690c6-431">若要設定`UseCompatibleTextRendering`至`true`應用程式中所有支援的控制項，呼叫<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>具有參數的方法`true`。</span><span class="sxs-lookup"><span data-stu-id="690c6-431">To set `UseCompatibleTextRendering` to `true` for all supported controls in the application, call the <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> method with a parameter of `true`.</span></span>  
  
 <span data-ttu-id="690c6-432">如果您的 Windows Form 程式碼裝載在另一個應用程式，例如 Internet Explorer 中，您應該永遠不會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-432">You should never call this method if your Windows Forms code is hosted in another application, such as Internet Explorer.</span></span> <span data-ttu-id="690c6-433">只能在獨立的 Windows Form 應用程式中呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-433">Only call this method in stand-alone Windows Forms applications.</span></span>  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  <span data-ttu-id="690c6-434">若要設定的預設值為`UseCompatibleTextRendering`中[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]或更新版本中，請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="690c6-434">To set the default value for `UseCompatibleTextRendering` in [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] or later, see <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="690c6-435">在[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]或更新版本中，呼叫<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>會自動產生的 Program.cs 檔案中。</span><span class="sxs-lookup"><span data-stu-id="690c6-435">In [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] or later, a call to <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> is automatically generated in the Program.cs file.</span></span> <span data-ttu-id="690c6-436">若要變更文字轉譯預設值，修改產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="690c6-436">To change the text rendering default, modify the generated code.</span></span>  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="690c6-437">您只可以在 Windows Form 應用程式建立第一個視窗之前呼叫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-437">You can only call this method before the first window is created by your Windows Forms application.</span>
          </span>
        </exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="690c6-438">
            <see cref="T:System.Windows.Forms.PowerState" />，表示要轉換至的電源啟動模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-438">A <see cref="T:System.Windows.Forms.PowerState" /> indicating the power activity mode to which to transition.</span>
          </span>
        </param>
        <param name="force">
          <span data-ttu-id="690c6-439">
            <see langword="true" /> 表示要立即強制執行暫止模式；<see langword="false" /> 則表示要讓 Windows 向每一個應用程式傳送暫止要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-439">
              <see langword="true" /> to force the suspended mode immediately; <see langword="false" /> to cause Windows to send a suspend request to every application.</span>
          </span>
        </param>
        <param name="disableWakeEvent">
          <span data-ttu-id="690c6-440">
            <see langword="true" /> 表示要在喚醒事件上停用將系統的電源狀態還原為作用中；<see langword="false" /> 則表示要在喚醒事件上啟用將系統的電源狀態還原為作用中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-440">
              <see langword="true" /> to disable restoring the system's power status to active on a wake event, <see langword="false" /> to enable restoring the system's power status to active on a wake event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-441">讓系統暫止或休眠，或要求讓系統暫止或休眠。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-441">Suspends or hibernates the system, or requests that the system be suspended or hibernated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="690c6-442">如果系統正處於暫止狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-442">
              <see langword="true" /> if the system is being suspended, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-443">如果應用程式不會在 20 秒內回應暫停要求，則 Windows 會判斷它處於非回應狀態，和應用程式可能已設定進入睡眠狀態或已結束。</span><span class="sxs-lookup"><span data-stu-id="690c6-443">If an application does not respond to a suspend request within 20 seconds, Windows determines that it is in a non-responsive state, and that the application can either be put to sleep or terminated.</span></span> <span data-ttu-id="690c6-444">一旦應用程式回應暫停要求，不過，可能需要清除資源，並關閉使用中處理序需要的間隔時間。</span><span class="sxs-lookup"><span data-stu-id="690c6-444">Once an application responds to a suspend request, however, it can take whatever time it needs to clean up resources and shut down active processes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-445">指示應用程式如何回應未處理的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-445">Instructs the application how to respond to unhandled exceptions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="690c6-446">下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-446">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="690c6-447">它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-447">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="690c6-448">它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-448">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="690c6-449">因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。</span><span class="sxs-lookup"><span data-stu-id="690c6-449">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="690c6-450">這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。</span><span class="sxs-lookup"><span data-stu-id="690c6-450">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">
          <span data-ttu-id="690c6-451">
            <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述如果未攔截到擲回的例外狀況時，應用程式的行為方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-451">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-452">指示應用程式如何回應未處理的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-452">Instructs the application how to respond to unhandled exceptions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-453">通常不是可攔截所有的 Windows Form 所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-453">It is often not feasible to catch all of the exceptions thrown by Windows Forms.</span></span> <span data-ttu-id="690c6-454">使用此方法，您可以指示您的應用程式應該攔截所有未處理的 Windows Form 元件所擲回的例外狀況並繼續作業，還是應該將它們公開給使用者並暫止執行。</span><span class="sxs-lookup"><span data-stu-id="690c6-454">Using this method, you can instruct your application whether it should catch all unhandled exceptions thrown by Windows Forms components and continue operating, or whether it should expose them to the user and halt execution.</span></span>  
  
 <span data-ttu-id="690c6-455">呼叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>您具現化您的應用程式使用的主要表單之前<xref:System.Windows.Forms.Application.Run%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-455">Call <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> before you instantiate the main form of your application using the <xref:System.Windows.Forms.Application.Run%2A> method.</span></span>  
  
 <span data-ttu-id="690c6-456">攔截無法建立執行緒中發生例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-456">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-457">下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-457">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="690c6-458">它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-458">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="690c6-459">它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-459">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="690c6-460">因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。</span><span class="sxs-lookup"><span data-stu-id="690c6-460">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="690c6-461">這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。</span><span class="sxs-lookup"><span data-stu-id="690c6-461">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="690c6-462">您不能在應用程式建立了第一個視窗之後，再設定例外狀況模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-462">You cannot set the exception mode after the application has created its first window.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">
          <span data-ttu-id="690c6-463">
            <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述如果未攔截到擲回的例外狀況時，應用程式的行為方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-463">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</span>
          </span>
        </param>
        <param name="threadScope">
          <span data-ttu-id="690c6-464">若為 <see langword="true" />，則會設定執行緒例外狀況模式，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-464">
              <see langword="true" /> to set the thread exception mode; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="690c6-465">指示應用程式如何回應未處理例外狀況，並選擇性地套用執行緒專屬的行為。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-465">Instructs the application how to respond to unhandled exceptions, optionally applying thread-specific behavior.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-466">通常不是可攔截所有的 Windows Form 所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-466">It is often not feasible to catch all of the exceptions thrown by Windows Forms.</span></span> <span data-ttu-id="690c6-467">使用此方法，您可以指示您的應用程式應該攔截所有未處理的 Windows Form 元件所擲回的例外狀況並繼續作業，還是應該將它們公開給使用者並暫止執行。</span><span class="sxs-lookup"><span data-stu-id="690c6-467">Using this method, you can instruct your application whether it should catch all unhandled exceptions thrown by Windows Forms components and continue operating, or whether it should expose them to the user and halt execution.</span></span>  
  
 <span data-ttu-id="690c6-468">呼叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>您具現化您的應用程式使用的主要表單之前<xref:System.Windows.Forms.Application.Run%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="690c6-468">Call <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> before you instantiate the main form of your application using the <xref:System.Windows.Forms.Application.Run%2A> method.</span></span>  
  
 <span data-ttu-id="690c6-469">當`threadScope`是`true`，設定執行緒例外狀況模式。</span><span class="sxs-lookup"><span data-stu-id="690c6-469">When `threadScope` is `true`, the thread exception mode is set.</span></span> <span data-ttu-id="690c6-470">如果執行緒例外狀況模式覆寫應用程式例外狀況模式`mode`未設定為<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>。</span><span class="sxs-lookup"><span data-stu-id="690c6-470">The thread exception mode overrides the application exception mode if `mode` is not set to <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.</span></span>  
  
 <span data-ttu-id="690c6-471">當`threadScope`是`false`，應用程式例外狀況模式設定。</span><span class="sxs-lookup"><span data-stu-id="690c6-471">When `threadScope` is `false`, the application exception mode is set.</span></span> <span data-ttu-id="690c6-472">應用程式例外狀況模式用於具有的所有執行緒<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>模式。</span><span class="sxs-lookup"><span data-stu-id="690c6-472">The application exception mode is used for all threads that have the <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> mode.</span></span> <span data-ttu-id="690c6-473">設定應用程式例外狀況模式不會影響目前執行緒的設定。</span><span class="sxs-lookup"><span data-stu-id="690c6-473">Setting the application exception mode does not affect the setting of the current thread.</span></span>  
  
 <span data-ttu-id="690c6-474">攔截無法建立執行緒中發生例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-474">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-475">下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-475">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="690c6-476">它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-476">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="690c6-477">它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-477">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="690c6-478">因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。</span><span class="sxs-lookup"><span data-stu-id="690c6-478">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="690c6-479">這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。</span><span class="sxs-lookup"><span data-stu-id="690c6-479">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="690c6-480">您不能在應用程式建立了第一個視窗之後，再設定例外狀況模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-480">You cannot set the exception mode after the application has created its first window.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-481">取得啟動應用程式的可執行檔路徑，不包括檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-481">Gets the path for the executable file that started the application, not including the executable name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-482">啟動應用程式的可執行檔路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-482">The path for the executable file that started the application.</span>
          </span>
          <span data-ttu-id="690c6-483">這個路徑會依據是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 來部署 Windows Forms 應用程式而有所不同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-483">This path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span>
          </span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="690c6-484"> 應用程式會儲存在 C:\Documents and Settings 中的每個使用者應用程式快取\\*username*目錄。</span><span class="sxs-lookup"><span data-stu-id="690c6-484"> applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span><span data-ttu-id="690c6-485">如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</span><span class="sxs-lookup"><span data-stu-id="690c6-485">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="690c6-486">下列程式碼範例會取得這個屬性和其值顯示在文字方塊中。</span><span class="sxs-lookup"><span data-stu-id="690c6-486">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="690c6-487">這個範例需要`textBox1`已放在表單上。</span><span class="sxs-lookup"><span data-stu-id="690c6-487">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="690c6-488">取得路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-488">for getting the path.</span>
          </span>
          <span data-ttu-id="690c6-489">相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-489">Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-490">發生於未被截取的執行緒擲回例外狀況 (Exception) 時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-490">Occurs when an untrapped thread exception is thrown.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-491">此事件可讓 Windows Forms 應用程式至 Windows Form 執行緒中發生的控制代碼為未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-491">This event allows your Windows Forms application to handle otherwise unhandled exceptions that occur in Windows Forms threads.</span></span> <span data-ttu-id="690c6-492">附加至事件處理常式<xref:System.Windows.Forms.Application.ThreadException>事件，以處理這些例外狀況會保留您的應用程式處於未知狀態。</span><span class="sxs-lookup"><span data-stu-id="690c6-492">Attach your event handlers to the <xref:System.Windows.Forms.Application.ThreadException> event to deal with these exceptions, which will leave your application in an unknown state.</span></span> <span data-ttu-id="690c6-493">可能的話，應該由結構化例外狀況處理區塊中處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-493">Where possible, exceptions should be handled by a structured exception handling block.</span></span>  
  
 <span data-ttu-id="690c6-494">您可以變更此回呼由未處理的 Windows Forms 執行緒例外狀況設定是否<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-494">You can change whether this callback is used for unhandled Windows Forms thread exceptions by setting <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>.</span></span> <span data-ttu-id="690c6-495">攔截無法建立執行緒中發生例外狀況，並擁有的 Windows Form 使用<xref:System.AppDomain.UnhandledException>事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-495">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="690c6-496">若要保證沒有啟用此事件會遺失，您必須將附加的處理常式呼叫之前<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="690c6-496">To guarantee that no activations of this event are missed, you must attach a handler before you call <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-497">因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-497">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-498">下列程式碼範例會設定 Windows Form 執行緒和其他執行緒上發生的例外狀況發生的例外狀況的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-498">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="690c6-499">它會設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，讓應用程式，不論應用程式的使用者設定檔中的設定會處理所有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="690c6-499">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="690c6-500">它會使用<xref:System.Windows.Forms.Application.ThreadException>事件，以處理 UI 執行緒例外狀況，而<xref:System.AppDomain.UnhandledException>處理非 UI 執行緒的例外狀況的事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-500">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="690c6-501">因為<xref:System.AppDomain.UnhandledException>無法防止應用程式終止，則只記錄錯誤終止之前在應用程式事件記錄檔。</span><span class="sxs-lookup"><span data-stu-id="690c6-501">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="690c6-502">這個範例假設您已經定義了兩個<xref:System.Windows.Forms.Button>控制項`button1`和`button2`上您<xref:System.Windows.Forms.Form>類別。</span><span class="sxs-lookup"><span data-stu-id="690c6-502">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="690c6-503">呼叫 unmanaged 程式碼加入此事件處理常式時立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-503">for the immediate caller to call unmanaged code when adding a handler to this event.</span>
          </span>
          <span data-ttu-id="690c6-504">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-504">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-505">發生在執行緒即將關閉時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-505">Occurs when a thread is about to shut down.</span>
          </span>
          <span data-ttu-id="690c6-506">當應用程式的主執行緒即將關閉時，會先引發這個事件，接著是 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-506">When the main thread for an application is about to be shut down, this event is raised first, followed by an <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-507">您必須將附加事件處理常式，<xref:System.Windows.Forms.Application.ThreadExit>事件以執行任何未處理、 執行緒停止執行之前的必要工作。</span><span class="sxs-lookup"><span data-stu-id="690c6-507">You must attach the event handlers to the <xref:System.Windows.Forms.Application.ThreadExit> event to perform any unhandled, required tasks before the thread stops running.</span></span> <span data-ttu-id="690c6-508">關閉這個執行緒或處置的記憶體回收行程未回收的物件所開啟的檔案。</span><span class="sxs-lookup"><span data-stu-id="690c6-508">Close files opened by this thread, or dispose of objects that the garbage collector did not reclaim.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="690c6-509">因為這是靜態事件，您必須處置應用程式，或將會造成記憶體流失時中斷連結事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-509">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-510">下列程式碼範例示範如何使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="690c6-510">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="690c6-511">在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Application.ThreadExit>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-511">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.ThreadExit> event.</span></span> <span data-ttu-id="690c6-512">此報表可協助您了解事件發生的時機，並可協助您偵錯。</span><span class="sxs-lookup"><span data-stu-id="690c6-512">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="690c6-513">若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="690c6-513">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="690c6-514">若要執行範例程式碼，將它貼到 Windows Form 並確認事件處理常式關聯<xref:System.Windows.Forms.Application.ThreadExit>事件。</span><span class="sxs-lookup"><span data-stu-id="690c6-514">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.ThreadExit> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="690c6-515">移除註冊 <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> 所進行的訊息迴圈回呼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-515">Unregisters the message loop callback made with <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-516">取得使用者的應用程式資料路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-516">Gets the path for the application data of a user.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-517">使用者的應用程式資料路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-517">The path for the application data of a user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-518">如果路徑不存在，會以下列格式建立一個：</span><span class="sxs-lookup"><span data-stu-id="690c6-518">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="690c6-519">*基底路徑*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="690c6-519">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>  
  
 <span data-ttu-id="690c6-520">資料儲存在這個路徑是啟用漫遊使用者設定檔的一部分。</span><span class="sxs-lookup"><span data-stu-id="690c6-520">Data stored in this path is part of user profile that is enabled for roaming.</span></span> <span data-ttu-id="690c6-521">漫遊使用者適用於在網路中的多部電腦。</span><span class="sxs-lookup"><span data-stu-id="690c6-521">A roaming user works on more than one computer in a network.</span></span> <span data-ttu-id="690c6-522">漫遊使用者的使用者設定檔會保留在網路上的伺服器上時，則載入系統在使用者登入。</span><span class="sxs-lookup"><span data-stu-id="690c6-522">The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on.</span></span> <span data-ttu-id="690c6-523">考量漫遊使用者設定檔的作業系統必須支援漫遊設定檔，必須啟用。</span><span class="sxs-lookup"><span data-stu-id="690c6-523">For a user profile to be considered for roaming, the operating system must support roaming profiles and it must be enabled.</span></span>  
  
 <span data-ttu-id="690c6-524">典型的基底路徑是 C:\Documents and Settings\\*username*\Application 資料。</span><span class="sxs-lookup"><span data-stu-id="690c6-524">A typical base path is C:\Documents and Settings\\*username*\Application Data.</span></span> <span data-ttu-id="690c6-525">這個路徑可能會不同，不過，如果在 Windows Forms 應用程式部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="690c6-525">This path will be different, however, if the Windows Forms application is deployed by using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="690c6-526"> 建立自己的應用程式資料目錄，且與所有其他應用程式隔離。</span><span class="sxs-lookup"><span data-stu-id="690c6-526"> creates its own application data directory that is isolated from all other applications.</span></span> <span data-ttu-id="690c6-527">如需詳細資訊，請參閱[存取本機和 ClickOnce 應用程式中的遠端資料](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</span><span class="sxs-lookup"><span data-stu-id="690c6-527">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-528">下列程式碼範例會顯示兩種形式，並結束應用程式，這兩個表單關閉時。</span><span class="sxs-lookup"><span data-stu-id="690c6-528">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="690c6-529">當應用程式啟動，並結束時，會記住每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-529">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="690c6-530">這個範例示範如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>屬性來儲存使用者的應用程式資料。</span><span class="sxs-lookup"><span data-stu-id="690c6-530">This example demonstrates using the <xref:System.Windows.Forms.Application.UserAppDataPath%2A> property to store application data for the user.</span></span>  
  
 <span data-ttu-id="690c6-531">類別`MyApplicationContext`繼承自<xref:System.Windows.Forms.ApplicationContext>和會持續追蹤每個表單會關閉，而在這兩個時結束目前的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="690c6-531">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="690c6-532">類別會儲存使用者的每個表單的位置。</span><span class="sxs-lookup"><span data-stu-id="690c6-532">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="690c6-533">表單位置的資料儲存在檔案標題為`Appdata.txt`位置取決於建立<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="690c6-533">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="690c6-534">`Main`方法呼叫`Application.Run(context)`啟動應用程式指定<xref:System.Windows.Forms.ApplicationContext>。</span><span class="sxs-lookup"><span data-stu-id="690c6-534">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="690c6-535">此程式碼是摘錄自中顯示的範例<xref:System.Windows.Forms.ApplicationContext>類別概觀。</span><span class="sxs-lookup"><span data-stu-id="690c6-535">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="690c6-536">為了簡潔起見，不會顯示一些程式碼。</span><span class="sxs-lookup"><span data-stu-id="690c6-536">Some code is not shown for the purpose of brevity.</span></span> <span data-ttu-id="690c6-537">請參閱<xref:System.Windows.Forms.ApplicationContext>整個程式碼清單。</span><span class="sxs-lookup"><span data-stu-id="690c6-537">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-538">取得使用者之應用程式資料的登錄機碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-538">Gets the registry key for the application data of a user.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-539">
            <see cref="T:Microsoft.Win32.RegistryKey" /> 代表使用者專用之應用程式資料的登錄機碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-539">A <see cref="T:Microsoft.Win32.RegistryKey" /> representing the registry key for the application data specific to the user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-540">如果索引鍵不存在，就會建立以下列格式：</span><span class="sxs-lookup"><span data-stu-id="690c6-540">If the key does not exist, it is created in the following format:</span></span>  
  
 <span data-ttu-id="690c6-541">CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="690c6-541">CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 <span data-ttu-id="690c6-542">資料儲存在這個索引鍵是已啟用漫遊使用者設定檔的一部分。</span><span class="sxs-lookup"><span data-stu-id="690c6-542">Data stored in this key is part of user profile that is enabled for roaming.</span></span> <span data-ttu-id="690c6-543">漫遊使用者適用於在網路中的多部電腦。</span><span class="sxs-lookup"><span data-stu-id="690c6-543">A roaming user works on more than one computer in a network.</span></span> <span data-ttu-id="690c6-544">漫遊使用者的使用者設定檔會保留在網路上的伺服器上時，則載入系統在使用者登入。</span><span class="sxs-lookup"><span data-stu-id="690c6-544">The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on.</span></span> <span data-ttu-id="690c6-545">考量漫遊使用者設定檔的作業系統必須支援漫遊設定檔，必須啟用。</span><span class="sxs-lookup"><span data-stu-id="690c6-545">For a user profile to be considered for roaming, the operating system must support roaming profiles and it must be enabled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-546">取得或設定應用程式的所有開啟表單是否都要使用等待游標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-546">Gets or sets whether the wait cursor is used for all open forms of the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-547">如果所有已開啟表單都使用等待游標，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-547">
              <see langword="true" /> is the wait cursor is used for all open forms; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-548">當這個屬性設定為`true`、<xref:System.Windows.Forms.Control.UseWaitCursor%2A>的應用程式中的所有開啟表單的屬性會設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="690c6-548">When this property is set to `true`, the <xref:System.Windows.Forms.Control.UseWaitCursor%2A> property of all open forms in the application will be set to `true`.</span></span> <span data-ttu-id="690c6-549">直到所有表單上已設定這個屬性，將不會傳回此呼叫。</span><span class="sxs-lookup"><span data-stu-id="690c6-549">This call will not return until this property has been set on all forms.</span></span> <span data-ttu-id="690c6-550">當您有長時間執行的作業，而且想要在所有應用程式表單表示作業仍在處理時，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="690c6-550">Use this property when you have a long-running operation, and want to indicate in all application forms that the operation is still processing.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="690c6-551">取得值，指定視覺化樣式套用至應用程式視窗的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-551">Gets a value that specifies how visual styles are applied to application windows.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="690c6-552">
            <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="690c6-552">A bitwise combination of the <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="690c6-553">這<xref:System.Windows.Forms.Application.VisualStyleState%2A>屬性會決定用戶端區域或應用程式視窗的非工作區中是否已啟用視覺化樣式。</span><span class="sxs-lookup"><span data-stu-id="690c6-553">This <xref:System.Windows.Forms.Application.VisualStyleState%2A> property determines whether visual styles are enabled in client areas or nonclient areas of application windows.</span></span> <span data-ttu-id="690c6-554">一般而言，應該設定這個屬性主要表單的建構函式內或<xref:System.Windows.Forms.Form.Load>事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="690c6-554">Generally, this property should be set within the main form's constructor or <xref:System.Windows.Forms.Form.Load> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="690c6-555">下列程式碼範例會設定<xref:System.Windows.Forms.Application.VisualStyleState%2A>屬性設為其中的<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>值內<xref:System.Windows.Forms.Control.Click>事件處理常式<xref:System.Windows.Forms.Button>控制項。</span><span class="sxs-lookup"><span data-stu-id="690c6-555">The following code example sets the <xref:System.Windows.Forms.Application.VisualStyleState%2A> property to one of the <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> values within the <xref:System.Windows.Forms.Control.Click> event handler for a <xref:System.Windows.Forms.Button> control.</span></span> <span data-ttu-id="690c6-556">這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="690c6-556">This code example is part of a larger example provided for the <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> enumeration.</span></span>  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>