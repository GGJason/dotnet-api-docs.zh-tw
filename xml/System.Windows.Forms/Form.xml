<Type Name="Form" FullName="System.Windows.Forms.Form">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f3fc084a02f774d87fefe2646b5cb5ad6cc9733" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659938" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <TypeSignature Language="VB.NET" Value="Public Class Form&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Form : System::Windows::Forms::ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示構成應用程式使用者介面的視窗或對話方塊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Forms.Form>是顯示在您的應用程式中的任何視窗的表示法。 <xref:System.Windows.Forms.Form>類別可以用來建立標準、 工具、 無框線和浮動視窗。 您也可以使用<xref:System.Windows.Forms.Form>類別來建立強制回應視窗，例如對話方塊。 一種特殊形式，多重文件介面 (MDI) 表單，可以包含其他呼叫 MDI 子表單的表單。 藉由設定建立 MDI 表單<xref:System.Windows.Forms.Form.IsMdiContainer%2A>屬性`true`。 藉由將會建立 MDI 子表單<xref:System.Windows.Forms.Form.MdiParent%2A>會包含子表單在 MDI 父表單的屬性。  
  
 使用中可用的屬性<xref:System.Windows.Forms.Form>類別，您可以判斷您要建立的視窗或對話方塊方塊的外觀、 大小、 色彩和視窗管理功能。 <xref:System.Windows.Forms.Control.Text%2A>屬性可讓您指定的視窗標題的標題列中。 <xref:System.Windows.Forms.Form.Size%2A>和<xref:System.Windows.Forms.Form.DesktopLocation%2A>屬性可讓您定義的大小和視窗的位置顯示時。 您可以使用<xref:System.Windows.Forms.Control.ForeColor%2A>来變更所有控制項的預設前景色彩的色彩屬性放置在表單上。 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.MaximizeBox%2A>屬性可讓您控制是否表單可以最小化、 最大化，或在執行階段調整大小時。  
  
 除了屬性之外，您可以使用類別的方法來管理表單。 例如，您可以使用<xref:System.Windows.Forms.Form.ShowDialog%2A>方法，以顯示強制回應對話方塊的形式。 您可以使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>放置在桌面上表單的方法。  
  
 事件的<xref:System.Windows.Forms.Form>類別可讓您回應表單上所執行的動作。 您可以使用<xref:System.Windows.Forms.Form.Activated>事件以執行操作，例如更新時啟動表單，表單的控制項中顯示的資料。  
  
 您可以為起始的類別使用的形式，應用程式中，放置呼叫的方法來`Main`類別中。 在`Main`方法新增程式碼，建立並顯示表單。 您也需要加入`STAThread`屬性`Main`表單，以執行順序的方法。 啟動表單關閉時，也會關閉應用程式。  
  
 如果您設定<xref:System.Windows.Forms.Control.Enabled%2A>屬性`false`之前<xref:System.Windows.Forms.Form>可見 (比方說，設定<xref:System.Windows.Forms.Control.Enabled%2A>中設為 false[!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]設計工具)，則最小化、 最大化，請關閉，並保持啟用狀態的系統按鈕。 如果您設定<xref:System.Windows.Forms.Control.Enabled%2A>來`false`之後<xref:System.Windows.Forms.Form>可見 （例如，當載入事件發生時），則按鈕會停用。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Form();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.Form" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表單的預設大小為 300 像素的高度和寬度 300 像素為單位。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會設定使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ AcceptButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定使用者按下 ENTER 鍵時所按下的表單上按鈕。</summary>
        <value>，代表做為表單接受按鈕的按鈕。<see cref="T:System.Windows.Forms.IButtonControl" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您指定當使用者在應用程式中按下 ENTER 鍵時所發生的預設動作。 必須是指派給這個屬性的按鈕<xref:System.Windows.Forms.IButtonControl>是現用表單上或位於目前的表單上的容器。  
  
 您可以使用這個屬性可讓使用者快速巡覽簡單表單，讓它們能夠在完成而不是手動按一下 [接受] 按鈕，使用滑鼠時，只要按下 ENTER 鍵。  
  
 如果目前選取的控制項在表單上會攔截 ENTER 鍵，並加以處理，可能無法啟動 [接受] 按鈕。 例如，多行文字方塊控制項允許選取要在控制項中插入新行字元時，可以按下 ENTER 鍵。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.CancelButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Activate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動表單並給予焦點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 啟動表單將它帶到前面如果這是作用中的應用程式，或它閃爍視窗的標題，如果這不是作用中的應用程式。 格式必須是可見的此方法才能發生效用。 若要判斷應用程式中作用中的表單，請使用<xref:System.Windows.Forms.Form.ActiveForm%2A>屬性或<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>屬性，如果您的表單中的多重文件介面 (MDI) 應用程式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>，<xref:System.Windows.Forms.Form.Load>和<xref:System.Windows.Forms.Form.Activate%2A>成員。 若要執行此範例，下列程式碼的呼叫格式貼`Form1`包含按鈕呼叫`Button1`和兩個`Label`控制項稱為`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用於變更焦點。 關聯的列舉型別：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單以程式碼或由使用者啟動時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  有多個表單或為作用中的應用程式，使用中的格式，是具有輸入焦點的表單。 看不到表單不能是現用表單。 啟動顯示表單的最簡單方式是按一下它，或使用適當的鍵盤組合。  
  
 若要啟動表單在執行階段使用程式碼，呼叫<xref:System.Windows.Forms.Form.Activate%2A>方法。 您可以使用此事件的工作，例如更新根據表單的資料變更時不啟動表單的表單內容。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Closed>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成員。 要執行此範例中，貼上下列程式碼呼叫 Form1 包含表單中<xref:System.Windows.Forms.Button>呼叫`Button1`和兩個<xref:System.Windows.Forms.Label>控制項稱為`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ActivateMdiChild(System::Windows::Forms::Form ^ form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">要啟動的子表單。</param>
        <summary>啟動表單的 MDI 子系。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`form`參數已使用中的 MDI 子表單，然後在<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>方法只會傳回。 如果`form`不`null`，則會設為作用中的 MDI 子表單。  
  
 是否`form`參數是`null`，<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>引發<xref:System.Windows.Forms.Form.MdiChildActivate>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ActiveForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Form ^ ActiveForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個應用程式目前的現用表單。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" />，代表目前現用表單；如果沒有現用表單，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法來取得目前的現用表單，表單或它的控制項上執行動作的參考。  
  
 如果您的應用程式的多重文件介面 (MDI) 應用程式，請使用<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>屬性，以取得目前現用的 MDI 子表單。  
  
   
  
## Examples  
 下列程式碼範例會取得使用中的表單，並停用表單上的所有控制項。 此範例會使用<xref:System.Windows.Forms.Control.Controls%2A>表單，以逐一查看每個控制項在表單上，並停用控制項的集合。  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">要求的表單。 關聯的列舉型別：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveMdiChild As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ActiveMdiChild { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前現用的多重文件介面 (MDI) 子視窗。</summary>
        <value>傳回 <see cref="T:System.Windows.Forms.Form" />，代表目前現用 MDI 子視窗；如果目前沒有子視窗，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法，以判斷是否有任何 MDI 子表單在 MDI 應用程式中開啟。 您也可以使用這個方法來執行作業 MDI 子視窗上，從 MDI 父表單或另一種形式顯示在您的應用程式中。  
  
 如果目前的現用表單不是 MDI 子表單，您可以使用<xref:System.Windows.Forms.Form.ActiveForm%2A>屬性，以取得它的參考。  
  
   
  
## Examples  
 下列程式碼範例會取得使用中的 MDI 子表單和所有執行迴圈的參考<xref:System.Windows.Forms.TextBox>控制項在表單中，重設其<xref:System.Windows.Forms.TextBoxBase.Text%2A>屬性。 這個範例需要確認已建立 MDI 父表單和，此方法進行呼叫，從 MDI 父表單。  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">這個表單將擁有的 <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>將這個表單加入附屬的表單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指派給主控表單表單將維持狀態直到擁有<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>方法呼叫。 您也可以進行表單擁有的另一個設定<xref:System.Windows.Forms.Form.Owner%2A>其擁有者的形式參考的屬性。  
  
 當表單由另一種形式所擁有時，它已關閉或隱藏的擁有者的表單。 例如，假設名為表單`Form2`名為的表單所擁有`Form1`。 如果`Form1`已關閉或最小化`Form2`也已關閉或隱藏。 擁有的表單也永遠不會顯示其主控表單後面。 您可以使用適用於 windows，例如尋找擁有的表單，並取代 windows，不應該顯示擁有者表單的後置選取主控表單時。  
  
> [!NOTE]
>  如果表單為多重文件介面 (MDI) 父表單，這個屬性會傳回顯示除了任何目前的 MDI 子表單的所有表單都開啟。 若要取得 MDI 子表單在 MDI 父表單中開啟，請使用<xref:System.Windows.Forms.Form.MdiChildren%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.AddOwnedForm%2A>表單顯示為附屬的表單的另一種形式的方法。 附屬的表單顯示後，您可以降低其擁有者的形式和附屬的表單會與其降至最低。 這個範例需要在範例中的程式碼會呼叫從另一個事件或表單的方法。  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          若要顯示捲軸，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>根據目前控制項的位置以及目前選取的控制項，調整容器上的捲軸。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否可調整表單的不透明度。</summary>
        <value>
          如果表單的不透明度可以變更，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會自動設定為`true`如果`Opacity`變更。 當使用設定表單的透明度`Opacity`屬性，表單會在表單上的物件分層。 如果您設定<xref:System.Windows.Forms.Form.AllowTransparency%2A>屬性`false`表單都不會在多層式模式，以提升的表單顯示效能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ApplyAutoScaling ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ApplyAutoScaling();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>根據目前 <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> 屬性值和目前的字型大小調整表單的大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會決定使用的值將表單大小<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>屬性和<xref:System.Windows.Forms.Form.Size%2A>所傳回的值<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScale As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoScale { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出表單是否要調整大小以配合表單上所使用的字型高度，並且縮放它的控制項。</summary>
        <value>
          如果表單根據指派給表單的目前字型自動縮放表單本身及其控制項，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.AutoScale%2A>已經過時，已保留回溯相容性。 非過時的替代方式是 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>。 如需自動調整的詳細資訊，請參閱[Windows Form 中的自動調整](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 您可以使用這個屬性允許您的表單和其自動調整控制項變更字型。 這可以是應用程式可能會增加字型的位置，或是根據語言的 windows 指定用來減少。  
  
 若要使用的標尺取得表單就會自動的大小<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>屬性。 如果您想要決定大小表單就會自動調整規模，以根據特定字型，而使用<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScaleBaseSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size AutoScaleBaseSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用以自動縮放表單的基底大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，代表這個表單用來自動縮放的基準大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  這個成員保留回溯相容性。 如需自動調整的詳細資訊，請參閱[Windows Form 中的自動調整](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 值<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>屬性在表單顯示時間用來計算表單的縮放比例。 自動縮放基準大小是由用於表單做為基準系統字型大小的比較來判斷多少縮放表單比例，使用自動調整時。 如果您想要決定大小表單就會自動調整規模，以根據特定字型，而使用<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
> [!NOTE]
>  一開始建立表單時，會使用這個屬性的值。 一旦設定屬性之後，就無法變更。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出表單是否啟用自動捲動。</summary>
        <value>
          <see langword="true" /> 表示要啟用表單上的自動捲動，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為`true`，如果任何控制項位於外部表單的工作區，將會顯示在表單上的捲軸。 此外，自動捲動時，表單工作區會自動捲動以顯示具有輸入焦點的控制項。  
  
 您可以使用這個屬性，以防止使用者檢視控制項，當其視訊解析度設定為低解析度的能力。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.AutoScroll%2A>啟用 outsize 表單的工作區的控制項顯示的屬性。 此範例會建立新表單，並將<xref:System.Windows.Forms.Button>控制項加入表單。 <xref:System.Windows.Forms.Button>控制項是定位的 outsize 新表單的工作區。 <xref:System.Windows.Forms.Form.AutoScroll%2A>屬性設定為 true 以啟用使用者捲動至控制項在表單上顯示捲軸。 這個範例需要在此範例中定義的方法從另一種形式的事件處理常式或其他方法中呼叫。  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>根據 <see cref="P:System.Windows.Forms.Form.AutoSizeMode" /> 的設定調整表單大小。</summary>
        <value>
          如果表單將自動調整大小，則為 <see langword="true" />；如果必須手動調整大小，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.Form.AutoSize%2A>強制表單，以調整大小以符合其內容。  
  
 不自動調整大小的表單不會在 Visual Studio 表單設計工具中，不論值<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>屬性。 表單正確調整其大小在執行階段根據這兩個屬性的值。 相較之下，自訂<xref:System.Windows.Forms.UserControl>在設計階段和執行階段會自動調整本身大小。  
  
 當使用<xref:System.Windows.Forms.Form.AutoSize%2A>、<xref:System.Windows.Forms.Control.MinimumSize%2A>和<xref:System.Windows.Forms.Control.MaximumSize%2A>遵守屬性，但目前的值<xref:System.Windows.Forms.Control.Size%2A>屬性會被忽略。 使用<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>也會呈現<xref:System.Windows.Forms.Form.AutoScroll%2A>多餘的因為沒有任何方法可以壓縮表單，以隱藏其包含的控制項檢視中的屬性。  
  
 請參閱<xref:System.Windows.Forms.AutoSizeMode>表單行為時的詳細資訊的列舉<xref:System.Windows.Forms.Form.AutoSize%2A>是`true`。  
  
   
  
## Examples  
 下列程式碼範例示範使用自動調整大小以符合其內容的程式碼建立的表單。 當執行時，會顯示表單<xref:System.Windows.Forms.Label>、<xref:System.Windows.Forms.TextBox>輸入 URL，和<xref:System.Windows.Forms.Button>顯示該使用者的預設網頁瀏覽器內的 URL。 此程式碼範例會使用<xref:System.Windows.Forms.FlowLayoutPanel>配置包含一個接著一個控制項。 它也會設定<xref:System.Windows.Forms.Control.AutoSize%2A>和<xref:System.Windows.Forms.AutoSizeMode>来擴增和縮減以適合其表單的內容。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.AutoSize" /> 屬性變更時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSizeMode As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoSizeMode AutoSizeMode { System::Windows::Forms::AutoSizeMode get(); void set(System::Windows::Forms::AutoSizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單自動調整其大小所根據的模式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.AutoSizeMode" /> 列舉值。 預設值為 <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Windows.Forms.Form.AutoSizeMode%2A>屬性設為新值會導致表單以進行重新配置。  
  
 不自動調整大小的表單不會在 Visual Studio 表單設計工具中，不論值<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>屬性。 表單正確調整其大小在執行階段根據這兩個屬性的值。 相較之下，自訂<xref:System.Windows.Forms.UserControl>在設計階段和執行階段會自動調整本身大小。  
  
   
  
## Examples  
 下列程式碼範例示範使用自動調整大小以符合其內容的程式碼建立的表單。 執行時，表單 displaya <xref:System.Windows.Forms.Label>、<xref:System.Windows.Forms.TextBox>輸入 URL，和<xref:System.Windows.Forms.Button>顯示該使用者的預設網頁瀏覽器內的 URL。 此程式碼範例會使用<xref:System.Windows.Forms.FlowLayoutPanel>配置包含一個接著一個控制項。 它也會設定<xref:System.Windows.Forms.Control.AutoSize%2A>和<xref:System.Windows.Forms.AutoSizeMode>来擴增和縮減以適合其表單的內容。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">該值不是有效的 <see cref="T:System.Windows.Forms.AutoSizeMode" /> 值。</exception>
        <altmember cref="T:System.Windows.Forms.AutoSizeMode" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出這個容器中的控制項是否會在焦點改變時自動進行驗證。</summary>
        <value>
          <see cref="T:System.Windows.Forms.AutoValidate" /> 列舉值，指出包含的控制項是否會在焦點改變時隱含地進行驗證。 預設值為 Inherit。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.AutoValidate" /> 屬性變更時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項的背景色彩。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，代表控制項的背景色彩。 預設值為 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 屬性的值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberSignature Language="VB.NET" Value="Public Property CancelButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ CancelButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定使用者按下 ESC 鍵時所按下的按鈕控制項。</summary>
        <value>
          <see cref="T:System.Windows.Forms.IButtonControl" />，代表表單的取消按鈕。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表單的取消按鈕是每當使用者按下 ESC 鍵時所按下的按鈕控制項。 必須是指派給這個屬性的按鈕<xref:System.Windows.Forms.IButtonControl>是現用表單上或位於目前的表單上的容器。  
  
 這個屬性可讓您指定當使用者在應用程式中按下 ESC 鍵時所發生的預設動作。 您可以使用這個屬性可讓使用者快速巡覽簡單表單，讓它們直接按下 ESC 鍵以關閉視窗而不認可變更，而不是手動按一下 [取消] 5d; 按鈕，使用滑鼠。  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A> 可能無法運作如果表單上的另一個控制項攔截 ESC 鍵。 例如，如果您有<xref:System.Windows.Forms.ComboBox>開啟您的表單上，esc 鍵將會關閉<xref:System.Windows.Forms.ComboBox>而不是關閉表單。  
  
 <xref:System.Windows.Forms.IButtonControl>物件指派給<xref:System.Windows.Forms.Form.CancelButton%2A>必須顯示在表單中，否則按下 ESC 鍵會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToParent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToParent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將表單的位置置於父表單範圍的中央。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫<xref:System.Windows.Forms.Form.CenterToParent%2A>直接從程式碼的方法。 相反地，設定<xref:System.Windows.Forms.Form.StartPosition%2A>屬性<xref:System.Windows.Forms.FormStartPosition.CenterParent>。  
  
 如果表單或對話方塊是最上層，則<xref:System.Windows.Forms.Form.CenterToParent%2A>中心相對於畫面或桌面上表單。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterParent" />
        <altmember cref="M:System.Windows.Forms.Form.CenterToScreen" />
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToScreen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將表單置於目前螢幕的中央位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿呼叫這個方法直接從程式碼。 相反地，設定<xref:System.Windows.Forms.Form.StartPosition%2A>屬性<xref:System.Windows.Forms.FormStartPosition.CenterScreen>。  
  
 <xref:System.Windows.Forms.Form.CenterToScreen%2A>方法會使用下列優先順序清單來判斷用來置表單螢幕：  
  
1.  <xref:System.Windows.Forms.Form.Owner%2A>表單的屬性。  
  
2.  形式的 HWND 擁有者。  
  
3.  螢幕目前的滑鼠游標。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterScreen" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單工作區的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，代表表單工作區的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表單的工作區的大小是格式不包括框線和標題列的大小。 表單的工作區是控制項放置在表單區域。 您可以使用這個屬性，以取得正確的維度，或調整大小並放置在表單上的控制項時執行圖形作業。 若要取得整個表單的大小，請使用<xref:System.Windows.Forms.Form.Size%2A>屬性使用的個別屬性或<xref:System.Windows.Forms.Control.Height%2A>和<xref:System.Windows.Forms.Control.Width%2A>。  
  
> [!NOTE]
>  您目前無法繫結使用應用程式設定這個屬性。 如需有關應用程式設定的詳細資訊，請參閱[應用程式設定概觀](~/docs/framework/winforms/advanced/application-settings-overview.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立事件處理常式<xref:System.Windows.Forms.Control.Resize>表單的事件。 事件處理常式使用<xref:System.Windows.Forms.Form.ClientSize%2A>進行表單屬性<xref:System.Windows.Forms.Button>控制項，名為`button1`填滿整個用戶端區域的表單。  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉表單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當關閉表單時，關閉物件內建立的所有資源，並處置表單。 您可以避免在執行階段在表單關閉處理<xref:System.Windows.Forms.Form.Closing>事件及設定<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.ComponentModel.CancelEventArgs>做為參數傳遞給事件處理常式。 如果您在關閉的表單是應用程式的啟動表單，您的應用程式就會結束。  
  
 兩個條件時不會處置表單`Close`時 （1） 它是多重文件介面 (MDI) 應用程式的一部分和表單不可見的; 且 （2） 您的顯示格式使用<xref:System.Windows.Forms.Form.ShowDialog%2A>。 在這些情況下，您必須呼叫<xref:System.Windows.Forms.Form.Dispose%2A>手動將標示所有表單的控制項進行記憶體回收。  
  
> [!NOTE]
>  當<xref:System.Windows.Forms.Form.Close%2A>上呼叫方法<xref:System.Windows.Forms.Form>顯示為強制回應視窗，您不能呼叫<xref:System.Windows.Forms.Control.Show%2A>方法來顯示表單，因為已發行的形式的資源。 若要隱藏的表單，然後讓可見的使用<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>方法。  
  
> [!CAUTION]
>  之前[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]2.0，<xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>和<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件也沒有引發的時機<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>呼叫方法來結束您的應用程式。 如果您有驗證程式碼必須執行這些事件之一時，您應該呼叫<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>方法的每個開啟的表單，然後再呼叫個別<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">當控制代碼正在建立時，表單會關閉。</exception>
        <exception cref="T:System.ObjectDisposedException">當 <see cref="E:System.Windows.Forms.Form.Activated" /> 設為 <see cref="P:System.Windows.Forms.Form.WindowState" /> 時，您無法從 <see cref="F:System.Windows.Forms.FormWindowState.Maximized" /> 事件呼叫這個方法。</exception>
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單已關閉時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed>事件是.NET Framework 2.0 版中的過時; 使用<xref:System.Windows.Forms.Form.FormClosed>事件改為。  
  
 由使用者或由關閉表單之後，就會發生此事件<xref:System.Windows.Forms.Form.Close%2A>形式的方法。 若要避免關閉表單，處理<xref:System.Windows.Forms.Form.Closing>事件以及組<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.ComponentModel.CancelEventArgs>傳遞至事件處理常式`true`。  
  
 執行工作，例如釋放表單所使用的資源和儲存在表單中輸入資訊或更新它的父表單，您可以使用此事件。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>和<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件也沒有引發的時機<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>呼叫方法來結束您的應用程式。 如果您有驗證程式碼必須執行這些事件之一時，您應該呼叫<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>方法的每個開啟的表單，然後再呼叫個別<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 如果表單為 MDI 父表單<xref:System.Windows.Forms.Form.Closing>MDI 父表單之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.Closing>就會引發事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.Closed>就會引發 MDI 父表單的事件。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Closed>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成員。 若要執行此範例，下列程式碼的呼叫格式貼`Form1`包含<xref:System.Windows.Forms.Button>呼叫`Button1`和兩個<xref:System.Windows.Forms.Label>控制項稱為`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單正在關閉時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closing>事件是.NET Framework 2.0 版中的過時; 使用<xref:System.Windows.Forms.Form.FormClosing>事件改為。  
  
 <xref:System.Windows.Forms.Form.Closing>關閉表單，就會發生事件。 當關閉表單時，並釋出物件內建立的所有資源，並處置表單。 如果您取消此事件，將表單保持開啟。 若要取消之表單的關閉，請設定<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.ComponentModel.CancelEventArgs>傳遞至事件處理常式`true`。  
  
 當表單顯示為強制回應對話方塊時，按一下**關閉**按鈕 （表單右上角的 X 按鈕） 將會隱藏表單和<xref:System.Windows.Forms.Form.DialogResult%2A>屬性設定為`DialogResult.Cancel`。 您可以覆寫的值指派給<xref:System.Windows.Forms.Form.DialogResult%2A>屬性，當使用者按一下**關閉**藉由設定按鈕<xref:System.Windows.Forms.Form.DialogResult%2A>屬性中的事件處理常式<xref:System.Windows.Forms.Form.Closing>表單的事件。  
  
> [!NOTE]
>  當<xref:System.Windows.Forms.Form.Close%2A>上呼叫方法<xref:System.Windows.Forms.Form>顯示為強制回應視窗，您不能呼叫<xref:System.Windows.Forms.Control.Show%2A>方法來顯示表單，因為已發行的形式的資源。 若要隱藏的表單，然後讓可見的使用<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>方法。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>和<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件也沒有引發的時機<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>呼叫方法來結束您的應用程式。 如果您有驗證程式碼必須執行這些事件之一時，您應該呼叫<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>方法的每個開啟的表單，然後再呼叫個別<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 如果表單為 MDI 父表單<xref:System.Windows.Forms.Form.Closing>MDI 父表單之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.Closing>就會引發事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.Closed>就會引發 MDI 父表單的事件。 取消<xref:System.Windows.Forms.Form.Closing>的 MDI 子表單的事件不會防止<xref:System.Windows.Forms.Form.Closing>引發 MDI 父表單的事件。 不過，取消事件將會設定為`true`<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.ComponentModel.CancelEventArgs>做為參數傳遞給父表單。 若要強制所有 MDI 父和子表單關閉時，將<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性`false`在 MDI 父表單。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Windows.Forms.Form.Closing>測試中的文字<xref:System.Windows.Forms.TextBox>已變更。 如果有，會要求使用者是否要將變更儲存至檔案。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberSignature Language="VB.NET" Value="Public Property ControlBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ControlBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出控制項方塊是否顯示在表單的標題列中。</summary>
        <value>
          <see langword="true" /> 如果表單的表單，右上角顯示控制項方塊否則， <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Forms.Form.ControlBox%2A>屬性設定為`true`，控制項方塊是否顯示在標題列右上角。 控制項方塊可以包含最小化、 最大化，以及協助按鈕除了 「 關閉 」 按鈕。 如`ControlBox`屬性才能發生效用，您也必須設定表單的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
 如果您設定<xref:System.Windows.Forms.Form.ControlBox%2A>至`false`也設定及<xref:System.Windows.Forms.Form.Location%2A>屬性，<xref:System.Windows.Forms.Form.Size%2A>表單的屬性不會更新以反映已隱藏表單的非工作區。 若要修正這個問題，請將程式碼放會改變<xref:System.Windows.Forms.Form.Location%2A>屬性<xref:System.Windows.Forms.Control.HandleCreated>事件處理常式。  
  
> [!NOTE]
>  當設定為`false`、<xref:System.Windows.Forms.Form.ControlBox%2A>屬性就會顯示最大化的建立時間為多重文件介面 (MDI) 子表單上沒有作用。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Windows.Forms.Form.ControlBox%2A>， <xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>屬性來建立一個表單，並沒有任何框線或標題 方塊。 在此範例中建立的表單無法用來建立應用程式的啟動顯示畫面。 這個範例需要範例的方法是定義在表單類別，而且當表單在初始化時呼叫。  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立控制項的控制項集合的新執行個體。</summary>
        <returns>指定至控制項的 <see cref="T:System.Windows.Forms.Control.ControlCollection" /> 的新執行個體。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立表單的控制代碼。 如果衍生類別覆寫這個函式，它必須呼叫基底實作。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">已經建立這個 <see cref="T:System.Windows.Forms.Form" /> 的控制代碼。</exception>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>建立控制代碼時，取得必要的建立參數。</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" />，包含建立控制項之控制代碼時所需的建立參數。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單失去焦點且不再是使用中的表單時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要執行工作，例如從停用表單的資料來更新應用程式中的另一個視窗，您可以使用此事件。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.Deactivate>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.Deactivate>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
        <altmember cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項支援的預設輸入法 (IME) 模式。</summary>
        <value>其中一個 <see cref="T:System.Windows.Forms.ImeMode" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 輸入的法 (ime) 是可讓使用者使用標準鍵盤輸入複雜字元和符號，例如日文漢字字元的程式。  
  
 在中實作<xref:System.Windows.Forms.Form>類別，這個屬性永遠傳回<xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType>值。 這個屬性的值指派給<xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項的預設大小。</summary>
        <value>控制項的預設 <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要處理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>傳送指定的訊息至預設的視窗程序。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle DesktopBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Windows 桌面上表單的大小和位置。</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" />，代表按照桌面座標，表單在 Windows 桌面上的界限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面座標為基礎的畫面中，排除工作列工作區域。 在桌面座標系統是以像素為基礎。 如果您的應用程式在多個監視器系統上執行，表單的合併桌面座標。  
  
 您可以使用這個屬性的大小和位置，相對於其他表單或應用程式表單在 Windows 桌面上。  
  
   
  
## Examples  
 下列程式碼範例會設定的大小和表單的位置，使表單從桌面到 50 像素的桌面左框線定位 50 像素。 這個範例需要在表單的類別內所定義之方法。  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopLocation" />
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopLocation As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point DesktopLocation { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Windows 桌面上表單的位置。</summary>
        <value>
          <see cref="T:System.Drawing.Point" />，代表桌面上表單的位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面座標為基礎的畫面中，排除工作列工作區域。 在桌面座標系統為基礎的像素。 如果您的應用程式正在執行多重監視器系統上，在表單的合併桌面座標。  
  
 您可以使用這個屬性，在 Windows 桌面上定位相對於其他表單和應用程式。  
  
 如果您呼叫<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>方法之前先呼叫<xref:System.Windows.Forms.Form.Show%2A>方法中，表單就會放置在其預設位置，是由作業系統決定。 如需視窗定位的詳細資訊，請參閱 < 視窗功能 > 文件位於 MSDN library 中的 「 視窗大小和位置 」 一節http://msdn.microsoft.com/library。  
  
 如果您呼叫<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>之後呼叫<xref:System.Windows.Forms.Form.Show%2A>，表單就會放置在您指定的位置。  
  
   
  
## Examples  
 下列程式碼範例會設定表單的位置，讓表單定位 100 像素的從左框線的桌面和 100 像素的桌面。 這個範例需要在表單的類別內已定義方法。  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DialogResult DialogResult { System::Windows::Forms::DialogResult get(); void set(System::Windows::Forms::DialogResult value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單的對話方塊結果。</summary>
        <value>
          <see cref="T:System.Windows.Forms.DialogResult" />，代表表單在當做對話方塊使用時的結果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 就會顯示為強制回應對話方塊時，會將表單中傳回的值為表單的對話方塊結果。 如果表單顯示為對話方塊中，設定此屬性的值與<xref:System.Windows.Forms.DialogResult>列舉設定表單的對話方塊結果的值，會隱藏強制回應對話方塊，將控制權傳回給呼叫的表單。 這個屬性通常由設定<xref:System.Windows.Forms.Button.DialogResult%2A>屬性<xref:System.Windows.Forms.Button>表單上的控制項。 當使用者按一下<xref:System.Windows.Forms.Button>控制項，指派給的值<xref:System.Windows.Forms.Button.DialogResult%2A>屬性<xref:System.Windows.Forms.Button>指派給<xref:System.Windows.Forms.Form.DialogResult%2A>表單的屬性。  
  
 當表單顯示為強制回應對話方塊時，按一下**關閉**按鈕 （表單右上角的 X 按鈕） 將會隱藏表單和<xref:System.Windows.Forms.Form.DialogResult%2A>屬性設定為`DialogResult.Cancel`。 <xref:System.Windows.Forms.Form.Close%2A>不會自動呼叫方法時使用者按下**關閉**按鈕的對話方塊中設定的值或<xref:System.Windows.Forms.Form.DialogResult%2A>屬性。 相反地，此表單隱藏的並可再次顯示，而不需要建立對話方塊中的新執行個體。 基於此行為，您必須呼叫<xref:System.Windows.Forms.Control.Dispose%2A>時您的應用程式不再需要表單形式的方法。  
  
 您可以使用這個屬性來決定對話方塊關閉才能正確地處理在對話方塊中所執行之動作的方式。  
  
> [!NOTE]
>  您可以覆寫的值指派給<xref:System.Windows.Forms.Form.DialogResult%2A>屬性，當使用者按一下**關閉**藉由設定按鈕<xref:System.Windows.Forms.Form.DialogResult%2A>屬性中的事件處理常式<xref:System.Windows.Forms.Form.Closing>表單的事件。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Form>顯示為強制回應視窗，所傳回的值<xref:System.Windows.Forms.Form.DialogResult%2A>屬性可能不會傳回值，因為當表單關閉時就會自動釋放表單的資源指派給表單。  
  
   
  
## Examples  
 下列程式碼範例顯示為對話方塊的表單，並顯示訊息方塊，指出表單的 [確定] 或 [取消] 按鈕已按下藉由參考<xref:System.Windows.Forms.Form.DialogResult%2A>表單的屬性。  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值超過有效值的範圍。</exception>
        <altmember cref="T:System.Windows.Forms.DialogResult" />
        <altmember cref="P:System.Windows.Forms.Button.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>處置 (Dispose) <see cref="T:System.Windows.Forms.Form" /> 所使用的資源 (除了記憶體之外)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`與`disposing`設`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.Windows.Forms.Form> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 `Dispose` 方法。  
  
 <xref:System.Windows.Forms.Form.Dispose%2A> 如果用來顯示表單會自動呼叫<xref:System.Windows.Forms.Form.Show%2A>方法。 如果另一個方法，例如<xref:System.Windows.Forms.Form.ShowDialog%2A>使用時，或表單會永遠不會顯示，您必須呼叫<xref:System.Windows.Forms.Form.Dispose%2A>自己應用程式中。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。 覆寫 <see langword="Dispose(Boolean)" /> 時，請小心不要參考到先前已在對 <see langword="Dispose" /> 的早期呼叫中被處置 (Dispose) 的物件。 如需有關如何實作<see langword="Dispose(Boolean)" />，請參閱[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 如需有關<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[覆寫 Finalize 方法](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於當表單顯示於顯示裝置上，而該裝置上的 DPI 設定變更時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FormBorderStyle As FormBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormBorderStyle FormBorderStyle { System::Windows::Forms::FormBorderStyle get(); void set(System::Windows::Forms::FormBorderStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單的框線樣式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormBorderStyle" />，代表顯示於表單的框線樣式。 預設值為 <see langword="FormBorderStyle.Sizable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表單的框線樣式會決定表單的外部端的顯示方式。 除了變更表單的框線顯示特定框線的樣式會防止表單會調整大小。 例如，`FormBorderStyle.FixedDialog`框線樣式，對話方塊中變更表單的框線，並防止表單正在調整大小。 大小或表單的標題列區段的可用性，也會影響的框線樣式。  
  
> [!NOTE]
>  與<xref:System.Windows.Forms.FormBorderStyle.Sizable>樣式，就無法調整大小視窗低於某些最小值，即使您已設定<xref:System.Windows.Forms.Form.ControlBox%2A>至`false`和指派的零長度字串<xref:System.Windows.Forms.Form.Text%2A>。 解決這個問題的工作，請考慮使用<xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow>改用樣式。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值超過有效值的範圍。</exception>
        <altmember cref="T:System.Windows.Forms.FormBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosed As FormClosedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosedEventHandler ^ FormClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單關閉之後。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosed>由使用者或由關閉表單之後，就會發生事件<xref:System.Windows.Forms.Form.Close%2A>方法或<xref:System.Windows.Forms.Application.Exit%2A>方法<xref:System.Windows.Forms.Application>類別。 若要避免關閉表單，處理<xref:System.Windows.Forms.Form.FormClosing>事件以及組<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.ComponentModel.CancelEventArgs>傳遞至事件處理常式`true`。  
  
 執行工作，例如釋放表單所使用的資源和儲存在表單中輸入資訊或更新它的父表單，您可以使用此事件。  
  
 格式為多重文件介面 (MDI) 父表單時，如果<xref:System.Windows.Forms.Form.FormClosing>MDI 父表單之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.FormClosing>就會引發事件。 同樣地，<xref:System.Windows.Forms.Form.FormClosed>之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.FormClosed>就會引發 MDI 父表單的事件。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.FormClosed>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.FormClosed>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosing As FormClosingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosingEventHandler ^ FormClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單關閉之前。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosing>關閉表單，就會發生事件。 當關閉表單時，加以處置，釋放與表單相關聯的所有資源。 如果您取消此事件，將表單保持開啟。 若要取消之表單的關閉，請設定<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.Windows.Forms.FormClosingEventArgs>傳遞至事件處理常式`true`。  
  
 當表單顯示為強制回應對話方塊時，按一下**關閉**按鈕 （表單右上角的 X 按鈕） 將會隱藏表單和<xref:System.Windows.Forms.Form.DialogResult%2A>屬性設定為`DialogResult.Cancel`。 您可以覆寫的值指派給<xref:System.Windows.Forms.Form.DialogResult%2A>屬性，當使用者按一下**關閉**藉由設定按鈕<xref:System.Windows.Forms.Form.DialogResult%2A>屬性中的事件處理常式<xref:System.Windows.Forms.Form.FormClosing>表單的事件。  
  
> [!NOTE]
>  當<xref:System.Windows.Forms.Form.Close%2A>上呼叫方法<xref:System.Windows.Forms.Form>顯示為強制回應視窗，您不能呼叫<xref:System.Windows.Forms.Control.Show%2A>方法來顯示表單，因為已發行的形式的資源。 若要隱藏的表單，然後讓可見的使用<xref:System.Windows.Forms.Control.Hide%2A>方法。  
  
 格式為多重文件介面 (MDI) 父表單時，如果<xref:System.Windows.Forms.Form.FormClosing>MDI 父表單之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.FormClosing>就會引發事件。 同樣地，<xref:System.Windows.Forms.Form.FormClosed>之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.FormClosed>就會引發 MDI 父表單的事件。 取消<xref:System.Windows.Forms.Form.FormClosing>的 MDI 子表單的事件不會防止<xref:System.Windows.Forms.Form.FormClosing>引發 MDI 父表單的事件。 不過，取消事件將會設定為`true`<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.Windows.Forms.FormClosingEventArgs>做為參數傳遞給父表單的類別。 若要強制所有 MDI 父和子表單關閉時，將<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性`false`在 MDI 父表單。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.FormClosing>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.FormClosing>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::SizeF GetAutoScaleSize(System::Drawing::Font ^ font);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，代表決定表單之自動縮放基準大小的字型。</param>
        <summary>取得根據指定字型自動縮放表單時所得的大小。</summary>
        <returns>
          <see cref="T:System.Drawing.SizeF" />，代表表單的自動縮放大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法已過時的.net Framework 2.0 版。 這個成員保留回溯相容性。 如需自動調整的詳細資訊，請參閱[Windows Form 中的自動調整](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 您可以使用這個方法來判斷表單將字型套用至表單之前會自動調整規模，特定字型的大小。 如果您想要決定大小表單自動縮放，以根據目前指派給表單的字型，請使用<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">
          <see cref="T:System.Drawing.Rectangle" />，指定要為其擷取顯示範圍的區域。</param>
        <param name="factor">控制項範圍的高度和寬度。</param>
        <param name="specified">其中一個 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值，指定在定義控制項的大小和位置時所用的控制項範圍。</param>
        <summary>擷取縮放控制項的範圍。</summary>
        <returns>
          <see cref="T:System.Drawing.Rectangle" />，表示縮放控制項的範圍。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberSignature Language="VB.NET" Value="Public Property HelpButton As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HelpButton { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應在表單的標題方塊中顯示 [說明] 按鈕。</summary>
        <value>
          若要在表單的標題列中顯示 [說明] 按鈕，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為`true`，加上問號的小按鈕會出現在左邊的標題列**關閉** 按鈕。 您可以使用此按鈕以顯示您的應用程式的說明。 您可以建立事件處理常式<xref:System.Windows.Forms.Control.HelpRequested>按一下表單的 [說明] 按鈕時顯示給使用者的說明資訊的事件。  

若要顯示 [說明] 按鈕，在表單值<xref:System.Windows.Forms.Form.ControlBox>屬性必須是`true`，其預設值。 <xref:System.Windows.Forms.Form.ControlBox>屬性決定的標題列右上角是否包含控制項，例如最大化按鈕、 最小化按鈕、 [說明] 按鈕和 [關閉] 按鈕。 此外，您也必須設定表單的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  


> [!IMPORTANT]
>  值<xref:System.Windows.Forms.Form.HelpButton%2A>屬性會被忽略，如果**最大化**或**最小化**按鈕會顯示。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpButtonClicked As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ HelpButtonClicked;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於按一下 [說明] 按鈕時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.HelpButtonClicked>就會發生事件時**協助**中表單的標題列按鈕。 **協助**按鈕會顯示當<xref:System.Windows.Forms.Form.HelpButton%2A>屬性設定為`true`。 <xref:System.Windows.Forms.Form.HelpButtonClicked> 您可以取消。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.HelpButtonClicked>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.HelpButtonClicked>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.HelpButton" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As Icon" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Icon ^ Icon { System::Drawing::Icon ^ get(); void set(System::Drawing::Icon ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單的圖示。</summary>
        <value>
          <see cref="T:System.Drawing.Icon" />，代表表單的圖示。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表單的圖示會指定代表表單的工作列，以及顯示控制項方塊，在表單的圖示的圖片。  
  
 如果此屬性會有任何作用<xref:System.Windows.Forms.Form.FormBorderStyle%2A>設<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>。 在此情況下，表單不會顯示圖示。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanged As InputLanguageChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangedEventHandler ^ InputLanguageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單的輸入語言已變更之後。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要變更表單的外觀和文字根據表單的輸入語言所做的變更，您可以使用此事件。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.InputLanguageChanged>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.InputLanguageChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanging As InputLanguageChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangingEventHandler ^ InputLanguageChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於使用者嘗試變更表單的輸入語言時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 輸入語言變更表單進行的作業之前，就會發生此事件。 您可以取消設定的語言變更<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.Windows.Forms.InputLanguageChangingEventArgs>傳遞至事件處理常式`false`。 如果事件已取消，不會變更輸入的語言。 您可以使用此事件以判斷是否適合您的應用程式要求的輸入的語言變更。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.InputLanguageChanging>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.InputLanguageChanging>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMdiChild As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiChild { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出表單是否為多重文件介面 (MDI) 子表單。</summary>
        <value>
          如果表單為 MDI 子表單，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在執行階段，MDI 子表單會顯示在 MDI 父表單的工作區。 可以最大化、 最小化，和在 MDI 父表單中移動的 MDI 子表單。 若要建立的 MDI 子表單，指派<xref:System.Windows.Forms.Form>將會是 MDI 父表單的<xref:System.Windows.Forms.Form.MdiParent%2A>子表單的屬性。 您可以使用<xref:System.Windows.Forms.Form.IsMdiContainer%2A>屬性來決定表單是否為 MDI 父表單。  
  
 您可以使用<xref:System.Windows.Forms.Form.IsMdiChild%2A>屬性來決定方法或屬性所傳回的表單為 MDI 子表單或在您的應用程式，例如對話方塊中的標準格式。  
  
> [!NOTE]
>  所有 MDI 子表單都有可調整大小框線、 控制功能表方塊和 最小化和**最大化**按鈕，不論設定為何<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.ControlBox%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.MaximizeBox%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property IsMdiContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiContainer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出表單是否為多重文件介面 (MDI) 子表單的容器。</summary>
        <value>
          如果表單為 MDI 子表單的容器，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性變更的顯示和行為的表單為 MDI 父表單。 當這個屬性設定為`true`，表單會顯示具有凸起框線下凹的工作區。 所有指派給父表單的 MDI 子表單會顯示在其工作區。  
  
 當關閉 MDI 父表單時， <xref:System.Windows.Forms.Form.Closing> MDI 父表單之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.Closing>就會引發事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前引發事件的所有 MDI 子表單<xref:System.Windows.Forms.Form.Closed>就會引發 MDI 父表單的事件。  
  
> [!NOTE]
>  如果有兩個<xref:System.Windows.Forms.MenuStrip>上設定的 MDI 子表單的控制項<xref:System.Windows.Forms.Form.IsMdiContainer%2A>至`true`父表單會合併的其中之一的內容<xref:System.Windows.Forms.MenuStrip>控制項。 使用<xref:System.Windows.Forms.ToolStripManager.Merge%2A>其他子內容合併<xref:System.Windows.Forms.MenuStrip>MDI 父表單上的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.IsMdiContainer%2A>屬性，以及變更`BackColor`MDI 表單的屬性。 若要執行此範例中，將下列程式碼貼在新的表單。  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRestrictedWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRestrictedWindow { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出表單是否可以無限制地使用所有的視窗和使用者輸入事件。</summary>
        <value>
          如果表單有限制則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A>屬性會決定是否<xref:System.Security.Permissions.UIPermissionWindow.AllWindows>授與權限。 這個屬性會設定表單的建構函式，在執行階段，而表單的存留期間快取。 在部分信任中執行的 Windows Form 應用程式不能規避這項檢查，因為通用語言執行平台可確保在部分信任中一律會呼叫父建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPreview As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeyPreview { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出表單是否要在事件傳送至焦點所在的控制項之前，接收按鍵事件。</summary>
        <value>
          如果表單將接收所有按鍵事件，則為 <see langword="true" />；如果表單上目前選取的控制項將接收按鍵事件，則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為`true`，表單將會收到所有<xref:System.Windows.Forms.Control.KeyPress>， <xref:System.Windows.Forms.Control.KeyDown>，和<xref:System.Windows.Forms.Control.KeyUp>事件。 表單的事件處理常式已處理按鍵輸入完成之後，並接著會將按鍵指派給擁有焦點的控制項。 例如，如果<xref:System.Windows.Forms.Form.KeyPreview%2A>屬性設定為`true`目前選取的控制項，且<xref:System.Windows.Forms.TextBox>按鍵由表單的事件處理常式之後<xref:System.Windows.Forms.TextBox>控制項將會收到已按下按鍵。 若要處理只能在表單層級的鍵盤事件，並允許接收鍵盤事件的控制項，將<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>屬性在表單的<xref:System.Windows.Forms.Control.KeyPress>事件處理常式來`true`。  
  
 您可以使用這個屬性來處理大部分的按鍵輸入，在您的應用程式並不是處理按鍵，或呼叫適當的控制項來處理按鍵。 例如，當應用程式使用功能鍵，您可以在處理表單層級，而非撰寫程式碼可能會收到按鍵事件的每個控制項的按鍵輸入。  
  
> [!NOTE]
>  如果表單中不的任何可見的或啟用的控制項，則會自動收到所有的鍵盤事件。  
  
> [!NOTE]
>  在表單上的控制項可能會設計成取消它接收的任何按鍵輸入。 因為控制項不會將這些按鍵動作傳送至表單，表單將永遠不會看到它們不論設定為何<xref:System.Windows.Forms.Form.KeyPreview%2A>。  
  
   
  
## Examples  
 下列程式碼範例將示範如何設定表單的<xref:System.Windows.Forms.Form.KeyPreview%2A>屬性設為 true 並處理表單層級的索引鍵的事件。 要執行此範例中，貼上下列程式碼空白表單中。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LayoutMdi (value As MdiLayout)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LayoutMdi(System::Windows::Forms::MdiLayout value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">其中一個 <see cref="T:System.Windows.Forms.MdiLayout" /> 值，定義 MDI 子表單的配置。</param>
        <summary>在 MDI 父表單內排列多重文件介面 (MDI) 子表單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法，以便更容易瀏覽和管理 MDI 子表單的 MDI 父表單中排列 MDI 子表單。 MDI 子表單可以並排顯示水平及垂直重疊，或為 MDI 父表單中的圖示。  
  
   
  
## Examples  
 下列程式碼範例會顯示在 MDI 應用程式的父表單中的事件處理常式的視窗功能表的功能表項目。 每個事件處理常式會呼叫<xref:System.Windows.Forms.Form.LayoutMdi%2A>排列任何子表單，方法是目前在應用程式中開啟。  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MdiLayout" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在表單第一次顯示之前。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要執行工作，例如配置表單所使用的資源，您可以使用此事件。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成員。 若要執行此範例，下列程式碼的呼叫格式貼`Form1`包含<xref:System.Windows.Forms.Button>呼叫`Button1`和兩個<xref:System.Windows.Forms.Label>控制項稱為`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Drawing.Point" />，代表螢幕座標中 <see cref="T:System.Windows.Forms.Form" /> 的左上角。</summary>
        <value>
          <see cref="T:System.Drawing.Point" />，代表螢幕座標中 <see cref="T:System.Windows.Forms.Form" /> 的左上角。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point> 為結構時，這表示它是實值類型。 如果您存取中的屬性<xref:System.Drawing.Point>，就會傳回一份屬性。 因此，變更<xref:System.Drawing.Point.X%2A>或<xref:System.Drawing.Point.Y%2A>屬性<xref:System.Drawing.Point>從傳回<xref:System.Windows.Forms.Control.Location%2A>屬性將不會影響<xref:System.Windows.Forms.Control.Left%2A>， <xref:System.Windows.Forms.Control.Right%2A>， <xref:System.Windows.Forms.Control.Top%2A>，或<xref:System.Windows.Forms.Control.Bottom%2A>屬性值<xref:System.Windows.Forms.Form>. 若要調整這些屬性，個別設定每個屬性的值，或設定<xref:System.Windows.Forms.Form.Location%2A>屬性與新<xref:System.Drawing.Point>。  
  
 <xref:System.Windows.Forms.Form.Location%2A>屬性取得或設定<xref:System.Windows.Forms.Control.Location%2A>屬性<xref:System.Windows.Forms.Control>基底類別，並設定<xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A>屬性`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Property MainMenuStrip As MenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuStrip ^ MainMenuStrip { System::Windows::Forms::MenuStrip ^ get(); void set(System::Windows::Forms::MenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單的主要功能表容器。</summary>
        <value>
          <see cref="T:System.Windows.Forms.MenuStrip" />，代表表單功能表結構的容器。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了設定<xref:System.Windows.Forms.Form.MainMenuStrip%2A>屬性，您必須<xref:System.Windows.Forms.Control.ControlCollection.Add%2A><xref:System.Windows.Forms.MenuStrip>控制權傳輸至<xref:System.Windows.Forms.Control.Controls%2A>表單的集合。  
  
 <xref:System.Windows.Forms.MenuStrip>類別會取代<xref:System.Windows.Forms.MainMenu>在舊版的.NET Framework 類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項之間的空格。</summary>
        <value>表示控制項之間間距的值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.Margin" /> 屬性變更時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaximizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要在表單的標題列中顯示 [最大化] 按鈕。</summary>
        <value>
          <see langword="true" /> 若要顯示**最大化**按鈕的表單，否則<see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 A**最大化**按鈕可讓使用者將視窗放大為全螢幕模式。 若要顯示**最大化**按鈕，在表單值<xref:System.Windows.Forms.Form.ControlBox>屬性必須是`true`，其預設值。  <xref:System.Windows.Forms.Form.ControlBox>屬性決定的標題列右上角是否包含控制項，例如最大化按鈕、 最小化按鈕、 [說明] 按鈕和 [關閉] 按鈕。 此外，您也必須設定表單的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
 A**最大化**按鈕會自動成為還原按鈕最大化視窗時。 最小化或還原視窗會自動變更 還原 按鈕回到**最大化** 按鈕。  
  
> [!NOTE]
>  最大化表單，在執行階段會產生<xref:System.Windows.Forms.Control.Resize>事件。 <xref:System.Windows.Forms.Form.WindowState%2A>屬性會反映在視窗的目前狀態。 如果您設定<xref:System.Windows.Forms.Form.WindowState%2A>屬性`FormWindowState.Maximized`，表單最大化獨立於任何設定，則實際上<xref:System.Windows.Forms.Form.MaximizeBox%2A>和<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Property MaximizedBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::Rectangle MaximizedBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得並設定當表單最大化時的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" />，代表表單最大化時的界限。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Drawing.Rectangle.Top" /> 屬性值大於表單高度。  
  
 -或-  
  
 <see cref="P:System.Drawing.Rectangle.Left" /> 屬性值大於表單寬度。</exception>
        <block subset="none" type="overrides">
          <para>類別繼承自<see cref="T:System.Windows.Forms.Form" />可以覆寫這個方法以提供表單的新界限最大化。 類別會設定這個屬性在內部當表單的**最大化**按鈕。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximizedBoundsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximizedBoundsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.MaximizedBounds" /> 屬性的值已變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表單所能調整的大小上限。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，代表表單的大小上限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您限制大小的表單，以指定的最大大小。 可以使用這項功能在相同的時間，顯示多個視窗時，若要確認的單一視窗不會隱藏其他視窗。 如果這個屬性設定為<xref:System.Drawing.Size>是 0 的高度和寬度，表單中的為 0 的物件會有沒有大小上限超過 Windows 所設定的限制。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定<xref:System.Windows.Forms.Form.MaximumSize%2A>屬性。  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Drawing.Size" /> 物件內的高度或寬度值小於零。</exception>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MaxWindowTrackSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.MaximumSize" /> 屬性的值已變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.MaximumSizeChanged>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.MaximumSizeChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MdiChildActivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MdiChildActivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於多重文件介面 (MDI) 子表單在 MDI 應用程式內啟動或關閉時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個事件來執行工作，例如更新的 MDI 子表單的內容和變更的功能表選項，可用在 MDI 父表單中的 MDI 子表單，就啟動狀態。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.MdiChildActivate>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.MdiChildActivate>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiChildren As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ MdiChildren { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表單陣列，表示身為這個表單父代的多重文件介面 (MDI) 子表單。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> 物件的陣列，每個物件會各自識別這個表單的其中一個 MDI 子表單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您取得目前已開啟 MDI 父表單中的所有 MDI 子表單的參考。 若要建立的 MDI 子表單，指派<xref:System.Windows.Forms.Form>將會是 MDI 父表單的<xref:System.Windows.Forms.Form.MdiParent%2A>子表單的屬性。  
  
 您可以使用這個屬性來循環所有 MDI 子表單來執行作業，例如在 MDI 父表單關閉時，將資料儲存至資料庫或更新您的應用程式中執行的動作為基礎的子表單上的欄位。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.MdiChildren%2A>屬性來逐一查看清單的 MDI 子表單，並加入<xref:System.Windows.Forms.Button>給每個控制項。  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiParent As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ MdiParent { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個表單目前的多重文件介面 (MDI) 父表單。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" />，代表 MDI 父表單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的 MDI 子表單，指派<xref:System.Windows.Forms.Form>將會是 MDI 父表單的<xref:System.Windows.Forms.Form.MdiParent%2A>子表單的屬性。 以取得需要所有的子表單的全域資訊，或叫用方法會執行所有的子表單的動作，您可以使用這個屬性，從 MDI 子表單。  
  
> [!NOTE]
>  如果有兩個<xref:System.Windows.Forms.MenuStrip>上設定的 MDI 子表單的控制項<xref:System.Windows.Forms.Form.IsMdiContainer%2A>至`true`父表單會合併的其中之一的內容<xref:System.Windows.Forms.MenuStrip>控制項。 使用<xref:System.Windows.Forms.ToolStripManager.Merge%2A>其他子內容合併<xref:System.Windows.Forms.MenuStrip>MDI 父表單上的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何在 MDI 應用程式中建立子表單。 範例程式碼會建立具有唯一的文字，以識別子表單的表單。 此範例會使用<xref:System.Windows.Forms.Form.MdiParent%2A>屬性可指定表單是子表單。 這個範例需要在範例中的程式碼會呼叫從表單具有其<xref:System.Windows.Forms.Form.IsMdiContainer%2A>屬性設定為`true`和表單具有名為的私用類別層級的整數變數`childCount`。  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">指派給這個屬性的 <see cref="T:System.Windows.Forms.Form" /> 並未標記為 MDI 容器。  
  
 -或-  
  
 指派給這個屬性的 <see cref="T:System.Windows.Forms.Form" /> 既是子表單也是 MDI 容器表單。  
  
 -或-  
  
 指派給這個屬性的 <see cref="T:System.Windows.Forms.Form" /> 位於不同的執行緒。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">要求的表單。 關聯的列舉型別：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberSignature Language="VB.NET" Value="Public Property Menu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ Menu { System::Windows::Forms::MainMenu ^ get(); void set(System::Windows::Forms::MainMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定顯示在表單中的 <see cref="T:System.Windows.Forms.MainMenu" />。</summary>
        <value>
          <see cref="T:System.Windows.Forms.MainMenu" />，代表要顯示在表單中的功能表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個屬性在執行階段完成功能表組之間切換。 例如，您可以定義一個<xref:System.Windows.Forms.MainMenu>多重文件介面 (MDI) 表單有任何作用中的 MDI 子表單，而另一個時所要顯示<xref:System.Windows.Forms.MainMenu>時子視窗隨即顯示。 您也可以使用不同<xref:System.Windows.Forms.MainMenu>當特定條件存在於您需要顯示另一個功能表設定的應用程式。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Windows.Forms.MainMenu>，會指派兩個<xref:System.Windows.Forms.MenuItem>物件加入至<xref:System.Windows.Forms.MainMenu>並將它連結至表單。 這個範例需要您有<xref:System.Windows.Forms.Form>建立名為`Form1`。  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單的功能表失去焦點時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您按一下功能表中的任何功能表項目，導致正在執行的命令和功能表失去焦點時，會引發這個事件。 您可以使用這個事件來執行工作，例如更新的文字<xref:System.Windows.Forms.StatusBar>控制項或啟用和停用按鈕上<xref:System.Windows.Forms.ToolBar>。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.MenuComplete>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.MenuComplete>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuStart As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuStart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單的功能表接收焦點時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者按下功能表中的任何功能表項目時，會引發這個事件。 若要執行工作，例如啟用和停用不應該能存取使用者正在存取功能表時，表單上的控制項，您可以使用此事件。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.MenuStart>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.MenuStart>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedMenu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ MergedMenu { System::Windows::Forms::MainMenu ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表單的合併功能表。</summary>
        <value>
          <see cref="T:System.Windows.Forms.MainMenu" />，代表表單的合併功能表。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性主要使用表單時將其功能表與父表單的功能表合併為多重文件介面 (MDI) 子表單。 若要取得目前功能表結構 MDI 應用程式進行變更或新增至功能表結構中的，您可以使用這個屬性。 若要取得 nonmerged<xref:System.Windows.Forms.MainMenu>指派給表單時，使用<xref:System.Windows.Forms.Form.Menu%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.Form.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MinimizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示是否要在表單的標題列中顯示 [最小化] 按鈕。</summary>
        <value>
          <see langword="true" /> 若要顯示**最小化**按鈕的表單，否則<see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A**最小化**按鈕可讓使用者以最小化視窗的圖示。 若要顯示**最小化**按鈕，在表單值<xref:System.Windows.Forms.Form.ControlBox>屬性必須是`true`，其預設值。  <xref:System.Windows.Forms.Form.ControlBox>屬性決定的標題列右上角是否包含控制項，例如最大化按鈕、 最小化按鈕、 [說明] 按鈕和 [關閉] 按鈕。 此外，您也必須設定表單的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
> [!NOTE]
>  減少表單在執行階段會產生<xref:System.Windows.Forms.Control.Resize>事件。 <xref:System.Windows.Forms.Form.WindowState%2A>屬性會反映在視窗的目前狀態。 如果您設定<xref:System.Windows.Forms.Form.WindowState%2A>屬性`FormWindowState.Minimized`，表單為最小化獨立於任何設定，則實際上<xref:System.Windows.Forms.Form.MinimizeBox%2A>和<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單所能調整的大小下限。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，代表表單的大小下限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您限制大小的表單，以指定的最小大小。 您可以使用這項功能，以防止使用者調整視窗的非預期的大小。 如果這個屬性設定為<xref:System.Drawing.Size>是 0 的高度和寬度，表單中的為 0 的物件會有沒有最小大小超出 Windows 所設定的限制。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Drawing.Size" /> 物件內的高度或寬度值小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MinimumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MinimumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.MinimumSize" /> 屬性的值已變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.MinimumSizeChanged>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.MinimumSizeChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出表單是否顯示為強制回應。</summary>
        <value>
          如果表單要顯示為強制回應，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當表單顯示為強制回應時，可能除了強制回應表單上的物件會不發生任何輸入 （鍵盤或滑鼠按一下）。 程式必須隱藏或關閉強制回應表單 （通常是在某些使用者動作的回應） 之前為另一種形式的輸入可能會發生。 表單顯示為強制回應，通常會作為應用程式中的對話方塊。  
  
 您可以使用這個屬性來判斷您已取得的方法或屬性的形式顯示是否為強制回應。  
  
 若要顯示表單為強制回應使用<xref:System.Windows.Forms.Form.ShowDialog%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Windows.Forms.Form.Modal%2A>屬性來判斷是否表單會顯示為強制回應表單。 如果不是<xref:System.Windows.Forms.Form.FormBorderStyle%2A>和<xref:System.Windows.Forms.Form.TopLevel%2A>屬性已變更，讓工具視窗的框線與非上層表單的表單。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.ShowDialog" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnActivated%2A> 方法也允許衍生類別處理事件，而不用附加委派。 覆寫這個方法是處理衍生類別中的事件的慣用的技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" />，包含資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.Closed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>方法在.NET Framework 2.0 版本中已過時; 使用<xref:System.Windows.Forms.Form.OnFormClosed%2A>方法改為。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 方法也允許衍生類別處理事件，而不用附加委派。 覆寫這個方法是處理衍生類別中的事件的慣用的技巧。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>和<xref:System.Windows.Forms.Form.OnClosing%2A>方法不會呼叫時<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>呼叫方法來結束您的應用程式。 如果您在其中一種方法，必須執行的驗證程式碼，您應該呼叫<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>方法的每個開啟的表單，然後再呼叫個別<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何覆寫<xref:System.Windows.Forms.Form.OnClosed%2A>從衍生類別中的方法<xref:System.Windows.Forms.Form>。  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.ComponentModel.CancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.Closing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosing%2A>方法在.NET Framework 2.0 版本中已過時; 使用<xref:System.Windows.Forms.Form.OnFormClosing%2A>方法改為。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnClosing%2A> 方法也允許衍生類別處理事件，而不用附加委派。 覆寫這個方法是處理衍生類別中的事件的慣用的技巧。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>和<xref:System.Windows.Forms.Form.OnClosing%2A>方法不會呼叫時<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>呼叫方法來結束您的應用程式。 如果您在其中一種方法，必須執行的驗證程式碼，您應該呼叫<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>方法的每個開啟的表單，然後再呼叫個別<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Windows.Forms.Form.Closing>測試中的文字<xref:System.Windows.Forms.TextBox>已變更。 如果有，會要求使用者是否要將變更儲存至檔案。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.ComponentModel.CancelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引發 <see langword="CreateControl" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Windows.Forms.Form.OnCreateControl" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Windows.Forms.Form.OnCreateControl" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.Deactivate" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnDeactivate%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As DpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::Forms::DpiChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.DpiChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.Enter" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnEnter%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.FontChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosed (e As FormClosedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosed(System::Windows::Forms::FormClosedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.FormClosedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.FormClosed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A>方法會移除從目前的表單<xref:System.Windows.Forms.Application.OpenForms%2A>集合相關聯的<xref:System.Windows.Forms.Application>。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 方法也允許衍生類別處理事件，而不用附加委派。 覆寫這個方法是處理衍生類別中的事件的慣用的技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosing (e As FormClosingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosing(System::Windows::Forms::FormClosingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.FormClosingEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.FormClosing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGetDpiScaledSize (deviceDpiOld As Integer, deviceDpiNew As Integer, ByRef desiredSize As Size) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnGetDpiScaledSize(int deviceDpiOld, int deviceDpiNew, System::Drawing::Size % desiredSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">先前顯示表單的顯示裝置的 DPI 值。</param>
        <param name="deviceDpiNew">將顯示表單的顯示裝置的 DPI 值。</param>
        <param name="desiredSize">
          <see cref="T:System.Drawing.Size" />，代表新的表單的大小 (以新的 DPI 值為依據)。</param>
        <summary>引發 GetDpiScaledSize 事件。</summary>
        <returns>
          如果成功，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpButtonClicked (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpButtonClicked(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.ComponentModel.CancelEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
        <altmember cref="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanged (e As InputLanguageChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanged(System::Windows::Forms::InputLanguageChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanging (e As InputLanguageChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanging(System::Windows::Forms::InputLanguageChangingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.Layout" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.Load" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnLoad%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximizedBoundsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximizedBoundsChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMdiChildActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMdiChildActivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.MdiChildActivate" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.MenuComplete" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMenuComplete%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuComplete" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuStart (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuStart(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.MenuStart" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMenuStart%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuStart" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMinimumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMinimumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.PaintEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.Paint" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.Resize" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeBegin (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeBegin(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.ResizeBegin" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>將只會引發事件，如果表單的<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>屬性設定為`true`。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnResizeBegin%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeEnd (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeEnd(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.ResizeEnd" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>將只會引發事件，如果表單的<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>屬性設定為`true`。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnResizeEnd%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的表單或其中一個其父代會處置資源，<xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A>方法返回時不會執行任何動作。 如果<xref:System.Windows.Forms.Control.RightToLeft%2A>表單屬性的值為<xref:System.Windows.Forms.RightToLeft.Yes>，然後將重新建立表單和其子控制項的控制代碼，透過呼叫<xref:System.Windows.Forms.Control.RecreateHandle%2A>方法。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Form.Dispose" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShown (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShown(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Form.Shown" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>事件發生於表單第一次顯示。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnShown%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.StyleChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.TextChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" />。</param>
        <summary>引發 <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> 方法也允許衍生類別處理事件，而不用附加委派。 這是在衍生類別中處理事件的慣用技巧。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當在衍生類別中覆寫 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 時，請確定呼叫基底類別的 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 方法，使已註冊的委派能接收到事件。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單的透明度等級。</summary>
        <value>表單的透明度等級。 預設值為 1.00。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Opacity%2A>屬性可讓您指定的表單和其控制項的透明度等級。 當這個屬性設定為小於 100%(1.00) 的值時，則整個表單，包括框線，變得更為透明。 將此屬性設為 0%(0.00) 的值，使表單完全不可見。 您可以使用這個屬性，以提供不同層級的透明度，或提供例如逐步版表單中，或超出檢視的效果。 例如，設定成檢視階段表單<xref:System.Windows.Forms.Form.Opacity%2A>屬性設為 0%(0.00) 和逐漸增加的值，直到達到 100%(1.00) 的值。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> 不同於所提供的透明度<xref:System.Windows.Forms.Form.TransparencyKey%2A>、 它只會在表單和其控制項完全透明的如果它們是相同的色彩中指定的值<xref:System.Windows.Forms.Form.TransparencyKey%2A>屬性。  
  
 這個屬性不支援時<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>是`true`。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A>屬性相依於分層 Windows API 導入 Windows 2000。 如需詳細資訊，請參閱 「 分層 Windows:: 新方式來使用半透明和透明度效果在 Windows 中的應用程式"Platform SDK 文件，網址[ http://msdn.microsoft.com ](http://msdn.microsoft.com/)。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立具有 75%的不透明度層級會顯示的表單。 程式碼範例會建立新表單，位於與螢幕的中央<xref:System.Windows.Forms.Form.Opacity%2A>屬性設定為變更表單的透明度等級。 程式碼範例也會設定<xref:System.Windows.Forms.Form.Size%2A>屬性以提供更大的大小比預設大小的表單的表單。 這個程式碼範例是假設在此範例中定義的方法呼叫從另一種形式的事件處理常式或其他方法中撰寫的。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TransparencyKey" />
        <altmember cref="F:System.Windows.Forms.OSFeature.LayeredWindows" />
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedForms As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ OwnedForms { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Windows.Forms.Form" /> 物件陣列，代表這個表單擁有的所有表單。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> 陣列，代表這個表單擁有的表單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回陣列，其中包含此表單所擁有的所有表單。 若要讓另一種形式所擁有的表單，呼叫<xref:System.Windows.Forms.Form.AddOwnedForm%2A>方法。 指派給主控表單表單仍擁有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>方法呼叫。 您也可以進行表單擁有的另一個設定<xref:System.Windows.Forms.Form.Owner%2A>其擁有者的形式參考的屬性。  
  
 當表單由另一種形式所擁有時，它已關閉或隱藏的擁有者的表單。 例如，假設名為表單`Form2`名為的表單所擁有`Form1`。 如果`Form1`已關閉或最小化`Form2`也已關閉或隱藏。 擁有的表單也永遠不會顯示其主控表單後面。 您可以使用適用於 windows，例如尋找擁有的表單，並取代 windows，不應該顯示擁有者表單的後置選取主控表單時。  
  
> [!NOTE]
>  如果表單為多重文件介面 (MDI) 父表單，這個屬性會傳回顯示除了任何目前的 MDI 子表單的所有表單都開啟。 若要取得 MDI 子表單在 MDI 父表單中開啟，請使用<xref:System.Windows.Forms.Form.MdiChildren%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.OwnedForms%2A>屬性以修改主控表單所擁有的所有表單。 在範例中的第一個方法會將表單加入至擁有附屬表單相關聯的表單陣列。 第二種方法執行迴圈，所有擁有的表單，並變更標題。 這個範例需要這兩種方法會呼叫的事件或表單的其他方法。  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ Owner { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定擁有這個表單的表單。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" />，代表做為這個表單擁有者的表單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要讓另一種形式所擁有的表單，將指派其<xref:System.Windows.Forms.Form.Owner%2A>屬性的參考，就是擁有者的表單。  
  
 當表單由另一種形式所擁有時，它已關閉或隱藏的擁有者的表單。 例如，假設名為表單`Form2`名為的表單所擁有`Form1`。 如果`Form1`已關閉或最小化`Form2`也已關閉或隱藏。擁有的表單也永遠不會顯示其主控表單後面。 您可以使用擁有的表單視窗，例如尋找和取代視窗，選取主控表單時，應該不會消失。 若要判斷父表單所擁有的表單，請使用<xref:System.Windows.Forms.Form.OwnedForms%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">最上層的視窗不能有擁有人。</exception>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">以傳址方式傳遞的 <see cref="T:System.Windows.Forms.Message" />，代表要處理的 Win32 訊息。</param>
        <param name="keyData">其中一個 <see cref="T:System.Windows.Forms.Keys" /> 值，表示要處理的按鍵。</param>
        <summary>處理命令按鍵。</summary>
        <returns>
          如果按鍵輸入是由控制項所處理及耗用，則為 <see langword="true" />，否則為表示允許進一步處理的 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessCmdKey%2A>方法會覆寫基底  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType> 要提供額外的處理主功能表命令索引鍵和 MDI 加速器的實作。  
  
 設陷按鍵動作的相關資訊，請參閱 < 如何使用 Visual C# 設陷控制項的按鍵輸入 「 和 」 如何捕捉.NET 中的按鍵輸入控制項使用 Visual Basic.NET"Microsoft 知識庫中在http://support.microsoft.com。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">要處理的字元。</param>
        <summary>處理對話方塊字元。</summary>
        <returns>
          如果字元已由控制項處理，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">其中一個 <see cref="T:System.Windows.Forms.Keys" /> 值，表示要處理的按鍵。</param>
        <summary>處理對話方塊按鍵。</summary>
        <returns>
          如果按鍵輸入是由控制項所處理及耗用，則為 <see langword="true" />，否則為表示允許進一步處理的 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessDialogKey%2A>方法會覆寫基底<xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType>實作提供的傳回和逸出索引鍵，在對話方塊中的其他處理。 方法包含 ALT 或控制項的修飾詞的按鍵輸入上執行任何處理。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">由參考所傳遞的 <see cref="T:System.Windows.Forms.Message" />，代表要處理的視窗訊息。</param>
        <summary>預覽鍵盤訊息。</summary>
        <returns>
          如果控制項已處理訊息，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">要處理的字元。</param>
        <summary>處理助憶鍵字元。</summary>
        <returns>
          如果控制項已將字元當成助憶鍵處理，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessTabKey(bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          <see langword="true" /> 表示順向循環 ContainerControl 中的控制項；否則為 <see langword="false" />。</param>
        <summary>選取下一個可用的控制項並使它成為作用中的控制項。</summary>
        <returns>
          如果已選取控制項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">
          <see cref="T:System.Windows.Forms.Form" />，代表要從這個表單所擁有表單的清單中移除的表單。</param>
        <summary>將附屬表單從這個表單移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指派給主控表單表單將維持狀態直到擁有<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>方法呼叫。 除了從擁有的表單清單中移除附屬的表單，這個方法也會將設定主控表單`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeBegin As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeBegin;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單進入調整大小模式時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>當使用者開始調整表單時，通常按一下並拖曳其中一個框線或表單的右下角的調整大小底框的大小，就會引發事件。 這個動作會將表單進入縮放強制回應迴圈，直到調整大小作業完成為止。 一般而言，下列事件集的調整大小作業期間發生：  
  
1.  單一<xref:System.Windows.Forms.Form.ResizeBegin>表單進入調整大小模式時，就會發生事件。  
  
2.  零或多個組<xref:System.Windows.Forms.Control.Resize>和<xref:System.Windows.Forms.Control.SizeChanged>發生事件，以與表單<xref:System.Windows.Forms.Form.Size%2A>修改。  
  
3.  單一<xref:System.Windows.Forms.Form.ResizeEnd>表單結束調整大小模式時，就會發生事件。  
  
> [!NOTE]
>  只要按一下框線拖曳或調整大小底框不會產生<xref:System.Windows.Forms.Form.ResizeBegin>和<xref:System.Windows.Forms.Form.ResizeEnd>事件沒有任何中繼<xref:System.Windows.Forms.Control.Resize>和<xref:System.Windows.Forms.Control.SizeChanged>事件組。  
  
 <xref:System.Windows.Forms.Form.ResizeBegin>和<xref:System.Windows.Forms.Form.ResizeEnd>當使用者將表單中，通常按一下並拖曳標題列上，也會引發的事件配對。 這些事件不會產生的表單，以程式設計方式操作，例如藉由變更<xref:System.Windows.Forms.Form.Size%2A>或<xref:System.Windows.Forms.Control.Location%2A>屬性。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.ResizeBegin>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.ResizeBegin>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeEnd As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeEnd;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單結束調整大小模式時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>使用者完成調整表單時，通常由拖曳框線或表單的右下角的調整大小底框之一，再放開它時，就會引發事件。 如需調整大小作業的詳細資訊，請參閱<xref:System.Windows.Forms.Form.ResizeBegin>事件。  
  
 <xref:System.Windows.Forms.Form.ResizeEnd>之後，使用者移動表單時，通常按一下並拖曳標題列上，也會產生事件。 這個事件不由產生的表單，以程式設計方式操作，例如藉由變更<xref:System.Windows.Forms.Form.Size%2A>或<xref:System.Windows.Forms.Control.Location%2A>屬性。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.ResizeEnd>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.ResizeEnd>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle RestoreBounds { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處於正常視窗狀態下的表單之位置和大小。</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" />，包含處於正常視窗狀態下的表單位置和大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，您會使用<xref:System.Windows.Forms.Form.RestoreBounds%2A>屬性，以追蹤使用者的視窗大小，並置於表單的喜好設定中處於正常視窗狀態。 您應該追蹤的值<xref:System.Windows.Forms.Form.WindowState%2A>和<xref:System.Windows.Forms.Form.RestoreBounds%2A>時追蹤使用者的視窗喜好設定的屬性。  
  
> [!NOTE]
>  值<xref:System.Windows.Forms.Form.RestoreBounds%2A>屬性時才有效唯一<xref:System.Windows.Forms.Form.WindowState%2A>屬性<xref:System.Windows.Forms.Form>類別是否不等於<xref:System.Windows.Forms.FormWindowState.Normal>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeftLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RightToLeftLayout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否已開啟右到左的左右反轉位置。</summary>
        <value>
          如果已開啟右到左的左右反轉位置，則為 <see langword="true" />，否則為表示標準子控制項位置的 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>屬性是主要用於開發世界性表單為全球的對象。 許多形式的設計可讓控制項的配置中以左到右的方式在表單上。 下列形式會以這個方向書寫的語言相容。 不過，顯示相同的表單顯示由右至左語言的使用者時，通常最好是在表單上控制項的順序互換。 如果兩個<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>和<xref:System.Windows.Forms.Control.RightToLeft%2A>屬性`true`、 鏡像將會開啟該表單和控制項位置和文字會由右至左。  
  
 不同於<xref:System.Windows.Forms.Control.RightToLeft%2A>，<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>不會繼承。 如果您想要進行子控制項，您必須設定每個您想要鏡像的子控制項。  
  
 不是主控描繪時，支援<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>設`Yes`。 主控描繪事件仍會發生，但您在這些事件中撰寫任何程式碼的行為未定義。 此外， <xref:System.Windows.Forms.Control.BackgroundImage%2A>， <xref:System.Windows.Forms.Form.Opacity%2A>， <xref:System.Windows.Forms.Form.TransparencyKey%2A>，而且不支援的繪製事件。  
  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>和<xref:System.Windows.Forms.Control.RightToLeft%2A>屬性會設定下列的 Win32 API 視窗樣式：  
  
-   當<xref:System.Windows.Forms.Control.RightToLeft%2A>設`Yes`和<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>設為`true`，設定 Windows Form`WS_EX_LAYOUTRTL`視窗樣式，並移除`WS_EX_RIGHT`和`WS_EX_RTLREADING`樣式。  
  
-   當<xref:System.Windows.Forms.Control.RightToLeft%2A>設為`Yes`但<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>設`No`，設定 Windows Form`WS_EX_RIGHT`和`WS_EX_RTLREADING`視窗樣式。  
  
 變更這個屬性的值會引發<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。  
  
 如需全球化問題的詳細資訊，請參閱[開發世界性的應用程式的最佳作法](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" /> 屬性的值變更之後。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>和<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>屬性通常用於開發世界性的應用程式。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">控制項高度與寬度的縮放比例。</param>
        <param name="specified">
          <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值，指定在定義控制項的大小和位置時所用的控制項範圍。</param>
        <summary>縮放控制項的位置、大小、邊框間距和邊界。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleCore (x As Single, y As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleCore(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">水平縮放表單比例的百分比。</param>
        <param name="y">垂直縮放表單比例的百分比。</param>
        <summary>執行表單的縮放。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">如果使用中控制項確實設定為已變更</param>
        <param name="forward">如果確實已導向，這會控制焦點移動的方向。 如果為 <see langword="true" />，則會選取下一個控制項，否則會選取上一個控制項。</param>
        <summary>選取這個表單，並選擇性地選取下一個或上一個控制項。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用於變更焦點。 關聯的列舉型別：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">控制項的新 <see cref="P:System.Windows.Forms.Control.Left" /> 屬性值。</param>
        <param name="y">控制項的新 <see cref="P:System.Windows.Forms.Control.Top" /> 屬性值。</param>
        <param name="width">控制項的新 <see cref="P:System.Windows.Forms.Control.Width" /> 屬性值。</param>
        <param name="height">控制項的新 <see cref="P:System.Windows.Forms.Control.Height" /> 屬性值。</param>
        <param name="specified">
          <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值的位元組合。</param>
        <summary>執行設定這個控制項的指定範圍的工作。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetClientSizeCore(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">要求的工作區寬度。</param>
        <param name="y">要求的工作區高度。</param>
        <summary>設定表單的工作區大小。 如此將會調整表單的邊界，讓工作區大小變成要求的大小。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">表單位置的 X 座標。</param>
        <param name="y">表單位置的 Y 座標。</param>
        <param name="width">表單的寬度。</param>
        <param name="height">表單的高度。</param>
        <summary>設定桌面座標中表單的界限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面座標為基礎的畫面中，排除工作列工作區域。 若要設定的位置和大小的表單在桌面，您可以使用這個方法。 由於桌面座標會根據表單的工作區域，您可以使用這個方法，以確保您的表單是在桌面上完全可見。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.SetDesktopBounds%2A>方法。 若要執行此範例中，貼上下列程式碼包含名為按鈕的形式`Button2`。 請確定所有事件都都具有其事件處理常式相關聯。  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopLocation (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopLocation(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">表單位置的 X 座標。</param>
        <param name="y">表單位置的 Y 座標。</param>
        <summary>設定桌面座標中表單的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面座標為基礎的畫面中，排除工作列工作區域。 若要在桌面上放在您的表單，您可以使用這個方法。 由於桌面座標會根據表單的工作區域，您可以使用這個方法，以確保您的表單是在桌面上完全可見。 這個方法適用於主要是針對最上層的表單。使用<xref:System.Windows.Forms.Form.LayoutMdi%2A>方法來將多重文件介面 (MDI) 子表單。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>，<xref:System.Windows.Forms.Form.Load>和<xref:System.Windows.Forms.Form.Activate%2A>成員。 若要執行此範例，下列程式碼的呼叫格式貼`Form1`包含按鈕呼叫`Button1`和兩個`Label`控制項稱為`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetVisibleCore(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" /> 表示將控制項設為可見，否則為 <see langword="false" />。</param>
        <summary>將控制項設定為指定的可見狀態。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show (owner As IWin32Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">實作 <see cref="T:System.Windows.Forms.IWin32Window" /> 及代表將擁有這個表單之最上層視窗的任何物件。</param>
        <summary>為使用者顯示具有指定擁有人的表單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法以顯示非強制回應表單。 當您使用這個方法，<xref:System.Windows.Forms.Form.Owner%2A>表單的屬性設定為`owner`。 非強制回應表單可以使用<xref:System.Windows.Forms.Form.Owner%2A>屬性來取得主控表單的相關資訊。  呼叫這個方法相當於設定<xref:System.Windows.Forms.Form.Owner%2A>非強制回應屬性，然後再呼叫<xref:System.Windows.Forms.Control.Show>方法。  
  
 顯示表單就相當於設定<xref:System.Windows.Forms.Control.Visible%2A>屬性`true`。 之後<xref:System.Windows.Forms.Form.Show%2A>呼叫方法時，<xref:System.Windows.Forms.Control.Visible%2A>屬性會傳回值為`true`直到<xref:System.Windows.Forms.Control.Hide%2A>方法呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經可以看到所顯示的表單。  
  
 -或-  
  
 <paramref name="owner" /> 參數中指定的表單與顯示的表單相同。  
  
 -或-  
  
 已停用所顯示的表單。  
  
 -或-  
  
 所顯示的表單不是最上層視窗。  
  
 -或-  
  
 顯示為對話方塊的表單已是強制回應表單。  
  
 -或-  
  
 目前的處理序不在使用者互動模式下執行 (如需詳細資訊，請參閱 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />)。</exception>
        <altmember cref="Overload:System.Windows.Forms.Form.ShowDialog" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowDialog">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將表單顯示為強制回應對話方塊。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將表單顯示為強制回應對話方塊。</summary>
        <returns>其中一個 <see cref="T:System.Windows.Forms.DialogResult" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在您的應用程式中顯示強制回應對話方塊中，您可以使用這個方法。 呼叫這個方法時，它後面的程式碼將會等到執行之後關閉對話方塊。 可指派的值的其中一個對話方塊<xref:System.Windows.Forms.DialogResult>將它指派給列舉<xref:System.Windows.Forms.Button.DialogResult%2A>屬性<xref:System.Windows.Forms.Button>表單上，或藉由設定<xref:System.Windows.Forms.Form.DialogResult%2A>表單程式碼中的屬性。 然後，這個值會傳回由這個方法。 您可以使用這個傳回值，以決定如何處理發生在對話方塊中的動作。 例如，如果對話方塊已關閉且傳回`DialogResult.Cancel`值透過這個方法，您可能導致在呼叫的程式碼<xref:System.Windows.Forms.Form.ShowDialog%2A>執行。  
  
 當表單顯示為強制回應對話方塊時，按一下**關閉**按鈕 （表單右上角的 X 按鈕） 將會隱藏表單和<xref:System.Windows.Forms.Form.DialogResult%2A>屬性設定為`DialogResult.Cancel`。 不像非強制回應表單<xref:System.Windows.Forms.Form.Close%2A>當使用者按一下對話方塊的 [關閉表單] 按鈕，或設定值的方法不由.NET Framework 呼叫<xref:System.Windows.Forms.Form.DialogResult%2A>屬性。 表單隱藏的而可再次顯示，而不需要建立對話方塊中的新執行個體。 因為表單中顯示為對話方塊中會隱藏而不是關閉，您必須呼叫<xref:System.Windows.Forms.Control.Dispose%2A>時您的應用程式不再需要表單形式的方法。  
  
 這個版本的<xref:System.Windows.Forms.Form.ShowDialog%2A>方法未指定表單或控制項為其擁有者。 此版本稱為目前作用中視窗會在對話方塊的 擁有者。 如果您想要指定特定擁有者，請使用這個方法的另一個版本。  
  
   
  
## Examples  
 下列程式碼範例顯示為強制回應對話方塊的表單，並評估對話方塊中的傳回值之前判斷要讀取的值<xref:System.Windows.Forms.TextBox>對話方塊表單上的控制項。 這個範例需要<xref:System.Windows.Forms.Form>名為`testDialog`建立和它包含<xref:System.Windows.Forms.TextBox>控制項，名為`TextBox1`。 此外，這個範例需要在此範例中的程式碼是包含，並呼叫來自不同<xref:System.Windows.Forms.Form>才能顯示`testDialog`為強制回應對話方塊。 此範例會使用新版<xref:System.Windows.Forms.Form.ShowDialog%2A>指定對話方塊的擁有者。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經可以看到所顯示的表單。  
  
 -或-  
  
 已停用所顯示的表單。  
  
 -或-  
  
 所顯示的表單不是最上層視窗。  
  
 -或-  
  
 顯示為對話方塊的表單已是強制回應表單。  
  
 -或-  
  
 目前的處理序不在使用者互動模式下執行 (如需詳細資訊，請參閱 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />)。</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog (owner As IWin32Window) As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">實作 <see cref="T:System.Windows.Forms.IWin32Window" /> 的任何物件，代表將擁有強制回應對話方塊的最上層視窗。</param>
        <summary>以指定的擁有人將表單顯示為強制回應對話方塊。</summary>
        <returns>其中一個 <see cref="T:System.Windows.Forms.DialogResult" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在您的應用程式中顯示強制回應對話方塊中，您可以使用這個方法。 呼叫這個方法時，它後面的程式碼將會等到執行之後關閉對話方塊。 可指派的值的其中一個對話方塊<xref:System.Windows.Forms.DialogResult>所指派到<xref:System.Windows.Forms.Button.DialogResult%2A>屬性<xref:System.Windows.Forms.Button>表單上，或藉由設定<xref:System.Windows.Forms.Form.DialogResult%2A>表單程式碼中的屬性。 然後，這個值會傳回由這個方法。 您可以使用這個傳回值，以決定如何處理發生在對話方塊中的動作。 例如，如果對話方塊已關閉且傳回`DialogResult.Cancel`值透過這個方法，您可能導致在呼叫的程式碼<xref:System.Windows.Forms.Form.ShowDialog%2A>執行。  
  
 當表單顯示為強制回應對話方塊時，按一下**關閉**按鈕 （表單右上角的 X 按鈕） 將會隱藏表單和<xref:System.Windows.Forms.Form.DialogResult%2A>屬性設定為`DialogResult.Cancel`。 不像非強制回應表單，<xref:System.Windows.Forms.Form.Close%2A>當使用者按一下對話方塊的 [關閉表單] 按鈕，或設定值的方法不由.NET Framework 呼叫<xref:System.Windows.Forms.Form.DialogResult%2A>屬性。 表單隱藏的而可再次顯示，而不需要建立對話方塊中的新執行個體。 因為表單中顯示為對話方塊中會隱藏而不是關閉，您必須呼叫<xref:System.Windows.Forms.Control.Dispose%2A>時您的應用程式不再需要表單形式的方法。  
  
 這個版本的<xref:System.Windows.Forms.Form.ShowDialog%2A>方法可讓您指定將擁有對話方塊所顯示的特定表單。  
  
   
  
## Examples  
 下列程式碼範例顯示為強制回應對話方塊的表單，並評估對話方塊中的傳回值之前判斷要讀取的值<xref:System.Windows.Forms.TextBox>對話方塊表單上的控制項。 這個範例需要<xref:System.Windows.Forms.Form>名為`Form2`建立和它包含<xref:System.Windows.Forms.TextBox>控制項，名為`TextBox1`。 此範例會使用新版<xref:System.Windows.Forms.Form.ShowDialog%2A>指定對話方塊的擁有者。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> 參數中指定的表單與顯示的表單相同。</exception>
        <exception cref="T:System.InvalidOperationException">已經可以看到所顯示的表單。  
  
 -或-  
  
 已停用所顯示的表單。  
  
 -或-  
  
 所顯示的表單不是最上層視窗。  
  
 -或-  
  
 顯示為對話方塊的表單已是強制回應表單。  
  
 -或-  
  
 目前的處理序不在使用者互動模式下執行 (如需詳細資訊，請參閱 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />)。</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowIcon As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowIcon { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出圖示是否會顯示在表單的標題列中。</summary>
        <value>
          如果表單會在標題列中顯示圖示，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ShowIcon%2A>屬性包含<xref:System.Boolean>值，指出是否將表單的<xref:System.Windows.Forms.Form.Icon%2A>會顯示在表單的標題列。 如果<xref:System.Windows.Forms.Form.ControlBox%2A>屬性是`false`，將隱藏的圖示和控制項的方塊。  
  
 如果<xref:System.Windows.Forms.Form.ShowIcon%2A>是`false`的一般圖示時顯示的主要形式，將顯示在應用程式的工作列按鈕。  
  
 如果這個屬性就不會影響<xref:System.Windows.Forms.Form.FormBorderStyle%2A>設<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>。 在此情況下，表單不會顯示圖示。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Icon" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出表單是否顯示在 Windows 工作列中。</summary>
        <value>
          <see langword="true" /> 表示要在執行階段於 Windows 工作列中顯示表單，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果表單在另一種形式中成為父代，父代的表單不會顯示在 Windows 工作列中。  
  
 您可以使用這個屬性，以避免使用者選取您透過 Windows 工作列的表單。 比方說，如果您在應用程式中顯示 [尋找和取代] 工具視窗，您可能想要防止該視窗正在選取透過 Windows 工作列中，因為您需要應用程式的主視窗和 [尋找和取代] 工具視窗顯示此選項，才能適當地處理搜尋。  
  
 您通常要使用這個屬性時建立的表單具有<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>樣式。 設定<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>樣式不單獨保證視窗不會出現在工作列。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Windows.Forms.Form.ShowInTaskbar%2A>屬性使方塊的對話方塊不會顯示在 Windows 工作列。  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Shown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Shown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於表單第一次顯示時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>才會引發事件會顯示在表單第一次; 後續最小化、 最大化、 還原、 隱藏、 顯示，或失效及重新繪製將不會引發這個事件。 表單的事件順序的相關資訊，請參閱[順序的 Windows Form 中事件](~/docs/framework/winforms/order-of-events-in-windows-forms.md)。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.Form.Shown>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>與<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.Form>名為`Form1`。 請確定事件處理常式關聯<xref:System.Windows.Forms.Form.Shown>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowWithoutActivation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowWithoutActivation { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出視窗是否將在其顯示時啟動。</summary>
        <value>
          如果視窗在其顯示時不啟動，則為 <see langword="True" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想要顯示最上層的視窗中，但不想要擷取輸入的焦點離開目前的視窗，藉此中斷使用者的工作，請使用這個屬性。 這可以是參考用的快顯視窗或浮動視窗中的，例如 [小畫家] 應用程式中工具調色盤。  
  
 因為這個屬性是唯讀，您可以只變更其值覆寫<xref:System.Windows.Forms.Form.ShowWithoutActivation%2A>在自己的表單和程式設計它傳回`true`。  
  
 如果您未啟用的視窗，就需要使用 UI 控制項，您應該考慮使用<xref:System.Windows.Forms.ToolStrip>控制項，例如<xref:System.Windows.Forms.ToolStripDropDown>。 這些控制項是無視窗，並不會選取此選項時，將啟動視窗。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，代表表單的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性可讓您設定高度和寬度 （以像素為單位） 的形式在相同的時間，而不是設定<xref:System.Windows.Forms.Control.Height%2A>和<xref:System.Windows.Forms.Control.Width%2A>屬性個別。 如果您想要設定的大小和表單的位置，您可以使用<xref:System.Windows.Forms.Form.DesktopBounds%2A>大小，並找出的表單屬性根據桌面座標或使用<xref:System.Windows.Forms.Control.Bounds%2A>屬性<xref:System.Windows.Forms.Control>類別來設定的大小和表單的位置根據螢幕座標inates。  
  
> [!NOTE]
>  這個屬性的最大值受限於此表單執行所在的螢幕解析度。 值不能大於 12 個像素針對每個螢幕維度 （水平 + 12 和垂直 + 12）。  
  
> [!NOTE]
>  在 Pocket PC 裝置，您可以建立可調整大小的視窗設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>至`None`並移除任何<xref:System.Windows.Forms.MainMenu>控制項。 智慧型手機在裝置上，您可以永遠不會調整大小<xref:System.Windows.Forms.Form>-它一定會填滿整個螢幕。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立具有 75%的不透明度層級會顯示的表單。 範例程式碼會建立新表單，位於與螢幕的中央<xref:System.Windows.Forms.Form.Opacity%2A>屬性設定為變更表單的透明度等級。 範例程式碼也會設定<xref:System.Windows.Forms.Form.Size%2A>屬性以提供更大的大小比預設大小的表單的表單。 這個範例需要在此範例中定義的方法從另一種形式的事件處理常式或其他方法中呼叫。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeGripStyle As SizeGripStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::SizeGripStyle SizeGripStyle { System::Windows::Forms::SizeGripStyle get(); void set(System::Windows::Forms::SizeGripStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定可調整大小的底框樣式，以顯示在表單的右下角。</summary>
        <value>
          <see cref="T:System.Windows.Forms.SizeGripStyle" />，代表所要顯示的大小底框樣式。 預設值為 <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您判斷在表單上顯示調整大小底框時。 您可以設定這個屬性，以顯示調整大小底框或為基礎的設定，讓它自動顯示<xref:System.Windows.Forms.Form.FormBorderStyle%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何隱藏的調整大小底框<xref:System.Windows.Forms.Form>時<xref:System.Windows.Forms.Form>不是可調整大小。  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值超過有效值的範圍。</exception>
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="T:System.Windows.Forms.SizeGripStyle" />
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property StartPosition As FormStartPosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormStartPosition StartPosition { System::Windows::Forms::FormStartPosition get(); void set(System::Windows::Forms::FormStartPosition value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定表單在執行階段中的開始位置。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormStartPosition" />，代表表單的開始位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您設定表單的開始位置，顯示在執行階段時。 可以手動指定表單的位置，藉由設定<xref:System.Windows.Forms.Form.Location%2A>屬性或使用 Windows 所指定的預設位置。 您也可以放置在螢幕中央或它的父表單的表單，例如多重文件介面 (MDI) 子表單的中央顯示表單。  
  
 顯示表單之前，應該設定這個屬性。  您可以設定此屬性，才能呼叫<xref:System.Windows.Forms.Form.Show%2A>或<xref:System.Windows.Forms.Form.ShowDialog%2A>方法或表單的建構函式中。  
  
   
  
## Examples  
 下列程式碼範例會建立的新執行個體<xref:System.Windows.Forms.Form>呼叫<xref:System.Windows.Forms.Form.ShowDialog%2A>要將表單顯示為對話方塊的方法。 範例會設定<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>內容 對話方塊中變更的外觀和表單的功能。 此範例也會使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>形式的方法<xref:System.Windows.Forms.Control.Controls%2A>要加入兩個集合<xref:System.Windows.Forms.Button>控制項。 此範例會使用<xref:System.Windows.Forms.Form.HelpButton%2A>屬性 對話方塊的標題列中顯示 說明 按鈕。  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值超過有效值的範圍。</exception>
        <altmember cref="T:System.Windows.Forms.FormStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定控制項容器中的控制項定位順序。</summary>
        <value>
          <see cref="T:System.Int32" />，包含依定位順序包含在其容器內之控制項集合中的控制項索引。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 定位順序中不包含表單。 設定<xref:System.Windows.Forms.Form.TabIndex%2A>屬性不會執行任何動作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.TabIndex" /> 屬性的值變更時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出使用者是否能使用 TAB 鍵，將焦點 (Focus) 給予這個控制項。</summary>
        <value>
          如果使用者可以使用 TAB 鍵將焦點置於這個控制項，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="P:System.Windows.Forms.Form.TabStop" /> 屬性變更時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個控制項的相關文字。</summary>
        <value>與這個控制項關聯的文字。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TopLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopLevel { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要將表單顯示為最上層視窗。</summary>
        <value>
          若要顯示表單為最上層視窗，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上層的表單是一個沒有父表單，或其父表單是桌面視窗的視窗。 最上層視窗通常會作為應用程式中的主要表單。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Windows.Forms.Form.Modal%2A>屬性來判斷是否表單會顯示為強制回應表單。 如果不是<xref:System.Windows.Forms.Form.FormBorderStyle%2A>和<xref:System.Windows.Forms.Form.TopLevel%2A>屬性已變更，讓工具視窗的框線與表單非上層表單。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">多重文件介面 (MDI) 父表單必須為最上層視窗。</exception>
        <altmember cref="P:System.Windows.Forms.Form.TopMost" />
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberSignature Language="VB.NET" Value="Public Property TopMost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopMost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，該值代表是否要將此表單顯示成最上層的表單。</summary>
        <value>
          <see langword="true" /> 表示要將該表單顯示為最上層的表單，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上層的表單是重疊其他 （非最上層） 形式，即使它不是作用中] 或 [前景表單的表單。 最上層表單永遠會顯示在 windows 桌面上的疊置順序最高點。 您可以使用這個屬性來建立一律會在您的應用程式，例如尋找和取代 工具視窗中顯示的表單。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立最上層的表單。 此範例會建立兩個表單最大化，一個會顯示為最上層的表單。 第一種形式，名為`bottomForm`，會顯示最大化，使用<xref:System.Windows.Forms.Form.WindowState%2A>屬性，以詳細說明的最上層表單的能力。 第二種形式，名為`topMostForm`，設定<xref:System.Windows.Forms.Form.TopMost%2A>屬性`true`顯示表單為最上層的表單。 執行此程式碼時，按一下最大化表單上將不會顯示最大化表單下最上層的表單。 這個範例需要在範例中定義的方法呼叫從另一種形式。  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TopLevel" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得表示表單目前執行個體的字串。</summary>
        <returns>由表單物件之類別的完整名稱所組成的字串，表單的 <see cref="P:System.Windows.Forms.Form.Text" /> 屬性會附加到結尾處。 例如，如果表單衍生自 <c>MyNamespace</c> 命名空間中的類別 <c>MyForm</c>，且 <see cref="P:System.Windows.Forms.Form.Text" /> 屬性設為 <c>Hello, World</c>，這個方法會傳回 <c>MyNamespace.MyForm, Text: Hello, World</c>。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberSignature Language="VB.NET" Value="Public Property TransparencyKey As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color TransparencyKey { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定將表示表單透明區域的色彩。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，代表要透明地顯示在表單上的色彩。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Forms.Form.TransparencyKey%2A>屬性會被指派<xref:System.Drawing.Color>，具有相同的表單區域<xref:System.Windows.Forms.Control.BackColor%2A>將會以透明的方式顯示。 任何滑鼠執行的動作，例如按一下滑鼠，透明的表單區域會傳輸至透明區域下方的視窗。 比方說，如果表單的用戶端區域是透明，按一下滑鼠按一下該區域會傳送事件通知的按一下它下面的任何視窗。 如果色彩指派給<xref:System.Windows.Forms.Form.TransparencyKey%2A>屬性等同於表單上的任何控制項，則也會顯示以透明的方式。 比方說，如果您有<xref:System.Windows.Forms.Button>已在表單上的控制項及其<xref:System.Windows.Forms.Form.TransparencyKey%2A>屬性設定為`SystemColors.Control`，除非控制項也會以透明的方式顯示<xref:System.Windows.Forms.Control.BackColor%2A>屬性<xref:System.Windows.Forms.Button>控制項變更為不同的色彩。  
  
 這個屬性不支援時<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>是`true`。  
  
   
  
## Examples  
 下列程式碼範例會建立擁有不論表單的背景色彩的透明用戶端區域的視窗。 這個範例需要在表單的類別內的已定義範例方法。  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateDefaultButton();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>更新哪一個按鈕為預設按鈕的資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A>方法會判斷哪一個按鈕，在表單上的引發其 Click 事件，當使用者按下 ENTER，根據下列優先順序：  
  
1.  如果<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>屬性實作<xref:System.Windows.Forms.IButtonControl>介面，控制為預設按鈕。  
  
2.  <xref:System.Windows.Forms.Form.AcceptButton%2A>屬性為預設按鈕。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>驗證表單中所有可選取的子控制項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使得控制項內支援驗證的所有子控制項驗證其資料。</summary>
        <returns>
          如果所有子控制項都驗證成功，則為 <see langword="true" />；否則為 <see langword="false" />。 如果從 <see cref="E:System.Windows.Forms.Control.Validating" /> 或 <see cref="E:System.Windows.Forms.Control.Validated" /> 事件處理常式呼叫這個方法，則該方法一律會傳回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">將限制套用於已引發 <see cref="E:System.Windows.Forms.Control.Validating" /> 事件的控制項。</param>
        <summary>使得控制項內支援驗證的所有子控制項驗證其資料。</summary>
        <returns>
          如果所有子控制項都驗證成功，則為 <see langword="true" />；否則為 <see langword="false" />。 如果從 <see cref="E:System.Windows.Forms.Control.Validating" /> 或 <see cref="E:System.Windows.Forms.Control.Validated" /> 事件處理常式呼叫這個方法，則該方法一律會傳回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As FormWindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormWindowState WindowState { System::Windows::Forms::FormWindowState get(); void set(System::Windows::Forms::FormWindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示表單為最小化、最大化或正常狀態。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormWindowState" />，代表表單為最小化、最大化還是正常狀態。 預設值為 <see langword="FormWindowState.Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示表單之前，<xref:System.Windows.Forms.Form.WindowState%2A>屬性一定會設定為`FormWindowState.Normal`，不論其初始設定值。 這會反映在<xref:System.Windows.Forms.Control.Height%2A>， <xref:System.Windows.Forms.Control.Left%2A>， <xref:System.Windows.Forms.Control.Top%2A>，和<xref:System.Windows.Forms.Control.Width%2A>屬性設定。 如果表單為隱藏，示範了之後，這些屬性會反映先前的狀態之前，不論所做的變更顯示表單<xref:System.Windows.Forms.Form.WindowState%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定<xref:System.Windows.Forms.Form.WindowState%2A>為最大化。 程式碼會呼叫從<xref:System.Windows.Forms.Form.Shown>建立表單後的事件處理常式。  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值超過有效值的範圍。</exception>
        <altmember cref="T:System.Windows.Forms.FormWindowState" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要處理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>處理 Windows 訊息。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>