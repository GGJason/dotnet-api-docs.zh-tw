<Type Name="HtmlWindow" FullName="System.Windows.Forms.HtmlWindow">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1aef2f327973525b659c9b3f24e2a0fac27a3ad0" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008440" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlWindow" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlWindow extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlWindow" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlWindow" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlWindow sealed" />
  <TypeSignature Language="F#" Value="type HtmlWindow = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>代表邏輯視窗，包含 <see cref="T:System.Windows.Forms.HtmlDocument" /> 的一個或多個執行個體。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow> 不應與在 Windows Form 或 Windows API 中，視窗的概念混淆沒有任何`HWND`或類似直接對應到的執行個體的 Windows 資源<xref:System.Windows.Forms.HtmlWindow>。 相反地，<xref:System.Windows.Forms.HtmlWindow>上使用者的畫面上，以及與透過提示和對話方塊的使用者互動的方法中提供的文件的位置的高層級描述。 <xref:System.Windows.Forms.HtmlWindow> 做為 Web 頁面的文件和它的中繼資料，例如文件的位置和網頁瀏覽器功能的邏輯容器。  
  
 Web 網頁所組成的單一文件，或是`FRAMESET`包含一或多個`FRAME`項目，其中每個裝載自己的文件。 Web 開發人員會使用框架，顯示邏輯相關的頁面並排顯示 （例如，瀏覽網頁旁的內容頁面）。 當頁面包含一份文件時，您可以存取透過<xref:System.Windows.Forms.HtmlWindow.Document%2A>的屬性<xref:System.Windows.Forms.HtmlWindow>; 如果頁面會使用畫面格，您也可以存取透過其文件<xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合，其中包含一或多個<xref:System.Windows.Forms.HtmlWindow>物件。  
  
 時您的主機<xref:System.Windows.Forms.WebBrowser>控制項中的 Windows Forms 應用程式中，您可以選擇與使用標準的 Windows Form 類別，例如使用者互動<xref:System.Windows.Forms.Form>或<xref:System.Windows.Forms.MessageBox>，或者您可以使用方法上<xref:System.Windows.Forms.HtmlWindow>定義針對此目的。 <xref:System.Windows.Forms.HtmlWindow.Alert%2A>方法會提供自訂文字中的簡單的對話方塊和**確定**按鈕;<xref:System.Windows.Forms.HtmlWindow.Prompt%2A>企業自訂文字和文字輸入的欄位會向使用者呈現; 和<xref:System.Windows.Forms.HtmlWindow.Confirm%2A> 對話方塊中提供自訂的文字行並**確定**並**取消**按鈕。  
  
 您可以使用<xref:System.Windows.Forms.HtmlWindow>開啟新視窗，其中包含新的文件。 <xref:System.Windows.Forms.HtmlWindow.Open%2A> 指定的 URL 載入具名視窗中，如果不存在，請建立它，而<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>一律在新建立的視窗中開啟它的 URL。  
  
   
  
## Examples  
 下列程式碼範例包含兩個方法。 第一個名為的視窗中開啟 URL `displayWindow`，則會建立與顯示狀態列。 第二個在相同的視窗中，開啟另一個 URL，但指定應該顯示只有位置列。 請注意視窗和控制項所顯示的維度取決所在 URL 第一次開啟。 程式碼範例需要您的表單包含<xref:System.Windows.Forms.WebBrowser>控制項，名為`WebBrowser1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#13)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms535873.aspx">視窗物件</related>
    <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741505.aspx">IHTMLWindow2 介面</related>
  </Docs>
  <Members>
    <Member MemberName="Alert">
      <MemberSignature Language="C#" Value="public void Alert (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Alert(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Alert(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Alert (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Alert(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.Alert : string -&gt; unit" Usage="htmlWindow.Alert message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要顯示在訊息方塊中的 <see cref="T:System.String" />。</param>
        <summary>顯示訊息方塊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MessageBox?displayProperty=nameWithType>類別提供更強大的版本<xref:System.Windows.Forms.HtmlWindow.Alert%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms535933.aspx">alert 方法</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlWindow.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">要處理的事件名稱。</param>
        <param name="eventHandler">處理事件之 Managed 程式碼的參考。</param>
        <summary>為具名的 HTML DOM 事件加入事件處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不應該附加至 HTML 文件或其中一個物件的事件，直到文件已完成載入。 您應該呼叫這個方法最舊的處於<xref:System.Windows.Forms.WebBrowser.DocumentCompleted>事件的<xref:System.Windows.Forms.WebBrowser>控制項。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="htmlWindow.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉視窗。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.HtmlWindow.IsClosed%2A>屬性來判斷是否視窗已關閉。 如果視窗已關閉，則這個方法會有任何作用。  
  
 當您建立新的 windows，使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或是<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，<xref:System.Windows.Forms.HtmlWindow.Close%2A>導致 HTML 文件物件模型，以開啟 Internet Explorer 的新執行個體。 如果您不能呼叫<xref:System.Windows.Forms.HtmlWindow.Close%2A>所有您已建立的 windows 上的 Internet Explorer 的這個執行個體將會繼續執行您的應用程式關閉時，即使。  
  
   
  
## Examples  
 下列程式碼範例會開啟視窗，並關閉它，如果使用者已無法使用它在過去 5 分鐘內。 撰寫程式碼範例假設您的表單具有<xref:System.Windows.Forms.WebBrowser>控制項，名為`WebBrowser1`，則<xref:System.Windows.Forms.Button>名為`Button1`，和<xref:System.Windows.Forms.Timer>類別名為`Timer1`。 若要成功執行此範例中，將變更提供給第一個引數<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>至有效的 URL。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlWindow#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536367.aspx">Close 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Confirm">
      <MemberSignature Language="C#" Value="public bool Confirm (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Confirm(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Confirm(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Confirm (message As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Confirm(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.Confirm : string -&gt; bool" Usage="htmlWindow.Confirm message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要顯示給使用者的文字。</param>
        <summary>顯示對話方塊，其中包含請求是/否回應的訊息和按鈕。</summary>
        <returns>如果使用者按下 [是]，則為 <see langword="true" />；如果使用者按下 [否] 或關閉對話方塊，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Confirm%2A> 顯示強制回應對話方塊;使用者將無法存取基礎的 HTML 網頁，而不需要先關閉此對話方塊。  
  
## Examples  

複製下列 HTML，並將它儲存到表單名 orderForm.htm:  

```html
<HTML>
<BODY>
<FORM name="NewOrderForm">
Select Part Type:
<SELECT name="PartType">
  <OPTION>AZ-3700
  <OPTION>AZ-3701
  <OPTION>AZ-3702  
</SELECT><br/>
Quantity: <INPUT type="text" name="PartQty" size="2" maxsize="2" /><br/>
Building/Desk:
<INPUT type="text" name="PartBuilding" size="2" maxsize="2"/> /  
<INPUT type="text" name="PartDesk" size="2" maxsize="2"/><p/>
<INPUT type="submit" value="Transmit Order"/>
</FORM>
</BODY>
</HTML>
```

下列範例會顯示<xref:System.Windows.Forms.HtmlWindow.Confirm%2A>對話方塊中，當使用者提交`NewOrderForm`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlWindow#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536376.aspx">確認方法</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlWindow.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">要處理的事件名稱。</param>
        <param name="eventHandler">處理事件之 Managed 程式碼的參考。</param>
        <summary>移除具名的事件處理常式。</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536411.aspx">detachEvent 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlWindow.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含在視窗內的 HTML 文件。</summary>
        <value>如果已載入文件，則為 <see cref="T:System.Windows.Forms.HtmlDocument" /> 的有效執行個體。 如果此視窗包含<c>FRAMESET</c>，或目前已載入任何文件，它會傳回<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，您將會存取<xref:System.Windows.Forms.HtmlWindow.Document%2A>經由<xref:System.Windows.Forms.WebBrowser.Document%2A>屬性<xref:System.Windows.Forms.WebBrowser>控制項。 使用這個屬性，當您需要存取文件`FRAME`使用<xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合。  
  
   
  
## Examples  
 下列程式碼範例會檢查每份文件內包含框架的網頁，並從每個頁面供未來檢查建立的所有外寄的超連結的資料表。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DomWindow">
      <MemberSignature Language="C#" Value="public object DomWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.DomWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomWindow As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomWindow { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomWindow : obj" Usage="System.Windows.Forms.HtmlWindow.DomWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此類別包裝的 Unmanaged 介面。</summary>
        <value>物件，可轉換成<see langword="IHTMLWindow2" />， <see langword="IHTMLWindow3" />，或<see langword="IHTMLWindow4" />指標。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要執行未公開的方法中使用基礎 unmanaged 的介面指標的文件物件模型 (DOM) <xref:System.Windows.Forms.HtmlWindow>。  
  
 您必須將參考加入 unmanaged MSHTML.dll 才能使用<xref:System.Windows.Forms.HtmlWindow.DomWindow%2A>。 如需詳細資訊，請參閱 <<c0> [ 匯入類型程式庫當成組件](~/docs/framework/interop/importing-a-type-library-as-an-assembly.md)。  
  
   
  
## Examples  
 下列程式碼範例會取得`IHTMLWindow2`從文件的指標的視窗，並強制回應視窗中顯示新的文件。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741505.aspx">IHTMLWindow2 介面</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741356.aspx">IHTMLWindow3 介面</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741344.aspx">IHTMLWindow4 介面</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlWindow.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要測試的物件。</param>
        <summary>依目前的物件測試物件的相等性。</summary>
        <returns>如果物件相等則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As HtmlElementErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.Windows.Forms.HtmlElementErrorEventHandler " Usage="member this.Error : System.Windows.Forms.HtmlElementErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在視窗內執行的指令碼遇到執行階段錯誤時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 頁面可以包含指令碼撰寫的程式碼，通常在 JScript 或 VBScript，載入頁面時執行。 <xref:System.Windows.Forms.HtmlWindow.Error> 每當指令碼遇到執行階段錯誤，就會發生。 因為指令碼是晚期繫結，表示對物件的呼叫，並解決執行階段錯誤時，可從參考 null 物件來呼叫未定義的屬性或方法的所有項目。  
  
 您可以設定<xref:System.Windows.Forms.HtmlElementErrorEventArgs.Handled%2A>屬性<xref:System.Windows.Forms.HtmlElementErrorEventArgs>為 true，以便防止 Internet Explorer 中的 [原生錯誤] 對話方塊中顯示。
  
   
  
## Examples  
 下列程式碼範例設陷錯誤的結果時的 HTML 網頁上的指令碼嘗試存取文件中未定義的物件。 必須完全載入之前<xref:System.Windows.Forms.HtmlWindow.Error>附加事件處理常式，否則將無法運作的範例。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#16)]
 [!code-vb[System.Windows.Forms.HtmlWindow#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/cc197053.aspx">onerror 事件</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlWindow.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓目前視窗具有焦點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果另一個視窗中會保留之前焦點<xref:System.Windows.Forms.HtmlWindow.Focus%2A>已呼叫，該視窗就會失去焦點。  
  
 請勿呼叫到視窗的視窗內的項目上焦點<xref:System.Windows.Forms.HtmlWindow.Load>在引發事件。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536425.aspx">焦點方法</related>
      </Docs>
    </Member>
    <Member MemberName="Frames">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindowCollection Frames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindowCollection Frames" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Frames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Frames As HtmlWindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindowCollection ^ Frames { System::Windows::Forms::HtmlWindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Frames : System.Windows.Forms.HtmlWindowCollection" Usage="System.Windows.Forms.HtmlWindow.Frames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得定義在網頁內每一個 <c>FRAME</c> 項目的參考。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlWindowCollection" />的文件<c>框架</c>並<c>IFRAME</c>物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A`FRAME`是一份定義內的 windows `FRAMESET`。 `FRAME`可讓裝載單一文件中的多個文件。 每個`FRAME`定義為具有特定資料列和資料行寬度，而且與其他頁面上的位置`FRAME`內定義的 s `FRAMESET`; 位置`FRAME`固定的雖然使用者可能有時會使用滑鼠資料指標來擴大或縮小`FRAME`。 `IFRAME`類似於在範圍內，但它需要不會錨定在固定位置。  
  
 畫面格會包含一個執行個體<xref:System.Windows.Forms.HtmlWindow>針對每個`FRAME`或`IFRAME`網頁中定義。  
  
   
  
## Examples  
 下列程式碼範例會檢查每份文件內包含框架的網頁，並從每個頁面供未來檢查建立的所有外寄的超連結的資料表。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms537459.aspx">畫面格集合</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlWindow.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>做為特定型別的雜湊函式。</summary>
        <returns>目前 <see cref="T:System.Windows.Forms.HtmlWindow" /> 的雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當目前的視窗取得使用者輸入焦點時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.GotFocus> 會發生：  
  
-   中的第一個視窗`FRAMESET`當`FRAMESET`第一次載入。  
  
-   `FRAME` ，最後有焦點時含有<xref:System.Windows.Forms.WebBrowser>控制項移到前景。  
  
-   A`FRAME`按一下使用者，但前提是使用者所按不會將焦點放在視窗內的項目。  
  
 您無法取消的預設動作<xref:System.Windows.Forms.HtmlWindow.GotFocus>事件，或防止該事件反昇。
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.HtmlWindow.GotFocus>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.HtmlWindow>名為`HtmlWindow1`。 請確定 與關聯的事件處理常式<xref:System.Windows.Forms.HtmlWindow.GotFocus>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#452](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#452)]
 [!code-vb[System.Windows.Forms.EventExamples#452](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#452)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536934.aspx">onfocus 事件</related>
      </Docs>
    </Member>
    <Member MemberName="History">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlHistory History { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlHistory History" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.History" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property History As HtmlHistory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlHistory ^ History { System::Windows::Forms::HtmlHistory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.History : System.Windows.Forms.HtmlHistory" Usage="System.Windows.Forms.HtmlWindow.History" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlHistory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含使用者最近瀏覽過的 URL 之物件。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlHistory" />目前的視窗。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.History%2A> 包含所有在目前的視窗中，就是瀏覽至的 Url*巡覽堆疊*，並提供方法來向後巡覽至這些文件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Windows.Forms.HtmlWindow.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出此視窗已開啟還是關閉。</summary>
        <value>如果視窗仍然在螢幕上開啟，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Forms.HtmlWindow>使用者，或透過呼叫已關閉<xref:System.Windows.Forms.HtmlWindow.Close%2A>方法，嘗試瀏覽至新的 URL，或存取視窗的文件將會產生錯誤。 使用這個屬性來判斷它是否安全地呼叫上目前的視窗物件的屬性和方法。  
  
   
  
## Examples  
 下列程式碼範例會開啟視窗，並關閉它，如果使用者已無法使用它在過去 5 分鐘內。 程式碼範例需要您的表單具有<xref:System.Windows.Forms.WebBrowser>控制項，名為`WebBrowser1`，則<xref:System.Windows.Forms.Button>名為`Button1`，和<xref:System.Windows.Forms.Timer>類別名為`Timer1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms537459.aspx">已關閉的屬性</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Load : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當視窗的文件和其所有項目完成初始化時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Load>事件運作方式類似<xref:System.Windows.Forms.WebBrowser.DocumentCompleted>上的事件<xref:System.Windows.Forms.WebBrowser>控制： 它會通知會安全地存取 HTML 文件內的項目。  
  
 您無法取消的預設動作<xref:System.Windows.Forms.HtmlWindow.Load>事件。
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.HtmlWindow.Load>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.HtmlWindow>名為`HtmlWindow1`。 請確定 與關聯的事件處理常式<xref:System.Windows.Forms.HtmlWindow.Load>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#453](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#453)]
 [!code-vb[System.Windows.Forms.EventExamples#453](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#453)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/cc197055.aspx">onload 事件</related>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者輸入焦點離開視窗時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.HtmlWindow.LostFocus>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.HtmlWindow>名為`HtmlWindow1`。 請確定 與關聯的事件處理常式<xref:System.Windows.Forms.HtmlWindow.LostFocus>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#454](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#454)]
 [!code-vb[System.Windows.Forms.EventExamples#454](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#454)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將視窗移到螢幕上的指定座標位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.MoveTo(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : System.Drawing.Point -&gt; unit" Usage="htmlWindow.MoveTo point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">視窗左上角的 X 和 Y 座標。</param>
        <summary>將視窗移到螢幕上的指定座標位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法使用<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>来移動的視窗顯示螢幕的邊緣上; 這個方法也會提供透過網頁上的指令碼，允許不受信任的指令碼，以呈現不可見的視窗不會視為安全。  
  
 <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> 將會引發<xref:System.UnauthorizedAccessException>如果您嘗試移動的視窗和它的父視窗具有不同的最上層網域。 例如，如果您要裝載<xref:System.Windows.Forms.WebBrowser>控制指向 a.adatum.com，建立新的視窗使用<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>顯示 b.adatum.com。 在此情況下，這兩個視窗會被視為相同的最上層網域的一部分，並不會擲回例外狀況。 不過，如果您呼叫<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>若要顯示 www,microsoft.com，兩個視窗現在有不同的最上層網域，而<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>作業將會導致擲回的例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">嘗試執行這項作業的程式碼無權管理這個視窗。</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536626.aspx">moveTo 方法</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.MoveTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : int * int -&gt; unit" Usage="htmlWindow.MoveTo (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">視窗左上角的 X 座標。</param>
        <param name="y">視窗左上角的 Y 座標。</param>
        <summary>將視窗移到螢幕上的指定座標位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法使用<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>来移動的視窗顯示螢幕的邊緣上; 這個方法也會提供透過網頁上的指令碼，允許不受信任的指令碼，以呈現不可見的視窗不會視為安全。  
  
 <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> 將會引發<xref:System.UnauthorizedAccessException>如果您嘗試移動的視窗和它的父視窗具有不同的最上層網域。 例如，如果您要裝載<xref:System.Windows.Forms.WebBrowser>控制項和它所指向 a.adatum.com，您建立新的視窗使用<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>顯示 b.adatum.com。 在此情況下，這兩個視窗會被視為相同的最上層網域的一部分，並不會擲回例外狀況。 不過，如果您呼叫<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>若要顯示 www,microsoft.com，兩個視窗現在有不同的最上層網域，而<xref:System.Windows.Forms.HtmlWindow.MoveTo%2A>作業將會導致擲回的例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">嘗試執行這項作業的程式碼無權管理這個視窗。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlWindow.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗的名稱。</summary>
        <value>表示此名稱的 <see cref="T:System.String" />。</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534187.aspx">name 屬性</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>顯示或下載位於指定 URL 上的新內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string urlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string urlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (urlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ urlString);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="htmlWindow.Navigate urlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="urlString">要顯示的資源，由統一資源定位器 (URL) 所描述。</param>
        <summary>顯示或下載位於指定 URL 上的新內容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`url`參數所指向的 HTML 網頁，將摧毀並取代為新的頁面目前顯示在視窗中的頁面; 您的應用程式會保留舊的頁面中受管理的 DOM 物件的任何參考都是無效。 如果`url`Internet Explorer 無法顯示資源的點，使用者會看到對話方塊，詢問是否要開啟應用程式，將它儲存至磁碟，或取消下載作業之外的資源。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536638.aspx">瀏覽方法</related>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (url As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ url);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="htmlWindow.Navigate url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="url">要在目前視窗中顯示的文件或物件的位置 (指定為 <see cref="T:System.Uri" />)。</param>
        <summary>在目前的視窗中顯示新的文件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlWindow left, System.Windows.Forms.HtmlWindow right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlWindow left, class System.Windows.Forms.HtmlWindow right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.op_Equality(System.Windows.Forms.HtmlWindow,System.Windows.Forms.HtmlWindow)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlWindow, right As HtmlWindow) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlWindow ^ left, System::Windows::Forms::HtmlWindow ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlWindow * System.Windows.Forms.HtmlWindow -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlWindow" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlWindow" />
      </Parameters>
      <Docs>
        <param name="left">第一個 <see cref="T:System.Windows.Forms.HtmlWindow" /> 物件。</param>
        <param name="right">第二個 <see cref="T:System.Windows.Forms.HtmlWindow" /> 物件。</param>
        <summary>測試兩個 <see cref="T:System.Windows.Forms.HtmlWindow" /> 物件是否相等。</summary>
        <returns>如果兩個參數都是 <see langword="true" />，則為 <see langword="null" />；如果兩個項目都擁有相同的基礎 COM 介面，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 等號比較運算子測試`IUnknown`包裝由所提供的基礎 COM 物件的指標<xref:System.Windows.Forms.HtmlWindow>類別。  
  
 這個運算子的對等方法是 <xref:System.Windows.Forms.HtmlWindow.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlWindow left, System.Windows.Forms.HtmlWindow right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlWindow left, class System.Windows.Forms.HtmlWindow right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.op_Inequality(System.Windows.Forms.HtmlWindow,System.Windows.Forms.HtmlWindow)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlWindow, right As HtmlWindow) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlWindow ^ left, System::Windows::Forms::HtmlWindow ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlWindow * System.Windows.Forms.HtmlWindow -&gt; bool" Usage="System.Windows.Forms.HtmlWindow.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlWindow" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlWindow" />
      </Parameters>
      <Docs>
        <param name="left">第一個 <see cref="T:System.Windows.Forms.HtmlWindow" /> 物件。</param>
        <param name="right">第二個 <see cref="T:System.Windows.Forms.HtmlWindow" /> 物件。</param>
        <summary>測試兩個 <see langword="HtmlWindow" /> 物件是否不相等。</summary>
        <returns>如果只有一個物件而不是兩個全部為 <see langword="true" />，或基礎 COM 指標不相符，則為 <see langword="null" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在具名視窗中顯示檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Open (string urlString, string target, string windowOptions, bool replaceEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow Open(string urlString, string target, string windowOptions, bool replaceEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (urlString As String, target As String, windowOptions As String, replaceEntry As Boolean) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ Open(System::String ^ urlString, System::String ^ target, System::String ^ windowOptions, bool replaceEntry);" />
      <MemberSignature Language="F#" Value="member this.Open : string * string * string * bool -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.Open (urlString, target, windowOptions, replaceEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
        <Parameter Name="replaceEntry" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="urlString">描述要載入的檔案之位置的統一資源定位器 (URL)。</param>
        <param name="target">要在其中開啟資源的視窗名稱。 這可能是程式開發人員所提供的名稱，或是下列其中一個特殊值： 
 <c>_blank</c>：在新視窗中開啟 <paramref name="urlString" />。 與呼叫 <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" /> 的作用相同。  
  
 <c>_media</c>：在媒體列中開啟 <paramref name="urlString" />。  
  
 <c>_parent</c>：在建立目前視窗的視窗中開啟 <paramref name="urlString" />。  
  
 <c>_search</c>：在搜尋列中開啟 <paramref name="urlString" />。  
  
 <c>_self</c>：在目前的視窗中開啟 <paramref name="urlString" />。  
  
 <c>_top</c>：若針對屬於 <c>FRAME</c> 項目的視窗進行呼叫，則會在主控其 <c>FRAMESET</c> 的視窗中開啟 <paramref name="urlString" />。 否則，會與 <c>_self</c> 的作用相同。</param>
        <param name="windowOptions">以逗號分隔的字串，由下列 <c>name=value</c> 格式的零或多個選項所組成。 除了 <c>left</c>、<c>top</c>、<c>height</c> 和 <c>width</c> 選項允許任意整數以外，其餘每個選項只接受 <c>yes</c> 或 <see langword="1" />，以及 <c>no</c> 或 <see langword="0" /> 作為有效值。  
  
 <c>channelmode</c>：與 Internet Explorer 4.0 的已淘汰通道技術一起使用。 預設值為 <c>no</c>。  
  
 <c>directories</c>：視窗是否應該顯示目錄巡覽按鈕。 預設值為 <c>yes</c>。  
  
 <c>height</c>：視窗工作區的高度 (以像素為單位)。 最小值為 100。若嘗試開啟比這個值還要小的視窗，該視窗就會根據 Internet Explorer 的預設來進行開啟。  
  
 <c>left</c>：相對於使用者螢幕左上角的視窗左方 (X 座標) 位置 (以像素為單位)。 必須是正整數。  
  
 <c>location</c>：是否要顯示網址列，讓使用者將視窗巡覽至新的 URL。 預設值為 <c>yes</c>。  
  
 <c>menubar</c>：是否要在新視窗上顯示功能表。 預設值為 <c>yes</c>。  
  
 <c>resizable</c>：使用者是否可以調整視窗的大小。 預設值為 <c>yes</c>。  
  
 <c>scrollbars</c>：視窗是否有水平和垂直捲軸。 預設值為 <c>yes</c>。  
  
 <c>status</c>：視窗底部是否有狀態列。 預設值為 <c>yes</c>。  
  
 <c>titlebar</c>：是否顯示目前網頁的標題。 將這個選項設為 <c>no</c> 在 Managed 應用程式中不會有任何作用，標題列還是一樣會顯示。  
  
 <c>toolbar</c>：工具列按鈕 (例如 [上一頁]、[下一頁] 及 [停止]) 是否可見。 預設值為 <c>yes</c>。  
  
 <c>top</c>：相對於使用者螢幕左上角的視窗上方 (Y 座標) 位置 (以像素為單位)。 必須是正整數。  
  
 <c>width</c>：視窗工作區的寬度 (以像素為單位)。 最小值為 100。若嘗試開啟比這個值還要小的視窗，該視窗就會根據 Internet Explorer 的預設來進行開啟。</param>
        <param name="replaceEntry"><paramref name="urlString" /> 是否取代巡覽記錄中目前視窗的 URL。 這將會影響 <see cref="T:System.Windows.Forms.HtmlHistory" /> 類別上的方法作業。</param>
        <summary>在具名視窗中顯示檔案。</summary>
        <returns><see cref="T:System.Windows.Forms.HtmlWindow" />，表示新的視窗，或是之前建立的視窗 (由 <paramref name="target" /> 參數所命名)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target`參數可以建立成由先前呼叫的結果視窗的名稱<xref:System.Windows.Forms.HtmlWindow.Open%2A>。 參數可能也會指向按一下超連結所開啟的視窗 (`A`項目) 或`FORM`使用的項目`TARGET`屬性，以在新視窗中開啟它的 URL。 下列 HTML 程式碼會開啟新視窗，名為`orderWindow`當使用者按一下它：  
  
 `<A HREF="/startOrder.aspx" TARGET="orderWindow">Click to Start Order</a>`  
  
 如果您提供的任何選項`windowOptions`參數，不包含任何選項會自動停用。 換句話說，如果您只指定藉由`windowOptions`您想要的狀態 列，則不顯示功能表列、 工具列、 標題、 捲軸等等除非您明確地啟用它們藉由`windowOptions`。  
  
 如果所參考的檔案`url`是 HTML 檔案、 文字檔或其他可以裝載在 Internet Explorer 內的檔案類型將會顯示在具名視窗中。 如果檔案不會顯示在 Internet Explorer 內，而且名為目標的視窗不存在，則視窗隨即開啟只有長到足以讓 Internet Explorer 才能下載資源它會立即關閉之後。  
  
 當您建立新的 windows，使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它會導致 HTML 文件物件模型，以開啟 Internet Explorer 的新執行個體。 如果您不能呼叫<xref:System.Windows.Forms.HtmlWindow.Close%2A>所有您已建立的 windows 上的 Internet Explorer 的這個執行個體將會繼續執行已結束您的應用程式時，即使。  
  
 如果您使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>載入 URL，以在現有的視窗中，`windowOptions`將會被忽略; 維度、 外觀及第一次的初始呼叫中指定它的螢幕位置，視窗將會保留<xref:System.Windows.Forms.HtmlWindow.Open%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Open (Uri url, string target, string windowOptions, bool replaceEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow Open(class System.Uri url, string target, string windowOptions, bool replaceEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Open(System.Uri,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (url As Uri, target As String, windowOptions As String, replaceEntry As Boolean) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ Open(Uri ^ url, System::String ^ target, System::String ^ windowOptions, bool replaceEntry);" />
      <MemberSignature Language="F#" Value="member this.Open : Uri * string * string * bool -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.Open (url, target, windowOptions, replaceEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
        <Parameter Name="replaceEntry" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">描述要載入的檔案之位置的統一資源定位器 (URL)。</param>
        <param name="target">要在其中開啟資源的視窗名稱。 這可能是開發人員所提供的名稱，或是下列其中一個特殊值： 
 <c>_blank</c>：在新視窗中開啟 <paramref name="url" />。 與呼叫 <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" /> 的作用相同。  
  
 <c>_media</c>：在媒體列中開啟 <paramref name="url" />。  
  
 <c>_parent</c>：在建立目前視窗的視窗中開啟 <paramref name="url" />。  
  
 <c>_search</c>：在搜尋列中開啟 <paramref name="url" />。  
  
 <c>_self</c>：在目前的視窗中開啟 <paramref name="url" />。  
  
 <c>_top</c>：若針對屬於 <c>FRAME</c> 項目的視窗進行呼叫，則會在主控其 <c>FRAMESET</c> 的視窗中開啟 <paramref name="url" />。 否則，會與 <c>_self</c> 的作用相同。</param>
        <param name="windowOptions">以逗號分隔的字串，由下列 <c>name=value</c> 格式的零或多個選項所組成。 除了 <c>left</c>、<c>top</c>、<c>height</c> 和 <c>width</c> 選項允許任意整數以外，其餘每個選項只接受 <c>yes</c> 或 <see langword="1" />，以及 <c>no</c> 或 <see langword="0" /> 作為有效值。  
  
 <c>channelmode</c>：與 Internet Explorer 4.0 的已淘汰通道技術一起使用。 預設值為 <c>no</c>。  
  
 <c>directories</c>：視窗是否應該顯示目錄巡覽按鈕。 預設值為 <c>yes</c>。  
  
 <c>height</c>：視窗工作區的高度 (以像素為單位)。 最小值為 100。若嘗試開啟比這個值還要小的視窗，該視窗就會根據 Internet Explorer 的預設來進行開啟。  
  
 <c>left</c>：相對於使用者螢幕左上角的視窗左方 (X 座標) 位置 (以像素為單位)。 必須是正整數。  
  
 <c>location</c>：是否要顯示網址列，讓使用者將視窗巡覽至新的 URL。 預設值為 <c>yes</c>。  
  
 <c>menubar</c>：是否要在新視窗上顯示功能表。 預設值為 <c>yes</c>。  
  
 <c>resizable</c>：使用者是否可以調整視窗的大小。 預設值為 <c>yes</c>。  
  
 <c>scrollbars</c>：視窗是否有水平和垂直捲軸。 預設值為 <c>yes</c>。  
  
 <c>status</c>：視窗底部是否有狀態列。 預設值為 <c>yes</c>。  
  
 <c>titlebar</c>：是否顯示目前網頁的標題。 將這個選項設為 <c>no</c> 在 Managed 應用程式中不會有任何作用，標題列還是一樣會顯示。  
  
 <c>toolbar</c>：工具列按鈕 (例如 [上一頁]、[下一頁] 及 [停止]) 是否可見。 預設值為 <c>yes</c>。  
  
 <c>top</c>：相對於使用者螢幕左上角的視窗上方 (Y 座標) 位置 (以像素為單位)。 必須是正整數。  
  
 <c>width</c>：視窗工作區的寬度 (以像素為單位)。 最小值為 100。若嘗試開啟比這個值還要小的視窗，該視窗就會根據 Internet Explorer 的預設來進行開啟。</param>
        <param name="replaceEntry"><paramref name="url" /> 是否取代巡覽記錄中目前視窗的 URL。 這將會影響 <see cref="T:System.Windows.Forms.HtmlHistory" /> 類別上的方法作業。</param>
        <summary>在具名視窗中顯示檔案。</summary>
        <returns><see cref="T:System.Windows.Forms.HtmlWindow" />，表示新的視窗，或是之前建立的視窗 (由 <paramref name="target" /> 參數所命名)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target`參數可以建立成由先前呼叫的結果視窗的名稱<xref:System.Windows.Forms.HtmlWindow.Open%2A>。 參數可能也會指向按一下超連結所開啟的視窗 (`A`項目) 或`FORM`使用的項目`TARGET`屬性，以在新視窗中開啟它的 URL。 下列 HTML 程式碼會開啟新視窗，名為`orderWindow`當使用者按一下它：  
  
 `<A HREF="/startOrder.aspx" TARGET="orderWindow">Click to Start Order</a>`  
  
 如果您提供的任何選項`windowOptions`參數，不包含任何選項會自動停用。 換句話說，如果您只指定藉由`windowOptions`您想要的狀態 列，則不顯示功能表列、 工具列、 標題、 捲軸等等除非您明確地啟用它們藉由`windowOptions`。  
  
 如果所參考的檔案`url`是 HTML 檔案、 文字檔或其他可以裝載在 Internet Explorer 內的檔案類型將會顯示在具名視窗中。 如果檔案不會顯示在 Internet Explorer 內，而且名為目標的視窗不存在，則視窗隨即開啟只有長到足以讓 Internet Explorer 才能下載資源它會立即關閉之後。  
  
 當您建立新的 windows，使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它會導致 HTML 文件物件模型，以開啟 Internet Explorer 的新執行個體。 如果您不能呼叫<xref:System.Windows.Forms.HtmlWindow.Close%2A>所有您已建立的 windows 上的 Internet Explorer 的這個執行個體將會繼續執行已結束您的應用程式時，即使。  
  
 如果您使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>載入 URL，以在現有的視窗中，`windowOptions`將會被忽略; 維度、 外觀及第一次的初始呼叫中指定它的螢幕位置，視窗將會保留<xref:System.Windows.Forms.HtmlWindow.Open%2A>。  
  
   
  
## Examples  
 下列程式碼範例包含兩個方法：  
  
-   第一個名為的視窗中開啟 URL `displayWindow`，則會建立與顯示狀態列。  
  
-   第二個在相同的視窗中，開啟另一個 URL，但指定應該顯示只有位置列。  
  
 請注意視窗和控制項所顯示的維度取決所在 URL 第一次開啟。 程式碼範例需要您的表單包含<xref:System.Windows.Forms.WebBrowser>控制項，名為`WebBrowser1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536651.aspx">Open 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Opener">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Opener { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Opener" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Opener" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Opener As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Opener { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Opener : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlWindow.Opener" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得開啟目前視窗的視窗參考。</summary>
        <value>由 <see cref="T:System.Windows.Forms.HtmlWindow" /> 或 <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" /> 方法的呼叫所建立的 <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />。 如果未使用其中一個方法建立視窗，這個屬性會傳回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenNew">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在新的視窗中顯示檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow OpenNew (string urlString, string windowOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow OpenNew(string urlString, string windowOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (urlString As String, windowOptions As String) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ OpenNew(System::String ^ urlString, System::String ^ windowOptions);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : string * string -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.OpenNew (urlString, windowOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="urlString">描述要載入的檔案之位置的統一資源定位器 (URL)。</param>
        <param name="windowOptions">以逗號分隔的字串，由下列 <c>name=value</c> 格式的零或多個選項所組成。 如需有效選項的完整描述，請參閱 <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />。</param>
        <summary>在新的視窗中顯示檔案。</summary>
        <returns>表示新視窗的 <see cref="T:System.Windows.Forms.HtmlWindow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果所參考的檔案`url`是 HTML 檔案、 文字檔或其他可以裝載在 Internet Explorer 內的檔案類型將會顯示在新視窗中。 如果檔案不會顯示在 Internet Explorer 內，則會開啟此視窗只夠長，讓 Internet Explorer 才能下載資源它會立即關閉之後。  
  
 當您建立新的 windows，使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它會導致 HTML 文件物件模型，以開啟 Internet Explorer 的新執行個體。 如果您不能呼叫<xref:System.Windows.Forms.HtmlWindow.Close%2A>所有您已建立的 windows 上的 Internet Explorer 的這個執行個體將會繼續執行已結束您的應用程式時，即使。  
  
 如果您想要載入先前開啟的視窗中的文件，請參閱<xref:System.Windows.Forms.HtmlWindow.Open%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow OpenNew (Uri url, string windowOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow OpenNew(class System.Uri url, string windowOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.OpenNew(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (url As Uri, windowOptions As String) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ OpenNew(Uri ^ url, System::String ^ windowOptions);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : Uri * string -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.OpenNew (url, windowOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
        <Parameter Name="windowOptions" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">描述要載入的檔案之位置的統一資源定位器 (URL)。</param>
        <param name="windowOptions">以逗號分隔的字串，由下列 <c>name=value</c> 格式的零或多個選項所組成。 如需有效選項的完整描述，請參閱 <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />。</param>
        <summary>在新的視窗中顯示檔案。</summary>
        <returns>表示新視窗的 <see cref="T:System.Windows.Forms.HtmlWindow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果所參考的檔案`url`是 HTML 檔案、 文字檔或其他可以裝載在 Internet Explorer 內的檔案類型將會顯示在新視窗中。 如果檔案不會顯示在 Internet Explorer 內，則會開啟此視窗只夠長，讓 Internet Explorer 才能下載資源它會立即關閉之後。  
  
 當您建立新的 windows，使用<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>，它會導致 HTML 文件物件模型，以開啟 Internet Explorer 的新執行個體。 如果您不能呼叫<xref:System.Windows.Forms.HtmlWindow.Close%2A>所有您已建立的 windows 上的 Internet Explorer 的這個執行個體將會繼續執行已結束您的應用程式時，即使。  
  
 如果您想要載入先前開啟的視窗中的文件，請參閱<xref:System.Windows.Forms.HtmlWindow.Open%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536651.aspx">Open 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Parent { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlWindow.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得位於包含框架的網頁中目前視窗上面的視窗。</summary>
        <value>主控目前視窗的 <see cref="T:System.Windows.Forms.HtmlWindow" />。 如果目前的視窗不是<c>框架</c>，或未內嵌內<c>框架</c>，它會傳回<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含框架，文件中每個`FRAME`內`FRAMESET`做為頁面上的個別的子視窗。 每個父代`FRAME`已`FRAMESET`包含`FRAME`。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534326.aspx">父屬性</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Position { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point" Usage="System.Windows.Forms.HtmlWindow.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得螢幕上視窗的工作區 (Client Area) 位置。</summary>
        <value><see cref="T:System.Drawing.Point" />，描述螢幕左上角的 X 和 Y 座標 (以像素為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Location%2A>屬性<xref:System.Windows.Forms.WebBrowser>控制項會傳回相對於表單左上角之控制項的位置。 相較之下，<xref:System.Windows.Forms.HtmlWindow.Position%2A>則會傳回文件的顯示區域，相對於使用者的螢幕左上角的位置。  
  
   
  
## Examples  
 下列程式碼範例會開啟新視窗直接透過<xref:System.Windows.Forms.WebBrowser>表單上的控制項。 程式碼範例需要您的表單中包含的執行個體<xref:System.Windows.Forms.WebBrowser>控制項，名為`WebBrowser1`。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlWindow#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/cc06e61f-43b6-4408-a676-2542dcfcd96e">Windows Form 座標</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534389.aspx">screenLeft 屬性</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534390.aspx">screenTop 屬性</related>
      </Docs>
    </Member>
    <Member MemberName="Prompt">
      <MemberSignature Language="C#" Value="public string Prompt (string message, string defaultInputValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Prompt(string message, string defaultInputValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Prompt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Prompt (message As String, defaultInputValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Prompt(System::String ^ message, System::String ^ defaultInputValue);" />
      <MemberSignature Language="F#" Value="member this.Prompt : string * string -&gt; string" Usage="htmlWindow.Prompt (message, defaultInputValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="defaultInputValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">對使用者顯示的訊息。</param>
        <param name="defaultInputValue">顯示在文字方塊中的預設值。</param>
        <summary>顯示對話方塊，其中會對使用者顯示訊息和文字方塊。</summary>
        <returns><see cref="T:System.String" />，表示使用者輸入的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Prompt%2A> 能夠快速且輕鬆地向使用者取得簡單的文字輸入。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536673.aspx">提示的方法</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlWindow.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓目前視窗失去焦點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當上呼叫`FRAME` 視窗中的`FRAMESET`，<xref:System.Windows.Forms.HtmlWindow.RemoveFocus%2A>會導致該視窗失去焦點，但它將不會自動設定焦點在另一個視窗。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536347.aspx">模糊方法</related>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Resize : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者使用滑鼠變更視窗的維度時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.HtmlWindow.Resize>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.HtmlWindow>名為`HtmlWindow1`。 請確定 與關聯的事件處理常式<xref:System.Windows.Forms.HtmlWindow.Resize>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#455](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#455)]
 [!code-vb[System.Windows.Forms.EventExamples#455](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#455)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536959.aspx">onresize 事件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResizeTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將視窗大小變更為指定的維度。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResizeTo">
      <MemberSignature Language="C#" Value="public void ResizeTo (System.Drawing.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResizeTo(valuetype System.Drawing.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ResizeTo(System.Drawing.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResizeTo(System::Drawing::Size size);" />
      <MemberSignature Language="F#" Value="member this.ResizeTo : System.Drawing.Size -&gt; unit" Usage="htmlWindow.ResizeTo size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="size"><see cref="T:System.Drawing.Size" />，描述所需的視窗寬度和高度 (以像素為單位)。 必須是兩個維度都為 100 像素 (含) 以上。</param>
        <summary>將視窗大小變更為指定的維度。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會開啟新視窗中，並調整大小以填滿可用的螢幕區域。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">您所嘗試調整大小的視窗與其父視窗所在的網域不同。 這項限制是跨框架指令碼安全性的一部分。如需詳細資訊，請參閱 [About Cross-Frame Scripting and Security](https://msdn.microsoft.com/library/ms533028.aspx) (關於跨框架指令碼及安全性)。</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536723.aspx">resizeTo 方法</related>
      </Docs>
    </Member>
    <Member MemberName="ResizeTo">
      <MemberSignature Language="C#" Value="public void ResizeTo (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResizeTo(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ResizeTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResizeTo (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResizeTo(int width, int height);" />
      <MemberSignature Language="F#" Value="member this.ResizeTo : int * int -&gt; unit" Usage="htmlWindow.ResizeTo (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">描述所需的視窗寬度 (以像素為單位)。 必須是 100 像素 (含) 以上。</param>
        <param name="height">描述所需的視窗高度 (以像素為單位)。 必須是 100 像素 (含) 以上。</param>
        <summary>將視窗大小變更為指定的維度。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UnauthorizedAccessException">您所嘗試調整大小的視窗與其父視窗所在的網域不同。 這項限制是跨框架指令碼安全性的一部分。如需詳細資訊，請參閱 [About Cross-Frame Scripting and Security](https://msdn.microsoft.com/library/ms533028.aspx) (關於跨框架指令碼及安全性)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Scroll : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當使用者在視窗中捲動來檢視螢幕範圍外的文字時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.HtmlWindow.Scroll>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.HtmlWindow>名為`HtmlWindow1`。 請確定 與關聯的事件處理常式<xref:System.Windows.Forms.HtmlWindow.Scroll>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#456](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#456)]
 [!code-vb[System.Windows.Forms.EventExamples#456](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#456)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536966.aspx">onscroll 事件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScrollTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>捲動視窗至指定的位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScrollTo">
      <MemberSignature Language="C#" Value="public void ScrollTo (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollTo(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ScrollTo(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollTo(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.ScrollTo : System.Drawing.Point -&gt; unit" Usage="htmlWindow.ScrollTo point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">相對於目前視窗左上角的 X 和 Y 座標 (網頁應該捲動到這個座標位置)。</param>
        <summary>將視窗移至指定的座標。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> 會導致文件，讓文件上的指定的座標位在文件視窗的左上角捲動。 如果文件不是長或太寬的這種情形，<xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A>盡可能指定方向中的文件會捲動。  
  
   
  
## Examples  
 下列程式碼範例是由使用者所按的座標位置的文件捲動。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536731.aspx">scrollTo 方法</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollTo">
      <MemberSignature Language="C#" Value="public void ScrollTo (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollTo(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ScrollTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollTo (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollTo(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.ScrollTo : int * int -&gt; unit" Usage="htmlWindow.ScrollTo (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">相對於目前視窗左上角的 X 座標 (網頁應該捲動到這個座標位置)。</param>
        <param name="y">相對於目前視窗左上角的 Y 座標 (網頁應該捲動到這個座標位置)。</param>
        <summary>捲動視窗至指定的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> 會導致文件，讓文件上的指定的座標位在文件視窗的左上角捲動。 如果文件不是長或太寬的這種情形，<xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A>盡可能指定方向中的文件會捲動。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.HtmlWindow.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前視窗的大小。</summary>
        <value><see cref="T:System.Drawing.Size" />，描述視窗大小 (以像素為單位)。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarText">
      <MemberSignature Language="C#" Value="public string StatusBarText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusBarText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.StatusBarText" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusBarText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusBarText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusBarText : string with get, set" Usage="System.Windows.Forms.HtmlWindow.StatusBarText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定顯示在視窗狀態列中的文字。</summary>
        <value><see cref="T:System.String" />，包含目前狀態的文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.WebBrowser>控制項不會顯示狀態列。 您開啟任何新視窗<xref:System.Windows.Forms.HtmlWindow.Open%2A>或<xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>方法，不過，會顯示狀態列的預設值。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534648.aspx">狀態屬性</related>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Unload : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當目前的網頁正在卸載，而且即將要顯示新的網頁時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用這個成員。 在範例中，事件處理常式會報告一次<xref:System.Windows.Forms.HtmlWindow.Unload>事件。 此報表可協助您了解事件發生的時機，並可協助您偵錯。 若要報告多個事件或事件經常發生，請考慮更換<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>具有<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或將訊息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要執行範例程式碼，將它貼到包含類型的執行個體的專案<xref:System.Windows.Forms.HtmlWindow>名為`HtmlWindow1`。 請確定 與關聯的事件處理常式<xref:System.Windows.Forms.HtmlWindow.Unload>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#457](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#457)]
 [!code-vb[System.Windows.Forms.EventExamples#457](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#457)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536973.aspx">onunload 事件</related>
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlWindow.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 URL，其對應到顯示在視窗中的目前項目。</summary>
        <value>描述此 URL 的 <see cref="T:System.Uri" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是唯讀的。 若要瀏覽至新的文件視窗，請使用<xref:System.Windows.Forms.HtmlWindow.Navigate%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowFrameElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement WindowFrameElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement WindowFrameElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.WindowFrameElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WindowFrameElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ WindowFrameElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowFrameElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlWindow.WindowFrameElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對應到此視窗的框架項目。</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" />對應到這個視窗<c>框架</c>項目。 如果此視窗不是框架，則會傳回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您擷取`FRAME`項目<xref:System.Windows.Forms.HtmlWindow.Frames%2A>集合，它會傳回<xref:System.Windows.Forms.HtmlWindow>。 呼叫<xref:System.Windows.Forms.HtmlWindow.WindowFrameElement%2A>如果您需要存取基礎的屬性，此物件上`FRAME`項目，例如`SRC`屬性。  
  
   
  
## Examples  
 下列程式碼範例的比較`SRC`屬性中的畫面格`FRAMESET`到目前的位置。 如果兩者不同，框架會重設成其原始的 Url。  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.UnauthorizedAccessException">您無法存取<c>框架</c>項目或有<c>框架</c>的文件，如果<c>框架</c>位於不同的區域比<c>框架組</c>，其中包含它。 如需完整說明，請參閱 &lt;&lt;c0&gt; [ 關於跨框架指令碼和安全性](https://msdn.microsoft.com/library/ms533028.aspx)。</permission>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533771.aspx">frameElement 屬性</related>
      </Docs>
    </Member>
  </Members>
</Type>