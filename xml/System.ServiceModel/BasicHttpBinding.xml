<Type Name="BasicHttpBinding" FullName="System.ServiceModel.BasicHttpBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d9b8a9f2385de57668ed6739fb2763dbf6561d34" /><Meta Name="ms.sourcegitcommit" Value="3efce15f3841385ee3ba24bd71ff0c0cf9a47815" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="04/03/2019" /><Meta Name="ms.locfileid" Value="58874354" /></Metadata><TypeSignature Language="C#" Value="public class BasicHttpBinding : System.ServiceModel.HttpBindingBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BasicHttpBinding extends System.ServiceModel.HttpBindingBase implements class System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.BasicHttpBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class BasicHttpBinding&#xA;Inherits HttpBindingBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class BasicHttpBinding : System::ServiceModel::HttpBindingBase" />
  <TypeSignature Language="F#" Value="type BasicHttpBinding = class&#xA;    inherit HttpBindingBase&#xA;    interface IBindingRuntimePreferences" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Http</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.HttpBindingBase</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.ServiceModel.Channels.Binding</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IBindingRuntimePreferences</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>代表繫結，Windows Communication Foundation (WCF) 服務可使用該繫結設定並公開能與 ASMX Web 服務和用戶端，以及其他符合 WS-I Basic Profile 1.1 的服務進行通訊的端點。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.BasicHttpBinding> 使用 HTTP 做為傳送 SOAP 1.1 訊息的傳輸。 服務可使用這個繫結公開符合 WS-I BP 1.1 的端點，例如 ASMX 用戶端存取的端點。 同樣地，用戶端可以使用<xref:System.ServiceModel.BasicHttpBinding>與公開符合 WS-I 的端點的服務進行通訊-我 BP 1.1，例如 ASMX Web 服務或與設定的 Windows Communication Foundation (WCF) 服務<xref:System.ServiceModel.BasicHttpBinding>。  
  
 安全性預設是關閉的，但是可以在 <xref:System.ServiceModel.BasicHttpSecurityMode> 建構函式中透過將 <xref:System.ServiceModel.BasicHttpSecurityMode.None> 設為非 <xref:System.ServiceModel.BasicHttpBinding.%23ctor%28System.ServiceModel.BasicHttpSecurityMode%29> 的值來新增。 根據預設，它使用「文字」訊息編碼和 UTF-8 文字編碼。  
  
   
  
## Examples  
 下列範例會示範如何在應用程式組態檔中設定 <xref:System.ServiceModel.BasicHttpBinding>。  
  
  
  
 下列範例會示範如何以程式設計的方式設定 <xref:System.ServiceModel.BasicHttpBinding>。  
  
 [!code-csharp[S_UEBasicHttpBinding#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/service.cs#1)]
 [!code-vb[S_UEBasicHttpBinding#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.BasicHttpBinding" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BasicHttpBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BasicHttpBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.BasicHttpBinding" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用之 <xref:System.ServiceModel.BasicHttpSecurityMode> 的預設值為 <xref:System.ServiceModel.BasicHttpSecurityMode.None>，這個值表示 SOAP 訊息並不安全，而且用戶端也尚未經過驗證。  
  
   
  
## Examples  
 [!code-csharp[S_UEBasicHttpBinding#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/service.cs#2)]
 [!code-vb[S_UEBasicHttpBinding#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/service.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BasicHttpBinding (System.ServiceModel.BasicHttpSecurityMode securityMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ServiceModel.BasicHttpSecurityMode securityMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.#ctor(System.ServiceModel.BasicHttpSecurityMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (securityMode As BasicHttpSecurityMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BasicHttpBinding(System::ServiceModel::BasicHttpSecurityMode securityMode);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.BasicHttpBinding : System.ServiceModel.BasicHttpSecurityMode -&gt; System.ServiceModel.BasicHttpBinding" Usage="new System.ServiceModel.BasicHttpBinding securityMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityMode" Type="System.ServiceModel.BasicHttpSecurityMode" />
      </Parameters>
      <Docs>
        <param name="securityMode"><see cref="T:System.ServiceModel.BasicHttpSecurityMode" /> 的值，指定搭配 SOAP 訊息使用和用戶端的安全性類型。</param>
        <summary>使用由繫結所使用之安全性的指定類型，初始化 <see cref="T:System.ServiceModel.BasicHttpBinding" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用之 <xref:System.ServiceModel.BasicHttpSecurityMode> 的預設值為 <xref:System.ServiceModel.BasicHttpSecurityMode.None>，這個值表示 SOAP 訊息並不安全，而且用戶端也尚未經過驗證。  
  
   
  
## Examples  
 [!code-csharp[S_UEBasicHttpBinding#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/snippets.cs#3)]
 [!code-vb[S_UEBasicHttpBinding#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/snippets.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BasicHttpBinding (string configurationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configurationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configurationName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BasicHttpBinding(System::String ^ configurationName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.BasicHttpBinding : string -&gt; System.ServiceModel.BasicHttpBinding" Usage="new System.ServiceModel.BasicHttpBinding configurationName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configurationName" Type="System.String" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="configurationName"><see cref="T:System.ServiceModel.Configuration.BasicHttpBindingElement" /> 的繫結組態名稱。</param>
        <summary>使用由組態名稱指定的繫結，初始化 <see cref="T:System.ServiceModel.BasicHttpBinding" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例會使用組態名稱 <xref:System.ServiceModel.BasicHttpBinding> 指定的繫結初始化新 `myBinding` 類別。 您必須在服務的組態檔中建立繫結區段。  
  
 [!code-csharp[S_UEBasicHttpBinding#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/snippets.cs#5)]
 [!code-vb[S_UEBasicHttpBinding#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/snippets.vb#5)]  
  
 然後在呼叫 <xref:System.ServiceModel.BasicHttpBinding> 建構函式時，指定繫結組態的名稱。  
  
 [!code-csharp[S_UEBasicHttpBinding#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/snippets.cs#4)]
 [!code-vb[S_UEBasicHttpBinding#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uebasichttpbinding/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">找不到組態名稱為 <paramref name="configurationName" /> 的繫結。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowCookies">
      <MemberSignature Language="C#" Value="public bool AllowCookies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCookies" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.AllowCookies" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCookies As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCookies { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCookies : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.AllowCookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示用戶端是否接受 Cookie 並在未來的要求傳播 Cookie。</summary>
        <value><see langword="true" /> 如果允許 cookie;否則， <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

提供這個屬性是為了方便與使用 Cookie 的 ASMX Web 服務互動。 用戶端將屬性設定為 `true`以接受 Cookie 後，從伺服器傳回的 Cookie 會自動複製到該服務未來所有的用戶端要求。

## Examples

下列範例會設定這個屬性，指出，從伺服器的所有 cookie 應該都複製到未來的用戶端要求：

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.AllowCookies = true;
```

這個屬性的值也可以在組態檔中設定。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.BuildChannelFactory``1(System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (parameters As BindingParameterCollection) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingParameterCollection ^ parameters);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingParameterCollection -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="basicHttpBinding.BuildChannelFactory parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">通道處理站所產生之通道的類型。</typeparam>
        <param name="parameters">指定所建置之通道處理站的需求。</param>
        <summary>在用戶端上建置通道處理站堆疊，此堆疊會建立指定的通道型別，並滿足繫結參數集合所指定的功能。</summary>
        <returns>屬於 <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> 型別的 <paramref name="TChannel" />，可滿足集合所指定的功能。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassProxyOnLocal">
      <MemberSignature Language="C#" Value="public bool BypassProxyOnLocal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BypassProxyOnLocal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.BypassProxyOnLocal" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassProxyOnLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BypassProxyOnLocal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BypassProxyOnLocal : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.BypassProxyOnLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指出是否對本機位址略過 Proxy 伺服器。</summary>
        <value><see langword="true" /> 略過 proxy 伺服器的本機位址;否則， <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

如果網際網路資源有本機位址，則此資源為本機資源。 本機位址是指位於同一部電腦、 區域 LAN 或內部網路上識別，語法上沒有句號 (\.) 與 Uri`http://webserver/`和`http://localhost/`。

設定 BypassProxyOnLocal 屬性會決定端點是否已設有<xref:System.ServiceModel.BasicHttpBinding>存取本機資源時使用 proxy 伺服器。

如果 BypassProxyOnLocal `true`，對於本機網際網路資源的要求不使用 proxy 伺服器。 當這個屬性設定為 `localhost` 時，如果想要讓用戶端在與相同電腦上的服務進行交談時通過 Proxy，請使用主機名稱 (而非 `true`)。

BypassProxyOnLocal 時`false`，所有的網際網路要求非 localhost 都會通過 proxy 伺服器。 使用 localhost 的要求 uri 不會使用 proxy 伺服器，不論 BypassProxyOnLocal 設定為何。
  
## Examples

下列範例會將這個屬性設為表示應略過本機資源的 Proxy。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.BypassProxyOnLocal = true;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1" 
                 bypassProxyOnLocal="true">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>
  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBindingElements">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElementCollection CreateBindingElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElementCollection CreateBindingElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.CreateBindingElements" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateBindingElements () As BindingElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElementCollection ^ CreateBindingElements();" />
      <MemberSignature Language="F#" Value="override this.CreateBindingElements : unit -&gt; System.ServiceModel.Channels.BindingElementCollection" Usage="basicHttpBinding.CreateBindingElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElementCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立並傳回包含在目前繫結中繫結項目的已排序集合。</summary>
        <returns><see cref="T:System.ServiceModel.Channels.BindingElementCollection" />，其中包含 <see cref="T:System.ServiceModel.BasicHttpBinding" /> 所描述之繫結項目的已排序堆疊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結項目的順序很重要。 它會反映建構及堆疊通訊協定和傳輸通道的順序。 這個繫結項目的集合是新的集合，可以修改後用於建立 <xref:System.ServiceModel.Channels.CustomBinding>。  
  
   
  
## Examples  
 下列範例會在目前繫結中建立繫結項目的已排序集合。  
  
 [!code-csharp[S_UEBasicHttpBinding#26](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/client.cs#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHttpCookieContainer">
      <MemberSignature Language="C#" Value="public bool EnableHttpCookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHttpCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.EnableHttpCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHttpCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHttpCookieContainer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHttpCookieContainer : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.EnableHttpCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. To enable Http CookieContainer, use the AllowCookies property instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否已啟用 HTTP Cookie 容器。</summary>
        <value><see langword="true" /> 如果已啟用 HTTP cookie 容器否則， <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnvelopeVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EnvelopeVersion EnvelopeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EnvelopeVersion EnvelopeVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.EnvelopeVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvelopeVersion As EnvelopeVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EnvelopeVersion ^ EnvelopeVersion { System::ServiceModel::EnvelopeVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvelopeVersion : System.ServiceModel.EnvelopeVersion" Usage="System.ServiceModel.BasicHttpBinding.EnvelopeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EnvelopeVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 SOAP 的版本，這個版本是用於由此繫結處理的訊息。</summary>
        <value>搭配此繫結使用之 <see cref="T:System.ServiceModel.EnvelopeVersion" /> 的值。 該值一律為 SOAP 1.1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  

SOAP 1.1 是唯一可搭配此繫結使用的值。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostNameComparisonMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.HostNameComparisonMode HostNameComparisonMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.HostNameComparisonMode HostNameComparisonMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.HostNameComparisonMode" />
      <MemberSignature Language="VB.NET" Value="Public Property HostNameComparisonMode As HostNameComparisonMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::HostNameComparisonMode HostNameComparisonMode { System::ServiceModel::HostNameComparisonMode get(); void set(System::ServiceModel::HostNameComparisonMode value); };" />
      <MemberSignature Language="F#" Value="member this.HostNameComparisonMode : System.ServiceModel.HostNameComparisonMode with get, set" Usage="System.ServiceModel.BasicHttpBinding.HostNameComparisonMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.HostNameComparisonMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指出在比對 URI 時此主機名稱是否會用來取用服務。</summary>
        <value><see cref="T:System.ServiceModel.HostNameComparisonMode" /> 值，指出在比對 URI 時此主機名稱是否會用來取用服務。 預設值為 <see cref="F:System.ServiceModel.HostNameComparisonMode.StrongWildcard" />，表示比對時忽略主機名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

下列範例會設定這個屬性，以表示需要完全相符。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.HostNameComparisonMode = HostNameComparisonMode.Exact;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
                 hostNameComparisonMode ="Exact">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.BasicHttpBinding.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(524288)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定配置供訊息緩衝區管理員使用的最大記憶體量 (以位元組為單位)，其中訊息緩衝區會從通道接收訊息。</summary>
        <value>可供訊息緩衝區管理員使用的最大記憶體量，單位為位元組。 預設值為 524288 (0x80000) 位元組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.ServiceModel.Channels.BufferManager> 利用緩衝區集區將使用緩衝區的成本降至最低。 當訊息從通道送出時，服務將需要緩衝區來處理訊息。 如果緩衝區集區中沒有足夠的記憶體可以處理訊息負載，<xref:System.ServiceModel.Channels.BufferManager> 就必須從 CLR 堆積配置額外的記憶體，進而增加記憶體回收負荷。 從 CLR 記憶體回收堆積的大量配置是的表示緩衝區集區大小太小，而且可以藉由增加 MaxBufferPoolSize 限制較大的配置改善效能。

## Examples

下列範例會將此屬性設為預設值的兩倍。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
// Use double the default value
binding.MaxBufferPoolSize = 0x80000 * 2;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1">

          <!-- set pool size to double default of 0x80000 -->
          maxBufferPoolSize = 0x100000

          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferSize">
      <MemberSignature Language="C#" Value="public int MaxBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MaxBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferSize : int with get, set" Usage="System.ServiceModel.BasicHttpBinding.MaxBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定自通道接收訊息的緩衝區大小上限 (以位元組為單位)。</summary>
        <value>儲存訊息之緩衝區的大小上限 (以位元組為單位)。在為此繫結設定的端點處理訊息時，可以將訊息儲存在緩衝區中。 預設值為 65,536 位元組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

如果在處理時緩衝區中沒有足夠的記憶體可以儲存訊息，就必須從 CLR 堆積配置額外的記憶體，因而增加記憶體回收負荷。 從 CLR 記憶體回收堆積所產生的大量配置表示緩衝區集區太小，而提供較大的配置便可改善效能。

MaxBufferSize 屬性，以及其重要性的值會有所不同的訊息是否正在緩衝還是串流方式透過它所收到之通道上：

- 緩衝的傳輸 (<xref:System.ServiceModel.BasicHttpBinding.TransferMode>設定為<xref:System.ServiceModel.TransferMode.Buffered?displayProperty=nameWithType>)，這個值會一律等於所指定<xref:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize>屬性。

- 如果是經過資料流處理的傳輸 (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> 設定為 <xref:System.ServiceModel.TransferMode.Streamed?displayProperty=nameWithType>)，則只有 SOAP 標頭必須經過緩衝才能產生訊息。 本文可視需要以資料流處理。 在此情況下，MaxBufferSize 小於或等於<xref:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize>，其中<xref:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize>限制整個訊息 （標頭和本文） 的大小和 MaxBufferSize 限制只有 SOAP 標頭的大小。

此處針對緩衝區大小所設的限制是為了讓訊息交換的效能最佳化。 如果訊息超出設定的緩衝區上限值，訊息不會被捨棄。 相反地，系統會從 CLR 堆積要求更多記憶體，進而比使用緩衝區造成更多記憶體回收負荷。

> [!NOTE]
> MaxBufferSize 和 MaxReceivedMessageSize 的設定是本機行為設定。 表示這些設定不會以中繼資料的方式傳送到其他端點。 當您從中繼資料產生服務的 Proxy 時，如果訊息大小上限為 2GB，則此 Proxy 的預設值仍為 64K， 讓訊息和訊息緩衝區大小適當限制的控制落在本機系統管理員的管轄範圍內。
  
## Examples


下列範例會設定**MaxBufferSize**為 1,000,000 個位元組。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
            
// set to one million
binding.MaxBufferSize = 1000000;
```

這個屬性的值也可以在組態檔中設定。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定可在使用此繫結所設定之通道上接收的訊息大小上限 (以位元組為單位)。</summary>
        <value>由此繫結處理之訊息的大小上限，單位為位元組。 預設值為 65,536 位元組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

可以在網路使用 BasicHttpBinding 的服務所接收的訊息大小受限於配置給每個訊息的記憶體數量。 這項關於訊息大小的限制是為了防止受到 DoS 攻擊。

<xref:System.ServiceModel.BasicHttpBinding.MaxBufferSize><xref:System.ServiceModel.BasicHttpBinding>上也有  屬性：

如果是經過緩衝處理的傳輸 (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> 設定為 <xref:System.ServiceModel.TransferMode.Buffered>)， 這個值會一律等於指定的 MaxReceivedMessageSize。

如果是經過資料流處理的傳輸 (<xref:System.ServiceModel.BasicHttpBinding.TransferMode> 設定為 <xref:System.ServiceModel.TransferMode.Streamed>)，則只有 SOAP 標頭必須經過緩衝才能產生訊息。 本文可視需要以資料流處理。 在此情況下，<xref:System.ServiceModel.BasicHttpBinding.MaxBufferSize>小於或等於 MaxReceivedMessageSize，其中的 MaxReceivedMessageSize 限制整個訊息 （標頭和本文） 的大小和<xref:System.ServiceModel.BasicHttpBinding.MaxBufferSize>限制 SOAP 標頭的大小。

## Examples

下列範例會設定為 1,000,000 個位元組的 MaxReceivedMessageSize。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();

// Use double the default value
binding.MaxReceivedMessageSize = 65536 * 2;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
                 maxReceivedMessageSize = "1000000">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個值小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageEncoding">
      <MemberSignature Language="C#" Value="public System.ServiceModel.WSMessageEncoding MessageEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.WSMessageEncoding MessageEncoding" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.MessageEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageEncoding As WSMessageEncoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::WSMessageEncoding MessageEncoding { System::ServiceModel::WSMessageEncoding get(); void set(System::ServiceModel::WSMessageEncoding value); };" />
      <MemberSignature Language="F#" Value="member this.MessageEncoding : System.ServiceModel.WSMessageEncoding with get, set" Usage="System.ServiceModel.BasicHttpBinding.MessageEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.WSMessageEncoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 MTOM 或 Text 是否要用來編碼 SOAP 訊息。</summary>
        <value><see cref="T:System.ServiceModel.WSMessageEncoding" /> 的值，指出 MTOM 或 Text/XML 是否要用來編碼 SOAP 訊息。 預設值為 <see cref="F:System.ServiceModel.WSMessageEncoding.Text" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將 MessageEncoding 設定為 Text。  
  
 [!code-csharp[S_UEBasicHttpBinding#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/client.cs#19)]  
  
 這個屬性的值也可以在組態檔中設定。  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProxyAddress">
      <MemberSignature Language="C#" Value="public Uri ProxyAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ProxyAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.ProxyAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property ProxyAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ ProxyAddress { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProxyAddress : Uri with get, set" Usage="System.ServiceModel.BasicHttpBinding.ProxyAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 HTTP Proxy 的 URI 位址。</summary>
        <value>當做 HTTP Proxy 之位址使用的 <see cref="T:System.Uri" />。 預設值為 null。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

如果<xref:System.ServiceModel.BasicHttpBinding.UseDefaultWebProxy>設為`true`會使用預設位址，則會忽略 ProxyAddress 集的值。

## Examples

下列範例會設定 ProxyAddress 應用程式設定。

```csharp
// Get base address from app settings in configuration
Uri baseAddress = new Uri(ConfigurationManager.AppSettings["baseAddress"]);

BasicHttpBinding binding = new BasicHttpBinding();

binding.ProxyAddress = baseAddress;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
                 proxyAddress = "http://myProxy">
          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReaderQuotas">
      <MemberSignature Language="C#" Value="public System.Xml.XmlDictionaryReaderQuotas ReaderQuotas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDictionaryReaderQuotas ReaderQuotas" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.ReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Property ReaderQuotas As XmlDictionaryReaderQuotas" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlDictionaryReaderQuotas ^ ReaderQuotas { System::Xml::XmlDictionaryReaderQuotas ^ get(); void set(System::Xml::XmlDictionaryReaderQuotas ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReaderQuotas : System.Xml.XmlDictionaryReaderQuotas with get, set" Usage="System.ServiceModel.BasicHttpBinding.ReaderQuotas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDictionaryReaderQuotas</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 SOAP 訊息複雜性的條件約束，而這些條件約束可由以此繫結所設定的端點處理。</summary>
        <value>指定複雜性條件約束的 <see cref="T:System.Xml.XmlDictionaryReaderQuotas" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

複雜性條件約束可以防止受到阻絕服務 (DOS) 攻擊，這種攻擊會嘗試使用訊息的複雜性來困住端點處理資源。 其他複雜性條件約束包含最大項目深度和訊息內最大字串內容長度等項目。

## Examples

下列範例會設定 ReaderQuotas 應用程式設定。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
XmlDictionaryReaderQuotas readerQuotas = new XmlDictionaryReaderQuotas();
readerQuotas.MaxArrayLength = 25 * 1024;
        
binding.ReaderQuotas = readerQuotas;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1">
          <readerQuotas maxBytesPerRead ="1000" 
                        maxDepth="100"/>

          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>

  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.BasicHttpBinding.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得使用這項繫結所設定之通道與接聽程式的 URI 傳輸配置。</summary>
        <value>如果傳輸繫結項目中的安全性模式設為 <see cref="F:System.ServiceModel.BasicHttpSecurityMode.Transport" /> 或 <see cref="F:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential" />，則為 "https"，否則為 "http"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

下列範例會取得目前配置。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
string thisScheme = binding.Scheme;
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Security">
      <MemberSignature Language="C#" Value="public System.ServiceModel.BasicHttpSecurity Security { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.BasicHttpSecurity Security" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.Security" />
      <MemberSignature Language="VB.NET" Value="Public Property Security As BasicHttpSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::BasicHttpSecurity ^ Security { System::ServiceModel::BasicHttpSecurity ^ get(); void set(System::ServiceModel::BasicHttpSecurity ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.BasicHttpSecurity with get, set" Usage="System.ServiceModel.BasicHttpBinding.Security" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.BasicHttpSecurity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要搭配此繫結使用的安全性類型。</summary>
        <value>搭配此繫結使用的 <see cref="T:System.ServiceModel.BasicHttpSecurity" />。 預設值為 <see cref="F:System.ServiceModel.BasicHttpSecurityMode.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，SOAP 訊息並不安全，而且用戶端也尚未經過驗證。 若要使用非預設類型的安全性，請使用 <xref:System.ServiceModel.BasicHttpBinding.%23ctor%28System.ServiceModel.BasicHttpSecurityMode%29> 建構函式。  
  
   
  
## Examples  
 下列範例會取得 `Security` 屬性。  
  
 [!code-csharp[S_UEBasicHttpBinding#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_uebasichttpbinding/cs/client.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeEnableHttpCookieContainer">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeEnableHttpCookieContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeEnableHttpCookieContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeEnableHttpCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeEnableHttpCookieContainer () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeEnableHttpCookieContainer();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeEnableHttpCookieContainer : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeEnableHttpCookieContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>表示 http cookie 容器是否應該啟用序列化。</summary>
        <returns><see langword="true" /> 如果 Http Cookie 容器應啟用序列化；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReaderQuotas">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReaderQuotas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReaderQuotas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReaderQuotas () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReaderQuotas();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReaderQuotas : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeReaderQuotas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回是否應序列化針對 SOAP 訊息結構複雜度所設立的約束條件值。</summary>
        <returns><see langword="true" /> 如果讀取器配額應進行序列化；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSecurity">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeSecurity" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSecurity () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSecurity();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSecurity : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>根據序列化是否已經發生 (例如位於訊息層級或傳輸層級)，傳回是否應序列化安全性設定。</summary>
        <returns><see langword="true" /> 如果安全性應進行序列化；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTextEncoding">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTextEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTextEncoding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.BasicHttpBinding.ShouldSerializeTextEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTextEncoding () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTextEncoding();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTextEncoding : unit -&gt; bool" Usage="basicHttpBinding.ShouldSerializeTextEncoding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回是否應序列化文字編碼方式的設定。</summary>
        <returns><see langword="true" /> 如果文字編碼方式應進行序列化；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously">
      <MemberSignature Language="C#" Value="bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.System#ServiceModel#Channels#IBindingRuntimePreferences#ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ReceiveSynchronously As Boolean Implements IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ServiceModel::Channels::IBindingRuntimePreferences::ReceiveSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示要以同步或非同步方式處理傳入要求。</summary>
        <value>一定是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

此範例會取得 ReceiveSynchronously 值。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
IBindingRuntimePreferences s = (binding as IBindingRuntimePreferences);
bool receiveSynchronously = s.ReceiveSynchronously;
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding TextEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding TextEncoding" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.TextEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ TextEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextEncoding : System.Text.Encoding with get, set" Usage="System.ServiceModel.BasicHttpBinding.TextEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.EncodingConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用於訊息文字的字元編碼。</summary>
        <value><see cref="T:System.Text.Encoding" />，表示所使用的字元編碼。 預設為 <see cref="T:System.Text.UTF8Encoding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

下列範例設定 TextEncoding <xref:System.Text.Encoding.Unicode?displayProperty=nameWithType>。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.TextEncoding = System.Text.Encoding.Unicode;
```

這個屬性的值也可以在組態檔中設定。

```xml
<configuration>
  <system.serviceModel>

    <bindings>
      <basicHttpBinding>
        <binding name="Binding1"
          textEncoding = "UnicodeFffeTextEncoding">

          <security mode="None" />
        </binding>
      </basicHttpBinding>
    </bindings>
  </system.serviceModel>

</configuration>
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransferMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransferMode TransferMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.TransferMode TransferMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.TransferMode" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferMode As TransferMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransferMode TransferMode { System::ServiceModel::TransferMode get(); void set(System::ServiceModel::TransferMode value); };" />
      <MemberSignature Language="F#" Value="member this.TransferMode : System.ServiceModel.TransferMode with get, set" Usage="System.ServiceModel.BasicHttpBinding.TransferMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransferMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指出訊息是以經過緩衝處理或資料流處理的方式傳送。</summary>
        <value><see cref="T:System.ServiceModel.TransferMode" />，指出訊息是以經過緩衝處理或資料流處理的方式傳送。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples

下列範例會將傳輸模式設定為<xref:System.ServiceModel.TransferMode.Streamed>。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.TransferMode = TransferMode.Streamed;
```

這個屬性的值也可以在組態檔中設定。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultWebProxy">
      <MemberSignature Language="C#" Value="public bool UseDefaultWebProxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultWebProxy" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.BasicHttpBinding.UseDefaultWebProxy" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultWebProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultWebProxy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultWebProxy : bool with get, set" Usage="System.ServiceModel.BasicHttpBinding.UseDefaultWebProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Http</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否應使用系統自動設定的 HTTP Proxy (如果有的話)。</summary>
        <value><see langword="true" /> 如果自動設定的 HTTP proxy 的系統應該使用，如果有的話，否則， <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

它是這個值是錯誤`true`和<xref:System.ServiceModel.BasicHttpBinding.ProxyAddress>為非 null。

## Examples

此範例中設定的值來 UseDefaultWebProxy `false`。

```csharp
BasicHttpBinding binding = new BasicHttpBinding();
binding.UseDefaultWebProxy = false;
```

這個屬性的值也可以在組態檔中設定。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
