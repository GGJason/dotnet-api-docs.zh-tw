<Type Name="MessageContractMemberAttribute" FullName="System.ServiceModel.MessageContractMemberAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8bd7dd5ba88b9904b8ea869d643e4d030ff67158" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36610656" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MessageContractMemberAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MessageContractMemberAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.MessageContractMemberAttribute" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MessageContractMemberAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageContractMemberAttribute abstract : Attribute" />
  <TypeSignature Language="F#" Value="type MessageContractMemberAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="3f6fa-101">宣告 <see cref="T:System.ServiceModel.MessageBodyMemberAttribute" /> 和 <see cref="T:System.ServiceModel.MessageHeaderAttribute" /> 的基底成員。</span>
      <span class="sxs-lookup">
        <span data-stu-id="3f6fa-101">Declares the base members for <see cref="T:System.ServiceModel.MessageBodyMemberAttribute" /> and <see cref="T:System.ServiceModel.MessageHeaderAttribute" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f6fa-102">這個類別包含 SOAP 訊息的所有部分都通用的屬性。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-102">This class contains properties common to all parts of a SOAP message.</span></span> <span data-ttu-id="3f6fa-103">例如，所有的部分都會有名稱和命名空間，而且可能套用了某個層級的安全性。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-103">For example, all parts have a name and a namespace, and potentially a level of security applied.</span></span>  
  
 <span data-ttu-id="3f6fa-104">如需如何控制 SOAP 本文內容的序列化，而不需修改預設 SOAP 封套本身的資訊，請參閱<xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>，[在服務合約中指定資料傳輸](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)，和[中使用資料合約](~/docs/framework/wcf/feature-details/using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-104">For information on controlling the serialization of the contents of a SOAP body without modifying the default SOAP envelope itself, see <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>, [Specifying Data Transfer in Service Contracts](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md), and [Using Data Contracts](~/docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="3f6fa-105">如需有關如何建立訊息合約的詳細資訊，請參閱[使用訊息合約](~/docs/framework/wcf/feature-details/using-message-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-105">For more information about creating message contracts, see [Using Message Contracts](~/docs/framework/wcf/feature-details/using-message-contracts.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f6fa-106">下列程式碼範例示範自訂訊息合約，這個合約會使用 <xref:System.ServiceModel.MessageContractAttribute>、<xref:System.ServiceModel.MessageHeaderAttribute> 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 屬性 (全都繼承自 <xref:System.ServiceModel.MessageContractMemberAttribute>) 建立自訂型別訊息以使用於作業中。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-106">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes (which all inherit from <xref:System.ServiceModel.MessageContractMemberAttribute>)to create custom typed messages to use in operations.</span></span> <span data-ttu-id="3f6fa-107">在此案例中，有三個序列化成 SOAP 訊息本文項目的成員：`sourceAccount`、`targetAccount` 以及 `amount` 值 (序列化成名稱為 `transactionAmount` 的項目)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-107">In this case, there are three members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="3f6fa-108">此外，`IsAudited` SOAP 標頭項目位於 `http://schemas.contosobank.com/auditing/2005` 命名空間中，而 `sourceAccount` 已經過加密和數位簽署。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-108">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace, and `sourceAccount` is encrypted and digitally signed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f6fa-109">`Operation` 和 `Account` 型別必須具有資料合約。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-109">The `Operation` and `Account` types must have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader]   
  public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")]   
  public bool IsAudited;  
  [MessageBody(ProtectionLevel=ProtectionLevel.EncryptAndSign)]   
  public Account sourceAccount;  
  [MessageBody]   
  public Account targetAccount;  
  [MessageBody(Name="transactionAmount")]   
  public int amount;  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MessageContractMemberAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.MessageContractMemberAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MessageContractMemberAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3f6fa-110">初始化 <see cref="T:System.ServiceModel.MessageContractMemberAttribute" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-110">Initializes a new instance of the <see cref="T:System.ServiceModel.MessageContractMemberAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.MessageContractMemberAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f6fa-111">在衍生類別中覆寫時，取得指出成員是否已指派保護層級的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-111">When overridden in a derived class, gets a value that indicates whether the member has a protection level assigned.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f6fa-112">如果成員具有保護層級，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-112">
              <see langword="true" /> if the member has a protection level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.MessageContractMemberAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f6fa-113">指定對應於這個成員的項目名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-113">Specifies the name of the element that corresponds to this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f6fa-114">對應至這個成員的項目名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-114">The name of the element that corresponds to this member.</span>
          </span>
          <span data-ttu-id="3f6fa-115">這個字串必須是有效的 XML 項目名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-115">This string must be a valid XML element name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f6fa-116">下列程式碼範例示範自訂訊息合約，這個合約會使用 <xref:System.ServiceModel.MessageContractAttribute>、<xref:System.ServiceModel.MessageHeaderAttribute> 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 屬性，以建立自訂的強型別訊息當做參數使用。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-116">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes to create custom, strongly-typed messages to use as parameters.</span></span> <span data-ttu-id="3f6fa-117">在此案例中，有三個序列化成 SOAP 訊息本文項目的資料成員：`sourceAccount`、`targetAccount` 以及 `amount` 值 (後者序列化成名稱為 `transactionAmount` 的項目)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-117">In this case, there are three data members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="3f6fa-118">此外，`IsAudited` SOAP 標頭項目是位於 `http://schemas.contosobank.com/auditing/2005` 命名空間。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-118">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f6fa-119">`Operation` 和 `Account` 型別還必須具有資料合約。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-119">The `Operation` and `Account` types must also have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader] public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")] public bool IsAudited;  
  [MessageBody] public Account sourceAccount;  
  [MessageBody] public Account targetAccount;  
  [MessageBody(Name="transactionAmount")] public int amount;  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.MessageContractMemberAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f6fa-120">指定對應於這個成員的項目命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-120">Specifies the namespace of the element that corresponds to this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f6fa-121">對應於這個成員的項目命名空間 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-121">A namespace URI of the element that corresponds to this member.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3f6fa-122">下列程式碼範例示範自訂訊息合約，這個合約會使用 <xref:System.ServiceModel.MessageContractAttribute>、<xref:System.ServiceModel.MessageHeaderAttribute> 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 屬性 (全都繼承自 <xref:System.ServiceModel.MessageContractMemberAttribute>) 建立自訂型別訊息以使用於作業中。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-122">The following code examples demonstrate a custom message contract that uses the <xref:System.ServiceModel.MessageContractAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes (which all inherit from <xref:System.ServiceModel.MessageContractMemberAttribute>)to create custom typed messages to use in operations.</span></span> <span data-ttu-id="3f6fa-123">在此案例中，有三個序列化成 SOAP 訊息本文項目的成員：`sourceAccount`、`targetAccount` 以及 `amount` 值 (序列化成名稱為 `transactionAmount` 的項目)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-123">In this case, there are three members that are serialized into the body element of the SOAP message: `sourceAccount`, `targetAccount`, and the `amount` value, (which is serialized into an element with the name `transactionAmount`).</span></span> <span data-ttu-id="3f6fa-124">此外，`IsAudited` SOAP 標頭項目位於 `http://schemas.contosobank.com/auditing/2005` 命名空間中，而 `sourceAccount` 已經過加密和數位簽署。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-124">In addition, the `IsAudited` SOAP header element resides in the `http://schemas.contosobank.com/auditing/2005` namespace, and `sourceAccount` is encrypted and digitally signed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f6fa-125">`Operation` 和 `Account` 型別必須具有資料合約。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-125">The `Operation` and `Account` types must have a data contract.</span></span>  
  
```csharp  
[MessageContract]  
public class BankingTransaction  
{  
  [MessageHeader] public Operation operation;  
  [MessageHeader(Namespace="http://schemas.contosobank.com/auditing/2005")] public bool IsAudited;  
  [MessageBody] public Account sourceAccount;  
  [MessageBody] public Account targetAccount;  
  [MessageBody(Name="transactionAmount")] public int amount;  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3f6fa-126">指定成員要依現狀加以傳輸、簽署，或者加以簽署並加密。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-126">Specifies whether the member is to be transmitted as-is, signed, or signed and encrypted.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3f6fa-127">其中一個 <see cref="T:System.Net.Security.ProtectionLevel" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-127">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values.</span>
          </span>
          <span data-ttu-id="3f6fa-128">預設值為 <see cref="F:System.Net.Security.ProtectionLevel.None" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3f6fa-128">The default is <see cref="F:System.Net.Security.ProtectionLevel.None" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f6fa-129">若要使用 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> 或 <xref:System.ServiceModel.MessageHeaderAttribute> 屬性中的 <xref:System.ServiceModel.MessageBodyMemberAttribute> 屬性，您必須正確設定繫結和行為。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-129">To make use of the <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property in either the <xref:System.ServiceModel.MessageHeaderAttribute> or <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes you must properly configure the binding and behaviors.</span></span> <span data-ttu-id="3f6fa-130">如果沒有透過正確的組態 (例如，使用具有未提供安全性認證之訊息部分的 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>) 使用這些安全性功能，就會在執行階段擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-130">If these security features are used without a proper configuration (for example, using <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> with a message part without supplying security credentials) an exception is thrown at run time.</span></span>  
  
 <span data-ttu-id="3f6fa-131">此外，保護層級是針對每一個標頭個別決定的。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-131">In addition, the protection level is determined for each header individually.</span></span> <span data-ttu-id="3f6fa-132">不過，無論有多少個本文部分，SOAP 本文都只有一個保護層級。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-132">However, the SOAP body has only one protection level, regardless of the number of body parts.</span></span> <span data-ttu-id="3f6fa-133">本文保護層級是由所有本文部分的最高層 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> 屬性值所決定。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-133">The protection level of the body is determined by the highest <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property value of all the body parts.</span></span> <span data-ttu-id="3f6fa-134">例如，請參考下列類別：</span><span class="sxs-lookup"><span data-stu-id="3f6fa-134">For example, consider the following class:</span></span>  
  
```csharp  
[MessageContract]  
public class PatientRecord  
{  
   [MessageHeader(ProtectionLevel=None)] public int recordID;  
   [MessageHeader(ProtectionLevel=Sign)] public string patientName;  
   [MessageHeader(ProtectionLevel=EncryptAndSign)] public string SSN;  
   [MessageBody(ProtectionLevel=None)] public string comments;  
   [MessageBody(ProtectionLevel=Sign)] public string diagnosis;  
   [MessageBody(ProtectionLevel=EncryptAndSign)] public string medicalHistory;  
}  
```  
  
 <span data-ttu-id="3f6fa-135">在這個範例中，`recordID` 標頭不受保護，`patientName` 已經過簽署，而 `SSN` 已經過加密並簽署。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-135">In this example, the `recordID` header is not protected, `patientName` is signed, and `SSN` is encrypted and signed.</span></span> <span data-ttu-id="3f6fa-136">至少有一個本文部分 `medicalHistory` 具有 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，因此會加密並簽署整個訊息本文，即使 `comments` 和 `diagnosis` 本文部分指定較低的保護層級亦然。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-136">There is at least one body part, `medicalHistory`, with <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and thus the entire message body is encrypted and signed, even though the `comments` and `diagnosis` body parts specify lower protection levels.</span></span>  
  
 <span data-ttu-id="3f6fa-137">執行階段的保護行為，是下列屬性的保護層級設定值的組合。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-137">The protection behavior at runtime is the combination of the protection-level values set on the following properties.</span></span> <span data-ttu-id="3f6fa-138">這些屬性有階層式結構。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-138">These properties have a hierarchical structure.</span></span> <span data-ttu-id="3f6fa-139">除非針對較窄的範圍明確設定不同的值，否則，設定最外層的值會建立所有較窄範圍的預設值。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-139">Setting the outermost value establishes the default setting for all narrower scopes unless a different value for a narrower scope is explicitly set.</span></span> <span data-ttu-id="3f6fa-140">在此情況下，外部值仍為所有較窄範圍的預設值 (特別設定的範圍除外)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-140">In this case, the outer value remains the default for all narrower scopes with the exception of that specifically set.</span></span>  
  
 <span data-ttu-id="3f6fa-141">例如，如果 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 設定為 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> 而且沒有其他更窄的範圍具有保護層級設定，則會加密並簽署作業合約中的所有訊息。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-141">For example, if <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> is set to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and no other narrower scopes have protection level settings, all messages in an operation contract are encrypted and signed.</span></span> <span data-ttu-id="3f6fa-142">但是，如果這些其中一個作業已將 <xref:System.ServiceModel.OperationContractAttribute> 設定為 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>，則會簽署該作業的訊息，但是合約中的其他所有訊息都會經過加密並簽署。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-142">If, however, one of those operations has the <xref:System.ServiceModel.OperationContractAttribute> set to <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, then the messages for that operation are signed but all other messages in the contract are encrypted and signed.</span></span>  
  
 <span data-ttu-id="3f6fa-143">如需保護層級及其假設和範圍的詳細資訊，請參閱[了解保護層級](~/docs/framework/wcf/understanding-protection-level.md)。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-143">For details about protection levels and their assumptions and scopes, see [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).</span></span>  
  
 <span data-ttu-id="3f6fa-144">設定這些值的範圍如下：</span><span class="sxs-lookup"><span data-stu-id="3f6fa-144">The scopes at which these values are set are:</span></span>  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="3f6fa-145"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 的 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-145">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3f6fa-146"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 的 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-146">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3f6fa-147">當合約上未明確指定保護層級，而且基礎繫結可支援安全性 (不論是在傳輸層級或訊息層級) 時，整個合約的有效保護層級會是 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-147">When there is no protection level explicitly specified on the contract and the underlying binding supports security (whether at the transport or message level), the effective protection level for the whole contract is <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3f6fa-148">如果繫結不支援安全性 (例如，<xref:System.ServiceModel.BasicHttpBinding>)，整個合約的有效 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> 為 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-148">If the binding does not support security (such as <xref:System.ServiceModel.BasicHttpBinding>), the effective <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> is <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> for the whole contract.</span></span> <span data-ttu-id="3f6fa-149">結果便是根據端點繫結的不同，用戶端可以要求不同的訊息或傳輸層級的安全性保護，即使當合約指定 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> 時亦然。</span><span class="sxs-lookup"><span data-stu-id="3f6fa-149">The result is that depending upon the endpoint binding, clients can require different message or transport level security protection even when the contract specifies <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>