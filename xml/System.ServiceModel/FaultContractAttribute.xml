<Type Name="FaultContractAttribute" FullName="System.ServiceModel.FaultContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81f46a1292e6c9b4524dce399b33d734e97bf019" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52910990" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FaultContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FaultContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.FaultContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FaultContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FaultContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type FaultContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true, Inherited=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="6dcd7-101">指定一個或多個 SOAP 錯誤，當服務作業遇到處理錯誤時會傳回這些 SOAP 錯誤。</span>
      <span class="sxs-lookup">
        <span data-stu-id="6dcd7-101">Specifies one or more SOAP faults that are returned when a service operation encounters processing errors.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dcd7-102">以 <xref:System.ServiceModel.FaultContractAttribute> 屬性標記一個作業，來宣告該服務作業的 Web 服務描述語言 (WSDL) 描述中所加入的一個或多個特定例外狀況，做為該作業傳回的明確 SOAP 錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-102">Mark an operation with the <xref:System.ServiceModel.FaultContractAttribute> attribute to declare one or more specific exception conditions that are added to the Web Service Description Language (WSDL) description of the service operation as explicit SOAP fault messages returned by the operation.</span></span>  
  
 <span data-ttu-id="6dcd7-103">在所有 Managed 應用程式中，處理錯誤由 <xref:System.Exception> 物件表示。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-103">In all managed applications, processing errors are represented by <xref:System.Exception> objects.</span></span> <span data-ttu-id="6dcd7-104">例如，Windows Communication Foundation (WCF) 應用程式以 SOAP 為基礎的應用程式，在服務方法通訊，使用 SOAP 錯誤訊息的處理錯誤資訊。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-104">In SOAP-based applications such as Windows Communication Foundation (WCF) applications, service methods communicate processing error information using SOAP fault messages.</span></span> <span data-ttu-id="6dcd7-105">因為 WCF 應用程式執行這兩種錯誤系統下，必須傳送至用戶端的任何 managed 例外狀況資訊必須轉換成 SOAP 錯誤的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-105">Because WCF applications execute under both types of error systems, any managed exception information that must be sent to the client must be converted from exceptions into SOAP faults.</span></span> <span data-ttu-id="6dcd7-106">您可使用預設的服務例外狀況行為，或自行控制是否要將例外狀況對應到錯誤訊息，以及其對應方式。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-106">You can use the default service exception behaviors, or you can explicitly control whether -- and how -- exceptions are mapped to fault messages.</span></span> <span data-ttu-id="6dcd7-107">如需例外狀況和 WCF 應用程式中的 SOAP 錯誤的概觀，請參閱 <<c0> [ 指定及處理合約和服務中的錯誤](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-107">For an overview of exceptions and SOAP faults in WCF applications, see [Specifying and Handling Faults in Contracts and Services](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).</span></span>  
  
 <span data-ttu-id="6dcd7-108">我們建議，服務作業應使用 <xref:System.ServiceModel.FaultContractAttribute> 正式指定用戶端在正常作業期間可能收到的所有 SOAP 錯誤。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-108">It is recommended that service operations use the <xref:System.ServiceModel.FaultContractAttribute> to formally specify all SOAP faults that a client can expect to receive in the normal course of an operation.</span></span> <span data-ttu-id="6dcd7-109">我們也建議 SOAP 錯誤只傳回用戶端應該知道的資訊，將資訊暴露的程度降至最低。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-109">It is also recommended that only that information a client must know is returned in a SOAP fault to minimize information disclosure.</span></span>  
  
-   <span data-ttu-id="6dcd7-110"><xref:System.ServiceModel.FaultContractAttribute.Action%2A> 屬性控制錯誤訊息的動作。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-110">The <xref:System.ServiceModel.FaultContractAttribute.Action%2A> property controls the action of the fault message.</span></span>  
  
-   <span data-ttu-id="6dcd7-111"><xref:System.ServiceModel.FaultContractAttribute.DetailType%2A> 屬性會取得在錯誤訊息中序列化的詳細物件型別。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-111">The <xref:System.ServiceModel.FaultContractAttribute.DetailType%2A> property gets the type of the detail object serialized in the fault message.</span></span>  
  
-   <span data-ttu-id="6dcd7-112"><xref:System.ServiceModel.FaultContractAttribute.Name%2A> 與 <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> 屬性分別控制了錯誤訊息的名稱與命名空間。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-112">The <xref:System.ServiceModel.FaultContractAttribute.Name%2A> and <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> properties control the name and namespace, respectively, of the fault message.</span></span>  
  
-   <span data-ttu-id="6dcd7-113"><xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> 表示錯誤訊息是否有指定的保護層級，若有，則由 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 屬性控制該保護層級。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-113">The <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> indicates whether the fault message has a protection level specified, and if so, the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> property controls that level of protection.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6dcd7-114">如果錯誤訊息含有敏感資訊或可能導致安全性問題的資訊，則強烈建議您設定 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-114">If a fault message carries information that is sensitive or can lead to security problems, it is strongly recommended that the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> property be set.</span></span>  
  
-   <span data-ttu-id="6dcd7-115">若您明確地將 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 設為 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> 或 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，則您必須使用繫結上的 <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> 屬性，來使用一個啟用安全性的繫結，否則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-115">If you set the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> explicitly to either <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType> or <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>, then you must use a binding with security enabled using the <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> property on the binding or an exception is thrown.</span></span>  
  
-   <span data-ttu-id="6dcd7-116">若您選擇了一個啟用安全性的繫結，卻沒有在合約中設定 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 屬性，則所有應用程式資料都會加密與簽章。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-116">If you select a binding that enables security and you do not set the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> property anywhere on the contract, all application data will be encrypted and signed.</span></span>  
  
-   <span data-ttu-id="6dcd7-117">若您選擇了尚未啟用安全性的繫結 (例如，根據預設，<xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> 的安全性是停用的)，又沒有明確設定 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A>，則所有應用程式資料都不會受到保護。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-117">If you select a binding that does not have security enabled (for example, the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> has security disabled by default), and the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> is not explicitly set, then none of the application data will be protected.</span></span>  
  
 <span data-ttu-id="6dcd7-118">對許多案例而言，將 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 設為 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> 對錯誤訊息而言就已足夠了。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-118">For many scenarios setting <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> for fault messages is sufficient.</span></span> <span data-ttu-id="6dcd7-119">如需詳細資訊，請參閱 <<c0> [ 了解保護層級](~/docs/framework/wcf/understanding-protection-level.md)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-119">For more details, see [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).</span></span>  
  
 <span data-ttu-id="6dcd7-120">若要從 <xref:System.ServiceModel.FaultContractAttribute> 所標記的作業傳回指定錯誤，那麼在作業期間發生 Managed 例外狀況時，請擲回一個 <xref:System.ServiceModel.FaultException%601> (其型別參數是可序列化的錯誤資訊)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-120">To return a specified fault from an operation marked with <xref:System.ServiceModel.FaultContractAttribute>, throw a <xref:System.ServiceModel.FaultException%601> (where the type parameter is the serializable error information) when the managed exception occurs during the operation.</span></span> <span data-ttu-id="6dcd7-121">WCF 用戶端應用程式會顯示為相同類型的 SOAP 錯誤時擲回用戶端實作，也就是當為<xref:System.ServiceModel.FaultException%601>（typeparameter 是可序列化的錯誤資訊）。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-121">WCF client applications surface the SOAP fault as the same type as was thrown in the client implementation -- that is, as a <xref:System.ServiceModel.FaultException%601> (where the typeparameter is the serializable error information).</span></span> <span data-ttu-id="6dcd7-122"><xref:System.ServiceModel.FaultContractAttribute> 只能用來指定雙向服務作業與非同步作業組的 SOAP 錯誤；單向作業不支援 SOAP 錯誤，因此也不支援 <xref:System.ServiceModel.FaultContractAttribute>。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-122">The <xref:System.ServiceModel.FaultContractAttribute> can be used only to specify SOAP faults for two-way service operations and for asynchronous operation pairs; one-way operations do not support SOAP faults and therefore do not support <xref:System.ServiceModel.FaultContractAttribute>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dcd7-123">您可使用任何可序列化型別來傳遞錯誤資訊。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-123">You can use any serializable type to convey error information.</span></span> <span data-ttu-id="6dcd7-124">在這個版本的 WCF 中的唯一限制是在指定類型<xref:System.ServiceModel.FaultContractAttribute>必須是可序列化的<xref:System.Runtime.Serialization.DataContractSerializer?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-124">The only restriction in this version of WCF is that types specified in a <xref:System.ServiceModel.FaultContractAttribute> must be serializable by the <xref:System.Runtime.Serialization.DataContractSerializer?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6dcd7-125">如需序列化支援<xref:System.Runtime.Serialization.DataContractSerializer>提供，請參閱 <<c2> [ 資料合約序列化程式](~/docs/framework/wcf/feature-details/data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-125">For the serialization support the <xref:System.Runtime.Serialization.DataContractSerializer> provides, see [Data Contract Serializer](~/docs/framework/wcf/feature-details/data-contract-serializer.md).</span></span>  
  
 <span data-ttu-id="6dcd7-126">例如，要指定用戶端可接受包含 <xref:System.Int32> 的 SOAP 錯誤，請將該型別參數置入您服務方法上的 <xref:System.ServiceModel.FaultContractAttribute>。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-126">For example, to specify that clients can expect a SOAP fault that contains an <xref:System.Int32>, place that type parameter in the <xref:System.ServiceModel.FaultContractAttribute> on your service method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dcd7-127">下列程式碼範例沒有設定 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A>、<xref:System.ServiceModel.FaultContractAttribute.Name%2A><xref:System.ServiceModel.FaultContractAttribute.Namespace%2A>或  屬性。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-127">The following code examples do not set the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A>, <xref:System.ServiceModel.FaultContractAttribute.Name%2A>, or <xref:System.ServiceModel.FaultContractAttribute.Namespace%2A> properties.</span></span>  
  
 [!code-csharp[C_FCA#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_fca/cs/fcademo.cs#1)]
 [!code-vb[C_FCA#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_fca/vb/fcademo.vb#1)]  
  
 <span data-ttu-id="6dcd7-128">接著，您的服務方法會擲回一個新的 <xref:System.ServiceModel.FaultException%601>，其型別參數是包含錯誤訊息的型別 (在前例中，便是 <xref:System.Int32>)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-128">Then, in your service method, throw a new <xref:System.ServiceModel.FaultException%601> where the type parameter is the type that contains the error information (in the above case, a <xref:System.Int32>).</span></span> <span data-ttu-id="6dcd7-129">例如: </span><span class="sxs-lookup"><span data-stu-id="6dcd7-129">For example:</span></span>  
  
 [!code-csharp[C_FCA#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_fca/cs/fcademo.cs#2)]
 [!code-vb[C_FCA#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_fca/vb/fcademo.vb#2)]  
  
 <span data-ttu-id="6dcd7-130">前述範例非常基本；幾乎所有資訊都可使用 <xref:System.Int32?displayProperty=nameWithType> 程式碼傳遞，所以這個詳細型別不是最有用的。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-130">The preceding example is very basic; almost any information can be passed using an <xref:System.Int32?displayProperty=nameWithType> code, so this detail type is not the most useful.</span></span> <span data-ttu-id="6dcd7-131">一般而言，WCF 應用程式會指定 SOAP 錯誤詳細類型特有的用戶端錯誤資訊需求。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-131">Typically, WCF applications specify SOAP faults with detail types specific to the error information requirements of the client.</span></span> <span data-ttu-id="6dcd7-132">如需更完整的範例，請參閱＜範例＞一節。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-132">For a more complete example, see the Example section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6dcd7-133">若您指定一個 <xref:System.ServiceModel.FaultException%601>，且型別參數為 <xref:System.String?displayProperty=nameWithType>，則此字串值會指派給用戶端應用程式中的 Detail 屬性；用戶端無法藉由呼叫 <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> 方法來擷取該字串。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-133">If you specify a <xref:System.ServiceModel.FaultException%601> where the type parameter is a <xref:System.String?displayProperty=nameWithType>, the string value is assigned to the Detail property in the client application; clients cannot retrieve that string by calling the <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6dcd7-134">若要在用戶端應用程式呼叫 <xref:System.Exception.ToString%2A?displayProperty=nameWithType> 時傳回字串值，請在該作業內擲回一個 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 例外狀況，並將字串傳遞給建構函式。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-134">To have the string value returned when the client application calls <xref:System.Exception.ToString%2A?displayProperty=nameWithType>, throw a <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> exception inside the operation and pass the string to the constructor.</span></span>  
  
 <span data-ttu-id="6dcd7-135">若要明確控制應用程式在擲回例外狀況或 <xref:System.ServiceModel.FaultException%601> 時的行為，請在 <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType>、<xref:System.ServiceModel.Description.IServiceBehavior?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.IContractBehavior?displayProperty=nameWithType> 實作 <xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> 介面，並將它指派給 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-135">To explicitly control the behavior of the application when an exception or <xref:System.ServiceModel.FaultException%601> is thrown, implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> interface on an <xref:System.ServiceModel.Description.IServiceBehavior?displayProperty=nameWithType>, <xref:System.ServiceModel.Description.IContractBehavior?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.IEndpointBehavior?displayProperty=nameWithType> and assign it to the <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6dcd7-136"><xref:System.ServiceModel.Dispatcher.IErrorHandler> 可讓您明確地控制產生的 SOAP 錯誤，以及是否要將它傳送回用戶端。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-136"><xref:System.ServiceModel.Dispatcher.IErrorHandler> enables you to explicitly control the SOAP fault that is generated and whether to send it back to the client.</span></span>  
  
 <span data-ttu-id="6dcd7-137">為了方便偵錯，設定<xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>要`true`程式碼，或者您可以使用<xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>應用程式組態檔中。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-137">To facilitate debugging, set the <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` in code or you can use the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> in an application configuration file.</span></span> <span data-ttu-id="6dcd7-138">啟用時，服務會自動將例外狀況資訊傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-138">When enabled, the service automatically returns exception information to the caller.</span></span> <span data-ttu-id="6dcd7-139">這些錯誤會以 <xref:System.ServiceModel.FaultException> 例外狀況的形式呈現給用戶端。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-139">These faults appear to the client as <xref:System.ServiceModel.FaultException> exceptions.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6dcd7-140">因為 managed 例外狀況可以顯露內部的應用程式的資訊，請設定<xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>或是<xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>到`true`可允許 WCF 用戶端取得有關內部服務作業例外狀況，包括個人資訊識別或其他機密資訊。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-140">Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.</span></span>  
>   
>  <span data-ttu-id="6dcd7-141">因此，若您只是暫時對服務應用程式進行偵錯，才建議把 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 設為 `true`。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-141">Therefore, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` is only recommended as a way of temporarily debugging a service application.</span></span> <span data-ttu-id="6dcd7-142">此外，若某個方法以這種方式傳回未處理的 Managed 例外狀況，則該方法的 WSDL 不會包含 <xref:System.ServiceModel.FaultException%601> 型別之 <xref:System.String> 的合約。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-142">In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <xref:System.ServiceModel.FaultException%601> of type <xref:System.String>.</span></span> <span data-ttu-id="6dcd7-143">用戶端必須預期未知 SOAP 錯誤的可能性 (傳回給 WCF 用戶端，做為<xref:System.ServiceModel.FaultException?displayProperty=nameWithType>物件) 以正確取得偵錯資訊。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-143">Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> objects) to obtain the debugging information properly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dcd7-144">下列程式碼範例將示範如何使用 <xref:System.ServiceModel.FaultContractAttribute> 來指定 `SampleMethod` 作業可以傳回 SOAP 錯誤，連同 `GreetingFault` 的詳細型別。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-144">The following code example shows the use of <xref:System.ServiceModel.FaultContractAttribute> to specify that the `SampleMethod` operation can return a SOAP fault with the detail type of `GreetingFault`.</span></span>  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 <span data-ttu-id="6dcd7-145">下列程式碼範例顯示的 WCF 用戶端`ISampleService`體驗做為此 SOAP 錯誤<xref:System.ServiceModel.FaultException%601>型別的`GreetingFault`。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-145">The following code example shows that WCF clients of `ISampleService` experience this SOAP fault as a <xref:System.ServiceModel.FaultException%601> of type `GreetingFault`.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FaultContractAttribute (Type detailType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type detailType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.FaultContractAttribute.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (detailType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FaultContractAttribute(Type ^ detailType);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.FaultContractAttribute : Type -&gt; System.ServiceModel.FaultContractAttribute" Usage="new System.ServiceModel.FaultContractAttribute detailType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="detailType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="detailType">
          <span data-ttu-id="6dcd7-146">包含呼叫者錯誤資訊的可序列化型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-146">The serializable type that contains error information for the caller.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6dcd7-147">初始化 <see cref="T:System.ServiceModel.FaultContractAttribute" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-147">Initializes a new instance of the <see cref="T:System.ServiceModel.FaultContractAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dcd7-148">此建構函式的典型執行方式，是將該屬性套用至服務方法，並指定一個型別當作該屬性中的引數。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-148">The constructor is typically executed by applying the attribute to a service method and specifying a type as the argument in the attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6dcd7-149">下列程式碼範例將示範如何使用 <xref:System.ServiceModel.FaultContractAttribute> 來指定 `SampleMethod` 作業可以傳回 SOAP 錯誤，連同 `GreetingFault` 的詳細型別。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-149">The following code example shows the use of <xref:System.ServiceModel.FaultContractAttribute> to specify that the `SampleMethod` operation can return a SOAP fault with the detail type of `GreetingFault`.</span></span>  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6dcd7-150">
            <paramref name="detailType" /> 引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-150">The <paramref name="detailType" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6dcd7-151">取得或設定 SOAP 錯誤訊息的動作，此訊息指定為作業合約的一部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-151">Gets or sets the action of the SOAP fault message that is specified as part of the operation contract.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6dcd7-152">SOAP 錯誤訊息的動作值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-152">The value of the action for the SOAP fault message.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dcd7-153">用來控制 SOAP 錯誤訊息的動作。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-153">Use to control the action of the SOAP fault message.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetailType">
      <MemberSignature Language="C#" Value="public Type DetailType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DetailType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.DetailType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DetailType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ DetailType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DetailType : Type" Usage="System.ServiceModel.FaultContractAttribute.DetailType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6dcd7-154">取得包含錯誤資訊的可序列化物件型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-154">Gets the type of a serializable object that contains error information.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6dcd7-155">表示可序列化錯誤類別的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-155">The type that represents the serializable error class.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6dcd7-156">下列程式碼範例將示範如何使用 <xref:System.ServiceModel.FaultContractAttribute> 來指定 `SampleMethod` 作業可以傳回 SOAP 錯誤，連同 `GreetingFault` 的詳細型別。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-156">The following code example shows the use of <xref:System.ServiceModel.FaultContractAttribute> to specify that the `SampleMethod` operation can return a SOAP fault with the detail type of `GreetingFault`.</span></span>  
  
 [!code-csharp[FaultContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#1)]
 [!code-vb[FaultContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.FaultContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6dcd7-157">取得指出 SOAP 錯誤訊息是否已指派保護層級的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-157">Gets a value that indicates whether the SOAP fault message has a protection level assigned.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6dcd7-158">如果錯誤訊息有保護層級則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-158">
              <see langword="true" /> if the fault message has a protection level; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="6dcd7-159">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-159">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dcd7-160">使用 <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> 屬性指定 SOAP 錯誤訊息是否要加密、簽章，或兩者都進行。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-160">Use the <xref:System.ServiceModel.FaultContractAttribute.HasProtectionLevel%2A> property to specify whether the SOAP fault message must be encrypted, signed, or both.</span></span> <span data-ttu-id="6dcd7-161">如需詳細資訊，請參閱 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-161">See the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> property for details.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6dcd7-162">取得或設定 Web 服務描述語言 (WSDL) 中的錯誤訊息名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-162">Gets or sets the name of the fault message in Web Services Description Language (WSDL).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6dcd7-163">錯誤訊息名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-163">The fault message name.</span>
          </span>
          <span data-ttu-id="6dcd7-164">預設是用來做為錯誤詳細資料之型別的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-164">The default is the name of the type used as the fault detail.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.FaultContractAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6dcd7-165">取得或設定 SOAP 錯誤的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-165">Gets or sets the namespace of the SOAP fault.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6dcd7-166">SOAP 錯誤的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-166">The namespace of the SOAP fault.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.FaultContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.FaultContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6dcd7-167">指定 SOAP 錯誤從繫結要求的保護層級。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-167">Specifies the level of protection the SOAP fault requires from the binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6dcd7-168">其中一個 <see cref="T:System.Net.Security.ProtectionLevel" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-168">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values.</span>
          </span>
          <span data-ttu-id="6dcd7-169">預設值為 <see cref="F:System.Net.Security.ProtectionLevel.None" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="6dcd7-169">The default is <see cref="F:System.Net.Security.ProtectionLevel.None" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6dcd7-170">您可以使用 <xref:System.ServiceModel.Description.FaultDescription.ProtectionLevel%2A?displayProperty=nameWithType> 屬性來指定傳送 SOAP 錯誤時，繫結必須加密、簽署，或兩者都進行的程度。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-170">Use the <xref:System.ServiceModel.Description.FaultDescription.ProtectionLevel%2A?displayProperty=nameWithType> property to specify the degree to which the binding must encrypt, sign, or both when sending the SOAP fault.</span></span> <span data-ttu-id="6dcd7-171">強烈建議在合約上，就明確指定作業錯誤的安全保護層級需求。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-171">It is strongly recommended that an operation's fault explicitly decide the security protection level requirements on the contract.</span></span> <span data-ttu-id="6dcd7-172">預設保護層級為 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>，表示您定義的 SOAP 錯誤訊息不需加密或數位簽章 (雖然您的繫結設定或許可以提供此支援)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-172">The default protection level is <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>, meaning that the SOAP fault message you are defining does not require encryption or a digital signature (although your binding may provide this support if it is configured to do so).</span></span> <span data-ttu-id="6dcd7-173">如果錯誤訊息含有敏感資訊或可能導致安全性問題的資訊，則強烈建議將 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> 屬性設為 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-173">If a fault message carries information that is sensitive or can lead to security problems, it is strongly recommended that the <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A> property be set to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6dcd7-174">如需有關安全性問題的詳細資訊，請參閱[了解保護層級](~/docs/framework/wcf/understanding-protection-level.md)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-174">For more about security issues, see [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).</span></span>  
  
 <span data-ttu-id="6dcd7-175">執行階段的保護行為，是各個保護層級屬性的組合，這些屬性具有階層式結構。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-175">The protection behavior at runtime is the combination of the protection-level properties that have a hierarchical structure.</span></span> <span data-ttu-id="6dcd7-176">除非針對較窄的範圍明確設定不同的值，否則，設定最外層的值會建立所有較窄範圍的預設值。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-176">Setting the outermost value establishes the default setting for all narrower scopes unless a different value for a narrower scope is explicitly set.</span></span> <span data-ttu-id="6dcd7-177">在此情況下，外部值仍為所有較窄範圍的預設值 (特別設定的範圍除外)。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-177">In this case, the outer value remains the default for all narrower scopes with the exception of that specifically set.</span></span>  
  
 <span data-ttu-id="6dcd7-178">例如，如果 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 設定為 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>，而且沒有其他更窄的範圍具有保護層級設定，則作業合約中的所有訊息 (包括錯誤訊息) 都會加密並簽署。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-178">For example, if <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> is set to <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> and no other narrower scopes have protection level settings, all messages in an operation contract are encrypted and signed, including fault messages.</span></span> <span data-ttu-id="6dcd7-179">但是，如果這些作業之一已將 <xref:System.ServiceModel.OperationContractAttribute> 設定為 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>，則會簽署該作業的訊息，但是合約中的其他所有訊息 (包括錯誤訊息) 都會經過加密並簽署。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-179">If, however, one of those operations has the <xref:System.ServiceModel.OperationContractAttribute> set to <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, then the messages for that operation are signed but all other messages in the contract are encrypted and signed, including fault messages.</span></span>  
  
 <span data-ttu-id="6dcd7-180">設定這些值的範圍如下：</span><span class="sxs-lookup"><span data-stu-id="6dcd7-180">The scopes at which these values are set are:</span></span>  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="6dcd7-181"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 的 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-181">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6dcd7-182"><xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 的 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-182">The <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> property on <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6dcd7-183">當合約上未明確指定保護層級，而且基礎繫結可支援安全性 (不論是在傳輸層級或訊息層級) 時，整個合約的有效保護層級會是 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-183">When there is no protection level explicitly specified on the contract and the underlying binding supports security (whether at the transport or message level), the effective protection level for the whole contract is <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6dcd7-184">如果繫結不支援安全性 (例如，<xref:System.ServiceModel.BasicHttpBinding>)，整個合約的有效 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> 為 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-184">If the binding does not support security (such as <xref:System.ServiceModel.BasicHttpBinding>), the effective <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> is <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> for the whole contract.</span></span> <span data-ttu-id="6dcd7-185">結果便是根據端點繫結的不同，用戶端可以要求不同的訊息或傳輸層級的安全性保護，即使當合約指定 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> 時亦然。</span><span class="sxs-lookup"><span data-stu-id="6dcd7-185">The result is that depending upon the endpoint binding, clients can require different message or transport level security protection even when the contract specifies <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>