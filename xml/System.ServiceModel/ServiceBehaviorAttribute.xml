<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="50331392363256e74f896d27155738cc69fd5c32" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53294794" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>指定服務合約實作的內部執行行為。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性套用至服務實作，即可指定整個服務的執行行為。 (如果要指定方法層級的執行行為，請使用 <xref:System.ServiceModel.OperationBehaviorAttribute> 屬性)。這個屬性只能套用至服務實作。 如需實用範例，請參閱[服務：行為範例](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90))。  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性是 Windows Communication Foundation (WCF) 程式設計模型功能，可讓開發人員必須另外實作的常見功能。 如需有關這些和其他行為的詳細資訊，請參閱 <<c0> [ 指定服務執行階段行為](~/docs/framework/wcf/specifying-service-run-time-behavior.md)。 如需有關基礎執行階段屬性的下列屬性設定中，該部分請參閱[擴充 ServiceHost 與服務模型層](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md)。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> 屬性會指定發送器系統用來找出負責處理要求之端點的篩選條件類型。  
  
-   當通道關閉，而且服務已完成處理任何剩餘的訊息時，<xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> 屬性便會自動關閉工作階段。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 屬性會控制內部執行緒模型，以便支援可重新進入 (Reentrant) 或多執行緒服務的物件。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> 屬性 (Property) 是用來宣告在組態檔中 `name` 項目之 `<service>` 屬性 (Attribute) 中所使用的名稱。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 屬性會讓執行階段略過不是處理訊息時所需要的額外序列化資訊。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 屬性會指定服務中未處理的例外狀況是否會當做 SOAP 錯誤傳回。 這種設定僅供偵錯用途。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 屬性會指定是否要在與用戶端交換期間回收服務和其服務物件，以及在何時回收。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> 屬性會限制物件圖形中已序列化項目的數目。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> 和 <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> 屬性會控制服務項目之 WSDL 運算式的名稱和命名空間。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 屬性會指定是否會在異動完成時回收服務物件。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> 屬性會指定是否要在工作階段關閉時完成未完成的異動。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> 屬性會指定合約支援的交易隔離等級。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> 屬性會指定異動必須在該段期間完成、否則就會中止的時間間隔。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> 屬性會指出是否要搭配使用者介面執行緒，自動同步處理傳入的方法呼叫。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> 屬性會通知系統是否要確認已實際瞭解標示為 `MustUnderstand` 的 SOAP 標頭。  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 屬性也可以使用應用程式組態檔來設定。 如需詳細資訊，請參閱 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>。  
  
   
  
## Examples  
 下列程式碼範例會示範 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性。 `BehaviorService` 類別會使用 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性指出：  
  
-   此服務物件會在交易完成時回收。  
  
-   每個工作階段都有一個服務物件。  
  
-   該服務為單一執行緒服務，而且不支援可重新進入的呼叫。  
  
 此外，位於作業層級的 <xref:System.ServiceModel.OperationBehaviorAttribute> 值表示 `TxWork` 方法會自動登記在流動交易中或建立新交易來執行工作，並且表示如果沒有發生未處理的例外狀況，則會自動認可這項交易。  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 基礎繫結必須支援流動交易，才能讓下列程式碼範例正確執行。 例如，若要使用 <xref:System.ServiceModel.WSHttpBinding> 支援流動的交易，請透過程式碼或應用程式組態檔，將 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 屬性設定為 `true`。 下列程式碼範例會顯示先前範例的組態檔。  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">服務：行為範例</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> 的預設值為：  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> 已設為 <xref:System.ServiceModel.AddressFilterMode.Exact>。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> 屬性為 `true`。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 已設為 <xref:System.ServiceModel.ConcurrencyMode.Single>。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> 屬性是不含組件資訊之型別的命名空間限定名稱。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 屬性為 `false`。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> 屬性是設定為 64KB。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> 屬性是不含命名空間或組件資訊之服務型別的名稱。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A>屬性是 「http://tempuri.org"。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 屬性為 `true`。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 為 `false`。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> 為 `true`。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> 屬性為 `false`。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> 屬性為 <xref:System.Transactions.IsolationLevel.Unspecified>。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> 屬性設定為 <xref:System.TimeSpan.Zero>。  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> 屬性為 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.ServiceModel.AddressFilterMode" />，此物件會由發送器用來將傳入訊息傳送至正確的端點。</summary>
        <value><see cref="T:System.ServiceModel.AddressFilterMode" /> 物件，此物件會由發送器用來將傳入訊息傳送至正確的端點。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">該值不是其中一個 <see cref="T:System.ServiceModel.AddressFilterMode" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定是否要在用戶端關閉輸出工作階段時，自動關閉工作階段。</summary>
        <value>如果服務會在用戶端關閉輸出工作階段時自動關閉工作階段，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，當用戶端關閉輸出工作階段，且服務已完成處理任何剩餘的訊息時，伺服器便會關閉工作階段。 將 <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> 設定為 `false`，以防止伺服器自動關閉工作階段，並啟用工作階段存留期的自訂控制。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定服務是支援單一執行緒、多重執行緒或可重新進入的呼叫。</summary>
        <value>其中一個 <see cref="T:System.ServiceModel.ConcurrencyMode" /> 值，預設值為 <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會指出服務的執行個體是可以處理單一執行緒或同時執行的多重執行緒，以及在遇到單一執行緒時，是否會支援重新進入。  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 屬性會與其他設定互動。 例如，如果 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 值是設定為 <xref:System.ServiceModel.InstanceContextMode.Single>，這時除非您也將 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 值設定為 <xref:System.ServiceModel.ConcurrencyMode.Multiple>，否則您的服務一次只能處理一個訊息。 這個屬性也會產生與 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 屬性一起使用的行為。 如需詳細資訊，請參閱 <<c0> [ 工作階段，Instancing，and Concurrency](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)。  
  
 將 <xref:System.ServiceModel.ConcurrencyMode> 設定為 <xref:System.ServiceModel.ConcurrencyMode.Single>，便會指示系統要將服務的執行個體限制為一次執行一個執行緒，這樣您就不需要處理執行緒問題。 值為 <xref:System.ServiceModel.ConcurrencyMode.Multiple> 時，表示服務物件可在任何時間由多個執行緒執行。 在這種情況下，您必須確保執行緒安全。  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 也會限制存取單一執行緒一次;當作業正在處理，沒有其他訊息進入作業。 如果有另一個服務呼叫在作業期間離開，這個目前訊息便會失去作業鎖定，並使得該作業可任意處理其他訊息。 當服務呼叫傳回時，鎖定便會重新建立，而原始訊息可以繼續處理其總結，或是繼續處理直到發生作業的另一個呼叫為止。  
  
> [!IMPORTANT]
>  即使<xref:System.ServiceModel.ConcurrencyMode.Single>執行個體限制為一次執行一個執行緒的服務，您也必須設定<xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A>為 1，以確保沒有順序的訊息。  
>   
>  此外，您必須負責以保持物件狀態在對外呼叫之前一致，而且您必須確認對外呼叫之後，作業本機資料有效。 請注意，只有透過 WCF 通道呼叫另一個服務才能解除服務執行個體鎖定。 此時，被呼叫的服務可透過回呼重新進入第一個服務。 如果第一個服務無法重新進入，這時的呼叫順序會造成死結。 如需詳細資訊，請參閱 <xref:System.ServiceModel.ConcurrencyMode>。  
  
 在處理作業處理任何傳出呼叫期間，非作業的本機資料可以進行修改  (本機狀態資料保證在原始訊息繼續處理時仍屬有效)。因此，在傳出呼叫之前，您必須確保非本機資料對其他傳入呼叫是有效的，而且會在傳出呼叫傳回時，重新驗證非本機資料。  
  
 下列虛擬程式碼將示範順利重新進入支援的必要模式。  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 當 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 為 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 時，對傳出呼叫使用 Begin/End 非同步呼叫模式會觸發例外狀況。 非同步傳出呼叫需要 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 為 <xref:System.ServiceModel.ConcurrencyMode.Multiple> 的作業，而在該情況下，您必須處理同步處理問題。  
  
 一般來說，如果違反其並行模式的執行個體有訊息到達，該訊息會等到執行個體可供使用為止，或等到它逾時為止。  
  
 此外，如果 <xref:System.ServiceModel.ConcurrencyMode> 設定為 <xref:System.ServiceModel.ConcurrencyMode.Single>，且可重新進入的呼叫在等待釋放執行個體時遭到封鎖，系統就會偵測到此死結並擲回例外狀況。  
  
> [!NOTE]
>  當 <xref:System.InvalidOperationException> 屬性設定為 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 時，如果 `true` 是 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>，便會在執行階段擲回 <xref:System.ServiceModel.ConcurrencyMode.Single>。  
  
 請注意，如果有作業的 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 設定為 true，且您將 `false` 設定為 <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>，則您必須將 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 明確設定為 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>。 否則，便會擲回驗證例外狀況，因為 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 的預設值為 `true`。  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 和其他屬性之間的互動可以改變執行階段行為。 這些互動的完整說明，請參閱[工作階段，Instancing，and Concurrency](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)。  
  
   
  
## Examples  
 下列程式碼範例將示範使用 <xref:System.ServiceModel.ConcurrencyMode.Single>、<xref:System.ServiceModel.ConcurrencyMode.Reentrant> 和 <xref:System.ServiceModel.ConcurrencyMode.Multiple> 之間的差異。 此範例不會編譯而不需要實際的實作，其項目，後面，但並未示範執行緒保證，可讓 Windows Communication Foundation (WCF)，這表示您的作業程式碼的類型。  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">該值不是其中一個 <see cref="T:System.ServiceModel.ConcurrencyMode" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在應用程式組態檔中尋找服務項目的值。</summary>
        <value>要在組態檔中尋找的值。 預設值是不含組件資訊的完整型別名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在組態檔中，使用這個值來指定特定的服務。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">值為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值為空字串。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會表示是否確保已排序的服務分派。</summary>
        <value>如果確保已排序的服務分派，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取會實作服務、並以該實作結果做為服務之單一執行個體的物件，如果沒有單一執行個體，則為 <see langword="null" />。</summary>
        <returns>服務的實作。 預設值是 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非 `null` 值會提供服務執行個體，而已定址到該服務的所有訊息都會分派到該執行個體。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否要將未知的序列化資料傳送到網路上。</summary>
        <value>如果絕不傳送未知的序列化資料，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果型別實作<xref:System.Runtime.Serialization.IExtensibleDataObject>介面，它會儲存它並不知道任何來自網路時還原序列化為該類型的額外資料。 例如，如果型別 `Person` 具有成員 `FirstName` 和 `LastName`，這時若有個 `PhoneNumber` 的項目進入，該項目便會被儲存起來。 當稍後序列化此型別時，`PhoneNumber` 將會重新發出。 問題是，結構描述`Person`匯出的服務只能有`FirstName`和`LastName`，因此 Windows Communication Foundation (WCF) 會產生結構描述無效的執行個體 ！ 如果嚴格的結構描述相容性很重要，您可以將 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 設定為 `true`，以便關閉這個重新發出的行為。  
  
 無論<xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A>設定，WCF 永遠會處理已知的資料 （傳入及傳出） 而且在額外資料進入時，不會擲回例外狀況。 您也可以設定此屬性使用[ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md)應用程式組態檔中的項目。  
  
   
  
## Examples  
 下列範例會示範 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 的使用和 <xref:System.Runtime.Serialization.IExtensibleDataObject> 的實作。 在這個範例中，藉由將 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 設定為 `false`，用戶端便會將所知道的額外資料再傳回用戶端。  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定一般未處理的執行例外狀況 (要轉換為型別 <see cref="T:System.ServiceModel.FaultException`1" /> 的 <see cref="T:System.ServiceModel.ExceptionDetail" />)，並傳送為錯誤訊息。 請只在開發期間將這個項目設定為 <see langword="true" />，以針對服務進行疑難排解。</summary>
        <value>如果未處理的例外狀況要當做 SOAP 錯誤傳回，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 設定為 `true`，即可讓例外狀況資訊流至用戶端，以供偵錯之用。 這個屬性需要支援要求-回應或雙工訊息的繫結。  
  
 在所有 Managed 應用程式中，處理錯誤由 <xref:System.Exception> 物件表示。 在 WCF 應用程式等 SOAP 型的應用程式，實作服務作業的方法進行通訊使用 SOAP 錯誤訊息的錯誤資訊。 因為 WCF 應用程式執行這兩種錯誤系統下，需要傳送給用戶端的任何 managed 例外狀況資訊必須轉換成 SOAP 錯誤的例外狀況。 如需詳細資訊，請參閱 <<c0> [ 指定及處理合約和服務中的錯誤](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)。  
  
 在開發期間，您可能會希望您的服務同時將其他例外狀況傳回用戶端，以進行偵錯。 這是開發階段專用的功能，因此不可以用在已部署的服務中。  
  
 若要協助偵錯開發，將<xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>至`true`程式碼，或使用應用程式組態檔。  
  
 啟用時，服務會自動將較安全的例外狀況資訊傳回給呼叫者。 這些錯誤會以型別 <xref:System.ServiceModel.FaultException%601> 的 <xref:System.ServiceModel.ExceptionDetail> 物件呈現給用戶端。  
  
> [!IMPORTANT]
>  設定<xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>至`true`可讓用戶端取得有關內部服務方法例外狀況，則只建議這種暫時偵錯服務應用程式。 此外，若某個方法以這種方式傳回未處理的 Managed 例外狀況，則該方法的 WSDL 不會包含 <xref:System.ServiceModel.FaultException%601> 型別之 <xref:System.ServiceModel.ExceptionDetail> 的合約。 用戶端必須預期未知 SOAP 錯誤的可能性，才能正確取得偵錯資訊。  
  
 將此屬性設定為`true`也可以使用應用程式組態檔和[ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md)項目，如下列程式碼範例所示。  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 下列程式碼範例會示範 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性。 `BehaviorService` 類別會使用 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性指出：  
  
-   實作方法會在 UI 執行緒上叫用。  
  
-   每個工作階段都有一個服務物件。  
  
-   該服務為單一執行緒服務，而且不支援可重新進入的呼叫。  
  
 此外，位於作業層級的 <xref:System.ServiceModel.OperationBehaviorAttribute> 值表示 `TxWork` 方法會自動登記在流動交易中或建立新交易來執行工作，並且表示如果沒有發生未處理的例外狀況，則會自動認可這項交易。  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 基礎繫結必須支援流動交易，才能讓下列程式碼範例正確執行。 例如，若要使用 <xref:System.ServiceModel.WSHttpBinding> 支援流動的交易，請透過程式碼或應用程式組態檔，將 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 屬性設定為 `true`。 下列程式碼範例會顯示先前範例的組態檔。  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指出何時建立新的服務物件。</summary>
        <value>其中一個 <see cref="T:System.ServiceModel.InstanceContextMode" /> 值；預設值為 <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.InstanceContextMode> 屬性，即可指定建立新服務物件的時機。 由於服務物件不是直接連接至通訊通道，因此服務物件的存留期與用戶端和服務應用程式之間的通道的存留期無關。 預設值 <xref:System.ServiceModel.InstanceContextMode.PerSession>，會在用戶端和服務應用程式之間建立新通訊工作階段時，指示服務應用程式建立新的服務物件。 在相同工作階段中的後續呼叫會由相同物件處理。  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> 表示每個服務物件都會處理來自一個用戶端通道的要求。  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 屬性會與其他設定互動。 例如，如果 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 值是設定為 <xref:System.ServiceModel.InstanceContextMode.Single>，這時除非您也將 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 值設定為 <xref:System.ServiceModel.ConcurrencyMode.Multiple>，否則您的服務一次只能處理一個訊息。 這個屬性也會產生與 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 屬性一起使用的行為。 如需詳細資訊，請參閱 <<c0> [ 工作階段，Instancing，and Concurrency](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)。  
  
 對於單一存留期行為 (例如，如果主應用程式呼叫 <xref:System.ServiceModel.ServiceHost.%23ctor%2A> 建構函式，並傳遞物件做為服務使用)，服務類別必須將 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 設定為 `Single`，否則會在執行階段擲回例外狀況。  
  
   
  
## Examples  
 下列程式碼範例會示範 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性。 `BehaviorService` 類別會使用 <xref:System.ServiceModel.ServiceBehaviorAttribute> 屬性指出：  
  
-   實作方法會在 UI 執行緒上叫用。  
  
-   每個工作階段都有一個服務物件。  
  
-   該服務為單一執行緒服務，而且不支援可重新進入的呼叫。  
  
 此外，位於作業層級的 <xref:System.ServiceModel.OperationBehaviorAttribute> 值表示 `TxWork` 方法會自動登記在流動交易中或建立新交易來執行工作，並且表示如果沒有發生未處理的例外狀況，則會自動認可這項交易。  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 基礎繫結必須支援流動交易，才能讓下列程式碼範例正確執行。 例如，若要使用 <xref:System.ServiceModel.WSHttpBinding> 支援流動的交易，請透過程式碼或應用程式組態檔，將 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 屬性設定為 `true`。 下列程式碼範例會顯示先前範例的組態檔。  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">該值不是其中一個 <see cref="T:System.ServiceModel.InstanceContextMode" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定已序列化之物件中允許的項目數目上限。</summary>
        <value>物件中允許的項目數目上限。 預設值為 65536 個位元組 (64KB)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> 屬性，即可設定物件圖形中已序列化項目的數目限制。 您也可以設定此屬性使用[ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md)應用程式組態檔中的項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Web 服務描述語言 (WSDL) 中服務項目中的名稱屬性的值。</summary>
        <value>在匯出時 <see langword="&lt;wsdl:service&gt;" /> 項目中的名稱屬性值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Web 服務描述語言 (WSDL) 中服務的目標命名空間值。</summary>
        <value><see langword="targetNamespace" /> 項目的 <see langword="&lt;wsdl:definitions&gt;" /> 屬性值，其中包含 <see langword="&lt;wsdl:service&gt;" /> 項目。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否在目前交易完成時釋放服務物件。</summary>
        <value>如果要釋放服務物件，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，如果有作業的 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 設定為 true，且您將 `false` 設定為 <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>，則您必須將 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 明確設定為 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>。 否則，便會擲回驗證例外狀況，因為 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 的預設值為 `true`。  
  
 此外，您務必要瞭解，如果服務是藉由將服務物件傳遞至 <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> 建構函式所建立，這個屬性的值就會以它是 `false` 的方式進行處理。  
  
   
  
## Examples  
 下列程式碼範例會將交易隔離等級設定為 <xref:System.Transactions.IsolationLevel.ReadCommitted>、停用並行交易的支援、需要來自作業呼叫的流動交易，並且會自動認可服務上的交易 (若無未處理的例外狀況發生)。  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 基礎繫結必須支援流動交易，才能讓下列程式碼範例正確執行。 例如，若要使用 <xref:System.ServiceModel.WSHttpBinding> 支援流動的交易，請透過程式碼或應用程式組態檔，將 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 屬性設定為 `true`。 下列程式碼範例會顯示先前範例的組態檔。  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">服務的單一執行個體。</param>
        <summary>指定會實作服務、並以該實作結果做為服務之單一執行個體的物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個值會提供服務執行個體，而已定址到該服務的所有訊息都會分派到該執行個體。  
  
 如果 <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> 是設定為非 `null` 值，則 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 必須設定為 <xref:System.ServiceModel.InstanceContextMode.Single>，否則便會擲回 <xref:System.InvalidOperationException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定的值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> 屬性是否已變更為非預設值且應該序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> 屬性是否已變更為非預設值且應該序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> 屬性是否已變更為非預設值且應該序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> 屬性是否已變更為非預設值且應該序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> 屬性是否已變更為非預設值且應該序列化。</summary>
        <returns>如果應序列化 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> 屬性值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">服務描述。</param>
        <param name="serviceHostBase">服務主機。</param>
        <param name="endpoints">服務端點。</param>
        <param name="parameters">繫結在支援該行為時所需要的資料物件。</param>
        <summary>將自訂資料物件傳遞至支援此行為屬性的繫結。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">服務描述。</param>
        <param name="serviceHostBase">服務主機。</param>
        <summary>將服務執行階段自訂成支援此行為屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">服務描述。</param>
        <param name="serviceHostBase">服務主機。</param>
        <summary>確認服務描述和服務主機可以支援此行為。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定當目前工作階段在沒有錯誤的情況下關閉時，是否完成擱置的交易。</summary>
        <value>若擱置的交易要在目前工作階段關閉且無錯誤的情況下完成，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定在服務內建立之新異動、以及來自用戶端之傳入異動的異動隔離等級。</summary>
        <value>指定異動隔離等級的 <see cref="T:System.Transactions.IsolationLevel" /> 值。 預設為 <see cref="F:System.Transactions.IsolationLevel.Unspecified" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異動所執行的隔離等級會決定其他異動變更時如何處理資料，並且決定異動必須保持鎖定的時間長度，以免受到這些變更影響。 例如，預設值 <xref:System.Transactions.IsolationLevel.Unspecified> 會指定在交易完成之前，不會發生任何更新或插入。  
  
 這個屬性也可以用於限制來自用戶端之傳入交易的隔離等級。  
  
   
  
## Examples  
 下列程式碼範例會將交易隔離等級設定為 <xref:System.Transactions.IsolationLevel.ReadCommitted>，且此範例不支援同時交易、需要來自方法呼叫的流動交易，並且會在沒有發生未處理的例外狀況自動認可該交易。  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 基礎繫結必須支援流動交易，才能讓下列程式碼範例正確執行。 例如，若要使用 <xref:System.ServiceModel.WSHttpBinding> 支援流動的交易，請透過程式碼或應用程式組態檔，將 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 屬性設定為 `true`。 下列程式碼範例會顯示先前範例的組態檔。  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">該值不是其中一個 <see cref="T:System.Transactions.IsolationLevel" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定交易必須完成的期間。</summary>
        <value><see cref="T:System.TimeSpan" /> 物件，代表異動必須在期間完成、否則會自動中止的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個值會設定 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType> 屬性。 您也可以設定此屬性使用[ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md)應用程式組態檔中的項目。  
  
   
  
## Examples  
 下列組態檔會指定三分鐘的異動逾時期間。  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">值為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">這個值小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.TimeSpan.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否使用目前的同步處理內容來選擇執行的執行緒。</summary>
        <value>如果所有對服務的呼叫都必須在 <see cref="T:System.Threading.SynchronizationContext" /> 指定的執行緒上執行，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性，即可提供部分應用程式所需要的使用者介面執行緒相似性。 例如，Windows Forms 應用程式可能會註冊為單一服務物件。 在這種情況中，所有對服務的呼叫都必須在 Windows Forms 執行緒上執行。 在預設的情況中，<xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> 是設定為 `true`，並將對服務的所有呼叫同步處理成都在 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> 所擷取的執行緒上執行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定系統或應用程式是否會強制執行 SOAP <see langword="MustUnderstand" /> 標頭處理。</summary>
        <value>如果系統要執行 SOAP 標頭 <see langword="true" /> 處理，則為 <see langword="MustUnderstand" />，否則為 <see langword="false" />，表示應用程式會執行這項處理。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> 屬性，即可關閉對抵達之訊息標頭的強制驗證。 在正常的執行過程中，訊息標頭會與 <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> 屬性進行比較，以確認服務已明確地處理抵達的標頭。 將此屬性設定為 `false`，即可停用這項檢查。 如果是設定為 `false`，應用程式就必須檢查標示為 MustUnderstand="true" 的標頭，並在無法瞭解其中一或多個標頭時傳回錯誤。 當應用程式應該接受任何傳入的 SOAP 訊息 (例如，使用具型別或不具型別的訊息時) 以及執行自訂標頭處理時，這種設定會十分有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>