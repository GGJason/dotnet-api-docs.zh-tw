<Type Name="OperationContractAttribute" FullName="System.ServiceModel.OperationContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb91cb0063fb387065cad10de28946bb51ba1001" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48768922" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OperationContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type OperationContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示某個方法定義了一個作業，此作業是 Windows Communication Foundation (WCF) 應用程式中服務合約的一部分。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將 <xref:System.ServiceModel.OperationContractAttribute> 套用至方法，以表示該方法實作了某個服務作業，做為服務合約的一部分 (由 <xref:System.ServiceModel.ServiceContractAttribute> 屬性指定)。  
  
 使用 <xref:System.ServiceModel.OperationContractAttribute> 屬性控制作業結構，以及中繼資料表示的值︰  
  
-   <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 屬性指定唯一識別此作業的動作。 WCF 會分派要求訊息，以根據其動作的方法。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 屬性表示該作業使用 Begin/End 方法組實作，或可使用 Begin/End 方法組以非同步方式呼叫該作業。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> 屬性表示是否已明確設定 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 屬性。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 屬性表示作業僅由一個輸入訊息組成。 作業沒有相關的輸出訊息。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 屬性指定此作業是否可成為工作階段中的初始作業。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>屬性會指定 WCF 是否會嘗試終止目前的工作階段在作業完成之後。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 屬性指定作業在執行階段所需的訊息層級安全性。  
  
-   <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 屬性指定該作業的回覆訊息動作。  
  
 <xref:System.ServiceModel.OperationContractAttribute> 屬性宣告某個方法是服務合約中的作業。 只有含 <xref:System.ServiceModel.OperationContractAttribute> 屬性的方法才會公開成為服務作業。 若服務合約中，沒有任何方法以 <xref:System.ServiceModel.OperationContractAttribute> 標記，則不會公開任何作業。  
  
 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>屬性表示一組`Begin` \< *methodName*> 並`End` \< *methodName*> 方法形成單一作業以非同步方式實作 （不論是在用戶端或服務）。 服務是否能採用非同步方式實作作業，是服務實作的細節，不會公開在中繼資料上 (如 Web 服務描述語言 (WSDL))。  
  
 同樣地，用戶端可選擇以非同步方式叫用作業，不論服務方法的實作方式為何。 若服務方法的執行需要一些時間，但必須直接傳回資訊給用戶端，則建議用戶端以非同步方式呼叫服務作業。 如需詳細資訊，請參閱 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>。  
  
 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 屬性表示某個方法不會傳回任何值，包括空的基礎回應訊息。 這種類型的方法對通知或事件型通訊很有用。 這種方法不能傳回回覆訊息，所以方法宣告必須傳回 `void`。  
  
> [!IMPORTANT]
>  在以程式設計方式擷取這個屬性中的資訊存放區時，使用<xref:System.ServiceModel.Description.ContractDescription>類別而不是反映。  
  
> [!NOTE]
>  如果 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 屬性設為 `false` (預設值)，那麼就算該方法傳回 `void`，在基礎訊息層級一樣是雙向方法。 在此情況下，基礎結構會建立並傳送空白訊息，向呼叫者指出方法已傳回  此方式可讓應用程式與基礎結構將錯誤資訊 (例如 SOAP 錯誤) 傳回給用戶端。 將 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 設為 `true` 是避免建立與分派回覆訊息的唯一方法。 如需詳細資訊，請參閱 <<c0> [ 單向服務](~/docs/framework/wcf/feature-details/one-way-services.md)。  
  
 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 與 <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 屬性不只可用來修改 SOAP 訊息的預設動作，亦可建立處理常式來處理無法辨認的訊息，或停用直接訊息程式設計的加入動作。 使用 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 屬性，避免用戶端在呼叫其他作業之前，先行呼叫某個特定服務作業。 使用<xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>屬性，讓 WCF 用戶端呼叫某個特定服務作業之後關閉通道。 如需詳細資訊，請參閱 <<c0> [ 使用工作階段的](~/docs/framework/wcf/using-sessions.md)。  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 屬性可讓您在作業合約上，指定作業訊息是否簽署、加密，或同時採用簽署與加密。 若繫結無法提供合約所需的安全性層級，在執行階段就會擲回例外狀況。 如需詳細資訊，請參閱 <<c0> <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 並[了解保護層級](~/docs/framework/wcf/understanding-protection-level.md)。  
  
   
  
## Examples  
 下列程式碼範例是一個簡單的服務合約，裡面只有一個作業。  
  
 [!code-csharp[OperationContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute/vb/services.vb#1)]  
  
 下列範例是一個實作隱含服務合約的服務，此合約指定三個作業。 其中兩個作業是雙向作業，不論其傳回值為何，它們都會傳回基礎回應訊息給呼叫者。 第三個作業接收一個呼叫 (基礎傳入訊息)，但不傳回基礎回應訊息。  
  
```csharp  
[ServiceContractAttribute]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContractAttribute]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContractAttribute]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is dispatched to the service; no response  
  // message is generated or sent from the service.  
  [OperationContractAttribute(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ServiceModel.OperationContractAttribute" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求訊息的 WS-Addressing 動作。</summary>
        <value>用來產生 WS-Addressing 動作標頭的動作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceModel.OperationContractAttribute.Action%2A>屬性，即可控制方法的動作的輸入訊息。 WCF 會使用這項動作來分派傳入訊息給適當的方法，因為合約作業內使用的訊息必須要有唯一的動作。 預設動作值是合約命名空間的組合 (預設值是"http://tempuri.org/」)，（介面名稱或類別名稱，如果沒有明確的服務介面） 的合約名稱、 作業名稱，以及為其他字串 ("Response") 如果訊息是相互關聯的回應。 您可用 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 屬性覆寫此預設。  
  
 若要表示某個服務作業會處理該服務所收到、但無法導向至服務作業的所有訊息，請指定該值為 "*" (星號)。 這種作業 (稱作無對應訊息處理常式) 的方法簽章必須為下列之一，否則會擲回 <xref:System.InvalidOperationException>︰  
  
-   服務作業只能讀取一個 <xref:System.ServiceModel.Channels.Message> 物件，並傳回一個 <xref:System.ServiceModel.Channels.Message> 物件。  
  
-   服務作業只能讀取一個 <xref:System.ServiceModel.Channels.Message> 物件，而不傳回任何東西 (也就是傳回 `void`)。  
  
> [!NOTE]
>  服務合約中，只能有一個把 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 屬性設為 "*" 的服務作業。 裝載於服務類別實作之相同 listenUri 上的服務合約的任何群組可以有多個<xref:System.ServiceModel.OperationContractAttribute.Action%2A>屬性設定為"\*」 時<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>屬性設定為`false`。 不過，只有其中一個服務作業可以有<xref:System.ServiceModel.OperationContractAttribute.Action%2A>屬性設定為"\*"和<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>屬性設定為 true。 如需詳細資訊，請參閱 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>。  
  
   
  
## Examples  
 下列範例是一個服務，它使用 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 與 <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 屬性來明確控制輸入與輸出 (或回覆) 訊息的 SOAP 動作，也使用 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 屬性控制中繼資料內的作業名稱。 最後，應用程式亦使用一個 "*" 的 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 值，表示用來處理無法辨認之訊息的方法。  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 實作此合約的服務會傳送如下範例所示的訊息︰  
  
 [!code-csharp[OperationContractAttribute_Properties#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPattern">
      <MemberSignature Language="C#" Value="public bool AsyncPattern { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncPattern" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPattern As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsyncPattern { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPattern : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示某個作業採用服務合約中的 <see langword="Begin" />&lt;*methodName*&gt; 和 <see langword="End" />&lt;*methodName*&gt; 方法組，以非同步方式實作。</summary>
        <value>
          <see langword="true" /> 如果<see langword="Begin" /> &lt; *methodName*&gt;所比對方法<see langword="End" /> &lt; *methodName* &gt;方法，可以藉由處理基礎結構即會實作成非同步方法組服務介面; 上的作業否則， <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 屬性建置服務作業，伺服器、用戶端或兩者上可非同步呼叫該作業。 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 屬性通知執行階段某個 `Begin` 方法有符合的 `End` 方法，它們符合 .NET 架構的非同步方法設計模式。 建置實作服務作業的伺服器非同步方法，可提升伺服器延展性與效能，而不會影響服務用戶端。若某項服務作業必須傳回某些資訊給用戶端，但執行時間較長，又可採用非同步方式執行，則建議採用此種做法。  
  
 用戶端不受影響，因為伺服器上的非同步方法組是實作細節，不影響該作業的基礎 Web 服務描述語言 (WSDL) 描述。 這類方法在用戶端以使用單一作業`<input>`相互關聯和`<output>`訊息。 WCF 會自動將輸入的訊息路由傳送`Begin` \< *methodName*> 方法，並將路由的結果`End` \< *methodName*> 呼叫輸出的訊息。 因此，用戶端通道可將該方法組表示成單一同步作業或非同步作業組。 用戶端的表示方式絕對不會影響到伺服器上的非同步實作。  
  
 用戶端合約可使用 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 屬性表示一組非同步方法組，用戶端可使用此方法組以非同步方式叫用該作業。 一般而言，用戶端應用程式使用[ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)工具並`/async`選項來產生`Begin` \< *methodName*>並`End` \< *methodName*> 方法配對，供用戶端可用來以非同步方式叫用作業。  
  
> [!NOTE]
>  若服務作業同時有同步版與非同步版，則服務的預設行為是叫用同步版。  
  
   
  
## Examples  
 下列程式碼範例示範用戶端通道至一個服務合約，該合約同時包含 `Add` 的同步版與非同步版。 若用戶端使用該合約介面，則 `BeginAdd` 與 `Add` 作業會叫用伺服器上的方法，而該方法可能是同步的，也可能是非同步的。 若使用該合約來實作服務，則傳入要求預設會分派給同步版方法。  
  
```csharp  
[ServiceContract]  
public interface IAddTwoNumbers  
{  
    // If the asynchronous method pair  
    // appears on the client channel, the client can call   
    // them asynchronously to prevent blocking.  
    [OperationContract (AsyncPattern=true)]  
    IAsyncResult BeginAdd(int a, int b, AsyncCallback cb, AsyncState s);  
  
    [OperationContract]  
    int EndAdd(IAsyncResult r);  
  
    // This is a synchronous version of the BeginAdd/EndAdd pair.  
    // It appears in the client channel code by default.   
    [OperationContract]  
    int Add(int a, int b);  
   }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得指出此作業的訊息是否必須加密及/或簽署的值。</summary>
        <value>若 <see cref="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" /> 屬性設為 <see cref="F:System.Net.Security.ProtectionLevel.None" /> 以外的值，則為<see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> 屬性，判斷此作業的訊息是否需要特定的保護層級。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitiating">
      <MemberSignature Language="C#" Value="public bool IsInitiating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitiating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInitiating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitiating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInitiating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示某個方法是否實作了可以在伺服器上初始化工作階段的作業 (若這樣的工作階段存在的話)。</summary>
        <value>如果允許作業在伺服器上初始化工作階段，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 屬性控制作業是否可在工作階段建立時，成為第一個被呼叫的作業。  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 的值必須為 <xref:System.ServiceModel.SessionMode.Allowed> 或 <xref:System.ServiceModel.SessionMode.Required>，而且使用的繫結必須要求或允許工作階段，<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 屬性才能正常運作。  
  
 預設為 `true`，表示作業可成為通道上第一個被呼叫的作業。 除了呼叫此方法，後續對初始化方法的呼叫就不再有效用。 不會再建立其他工作階段。 若合約不使用工作階段，則將 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 設為 `false` 的設定會忽略。  
  
 一般而言，您可將 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 設為 `false`，強制用戶端在叫用此方法前，先呼叫服務上的另一個方法。 例如，若您的服務有一系列的作業，這些作業依存於一個訂單 ID 號碼，您可將 <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>`true`服務作業的`GetOrderId``false` 設為 ，將其餘服務作業設為 。 這樣可確保每個新用戶端在使用服務所公開的其他方法之前，都先取得了訂單 ID。  
  
> [!NOTE]
>  <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> 與 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 屬性之間有互動。 服務合約中，只能有一個把 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 屬性設為 "*" 的服務作業。 裝載於相同接聽服務類別實作的 URI 上的服務合約的任何群組可以有多個<xref:System.ServiceModel.OperationContractAttribute.Action%2A>屬性設定為"\*」 時<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>屬性設定為`false`。 不過，只有其中一個服務方法可以有<xref:System.ServiceModel.OperationContractAttribute.Action%2A>屬性設定為"\*"，<xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>屬性設定為`true`。  
  
 若服務收到一個非初始化作業的訊息，該服務會傳回 ActionNotSupported SOAP 錯誤。 用戶端會把它當做 <xref:System.ServiceModel.FaultException>。 若用戶端先呼叫非初始化作業，用戶端會擲回 <xref:System.InvalidOperationException?displayProperty=nameWithType>。  
  
 如需詳細資訊，請參閱 <<c0> [ 使用工作階段的](~/docs/framework/wcf/using-sessions.md)。  
  
   
  
## Examples  
 下列範例是一個實作服務合約的服務，此合約指定三個方法。 此服務需要工作階段。 若呼叫者先呼叫其他作業，而非 `MethodOne`，通道會拒絕並擲回例外狀況。 當呼叫者呼叫 `MethodOne` 以初始化工作階段時，該呼叫者隨時可呼叫 `MethodThree` 終止通訊工作階段。 在工作階段期間，可任意呼叫 `MethodTwo`，次數不限。  
  
```csharp  
[ServiceContract(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false,  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public bool IsOneWay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOneWay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOneWay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOneWay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOneWay : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指出作業是否傳回回覆訊息。</summary>
        <value>如果此方法接收要求訊息且不會傳回回覆訊息，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 屬性表示某個作業不會傳回回覆訊息。 這種類型的作業對通知或事件型通訊很有用，尤其是雙向通訊。 由於呼叫者呼叫單向作業時，不會等待基礎回應訊息，因此呼叫者沒有直接的方式，可以偵測到處理要求訊息的失敗  (使用可靠通道與單向作業的服務應用程式，可在通道層級偵測到訊息傳遞失敗。 如需詳細資訊，請參閱 <<c0> [ 可靠工作階段概觀](~/docs/framework/wcf/feature-details/reliable-sessions-overview.md)。)  
  
 在雙工 (或雙向) 服務導向應用程式中，用戶端與伺服器彼此獨立地進行通訊，用戶端通道可在其方法上使用 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 屬性，表示該服務可對用戶端進行單向呼叫，用戶端會把它視為事件。 不會產生傳回呼叫或訊息，因為該服務不期待任何回應訊息。  
  
 若 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 屬性設為 `false` (預設值)，那麼就算方法的傳回值為 `void`，一樣會產生回覆訊息。 在此情況下，基礎結構會建立並傳送空白訊息，向呼叫者指出方法已傳回  (此方式可讓基礎結構將 SOAP 錯誤傳回給用戶端)。將 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 設為 `true` 是取消建立與分派回應訊息的唯一方法。  
  
 單向方法不能有傳回值或擁有 `ref` 或 `out` 參數，否則會擲回 <xref:System.InvalidOperationException?displayProperty=nameWithType> 例外狀況。  
  
 指定某個作業為單向作業，只是表示它沒有回應訊息。 若無法建立連線、傳出訊息過大，或該服務無法快速的讀取資訊，該作業仍可能封鎖。 若用戶端需要不會封鎖的呼叫，請產生 <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> 作業。 如需詳細資訊，請參閱 <<c0> [ 單向服務](~/docs/framework/wcf/feature-details/one-way-services.md)並[使用 WCF 用戶端存取服務](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md)。  
  
   
  
## Examples  
 下列範例是一個實作服務合約的服務，此合約指定三個作業。 其中兩個方法實作雙向作業，不論其傳回值為何，它們都會傳回基礎回應訊息給呼叫者。 第三個方法實作一個接收呼叫的作業 (基礎傳入訊息)，但不傳回基礎回應訊息。  
  
```csharp  
[ServiceContract]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContract]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContract]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is queued for dispatch to the service; no response  
  // message is generated or sent.  
  [OperationContract(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示服務作業在傳送回覆訊息 (如果有的話) 之後，是否導致伺服器關閉該工作階段。</summary>
        <value>如果作業會導致伺服器關閉工作階段，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> 屬性，表示呼叫某個服務作業會終止通訊工作階段。  
  
 用戶端應用程式中，值為<xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>設定為`true`會指示 WCF 在回覆到達之後關閉通道。  
  
 服務中會設定計時器，若用戶端沒有在該時段內關閉通道，通道就會中止。  
  
 如需使用此屬性的工作階段的詳細資訊，請參閱[使用工作階段的](~/docs/framework/wcf/using-sessions.md)。  
  
> [!NOTE]
>  如果呼叫者正在接聽 <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> 作業的 <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType> 事件，當收到回應時，它可能會封鎖。 處理這種情況的正確方式是，當引發 <xref:System.ServiceModel.OperationContext.OperationCompleted> 時在另一個執行緒上排程工作，然後立即從該事件處理常式傳回。  
  
   
  
## Examples  
 下列範例是一個實作服務合約的服務，此合約指定三個作業。 此服務需要一個可設定狀態的連線。 若呼叫者先呼叫其他作業，而非 `MethodOne`，通道會拒絕並擲回例外狀況。 當呼叫者呼叫 `MethodOne` 以初始化工作階段時，該呼叫者隨時可呼叫 `MethodThree` 終止通訊工作階段。 在工作階段期間，可任意呼叫 `MethodTwo`，次數不限。  
  
```csharp  
[ServiceContractAttribute(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定作業的名稱。</summary>
        <value>作業的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceModel.OperationContractAttribute.Name%2A>屬性來覆寫 <`operation`> WSDL 中的項目名稱。 預設作業名稱是實作方法的名稱。  
  
   
  
## Examples  
 下列程式碼範例使用 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 屬性來宣告中繼資料內所公開的作業名稱。  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.Name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值為空字串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，此值指定某個作業的訊息是否須加密、簽署，或兩者都進行。</summary>
        <value>其中一個 <see cref="T:System.Net.Security.ProtectionLevel" /> 值。 預設值為 <see cref="F:System.Net.Security.ProtectionLevel.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 屬性，來控制某個作業的訊息是否需加密、簽署，或兩者都進行。 除非較窄的範圍覆寫了此值，否則這裡設定的值，會成為本作業指定的所有訊息的預設值。  
  
 請記住，執行階段的保護行為，是以下屬性的保護層級設定值的組合，這點很重要。 這些屬性有階層式結構。 除非針對較窄的範圍明確設定不同的值，否則，設定最外層的值會建立所有較窄範圍的預設值。 在此情況下，外部值仍為所有較窄範圍的預設值 (特別設定的範圍除外)。  
  
 例如，如果 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 設定為 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> 而且沒有其他更窄的範圍具有保護層級設定，則會加密並簽署作業合約中的所有訊息。 但是，如果這些其中一個作業已將 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 設定為 <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>，則會簽署該作業的訊息，但是合約中的其他所有訊息都會經過加密並簽署。  
  
 如需保護層級及其假設和範圍的詳細資訊，請參閱[了解保護層級](~/docs/framework/wcf/understanding-protection-level.md)。  
  
 設定這些值的範圍如下：  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 的 <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType> 屬性。  
  
 <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> 的 <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType> 屬性。  
  
 當合約上未明確指定保護層級，而且基礎繫結可支援安全性 (不論是在傳輸層級或訊息層級) 時，整個合約的有效保護層級會是 <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>。 如果繫結不支援安全性 (例如，<xref:System.ServiceModel.BasicHttpBinding>)，整個合約的有效 <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> 為 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>。 結果便是根據端點繫結的不同，用戶端可以要求不同的訊息或傳輸層級的安全性保護，即使當合約指定 <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> 時亦然。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">該值不是其中一個 <see cref="T:System.Net.Security.ProtectionLevel" /> 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReplyAction">
      <MemberSignature Language="C#" Value="public string ReplyAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ReplyAction" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberSignature Language="VB.NET" Value="Public Property ReplyAction As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ReplyAction { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReplyAction : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定作業之回覆訊息的 SOAP 動作值。</summary>
        <value>回覆訊息的 SOAP 動作值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了指定回覆訊息的動作標頭之特定值之外，您亦可指定 "*" (星號) 字串。 指定在服務中的星號會指示 WCF 在不到訊息，這非常有用，如果您對訊息進行程式設計直接新增回覆動作。 用戶端應用程式中指定星號會指示 WCF 在不去驗證回覆動作。  
  
   
  
## Examples  
 下列範例中的服務使用 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 與 <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> 屬性，明確控制輸入與輸出 (或回覆) 訊息的 SOAP 動作。 它亦使用 <xref:System.ServiceModel.OperationContractAttribute.Name%2A> 屬性來宣告中繼資料內所公開的作業名稱。  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.ReplyAction" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>