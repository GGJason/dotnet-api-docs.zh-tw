<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e72f052bc6e3f5ecb4b0db7370b6c71323d55a32" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48673792" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f0491-101">定義所有程式碼存取權限的基礎結構。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f0491-101">Defines the underlying structure of all code access permissions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-102">程式碼存取權限會使用堆疊查核行程，以確保所有的呼叫端程式碼必須被授與，權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-102">Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</span></span> <span data-ttu-id="f0491-103">權限物件是否`null`，它會處理與狀態的使用權限物件相同<xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0491-103">If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f0491-104">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="f0491-104">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="f0491-105">繼承者<xref:System.Security.CodeAccessPermission>類別必須被授與完全信任才能正確運作，做為擴充的安全性基礎結構的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-105">Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure.</span></span> <span data-ttu-id="f0491-106">若要判斷是否完全信任，所以繼承者<xref:System.Security.CodeAccessPermission>問題<xref:System.Security.Permissions.SecurityAction.InheritanceDemand>for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true`並<xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`。</span><span class="sxs-lookup"><span data-stu-id="f0491-106">To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> = `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-107">下列程式碼範例示範衍生自的權限<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-107">The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="f0491-108">繼承者提供的辨識項，並檢視和修改原則的能力。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f0491-108">for the ability of inheritors to provide evidence and view and modify policy.</span>
      </span>
      <span data-ttu-id="f0491-109">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />， <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f0491-109">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="f0491-110">當您繼承自<see cref="T:System.Security.CodeAccessPermission" />，您也必須實作<see cref="T:System.Security.Permissions.IUnrestrictedPermission" />介面。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f0491-110">When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.</span>
        </span>
        <span data-ttu-id="f0491-111">下列<see cref="T:System.Security.CodeAccessPermission" />成員必須覆寫： <see cref="M:System.Security.CodeAccessPermission.Copy" />， <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />， <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />， <see cref="M:System.Security.CodeAccessPermission.ToXml" />， <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />，和<see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f0491-111">The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span>
        </span>
        <span data-ttu-id="f0491-112">您也必須定義的建構函式<see cref="T:System.Security.Permissions.PermissionState" />做為其唯一參數。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f0491-112">You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.</span>
        </span>
        <span data-ttu-id="f0491-113">您必須套用<see cref="T:System.SerializableAttribute" />屬性的類別，繼承自<see cref="T:System.Security.CodeAccessPermission" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="f0491-113">You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-114">初始化 <see cref="T:System.Security.CodeAccessPermission" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-114">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-115">這個建構函式呼叫來初始化類型中的狀態，只要在建立衍生類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f0491-115">This constructor is called to initialize state in the type whenever an instance of the derived class is created.</span></span> <span data-ttu-id="f0491-116">雖然您可以在衍生的類別建構函式的建構函式宣告中明確呼叫這個建構函式，這通常不需要;大多數的編譯器會自動產生您的呼叫。</span><span class="sxs-lookup"><span data-stu-id="f0491-116">Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-117">宣告即使堆疊中較高層的呼叫端未獲得資源存取權限，呼叫程式碼仍可透過呼叫這個方法的程式碼要求權限，來存取受保護的資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-117">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
          <span data-ttu-id="f0491-118">使用 <see cref="M:System.Security.CodeAccessPermission.Assert" /> 可能會造成安全性問題。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-118">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-119">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="f0491-119">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="f0491-120">呼叫<xref:System.Security.CodeAccessPermission.Assert%2A>防止源自於呼叫堆疊，從繼續向上之外的程式碼，會呼叫這個方法的呼叫堆疊的較低的堆疊查核行程。</span><span class="sxs-lookup"><span data-stu-id="f0491-120">Calling <xref:System.Security.CodeAccessPermission.Assert%2A> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</span></span> <span data-ttu-id="f0491-121">因此，即使較高的呼叫堆疊上呼叫端沒有必要的權限來存取資源，他們仍然可以透過呼叫這個方法所需的權限的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0491-121">Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</span></span> <span data-ttu-id="f0491-122">判斷提示是有效的程式碼呼叫時，才<xref:System.Security.CodeAccessPermission.Assert%2A>通過安全性檢查，它會判斷提示之權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-122">An assertion is effective only if the code that calls <xref:System.Security.CodeAccessPermission.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="f0491-123">若要呼叫<xref:System.Security.CodeAccessPermission.Assert%2A>會生效，直到呼叫程式碼傳回至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="f0491-123">The call to <xref:System.Security.CodeAccessPermission.Assert%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="f0491-124">只有一個<xref:System.Security.CodeAccessPermission.Assert%2A>作用中的框架。</span><span class="sxs-lookup"><span data-stu-id="f0491-124">Only one <xref:System.Security.CodeAccessPermission.Assert%2A> can be active on a frame.</span></span> <span data-ttu-id="f0491-125">嘗試呼叫<xref:System.Security.CodeAccessPermission.Assert%2A>當作用<xref:System.Security.CodeAccessPermission.Assert%2A>中的框架結果存在於<xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="f0491-125">An attempt to call <xref:System.Security.CodeAccessPermission.Assert%2A> when an active <xref:System.Security.CodeAccessPermission.Assert%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="f0491-126">呼叫<xref:System.Security.CodeAccessPermission.RevertAssert%2A>或是<xref:System.Security.CodeAccessPermission.RevertAll%2A>若要移除作用<xref:System.Security.CodeAccessPermission.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-126">Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span>  
  
 <span data-ttu-id="f0491-127"><xref:System.Security.CodeAccessPermission.Assert%2A> 會忽略該權限的要求將會失敗，因為未授與權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-127"><xref:System.Security.CodeAccessPermission.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="f0491-128">不過，如果在呼叫堆疊中較低的程式碼會呼叫<xref:System.Security.CodeAccessPermission.Demand%2A>該權限，請<xref:System.Security.SecurityException>堆疊查核行程達到嘗試呼叫的程式碼時，會擲回<xref:System.Security.CodeAccessPermission.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-128">However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="f0491-129">這是因為，所呼叫的程式碼<xref:System.Security.CodeAccessPermission.Assert%2A>沒有被授予權限，即使應用程式嘗試<xref:System.Security.CodeAccessPermission.Assert%2A>它。</span><span class="sxs-lookup"><span data-stu-id="f0491-129">This happens because the code that called <xref:System.Security.CodeAccessPermission.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.CodeAccessPermission.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f0491-130">因為呼叫<xref:System.Security.CodeAccessPermission.Assert%2A>移除所有程式碼呼叫鏈結中的需求必須被授與權限來存取指定的資源，如果不正確或不當使用，它可以開啟安全性的問題。</span><span class="sxs-lookup"><span data-stu-id="f0491-130">Because calling <xref:System.Security.CodeAccessPermission.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</span></span> <span data-ttu-id="f0491-131">因此，它應該使用小心謹慎。</span><span class="sxs-lookup"><span data-stu-id="f0491-131">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f0491-132">呼叫的程式碼沒有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-132">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
          <span data-ttu-id="f0491-133">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-133">-or-</span>
          </span>
          <span data-ttu-id="f0491-134">目前的框架已有作用中的 <see cref="M:System.Security.CodeAccessPermission.Assert" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-134">There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f0491-135">能夠呼叫<see cref="M:System.Security.CodeAccessPermission.Assert" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-135">for the ability to call <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span>
          </span>
          <span data-ttu-id="f0491-136">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          </span>
        </permission>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-137">您無法覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-137">You cannot override this method.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">
          <span data-ttu-id="f0491-138">使用 Assert 方法</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-138">Using the Assert Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-139">由衍生類別實作時，建立並傳回目前權限物件的相同複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-139">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-140">目前權限物件的複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-140">A copy of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-141">權限物件的複本會表示資源與原始的使用權限物件相同的存取權。</span><span class="sxs-lookup"><span data-stu-id="f0491-141">A copy of a permission object represents the same access to resources as the original permission object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-142">下列程式碼範例示範的覆寫<xref:System.Security.CodeAccessPermission.Copy%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-142">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method.</span></span> <span data-ttu-id="f0491-143">此程式碼範例是針對提供之較大範例的一部分<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-143">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-144">您必須覆寫這個方法在衍生類別中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-144">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-145">如果在呼叫堆疊中較高的所有呼叫端都尚未被授與由目前執行個體所指定之權限，則會在執行階段強制執行 <see cref="T:System.Security.SecurityException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-145">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-146">安全程式庫通常會使用這個方法以確保呼叫端擁有存取資源的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-146">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="f0491-147">安全類別庫中的檔案類別的呼叫，例如<xref:System.Security.CodeAccessPermission.Demand%2A>的必要<xref:System.Security.Permissions.FileIOPermission>之前執行檔案作業要求的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="f0491-147">For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="f0491-148">呼叫這個方法的程式碼的權限就不會檢查;檢查立即呼叫端程式碼從開始，並繼續向上堆疊。</span><span class="sxs-lookup"><span data-stu-id="f0491-148">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="f0491-149">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="f0491-149">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="f0491-150"><xref:System.Security.CodeAccessPermission.Demand%2A> 只有當沒有成功<xref:System.Security.SecurityException>，就會引發。</span><span class="sxs-lookup"><span data-stu-id="f0491-150"><xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f0491-151">此呼叫堆疊中較高層的呼叫端，不需要獲得目前執行個體所指定的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-151">A caller higher in the call stack does not have the permission specified by the current instance.</span>
          </span>
          <span data-ttu-id="f0491-152">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-152">-or-</span>
          </span>
          <span data-ttu-id="f0491-153">此呼叫堆疊中較高層的呼叫端已呼叫目前權限物件上的 <see cref="M:System.Security.CodeAccessPermission.Deny" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-153">A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-154">您無法覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-154">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-155">防止呼叫堆疊中較高的呼叫端，使用程式碼呼叫此方法來存取目前執行個體所指定的資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-155">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f0491-156"><xref:System.Security.CodeAccessPermission.Deny%2A>方法應該只能用來防止意外存取的資源由完全信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0491-156">The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="f0491-157">它應該不會用來防範刻意誤用的資源不受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0491-157">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="f0491-158">例如，如果方法`A`問題<xref:System.Security.CodeAccessPermission.Deny%2A>進行權限，然後呼叫方法`B`，方法`B`overtly 可以覆寫<xref:System.Security.CodeAccessPermission.Deny%2A>發出<xref:System.Security.CodeAccessPermission.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-158">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="f0491-159">呼叫的方法一律是在堆疊中較高的。</span><span class="sxs-lookup"><span data-stu-id="f0491-159">The called method is always higher in the stack.</span></span> <span data-ttu-id="f0491-160">因此，如果方法`B`嘗試存取受保護的資源時，安全性系統開始使用它的權限檢查，因為方法`B`是立即呼叫端，上下然後會逐步引導的堆疊，以確認沒有任何<xref:System.Security.CodeAccessPermission.Deny%2A>或<xref:System.Security.CodeAccessPermission.PermitOnly%2A>堆疊中較低。</span><span class="sxs-lookup"><span data-stu-id="f0491-160">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="f0491-161">方法`B`，這嘗試存取資源，可以停止堆疊查核行程立即使用<xref:System.Security.CodeAccessPermission.Assert%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-161">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="f0491-162">在此情況下，<xref:System.Security.CodeAccessPermission.Deny%2A>放置在堆疊上方法`A`永遠不會探索 （呼叫的方法）。</span><span class="sxs-lookup"><span data-stu-id="f0491-162">In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="f0491-163">這個方法可防止呼叫堆疊中較高層的呼叫端程式碼呼叫此方法中，透過存取受保護的資源，即使這些呼叫端必須被授與存取權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-163">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="f0491-164">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="f0491-164">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="f0491-165"><xref:System.Security.CodeAccessPermission.Deny%2A> 可以限制程式設計師的責任或協助避免意外的安全性問題，因有利於防止呼叫<xref:System.Security.CodeAccessPermission.Deny%2A>從用來存取所拒絕的權限保護的資源。</span><span class="sxs-lookup"><span data-stu-id="f0491-165"><xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="f0491-166">如果方法呼叫<xref:System.Security.CodeAccessPermission.Deny%2A>權限，而且如果<xref:System.Security.CodeAccessPermission.Demand%2A>該安全性檢查的呼叫堆疊中較低的呼叫端叫用該權限時，將會失敗，當它到達<xref:System.Security.CodeAccessPermission.Deny%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-166">If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span>  
  
 <span data-ttu-id="f0491-167">若要呼叫<xref:System.Security.CodeAccessPermission.Deny%2A>會生效，直到呼叫程式碼傳回至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="f0491-167">The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="f0491-168">只有一個<xref:System.Security.CodeAccessPermission.Deny%2A>作用中的框架。</span><span class="sxs-lookup"><span data-stu-id="f0491-168">Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame.</span></span> <span data-ttu-id="f0491-169">嘗試呼叫<xref:System.Security.CodeAccessPermission.Deny%2A>當作用<xref:System.Security.CodeAccessPermission.Deny%2A>中的框架結果存在於<xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="f0491-169">An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="f0491-170">呼叫<xref:System.Security.CodeAccessPermission.RevertDeny%2A>或是<xref:System.Security.CodeAccessPermission.RevertAll%2A>若要移除作用<xref:System.Security.CodeAccessPermission.Deny%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-170">Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span> <span data-ttu-id="f0491-171"><xref:System.Security.CodeAccessPermission.Deny%2A> 會忽略該權限的要求將會失敗，因為未授與權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-171"><xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f0491-172">目前的框架已有作用中的 <see cref="M:System.Security.CodeAccessPermission.Deny" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-172">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-173">您無法覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-173">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f0491-174">要與目前 <see cref="T:System.Security.CodeAccessPermission" /> 比較的 <see cref="T:System.Security.CodeAccessPermission" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-174">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f0491-175">判斷指定的 <see cref="T:System.Security.CodeAccessPermission" /> 物件是否等於目前的 <see cref="T:System.Security.CodeAccessPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-175">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-176">如果指定的 <see cref="T:System.Security.CodeAccessPermission" /> 物件等於目前的 <see cref="T:System.Security.CodeAccessPermission" />，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-176">
              <see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-177">如需詳細資訊，請參閱<xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-177">For more information, see <xref:System.Object.Equals%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">
          <span data-ttu-id="f0491-178">用來重新建構安全性物件的 XML 編碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-178">The XML encoding to use to reconstruct the security object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f0491-179">在衍生類別中覆寫時，透過 XML 編碼方式，重新建構具有指定狀態的安全性物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-179">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-180">擴充安全性物件的自訂程式碼必須實作<xref:System.Security.CodeAccessPermission.ToXml%2A>和<xref:System.Security.CodeAccessPermission.FromXml%2A>方法，以使安全性 encodable 的物件。</span><span class="sxs-lookup"><span data-stu-id="f0491-180">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-181">下列程式碼範例示範的覆寫<xref:System.Security.CodeAccessPermission.FromXml%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-181">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.FromXml%2A> method.</span></span> <span data-ttu-id="f0491-182">此程式碼範例是針對提供之較大範例的一部分<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-182">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f0491-183">
            <paramref name="elem" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-183">The <paramref name="elem" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f0491-184">
            <paramref name="elem" /> 參數不包含與目前執行個體相同型別的執行個體的 XML 編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-184">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span>
          </span>
          <span data-ttu-id="f0491-185">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-185">-or-</span>
          </span>
          <span data-ttu-id="f0491-186">不支援 <paramref name="elem" /> 參數的版本號碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-186">The version number of the <paramref name="elem" /> parameter is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-187">您必須覆寫這個方法在衍生類別中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-187">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-188">取得 <see cref="T:System.Security.CodeAccessPermission" /> 物件的雜湊碼，其適合用於雜湊表這類的雜湊演算法和資料結構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-188">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-189">目前 <see cref="T:System.Security.CodeAccessPermission" /> 物件的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-189">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-190">兩個相同的權限執行個體的雜湊程式碼可能會不同，因此雜湊程式碼應該不會用來比較兩個<xref:System.Security.CodeAccessPermission>物件。</span><span class="sxs-lookup"><span data-stu-id="f0491-190">The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f0491-191">要與目前權限產生交集的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-191">A permission to intersect with the current permission.</span>
          </span>
          <span data-ttu-id="f0491-192">必須與目前權限屬於相同的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-192">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f0491-193">由衍生類別實作時，建立並傳回目前權限與指定權限交集的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-193">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-194">代表目前權限與指定權限交集的新權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-194">A new permission that represents the intersection of the current permission and the specified permission.</span>
          </span>
          <span data-ttu-id="f0491-195">如果交集是空的，這個新使用權限為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-195">This new permission is <see langword="null" /> if the intersection is empty.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-196">兩個權限的交集會說明兩者所共同描述的作業集合的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-196">The intersection of two permissions is a permission that describes the set of operations they both describe in common.</span></span> <span data-ttu-id="f0491-197">只有通過這兩個原始的使用權限的需求將會通過交集。</span><span class="sxs-lookup"><span data-stu-id="f0491-197">Only a demand that passes both original permissions will pass the intersection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-198">下列程式碼範例示範的覆寫<xref:System.Security.CodeAccessPermission.Intersect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-198">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Intersect%2A> method.</span></span> <span data-ttu-id="f0491-199">此程式碼範例是針對提供之較大範例的一部分<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-199">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f0491-200">
            <paramref name="target" /> 參數不是 <see langword="null" />，並且不是與目前使用權限相同類別的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-200">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-201">您必須覆寫這個方法在衍生類別中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-201">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f0491-202">要測試子集關聯性的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-202">A permission that is to be tested for the subset relationship.</span>
          </span>
          <span data-ttu-id="f0491-203">這個權限必須與目前權限屬於相同的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-203">This permission must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f0491-204">由衍生類別實作時，會判斷目前權限是否為指定權限的子集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-204">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-205">如果目前的使用權限是指定之使用權限的子集，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-205">
              <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-206">如果目前的使用權限會指定一組完全包含在指定的權限的作業，目前的使用權限是指定的權限的子集。</span><span class="sxs-lookup"><span data-stu-id="f0491-206">The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</span></span> <span data-ttu-id="f0491-207">例如，表示 C:\example.txt 的存取權限是 c： 表示存取權限的子集\\。</span><span class="sxs-lookup"><span data-stu-id="f0491-207">For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\\.</span></span> <span data-ttu-id="f0491-208">如果此方法傳回`true`，目前的權限，表示沒有存取受保護的資源比指定的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-208">If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.</span></span>  
  
 <span data-ttu-id="f0491-209">下列陳述式必須是`true`所有覆寫的<xref:System.Security.CodeAccessPermission.IsSubsetOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-209">The following statements are required to be `true` for all overrides of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="f0491-210">*X*， *Y*，以及*Z*代表不是 null 參考的自訂程式碼存取使用權限物件*U*代表不受限制的程式碼存取權限，並*N*表示使用空的權限<xref:System.Security.Permissions.PermissionState>的<xref:System.Security.Permissions.PermissionState.None>。</span><span class="sxs-lookup"><span data-stu-id="f0491-210">*X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState.None>.</span></span>  
  
-   <span data-ttu-id="f0491-211">*X*。IsSubsetOf (*X*) 會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="f0491-211">*X*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
-   <span data-ttu-id="f0491-212">*X*。IsSubsetOf (*Y*) 傳回相同的值，成為*Y*。IsSubsetOf (*X*)，才*X*並*Y*代表相同的權限集。</span><span class="sxs-lookup"><span data-stu-id="f0491-212">*X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.</span></span>  
  
-   <span data-ttu-id="f0491-213">如果*X*。IsSubsetOf (*Y*) 和*Y*。IsSubsetOf (*Z*)，傳回`true`， *X*。IsSubsetOf (*Z*) 會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="f0491-213">If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.</span></span>  
  
-   <span data-ttu-id="f0491-214">*X*。IsSubsetOf (*U*) 會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="f0491-214">*X*.IsSubsetOf(*U*) returns `true`.</span></span>  
  
-   <span data-ttu-id="f0491-215">*X*。IsSubsetOf (*N*) 會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="f0491-215">*X*.IsSubsetOf(*N*) returns `false`.</span></span>  
  
-   <span data-ttu-id="f0491-216">*N*。IsSubsetOf (*X*) 會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="f0491-216">*N*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
 <span data-ttu-id="f0491-217">如果*X*並*Y*代表自訂程式碼存取使用權限物件是 null 參考， *X*。IsSubsetOf (*Y*) 會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="f0491-217">If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`.</span></span> <span data-ttu-id="f0491-218">如果*Z*也是 null，複合設定作業*X*。聯集 (*Y*)。IsSubsetOf (*Z*) 也會傳回`true`因為兩個 null 的權限的聯集為 null 的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-218">If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-219">下列程式碼範例示範的覆寫<xref:System.Security.CodeAccessPermission.IsSubsetOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-219">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="f0491-220">此程式碼範例是針對提供之較大範例的一部分<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-220">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f0491-221">
            <paramref name="target" /> 參數不是 <see langword="null" />，而且與目前使用權限不是相同的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-221">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-222">您必須覆寫這個方法在衍生類別中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-222">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-223">防止呼叫堆疊中較高的呼叫端，使用程式碼呼叫此方法來存取目前執行個體所指定之資源以外的所有資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-223">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f0491-224"><xref:System.Security.CodeAccessPermission.PermitOnly%2A>方法應該只能用來防止意外存取的資源由完全信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0491-224">The <xref:System.Security.CodeAccessPermission.PermitOnly%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="f0491-225">它應該不會用來防範刻意誤用的資源不受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0491-225">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="f0491-226">例如，如果方法`A`問題<xref:System.Security.CodeAccessPermission.PermitOnly%2A>進行權限，然後呼叫方法`B`，方法`B`overtly 可以覆寫<xref:System.Security.CodeAccessPermission.PermitOnly%2A>發出<xref:System.Security.CodeAccessPermission.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-226">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="f0491-227">呼叫的方法一律是在堆疊中較高的。</span><span class="sxs-lookup"><span data-stu-id="f0491-227">The called method is always higher in the stack.</span></span> <span data-ttu-id="f0491-228">因此，如果方法`B`嘗試存取受保護的資源時，安全性系統開始使用它的權限檢查，因為方法`B`是立即呼叫端，上下然後會逐步引導的堆疊，以確認沒有任何<xref:System.Security.CodeAccessPermission.Deny%2A>或<xref:System.Security.CodeAccessPermission.PermitOnly%2A>堆疊中較低。</span><span class="sxs-lookup"><span data-stu-id="f0491-228">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="f0491-229">方法`B`，這嘗試存取資源，可以停止堆疊查核行程立即使用<xref:System.Security.CodeAccessPermission.Assert%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-229">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="f0491-230">在此情況下，<xref:System.Security.CodeAccessPermission.PermitOnly%2A>放置在堆疊上方法`A`永遠不會探索 （呼叫的方法）。</span><span class="sxs-lookup"><span data-stu-id="f0491-230">In that case, the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="f0491-231"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 類似於<xref:System.Security.CodeAccessPermission.Deny%2A>，兩者會導致堆疊查核行程，它們本來可以成功時失敗。</span><span class="sxs-lookup"><span data-stu-id="f0491-231"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="f0491-232">其差異在於<xref:System.Security.CodeAccessPermission.Deny%2A>指定將會導致失敗，堆疊查核行程的權限，但<xref:System.Security.CodeAccessPermission.PermitOnly%2A>指定唯一的權限不會造成失敗的堆疊查核行程。</span><span class="sxs-lookup"><span data-stu-id="f0491-232">The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span>  
  
 <span data-ttu-id="f0491-233">呼叫此方法，以確保您的程式碼，可用來存取指定的資源。</span><span class="sxs-lookup"><span data-stu-id="f0491-233">Call this method to ensure that your code can be used to access only the specified resources.</span></span> <span data-ttu-id="f0491-234">若要呼叫<xref:System.Security.CodeAccessPermission.PermitOnly%2A>會生效，直到呼叫程式碼傳回至呼叫端。</span><span class="sxs-lookup"><span data-stu-id="f0491-234">The call to <xref:System.Security.CodeAccessPermission.PermitOnly%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="f0491-235">只有一個<xref:System.Security.CodeAccessPermission.PermitOnly%2A>作用中的框架。</span><span class="sxs-lookup"><span data-stu-id="f0491-235">Only one <xref:System.Security.CodeAccessPermission.PermitOnly%2A> can be active on a frame.</span></span> <span data-ttu-id="f0491-236">嘗試呼叫<xref:System.Security.CodeAccessPermission.PermitOnly%2A>當作用<xref:System.Security.CodeAccessPermission.PermitOnly%2A>中的框架結果存在於<xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="f0491-236">An attempt to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A> when an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="f0491-237">呼叫<xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A>或是<xref:System.Security.CodeAccessPermission.RevertAll%2A>若要移除作用<xref:System.Security.CodeAccessPermission.PermitOnly%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-237">Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span>  
  
 <span data-ttu-id="f0491-238"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> 會忽略該權限的要求將會失敗，因為未授與權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-238"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="f0491-239">不過，如果程式碼呼叫較低堆疊稍後呼叫<xref:System.Security.CodeAccessPermission.Demand%2A>該權限，請<xref:System.Security.SecurityException>堆疊查核行程達到嘗試呼叫的程式碼時，會擲回<xref:System.Security.CodeAccessPermission.PermitOnly%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0491-239">However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span> <span data-ttu-id="f0491-240">這是因為程式碼，呼叫<xref:System.Security.CodeAccessPermission.PermitOnly%2A>沒有被授予權限，即使它呼叫<xref:System.Security.CodeAccessPermission.PermitOnly%2A>該使用權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-240">This is because the code that called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="f0491-241">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="f0491-241">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f0491-242">目前的框架已有作用中的 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-242">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-243">您無法覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-243">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-244">會移除目前畫面格之所有先前覆寫，且不再有作用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-244">Causes all previous overrides for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-245">如果不有任何覆寫 (<xref:System.Security.CodeAccessPermission.Assert%2A>， <xref:System.Security.CodeAccessPermission.Deny%2A>，或<xref:System.Security.CodeAccessPermission.PermitOnly%2A>) 目前的框架，<xref:System.ExecutionEngineException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f0491-245">If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f0491-246">沒有目前框架先前的 <see cref="M:System.Security.CodeAccessPermission.Assert" />、<see cref="M:System.Security.CodeAccessPermission.Deny" /> 或 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-246">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-247">造成目前框架任何先前的 <see cref="M:System.Security.CodeAccessPermission.Assert" /> 將移除並且不再有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-247">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-248">如果沒有任何<xref:System.Security.CodeAccessPermission.Assert%2A>目前的框架，<xref:System.ExecutionEngineException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f0491-248">If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f0491-249">沒有目前框架先前的 <see cref="M:System.Security.CodeAccessPermission.Assert" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-249">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-250">造成目前框架任何先前的 <see cref="M:System.Security.CodeAccessPermission.Deny" /> 將移除並且不再有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-250">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-251">如果沒有任何<xref:System.Security.CodeAccessPermission.Deny%2A>目前的框架，<xref:System.ExecutionEngineException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f0491-251">If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f0491-252">沒有目前框架先前的 <see cref="M:System.Security.CodeAccessPermission.Deny" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-252">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-253">造成目前框架任何先前的 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> 將移除並且不再有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-253">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-254">如果沒有任何<xref:System.Security.CodeAccessPermission.PermitOnly%2A>目前的框架，<xref:System.ExecutionEngineException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f0491-254">If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f0491-255">沒有目前框架先前的 <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-255">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-256">建立並傳回目前權限物件的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-256">Creates and returns a string representation of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-257">目前權限物件的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-257">A string representation of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-258">這個方法可用於偵錯時要顯示為字串的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-258">This method is useful in debugging when you need to display the permission as a string.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f0491-259">在衍生類別中覆寫時，建立安全性物件及其目前狀態的 XML 編碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-259">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-260">安全物件的 XML 編碼方式，包含所有狀態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-260">An XML encoding of the security object, including any state information.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-261">擴充安全性物件的自訂程式碼必須實作<xref:System.Security.CodeAccessPermission.ToXml%2A>和<xref:System.Security.CodeAccessPermission.FromXml%2A>方法，以使安全性 encodable 的物件。</span><span class="sxs-lookup"><span data-stu-id="f0491-261">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-262">下列程式碼範例示範的覆寫<xref:System.Security.CodeAccessPermission.ToXml%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-262">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.ToXml%2A> method.</span></span> <span data-ttu-id="f0491-263">此程式碼範例是針對提供之較大範例的一部分<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-263">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-264">您必須覆寫這個方法在衍生類別中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-264">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="f0491-265">要與目前權限結合的權限，</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-265">A permission to combine with the current permission.</span>
          </span>
          <span data-ttu-id="f0491-266">必須與目前權限屬於相同的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-266">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f0491-267">在衍生類別中覆寫時，建立目前權限與指定權限聯集的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-267">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f0491-268">代表目前權限與指定權限聯集的新權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-268">A new permission that represents the union of the current permission and the specified permission.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0491-269">若要呼叫的結果<xref:System.Security.CodeAccessPermission.Union%2A>是代表的權限表示的所有作業的目前權限和指定的權限。</span><span class="sxs-lookup"><span data-stu-id="f0491-269">The result of a call to <xref:System.Security.CodeAccessPermission.Union%2A> is a permission that represents all the operations represented by both the current permission and the specified permission.</span></span> <span data-ttu-id="f0491-270">任何通過其中之一權限的需求會傳遞它們的聯集。</span><span class="sxs-lookup"><span data-stu-id="f0491-270">Any demand that passes either permission passes their union.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0491-271">下列程式碼範例示範的覆寫<xref:System.Security.CodeAccessPermission.Union%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f0491-271">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Union%2A> method.</span></span> <span data-ttu-id="f0491-272">此程式碼範例是針對提供之較大範例的一部分<xref:System.Security.CodeAccessPermission>類別。</span><span class="sxs-lookup"><span data-stu-id="f0491-272">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f0491-273">
            <paramref name="other" /> 參數不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-273">The <paramref name="other" /> parameter is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f0491-274">當傳遞 <see langword="null" /> 這個方法只在這個層級受到支援。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f0491-274">This method is only supported at this level when passed <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f0491-275">您必須覆寫這個方法在衍生類別中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-275">You must override this method in a derived class.</span>
            </span>
            <span data-ttu-id="f0491-276">如果應該傳回一份權限的值<paramref name="other" />參數是<see langword="null" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="f0491-276">You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>