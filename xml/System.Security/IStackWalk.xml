<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df8c33ab7bb831c9a8d979c182a56263b8e53575" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48766768" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="38a41-101">管理堆疊查核行程，其判斷呼叫堆疊中所有呼叫端是否具有存取受保護資源的必要權限。</span>
      <span class="sxs-lookup">
        <span data-stu-id="38a41-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38a41-102">部分信任程式碼一律會造成安全性風險。</span><span class="sxs-lookup"><span data-stu-id="38a41-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="38a41-103">它有時可以操作來代表沒有存取資源的權限的惡意程式碼執行動作。</span><span class="sxs-lookup"><span data-stu-id="38a41-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="38a41-104">如此一來，惡意程式碼能夠比應允許較高的安全性存取權。</span><span class="sxs-lookup"><span data-stu-id="38a41-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="38a41-105">通用語言執行平台有助於防止這些攻擊中的 managed 程式碼，所有的呼叫上執行堆疊查核行程。</span><span class="sxs-lookup"><span data-stu-id="38a41-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="38a41-106">堆疊查核行程要求呼叫堆疊中的所有程式碼必須具有存取受保護的資源的權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="38a41-107">因為嘗試攻擊的程式碼一定會某處呼叫堆疊中，將無法超過它自己的安全性權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="38a41-108">即使堆疊中較高的呼叫端未獲得資源存取權限，呼叫程式碼仍可以存取目前權限物件所識別之資源的判斷提示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38a41-109">呼叫<xref:System.Security.IStackWalk.Assert%2A>呼叫堆疊中較高層的呼叫端的權限檢查就會停止。</span><span class="sxs-lookup"><span data-stu-id="38a41-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="38a41-110">因此，即使這些呼叫端沒有必要的權限，他們仍然可以存取資源。</span><span class="sxs-lookup"><span data-stu-id="38a41-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="38a41-111">判斷提示是有效的程式碼呼叫時，才<xref:System.Security.IStackWalk.Assert%2A>通過安全性檢查，它會判斷提示之權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="38a41-112">呼叫<xref:System.Security.IStackWalk.Assert%2A>會生效，直到呼叫程式碼傳回給其呼叫端，或直到後續呼叫<xref:System.Security.IStackWalk.Assert%2A>轉譯先前的判斷提示無效。</span><span class="sxs-lookup"><span data-stu-id="38a41-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="38a41-113">此外，<xref:System.Security.CodeAccessPermission.RevertAssert%2A>或是<xref:System.Security.CodeAccessPermission.RevertAll%2A>移除暫止<xref:System.Security.IStackWalk.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="38a41-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="38a41-114"><xref:System.Security.IStackWalk.Assert%2A> 會忽略該權限的要求將會失敗，因為未授與權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="38a41-115">不過，如果在呼叫堆疊中較低的程式碼會呼叫<xref:System.Security.IStackWalk.Demand%2A>該權限，請<xref:System.Security.SecurityException>堆疊查核行程達到嘗試呼叫的程式碼時，會擲回<xref:System.Security.IStackWalk.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="38a41-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="38a41-116">這是因為，所呼叫的程式碼<xref:System.Security.IStackWalk.Assert%2A>沒有被授予權限，即使應用程式嘗試<xref:System.Security.IStackWalk.Assert%2A>它。</span><span class="sxs-lookup"><span data-stu-id="38a41-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="38a41-117">因為呼叫<xref:System.Security.IStackWalk.Assert%2A>移除所有程式碼呼叫鏈結中的需求必須被授與權限來存取指定的資源，如果不正確或不當使用，它可以開啟啟動安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="38a41-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="38a41-118">因此，它應該使用小心謹慎。</span><span class="sxs-lookup"><span data-stu-id="38a41-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="38a41-119">呼叫的程式碼沒有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">
          <span data-ttu-id="38a41-120">使用 Assert 方法</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-120">Using the Assert Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="38a41-121">判斷執行階段期間呼叫堆疊中的所有呼叫端，是否已獲得目前權限物件所指定的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-121">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38a41-122">安全程式庫通常會使用這個方法以確保呼叫端擁有存取資源的權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-122">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="38a41-123">安全類別庫中的檔案類別的呼叫，例如<xref:System.Security.IStackWalk.Demand%2A>的必要<xref:System.Security.Permissions.FileIOPermission>之前執行檔案作業要求的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="38a41-123">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="38a41-124">呼叫這個方法的程式碼的權限就不會檢查;檢查立即呼叫端程式碼從開始，並繼續向上堆疊。</span><span class="sxs-lookup"><span data-stu-id="38a41-124">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="38a41-125"><xref:System.Security.IStackWalk.Demand%2A> 只有當沒有成功<xref:System.Security.SecurityException>，就會引發。</span><span class="sxs-lookup"><span data-stu-id="38a41-125"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="38a41-126">此呼叫堆疊中較高層的呼叫端，不需要獲得目前權限物件所指定的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-126">A caller higher in the call stack does not have the permission specified by the current permission object.</span>
          </span>
          <span data-ttu-id="38a41-127">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-127">-or-</span>
          </span>
          <span data-ttu-id="38a41-128">此呼叫堆疊中的呼叫端已呼叫目前權限物件上的 <see cref="M:System.Security.IStackWalk.Deny" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-128">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="38a41-129">導致透過呼叫程式碼傳遞之目前物件的每一個 <see cref="M:System.Security.IStackWalk.Demand" /> 都失敗。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-129">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38a41-130">這個方法可防止呼叫堆疊中較高層的呼叫端程式碼呼叫此方法中，透過存取受保護的資源，即使這些呼叫端必須被授與存取權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-130">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="38a41-131">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="38a41-131">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="38a41-132"><xref:System.Security.IStackWalk.Deny%2A> 可以限制程式設計師的責任或協助避免意外安全性漏洞，因有利於防止呼叫<xref:System.Security.IStackWalk.Deny%2A>從用來存取所拒絕的權限保護的資源。</span><span class="sxs-lookup"><span data-stu-id="38a41-132"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="38a41-133">如果方法呼叫<xref:System.Security.IStackWalk.Deny%2A>權限，而且如果<xref:System.Security.IStackWalk.Demand%2A>該安全性檢查的呼叫堆疊中較低的呼叫端叫用該權限時，將會失敗，當它到達<xref:System.Security.IStackWalk.Deny%2A>。</span><span class="sxs-lookup"><span data-stu-id="38a41-133">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="38a41-134"><xref:System.Security.IStackWalk.Deny%2A> 會忽略該權限的要求將會失敗，因為未授與權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-134"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="38a41-135">您無法覆寫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="38a41-135">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="38a41-136">即使呼叫堆疊中較高層的程式碼已授與存取其他資源的使用權限，還是會導致經過呼叫程式碼、除了目前物件之外之所有物件的每一個 <see cref="M:System.Security.IStackWalk.Demand" /> 發生錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="38a41-136">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38a41-137"><xref:System.Security.IStackWalk.PermitOnly%2A> 類似於<xref:System.Security.IStackWalk.Deny%2A>，兩者會導致堆疊查核行程，它們本來可以成功時失敗。</span><span class="sxs-lookup"><span data-stu-id="38a41-137"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="38a41-138">其差異在於<xref:System.Security.IStackWalk.Deny%2A>指定將會導致失敗，堆疊查核行程的權限，但<xref:System.Security.IStackWalk.PermitOnly%2A>指定唯一的權限不會造成失敗的堆疊查核行程。</span><span class="sxs-lookup"><span data-stu-id="38a41-138">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="38a41-139">呼叫此方法，以確保您的程式碼，可用來存取指定的資源。</span><span class="sxs-lookup"><span data-stu-id="38a41-139">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="38a41-140"><xref:System.Security.IStackWalk.PermitOnly%2A> 會忽略該權限的要求將會失敗，因為未授與權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-140"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="38a41-141">不過，如果程式碼呼叫較低堆疊稍後呼叫<xref:System.Security.IStackWalk.Demand%2A>該權限，請<xref:System.Security.SecurityException>堆疊查核行程達到嘗試呼叫的程式碼時，會擲回<xref:System.Security.IStackWalk.PermitOnly%2A>。</span><span class="sxs-lookup"><span data-stu-id="38a41-141">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="38a41-142">這是因為程式碼，呼叫<xref:System.Security.IStackWalk.PermitOnly%2A>沒有被授予權限，即使它呼叫<xref:System.Security.IStackWalk.PermitOnly%2A>該使用權限。</span><span class="sxs-lookup"><span data-stu-id="38a41-142">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="38a41-143">通常，向下成長，來表示呼叫堆疊，使方法呼叫堆疊中較高層呼叫方法較低的呼叫堆疊中。</span><span class="sxs-lookup"><span data-stu-id="38a41-143">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>