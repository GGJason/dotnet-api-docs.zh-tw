<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56d9d023a154981435b37666fa081861ca0100c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="700b1-101">代表控制代碼資源的包裝函式類別。</span>
      <span class="sxs-lookup">
        <span data-stu-id="700b1-101">Represents a wrapper class for handle resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-102"><xref:System.Runtime.InteropServices.CriticalHandle>類別是類似於<xref:System.Runtime.InteropServices.SafeHandle>類別，但是<xref:System.Runtime.InteropServices.SafeHandle>實作參考計數。</span><span class="sxs-lookup"><span data-stu-id="700b1-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="700b1-103">您可以使用<xref:System.Runtime.InteropServices.CriticalHandle>而不是<xref:System.Runtime.InteropServices.SafeHandle>位址效能考量，當多個提供所需的同步處理時至有效率地使用您自己。</span><span class="sxs-lookup"><span data-stu-id="700b1-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="700b1-104">因為<xref:System.Runtime.InteropServices.CriticalHandle>類別不會執行參考計數，但是它不提供從回收安全性攻擊的控制代碼的保護。</span><span class="sxs-lookup"><span data-stu-id="700b1-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="700b1-105">參考計數演算法會以隱含方式序列化作業，因為安全執行緒數量也會遺失。</span><span class="sxs-lookup"><span data-stu-id="700b1-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="700b1-106">如果您呼叫<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>或<xref:System.Runtime.InteropServices.SafeHandle.Close%2A>方法使用控制代碼的作業，另一個執行緒上未執行時，或您呼叫<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>或<xref:System.Runtime.InteropServices.SafeHandle.Close%2A>從在同一時間的兩個執行緒，則結果為不具決定性。</span><span class="sxs-lookup"><span data-stu-id="700b1-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="700b1-107"><xref:System.Runtime.InteropServices.CriticalHandle>類別仍然會提供所提供的保證關鍵結束<xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>類別。</span><span class="sxs-lookup"><span data-stu-id="700b1-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="700b1-108">針對繼承者完全信任。</span>
      <span class="sxs-lookup">
        <span data-stu-id="700b1-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="700b1-109">這個成員無法繼承由部分信任程式碼。</span>
      <span class="sxs-lookup">
        <span data-stu-id="700b1-109">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="700b1-110">需要完全信任立即呼叫者。</span>
      <span class="sxs-lookup">
        <span data-stu-id="700b1-110">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="700b1-111">這個類別無法供部分信任或安全性透明程式碼。</span>
      <span class="sxs-lookup">
        <span data-stu-id="700b1-111">This class cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="700b1-112">無效控制代碼的值 (通常是 0 或 -1)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-112">The value of an invalid handle (usually 0 or -1).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="700b1-113">使用指定的無效控制代碼值，初始化 <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="700b1-114">衍生類別位於沒有 Unmanaged 程式碼存取權限的組件中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="700b1-115">針對繼承者完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-115">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="700b1-116">這個成員無法繼承由部分信任程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-116">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="700b1-117">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-117">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="700b1-118">這個類別無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-118">This class cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="700b1-119">標記要釋出和釋放資源的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-119">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-120">呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法可讓要釋放資源。</span><span class="sxs-lookup"><span data-stu-id="700b1-120">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="700b1-121">不同於<xref:System.Runtime.InteropServices.SafeHandle>類別，這一律會發生立即因為沒有參考計數，以指出其他執行緒正在使用此控制代碼。</span><span class="sxs-lookup"><span data-stu-id="700b1-121">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="700b1-122">因此，您必須採用同步處理機制，以確保其安全地呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-122">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="700b1-123">雖然大部分的類別使用<xref:System.Runtime.InteropServices.CriticalHandle>類別不需要提供完成項，這有時是必要 （例如，清除檔案緩衝區，或者撰寫一些資料放回記憶體）。</span><span class="sxs-lookup"><span data-stu-id="700b1-123">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="700b1-124">在此情況下，類別可以提供一定會先執行完成項<xref:System.Runtime.InteropServices.CriticalHandle>重要的完成項執行。</span><span class="sxs-lookup"><span data-stu-id="700b1-124">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="700b1-125">呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法，當您完成使用<xref:System.Runtime.InteropServices.CriticalHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-125">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="700b1-126"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>方法會使<xref:System.Runtime.InteropServices.CriticalHandle>中無法使用的狀態物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-126">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="700b1-127">**請注意**永遠呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>您釋放最後一個參考之前<xref:System.Runtime.InteropServices.CriticalHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-127">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="700b1-128">否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Runtime.InteropServices.CriticalHandle> 物件的 <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-128">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="700b1-129">標記要釋出和釋放資源的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-129">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="700b1-130">釋放 <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> 所使用的所有資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-131">呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法可讓要釋放資源。</span><span class="sxs-lookup"><span data-stu-id="700b1-131">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="700b1-132">不同於<xref:System.Runtime.InteropServices.SafeHandle>類別，這一律會發生立即因為沒有參考計數，以指出其他執行緒正在使用此控制代碼。</span><span class="sxs-lookup"><span data-stu-id="700b1-132">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="700b1-133">因此，您必須採用同步處理機制，以確保其安全地呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-133">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="700b1-134">雖然大部分的類別使用<xref:System.Runtime.InteropServices.CriticalHandle>類別不需要提供完成項，這有時是必要 （例如，清除檔案緩衝區，或者撰寫一些資料放回記憶體）。</span><span class="sxs-lookup"><span data-stu-id="700b1-134">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="700b1-135">在此情況下，類別可以提供一定會先執行完成項<xref:System.Runtime.InteropServices.CriticalHandle>重要的完成項執行。</span><span class="sxs-lookup"><span data-stu-id="700b1-135">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="700b1-136">呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法，當您完成使用<xref:System.Runtime.InteropServices.CriticalHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-136">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="700b1-137"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>方法會使<xref:System.Runtime.InteropServices.CriticalHandle>中無法使用的狀態物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-137">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="700b1-138">**請注意**永遠呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法之前您釋放最後一個參考<xref:System.Runtime.InteropServices.CriticalHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-138">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="700b1-139">否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Runtime.InteropServices.CriticalHandle> 物件的 <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-139">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="700b1-140">
            <see langword="true" /> 表示一般處置作業，而 <see langword="false" /> 則表示完成控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-140">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="700b1-141">釋放 <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> 類別所使用的 Unmanaged 資源，指定是否要執行一般處置作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-142">您應該永遠不會明確地呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法`disposing`參數設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="700b1-142">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="700b1-143">釋放與控制代碼相關的所有資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-143">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-144"><xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>方法是解構函式<xref:System.Runtime.InteropServices.CriticalHandle>類別。</span><span class="sxs-lookup"><span data-stu-id="700b1-144">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="700b1-145">應用程式程式碼不應該直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-145">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="700b1-146">指定要包裝的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-146">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-147">公開不公開控制代碼 (也就是說，衍生的類別之外)。</span><span class="sxs-lookup"><span data-stu-id="700b1-147">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="700b1-148">取得值，指出控制代碼是否已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-148">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="700b1-149">如果控制代碼已關閉，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-149">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-150"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>方法傳回值，指出是否<xref:System.Runtime.InteropServices.CriticalHandle>物件的控制代碼不再與原生資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="700b1-150">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="700b1-151">這不同於的定義<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>屬性，計算是否一律視為指定的控制代碼無效。</span><span class="sxs-lookup"><span data-stu-id="700b1-151">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="700b1-152"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>方法會傳回`true`值在下列情況：</span><span class="sxs-lookup"><span data-stu-id="700b1-152">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="700b1-153"><xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-153">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="700b1-154"><xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法或<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>而呼叫方法，且沒有參考至<xref:System.Runtime.InteropServices.CriticalHandle>其他執行緒上的物件。</span><span class="sxs-lookup"><span data-stu-id="700b1-154">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="700b1-155">在衍生類別中覆寫時，取得值以指出這個控制代碼值是否無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="700b1-156">如果控制代碼有效則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-156">
              <see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-157">在衍生的類別必須實作<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>屬性，以便決定是否需要重大的最終處理，通用語言執行平台。</span><span class="sxs-lookup"><span data-stu-id="700b1-157">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="700b1-158">在衍生的類別必須提供符合它們支援的控制代碼的一般類型的實作 （0 或-1 無效）。</span><span class="sxs-lookup"><span data-stu-id="700b1-158">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="700b1-159">這些類別可以再進一步衍生特定的安全控制代碼類型。</span><span class="sxs-lookup"><span data-stu-id="700b1-159">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="700b1-160">不同於<xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>屬性，報告是否<xref:System.Runtime.InteropServices.CriticalHandle>物件已經完成使用基礎控制代碼，<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>屬性計算是否一律視為指定的控制代碼值無效。</span><span class="sxs-lookup"><span data-stu-id="700b1-160">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="700b1-161">因此，<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>屬性一律會傳回相同值的任何一個控制代碼值。</span><span class="sxs-lookup"><span data-stu-id="700b1-161">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="700b1-162">在衍生類別中覆寫時，執行釋放控制代碼所需的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-162">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="700b1-163">如果成功釋放控制代碼，則為 <see langword="true" />；如果發生嚴重失敗的事件，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-163">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="700b1-164">在這種情況下，它會產生 [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed 偵錯助理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-165"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>方法保證僅一次，前提是您採用適當的同步處理機制，以確保只有一個呼叫<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法進行。</span><span class="sxs-lookup"><span data-stu-id="700b1-165">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="700b1-166"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>將不會呼叫方法，如果<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="700b1-166">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="700b1-167">實作這個方法在您<xref:System.Runtime.InteropServices.CriticalHandle>衍生類別，執行釋放控制代碼所需的任何程式碼。</span><span class="sxs-lookup"><span data-stu-id="700b1-167">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="700b1-168">因為其中一個函式的<xref:System.Runtime.InteropServices.CriticalHandle>是保證的資源流失，您的實作中的程式碼防護<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>必須永遠不會失敗。</span><span class="sxs-lookup"><span data-stu-id="700b1-168">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="700b1-169">記憶體回收行程呼叫<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>之後正常完成項已執行之物件的同時，回收，並且正在進行中的資源，以叫用和，它將不會中斷，而它的保證。</span><span class="sxs-lookup"><span data-stu-id="700b1-169">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="700b1-170">這個方法會在執行個體 （以及它以靜態方式判斷呼叫歷程圖中的方法） 的建構階段準備做為限制的執行區域 (CER)。</span><span class="sxs-lookup"><span data-stu-id="700b1-170">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="700b1-171">雖然這會防止執行緒中止插斷，但您仍然必須小心，不要導入任何錯誤路徑，在您覆寫<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="700b1-171">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="700b1-172">特別是，套用<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性設定為您從呼叫任何方法<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>。</span><span class="sxs-lookup"><span data-stu-id="700b1-172">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="700b1-173">在大部分情況下應使用此程式碼：</span><span class="sxs-lookup"><span data-stu-id="700b1-173">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="700b1-174">此外，對於簡單的清除 (例如，呼叫 Win32 API`CloseHandle`上的檔案控制代碼) 為單一平台叫用呼叫，您可以檢查傳回的值。</span><span class="sxs-lookup"><span data-stu-id="700b1-174">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="700b1-175">複雜的清除，您可能使用大量的程式邏輯和多個方法呼叫，其中有些可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="700b1-175">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="700b1-176">您必須確定您的程式邏輯具有回溯程式碼，針對每個這種情況。</span><span class="sxs-lookup"><span data-stu-id="700b1-176">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="700b1-177">如果<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>方法會傳回`false`基於任何理由，它會產生[releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed 偵錯助理。</span><span class="sxs-lookup"><span data-stu-id="700b1-177">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="700b1-178">要使用的既有控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-178">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="700b1-179">將控制代碼設定為指定的既有控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-179">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-180">使用<xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A>方法，您需要支援既有控制代碼 （例如，如果在結構中傳回的控制代碼） 因為.NET Framework COM interop 的基礎結構不支援封送處理時，才會處理結構中。</span><span class="sxs-lookup"><span data-stu-id="700b1-180">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="700b1-181">將控制代碼標示為無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="700b1-181">Marks a handle as invalid.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="700b1-182">呼叫<xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>方法只有在您知道您的控制代碼無效，而且想要將它標示為時。</span><span class="sxs-lookup"><span data-stu-id="700b1-182">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="700b1-183">如此一來，不會變更的值<xref:System.Runtime.InteropServices.CriticalHandle.handle>欄位; 它只會將標示為無效的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="700b1-183">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="700b1-184">控制代碼，則可能會包含過時的值。</span><span class="sxs-lookup"><span data-stu-id="700b1-184">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="700b1-185">這個呼叫的效果是，不會嘗試釋放資源。</span><span class="sxs-lookup"><span data-stu-id="700b1-185">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="700b1-186">如同<xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A>方法，請使用<xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>只有當您需要支援既有控制代碼。</span><span class="sxs-lookup"><span data-stu-id="700b1-186">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>