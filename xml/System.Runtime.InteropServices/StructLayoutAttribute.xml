<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="StructLayoutAttribute.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac540521d9554f0cf59a81ca8f000f7fb5aa654a557.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">40521d9554f0cf59a81ca8f000f7fb5aa654a557</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Lets you control the physical layout of the data fields of a class or structure in memory.</source>
          <target state="translated">讓您控制記憶體中類別或結構之資料欄位的實際配置。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>You can apply this attribute to classes or structures.</source>
          <target state="translated">您可以將此屬性套用至類別或結構。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</source>
          <target state="translated">Common language runtime 會控制類別或結構在 managed 記憶體中的資料欄位的實際配置。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>However, if you want to pass the type to unmanaged code, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute to control the unmanaged layout of the type.</source>
          <target state="translated">不過，如果您想要此型別傳遞至 unmanaged 程式碼，您可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>屬性來控制 unmanaged 的類型的配置。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> to force the members to be laid out sequentially in the order they appear.</source>
          <target state="translated">使用具有屬性<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>強制要循序配置它們出現的順序中的成員。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For , <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> controls both the layout in managed memory and the layout in unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>控制和 unmanaged 記憶體中的配置都配置於 managed 記憶體中的。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</source>
          <target state="translated">對於非 blittable 類型，它會控制配置，類別或結構會封送處理至 unmanaged 程式碼，但不會控制在 managed 記憶體中的配置時。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> to control the precise position of each data member.</source>
          <target state="translated">使用具有屬性<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>來控制每個資料成員的精確位置。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>This affects both managed and unmanaged layout, for both blittable and non-blittable types.</source>
          <target state="translated">這會影響 managed 和 unmanaged 兩種版面配置，blittable 和非 blittable 類型。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> requires that you use the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> attribute to indicate the position of each field within the type.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>需要您使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph>屬性來指出每個欄位的型別內的位置。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>C#, Visual Basic, and C++ compilers apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> layout value to structures by default.</source>
          <target state="translated">C#、 Visual Basic 和 c + + 編譯器套用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph>到預設的結構的配置值。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For classes, you must apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value explicitly.</source>
          <target state="translated">對於類別，您必須套用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>明確值。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> also applies the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute; it always applies the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value when it imports a type library.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （類型程式庫匯入工具）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>也適用於<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>屬性; 它會一律套用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>匯入類型程式庫時的值。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The following example demonstrates a managed declaration of the <ph id="ph1">`GetSystemTime`</ph> function and defines <ph id="ph2">`MySystemTime`</ph> class with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> layout.</source>
          <target state="translated">下列範例會示範 managed 的宣告<ph id="ph1">`GetSystemTime`</ph>函式，並定義<ph id="ph2">`MySystemTime`</ph>類別<ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>版面配置。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source><ph id="ph1">`GetSystemTime`</ph> gets the system time and prints to the console.</source>
          <target state="translated"><ph id="ph1">`GetSystemTime`</ph> 取得系統時間，並列印到主控台。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>A 16-bit integer that represents one of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> values that specifes how the class or structure should be arranged.</source>
          <target state="translated">代表其中一個 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 值的 16 位元整數，指定類別或結構的排列方式。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">使用指定的 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 列舉成員初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>This constructor takes an underlying 16-bit integer that represents each <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration member.</source>
          <target state="translated">這個建構函式接受基礎 16 位元整數，表示每個<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph>列舉成員。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> uses this constructor.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （類型程式庫匯入工具）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>會使用這個建構函式。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>One of the enumeration values that specifes how the class or structure should be arranged.</source>
          <target state="translated">其中一個列舉值，指定類別或結構的排列方式。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">使用指定的 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 列舉成員初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>For readable code that is less prone to error, always use this constructor.</source>
          <target state="translated">可讀取的程式碼較不容易出錯，一律使用這個建構函式。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>Indicates whether string data fields within the class should be marshaled as <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> or <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> by default.</source>
          <target state="translated">表示根據預設，類別中的字串資料欄位應該封送處理為 <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph>，還是 <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>, all string arguments are converted to Unicode characters (<ph id="ph3">`LPWSTR`</ph>) before they are passed to the unmanaged implementation.</source>
          <target state="translated">如果<ph id="ph1">`CharSet`</ph>欄位設定為<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>，所有的字串引數都會轉換成 Unicode 字元 (<ph id="ph3">`LPWSTR`</ph>) 傳遞至 unmanaged 實作之前。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the field is set to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>, the strings are converted to ANSI strings (<ph id="ph2">`LPSTR`</ph>).</source>
          <target state="translated">如果欄位設定為<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>，字串會轉換為 ANSI 字串 (<ph id="ph2">`LPSTR`</ph>)。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</source>
          <target state="translated">如果<ph id="ph1">`CharSet`</ph>欄位設定為<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>，轉換為平台相依 (ANSI Windows 98 和 Windows Me，以及更新版本上的 Unicode)。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Controls the alignment of data fields of a class or structure in memory.</source>
          <target state="translated">控制記憶體中類別或結構之資料欄位的對齊。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field controls the alignment of a type's fields in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>欄位控制項類型的欄位，在記憶體中的對齊方式。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>It affects both <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">它會同時影響<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>By default, the value is 0, indicating the default packing size for the current platform.</source>
          <target state="translated">根據預設，值為 0，指出預設的封裝大小目前平台。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>必須是 0、 1、 2、 4、 8、 16、 32、 64、 或 128:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The fields of a type instance are aligned by using the following rules:</source>
          <target state="translated">類型執行個體的欄位對齊，使用下列規則：</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</source>
          <target state="translated">類型的對齊是其最大項目的大小 (1、 2、 4、 8 等等，位元組) 或指定的封裝大小為準。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</source>
          <target state="translated">每個欄位必須配合自己大小的欄位 (1、 2、 4、 8 等等，位元組) 或類型的對齊方式小者為準。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</source>
          <target state="translated">因為類型的預設對齊是其最大項目，也就是大於或等於其他所有的欄位長度，大小這通常表示欄位對齊其大小。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields align on 1-byte boundaries, <ph id="ph2">&lt;xref:System.Int16&gt;</ph> fields align on 2-byte boundaries, and <ph id="ph3">&lt;xref:System.Int32&gt;</ph> fields align on 4-byte boundaries.</source>
          <target state="translated">比方說，即使在類型中的最大欄位是 64 位元 （8 個位元組） 整數或組件欄位就會設定為 8， <ph id="ph1">&lt;xref:System.Byte&gt;</ph> 1 位元組界限上對齊欄位<ph id="ph2">&lt;xref:System.Int16&gt;</ph>2 位元組界限上對齊欄位和<ph id="ph3">&lt;xref:System.Int32&gt;</ph>欄位對齊 4 位元組界限。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Padding is added between fields to satisfy the alignment requirements.</source>
          <target state="translated">為了滿足的對齊需求的欄位之間加上填補。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, consider the following structure, which consists of two <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields and one <ph id="ph2">&lt;xref:System.Int32&gt;</ph> field, when it is used with various values for the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field.</source>
          <target state="translated">例如，請考慮下列的結構包含兩個<ph id="ph1">&lt;xref:System.Byte&gt;</ph>欄位和一個<ph id="ph2">&lt;xref:System.Int32&gt;</ph>時的各種值搭配使用的欄位<ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>欄位。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To successfully compile the C# examples, you must specify the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">若要成功編譯 C# 範例，您必須指定<ph id="ph1">`/unsafe`</ph>編譯器參數。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If you specify the default packing size, the size of the structure is 8 bytes.</source>
          <target state="translated">如果您指定預設的封裝大小，則結構的大小是 8 位元組。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</source>
          <target state="translated">兩個位元組會佔用前的兩個位元組的記憶體，因為位元組必須對齊一個位元組界限。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is 4 bytes, which is the size of its largest fields, <ph id="ph1">`i3`</ph>, there are two bytes of padding followed by the integer field.</source>
          <target state="translated">類型的預設對齊是 4 個位元組，也就是其最大欄位的大小，因為<ph id="ph1">`i3`</ph>，有兩個位元組，後面接著整數欄位留白。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 6 bytes.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>設為 2，此結構的大小是 6 個位元組。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>As before, the two bytes occupy the first two bytes of memory.</source>
          <target state="translated">為之前，兩個位元組所佔用的記憶體前兩個位元組。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</source>
          <target state="translated">因為欄位現在對齊 2 位元組界限，所以第二個位元組和整數之間的任何填補。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, <ph id="ph2">`i3`</ph>, which is 4.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>設為 4，結構的大小是預設案例中，在其最大欄位大小所定義類型的對齊方式，與相同<ph id="ph2">`i3`</ph>，為 4。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the still same as in the default case, because the <ph id="ph2">`i3`</ph> field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>設為 8，結構的大小是否仍然與預設值在相同的大小寫，因為<ph id="ph2">`i3`</ph>欄位對齊 4 位元組界限，這可能會小於組件欄位所指定的 8 位元組界限上。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</source>
          <target state="translated">若要另一個範例，請考慮下列的結構，其中包含兩個位元組的欄位、 一個 32 位元帶正負號的整數欄位、 一個單一元素位元組陣列和十進位值。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>With the default packing size, the size of the structure is 28 bytes.</source>
          <target state="translated">預設的封裝大小，與結構的大小是 28 個位元組。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</source>
          <target state="translated">兩個位元組所佔用的記憶體，後面接著兩個位元組填補整數的前兩個位元組。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Next is the one-byte array, followed by three bytes of padding.</source>
          <target state="translated">接下來是一個位元組陣列，後面接著三個位元組填補。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <ph id="ph2">&lt;xref:System.Int32&gt;</ph> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> structure as a whole.</source>
          <target state="translated">最後， <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>  欄位中，d5，將 4 位元組界限上對齊十進位值包含四個，因此<ph id="ph2">&lt;xref:System.Int32&gt;</ph>欄位，因此其對齊會根據最大大小的欄位，而不是大小<ph id="ph3">&lt;xref:System.Decimal&gt;</ph>整體結構。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 24 bytes.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>設為 2，結構的大小是 24 個位元組。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</source>
          <target state="translated">相較於預設的對齊方式，因為類型的對齊方式現在是 4，而不是 2，已被移除兩個位元組的兩個位元組和整數之間的填補。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>And the three bytes of padding after <ph id="ph1">`a4`</ph> have been replaced by one byte of padding, since <ph id="ph2">`d5`</ph> now aligns on a 2-byte boundary rather than a 4-byte boundary.</source>
          <target state="translated">和三個位元組填補之後<ph id="ph1">`a4`</ph>已由一個位元組的填補，因為取代<ph id="ph2">`d5`</ph>現在 2 位元組界限，而不是 4 位元組界限上對齊。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>設為 8，結構的大小是相同預設案例中，因為在此結構中的對齊需求會小於 8。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field is frequently used when structures are exported during disk and network write operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>結構匯出期間磁碟和網路寫入作業時經常使用欄位。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The field is also frequently used during platform invoke and interop operations.</source>
          <target state="translated">此欄位也經常會用在平台叫用和 interop 作業。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</source>
          <target state="translated">有時候，欄位用來產生更緊密的封裝大小減少記憶體需求。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</source>
          <target state="translated">不過，這種使用方式需要仔細考量的實際硬體的條件約束，而實際上可能會降低效能。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>Indicates the absolute size of the class or structure.</source>
          <target state="translated">指示結構或類別的絕對大小。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</source>
          <target state="translated">此欄位必須是等於或大於的總大小，以位元組為單位的類別或結構成員。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</source>
          <target state="translated">這個欄位是主要用於編譯器寫入器會想要擴充的結構未受管理的直接存取所佔用的記憶體。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>For example, you can use this field when working with unions that are not represented in metadata directly.</source>
          <target state="translated">例如，您可以使用這個欄位使用未在中繼資料中直接呈現的等位時。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> value that specifies how the class or structure is arranged.</source>
          <target state="translated">取得 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 值，指定類別或結構的排列方式。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>One of the enumeration values that specifies how the class or structure is arranged.</source>
          <target state="translated">其中一個列舉值，指定類別或結構的排列方式。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>