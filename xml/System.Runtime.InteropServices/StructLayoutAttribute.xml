<Type Name="StructLayoutAttribute" FullName="System.Runtime.InteropServices.StructLayoutAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db9d17e61314349383ef30525e10979ba1b06e55" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57930007" /></Metadata><TypeSignature Language="C#" Value="public sealed class StructLayoutAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StructLayoutAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.StructLayoutAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StructLayoutAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class StructLayoutAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type StructLayoutAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="31588-101">讓您控制記憶體中類別或結構之資料欄位的實際配置。</span><span class="sxs-lookup"><span data-stu-id="31588-101">Lets you control the physical layout of the data fields of a class or structure in memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31588-102">您可以將此屬性套用至類別或結構中。</span><span class="sxs-lookup"><span data-stu-id="31588-102">You can apply this attribute to classes or structures.</span></span>  
  
 <span data-ttu-id="31588-103">Common language runtime 會控制資料欄位的類別或結構，在受管理的記憶體中的實體配置。</span><span class="sxs-lookup"><span data-stu-id="31588-103">The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</span></span> <span data-ttu-id="31588-104">不過，如果您想要將類型傳遞至 unmanaged 程式碼，您可以使用<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性來控制非受控的類型的配置。</span><span class="sxs-lookup"><span data-stu-id="31588-104">However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type.</span></span> <span data-ttu-id="31588-105">屬性搭配使用的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>強制要循序配置其出現的順序中的成員。</span><span class="sxs-lookup"><span data-stu-id="31588-105">Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> to force the members to be laid out sequentially in the order they appear.</span></span> <span data-ttu-id="31588-106">Blittable 類型<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>控制兩個 managed 記憶體中的配置和版面配置 unmanaged 記憶體中的。</span><span class="sxs-lookup"><span data-stu-id="31588-106">For blittable types, <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> controls both the layout in managed memory and the layout in unmanaged memory.</span></span> <span data-ttu-id="31588-107">非 blittable 類型，它會控制配置，當類別或結構會封送處理至 unmanaged 程式碼，但不會控制在受管理的記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="31588-107">For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</span></span> <span data-ttu-id="31588-108">屬性搭配使用的<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>來控制每個資料成員的精確位置。</span><span class="sxs-lookup"><span data-stu-id="31588-108">Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> to control the precise position of each data member.</span></span> <span data-ttu-id="31588-109">這會影響 managed 和 unmanaged 兩種版面配置，blittable 和非 blittable 類型。</span><span class="sxs-lookup"><span data-stu-id="31588-109">This affects both managed and unmanaged layout, for both blittable and non-blittable types.</span></span> <span data-ttu-id="31588-110">使用<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>需要您使用<xref:System.Runtime.InteropServices.FieldOffsetAttribute>屬性來指出每個欄位的型別內的位置。</span><span class="sxs-lookup"><span data-stu-id="31588-110">Using <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.</span></span>  
  
 <span data-ttu-id="31588-111">適用於 C#、 Visual Basic 和 c + + 編譯器<xref:System.Runtime.InteropServices.LayoutKind.Sequential>預設結構的配置值。</span><span class="sxs-lookup"><span data-stu-id="31588-111">C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default.</span></span> <span data-ttu-id="31588-112">對於類別而言，您必須套用<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>明確值。</span><span class="sxs-lookup"><span data-stu-id="31588-112">For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> value explicitly.</span></span> <span data-ttu-id="31588-113">[Tlbimp.exe （型別程式庫匯入工具）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)也適用於<xref:System.Runtime.InteropServices.StructLayoutAttribute>屬性，因為它一律會套用<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>時匯入類型程式庫的值。</span><span class="sxs-lookup"><span data-stu-id="31588-113">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> value when it imports a type library.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31588-114">下列範例示範 managed 的宣告`GetSystemTime`函式，並定義`MySystemTime`類別<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>版面配置。</span><span class="sxs-lookup"><span data-stu-id="31588-114">The following example demonstrates a managed declaration of the `GetSystemTime` function and defines `MySystemTime` class with <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> layout.</span></span> <span data-ttu-id="31588-115">`GetSystemTime` 取得系統時間，並列印至主控台。</span><span class="sxs-lookup"><span data-stu-id="31588-115">`GetSystemTime` gets the system time and prints to the console.</span></span>  
  
 [!code-cpp[StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/StructLayoutAttribute/CPP/structlayoutattribute.cpp#1)]
 [!code-csharp[StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/StructLayoutAttribute/CS/structlayoutattribute.cs#1)]
 [!code-vb[StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StructLayoutAttribute/VB/structlayoutattribute.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/tools/tlbimp-exe-type-library-importer.md"><span data-ttu-id="31588-116">Tlbimp.exe (類型程式庫匯入工具)</span><span class="sxs-lookup"><span data-stu-id="31588-116">Tlbimp.exe (Type Library Importer)</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31588-117">初始化 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="31588-117">Initalizes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (short layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int16 layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (layoutKind As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(short layoutKind);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.StructLayoutAttribute : int16 -&gt; System.Runtime.InteropServices.StructLayoutAttribute" Usage="new System.Runtime.InteropServices.StructLayoutAttribute layoutKind" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Int16" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="layoutKind"><span data-ttu-id="31588-118">代表其中一個 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 值的 16 位元整數，指定類別或結構的排列方式。</span><span class="sxs-lookup"><span data-stu-id="31588-118">A 16-bit integer that represents one of the <see cref="T:System.Runtime.InteropServices.LayoutKind" /> values that specifes how the class or structure should be arranged.</span></span></param>
        <summary><span data-ttu-id="31588-119">使用指定的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 列舉成員初始化 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="31588-119">Initalizes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class with the specified <see cref="T:System.Runtime.InteropServices.LayoutKind" /> enumeration member.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31588-120">這個建構函式為基礎的 16 位元整數代表每個<xref:System.Runtime.InteropServices.LayoutKind>列舉成員。</span><span class="sxs-lookup"><span data-stu-id="31588-120">This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member.</span></span> <span data-ttu-id="31588-121">[Tlbimp.exe （型別程式庫匯入工具）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)會使用這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="31588-121">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
        <related type="Article" href="~/docs/framework/tools/tlbimp-exe-type-library-importer.md"><span data-ttu-id="31588-122">Tlbimp.exe (類型程式庫匯入工具)</span><span class="sxs-lookup"><span data-stu-id="31588-122">Tlbimp.exe (Type Library Importer)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (System.Runtime.InteropServices.LayoutKind layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.InteropServices.LayoutKind layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(System::Runtime::InteropServices::LayoutKind layoutKind);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.StructLayoutAttribute : System.Runtime.InteropServices.LayoutKind -&gt; System.Runtime.InteropServices.StructLayoutAttribute" Usage="new System.Runtime.InteropServices.StructLayoutAttribute layoutKind" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Runtime.InteropServices.LayoutKind" />
      </Parameters>
      <Docs>
        <param name="layoutKind"><span data-ttu-id="31588-123">其中一個列舉值，指定類別或結構的排列方式。</span><span class="sxs-lookup"><span data-stu-id="31588-123">One of the enumeration values that specifes how the class or structure should be arranged.</span></span></param>
        <summary><span data-ttu-id="31588-124">使用指定的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 列舉成員初始化 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="31588-124">Initalizes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class with the specified <see cref="T:System.Runtime.InteropServices.LayoutKind" /> enumeration member.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31588-125">針對可讀取的程式碼較不容易出錯，一律使用這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="31588-125">For readable code that is less prone to error, always use this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.StructLayoutAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31588-126">表示根據預設，類別中的字串資料欄位應該封送處理為 <see langword="LPWSTR" />，還是 <see langword="LPSTR" />。</span><span class="sxs-lookup"><span data-stu-id="31588-126">Indicates whether string data fields within the class should be marshaled as <see langword="LPWSTR" /> or <see langword="LPSTR" /> by default.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31588-127">如果`CharSet`欄位設定為<xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>，所有的字串引數都會轉換成 Unicode 字元 (`LPWSTR`) 傳遞至 unmanaged 實作之前。</span><span class="sxs-lookup"><span data-stu-id="31588-127">If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation.</span></span> <span data-ttu-id="31588-128">如果欄位設定為<xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>，將字串轉換為 ANSI 字串 (`LPSTR`)。</span><span class="sxs-lookup"><span data-stu-id="31588-128">If the field is set to <xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>, the strings are converted to ANSI strings (`LPSTR`).</span></span> <span data-ttu-id="31588-129">如果`CharSet`欄位設定為<xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>，轉換為平台相依 (在 Windows 98 和 Windows Me 和更新版本上的為 Unicode 的 ANSI)。</span><span class="sxs-lookup"><span data-stu-id="31588-129">If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public int Pack;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Pack" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack" />
      <MemberSignature Language="VB.NET" Value="Public Pack As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Pack;" />
      <MemberSignature Language="F#" Value="val mutable Pack : int" Usage="System.Runtime.InteropServices.StructLayoutAttribute.Pack" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31588-130">控制記憶體中類別或結構之資料欄位的對齊。</span><span class="sxs-lookup"><span data-stu-id="31588-130">Controls the alignment of data fields of a class or structure in memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31588-131"><xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>欄位控制項類型的欄位，在記憶體中的對齊方式。</span><span class="sxs-lookup"><span data-stu-id="31588-131">The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.</span></span>  <span data-ttu-id="31588-132">它會影響兩者<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>和<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="31588-132">It affects both <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31588-133">根據預設，值會是 0，指出預設的封裝大小為目前的平台。</span><span class="sxs-lookup"><span data-stu-id="31588-133">By default, the value is 0, indicating the default packing size for the current platform.</span></span> <span data-ttu-id="31588-134">值<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>必須是 0、 1、 2、 4、 8、 16、 32、 64 或 128:</span><span class="sxs-lookup"><span data-stu-id="31588-134">The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</span></span>  
  
 <span data-ttu-id="31588-135">類型執行個體欄位對齊藉由使用下列規則：</span><span class="sxs-lookup"><span data-stu-id="31588-135">The fields of a type instance are aligned by using the following rules:</span></span>  
  
-   <span data-ttu-id="31588-136">類型的對齊是其最大項目的大小 (1、 2、 4、 8 等等，位元組為單位) 或指定的封裝大小，取其較小。</span><span class="sxs-lookup"><span data-stu-id="31588-136">The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</span></span>  
  
-   <span data-ttu-id="31588-137">每個欄位必須配合欄位本身的大小 (1、 2、 4、 8 等等，位元組為單位) 或類型的對齊，取其較小。</span><span class="sxs-lookup"><span data-stu-id="31588-137">Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</span></span>  <span data-ttu-id="31588-138">因為類型的預設對齊是其最大的項目，也就是大於或等於為所有其他欄位長度的大小，這通常表示欄位會對齊其大小。</span><span class="sxs-lookup"><span data-stu-id="31588-138">Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</span></span> <span data-ttu-id="31588-139">比方說，即使最大的欄位型別中的 64 位元 （8 個位元組） 整數或組件欄位設為 8、<xref:System.Byte>欄位對齊 1 個位元組的界限<xref:System.Int16>對齊 2 位元組界限上的欄位和<xref:System.Int32>欄位對齊 4 位元組的界限。</span><span class="sxs-lookup"><span data-stu-id="31588-139">For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.</span></span>  
  
-   <span data-ttu-id="31588-140">為滿足的對齊需求的欄位之間加入填補。</span><span class="sxs-lookup"><span data-stu-id="31588-140">Padding is added between fields to satisfy the alignment requirements.</span></span>  
  
 <span data-ttu-id="31588-141">例如，請考慮下列結構，其中包含兩個<xref:System.Byte>欄位和一個<xref:System.Int32>時的各種值搭配使用的欄位<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>欄位。</span><span class="sxs-lookup"><span data-stu-id="31588-141">For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="31588-142">若要成功編譯的 C# 範例，您必須指定`/unsafe`編譯器參數。</span><span class="sxs-lookup"><span data-stu-id="31588-142">To successfully compile the C# examples, you must specify the `/unsafe` compiler switch.</span></span>  
  
 <span data-ttu-id="31588-143">如果您指定預設的封裝大小，則結構的大小是 8 個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-143">If you specify the default packing size, the size of the structure is 8 bytes.</span></span> <span data-ttu-id="31588-144">因為位元組必須對齊一個位元組的界限，兩個位元組會佔用的記憶體，前兩個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-144">The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</span></span> <span data-ttu-id="31588-145">類型的預設對齊是 4 個位元組，也就是其最大欄位大小，因為`i3`，有兩個位元組，後面接著 [整數] 欄位留白。</span><span class="sxs-lookup"><span data-stu-id="31588-145">Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]  
  
 <span data-ttu-id="31588-146">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>設為 2，結構的大小為 6 個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-146">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes.</span></span> <span data-ttu-id="31588-147">為之前，兩個位元組所佔用的前兩個位元組的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31588-147">As before, the two bytes occupy the first two bytes of memory.</span></span> <span data-ttu-id="31588-148">因為欄位現在對齊 2 位元組界限上，沒有任何第二個位元組整數之間的填補量。</span><span class="sxs-lookup"><span data-stu-id="31588-148">Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]  
  
 <span data-ttu-id="31588-149">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>設為 4，結構的大小會是預設案例中，其中其最大欄位大小所定義類型的對齊方式，與相同`i3`，這是 4。</span><span class="sxs-lookup"><span data-stu-id="31588-149">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, `i3`, which is 4.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]  
  
 <span data-ttu-id="31588-150">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>設為 8，結構的大小是仍然相同預設情況下，因為`i3`欄位對齊 4 位元組界限，也就是小於組件欄位所指定的 8 位元組界限。</span><span class="sxs-lookup"><span data-stu-id="31588-150">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the still same as in the default case, because the `i3` field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]  
  
 <span data-ttu-id="31588-151">若要另一個範例，請考慮下列結構，其中包含兩個位元組的欄位、 一個 32 位元帶正負號的整數欄位、 一個單一元素位元組陣列和十進位值。</span><span class="sxs-lookup"><span data-stu-id="31588-151">To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</span></span> <span data-ttu-id="31588-152">預設的封裝大小，與結構的大小會是 28 個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-152">With the default packing size, the size of the structure is 28 bytes.</span></span> <span data-ttu-id="31588-153">兩個位元組佔滿前的兩個位元組的記憶體，後面接著兩個位元組填補，後面接著的整數。</span><span class="sxs-lookup"><span data-stu-id="31588-153">The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</span></span> <span data-ttu-id="31588-154">接下來是填補的一個位元組陣列，後面接著三個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-154">Next is the one-byte array, followed by three bytes of padding.</span></span> <span data-ttu-id="31588-155">最後， <xref:System.Decimal>  欄位中，d5，將 4 位元組界限上對齊，因為十進位值包含四個<xref:System.Int32>欄位，因此其對齊根據最大大小的欄位，而不是大小<xref:System.Decimal>整體結構。</span><span class="sxs-lookup"><span data-stu-id="31588-155">Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]  
  
 <span data-ttu-id="31588-156">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>設為 2，結構的大小是 24 個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-156">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes.</span></span> <span data-ttu-id="31588-157">相較於預設的對齊方式，因為此類型的對齊方式現在是 4，而不是 2，已被移除兩個位元組整數之間的填補兩個位元組。</span><span class="sxs-lookup"><span data-stu-id="31588-157">In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</span></span> <span data-ttu-id="31588-158">和三個位元組之後的填補`a4`已取代一個位元組的填補，因為`d5`現在 2 位元組界限，而不是 4 位元組界限上對齊。</span><span class="sxs-lookup"><span data-stu-id="31588-158">And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]  
  
 <span data-ttu-id="31588-159">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>設為 8，結構的大小是相同的預設情況下，因為在此結構中的對齊需求小於 8。</span><span class="sxs-lookup"><span data-stu-id="31588-159">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]  
  
 <span data-ttu-id="31588-160"><xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>欄位通常用於結構匯出期間磁碟和網路寫入作業。</span><span class="sxs-lookup"><span data-stu-id="31588-160">The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations.</span></span> <span data-ttu-id="31588-161">欄位也經常用於平台叫用和 interop 的作業。</span><span class="sxs-lookup"><span data-stu-id="31588-161">The field is also frequently used during platform invoke and interop operations.</span></span>  
  
 <span data-ttu-id="31588-162">有時候，欄位用來產生更緊密的封裝大小減少記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="31588-162">Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</span></span> <span data-ttu-id="31588-163">不過，這種使用方式需要仔細考量的實際的硬體限制，而且實際上可能會降低效能。</span><span class="sxs-lookup"><span data-stu-id="31588-163">However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Size" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Size" />
      <MemberSignature Language="VB.NET" Value="Public Size As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Size;" />
      <MemberSignature Language="F#" Value="val mutable Size : int" Usage="System.Runtime.InteropServices.StructLayoutAttribute.Size" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31588-164">指示結構或類別的絕對大小。</span><span class="sxs-lookup"><span data-stu-id="31588-164">Indicates the absolute size of the class or structure.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31588-165">此欄位必須是等於或大於的總大小，以位元組為單位的類別或結構成員。</span><span class="sxs-lookup"><span data-stu-id="31588-165">This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</span></span> <span data-ttu-id="31588-166">此欄位主要是供編譯器寫入器會想要擴充直接、 未受管理的存取權的結構所佔用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31588-166">This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</span></span> <span data-ttu-id="31588-167">比方說，您可以在使用未在中繼資料中直接表示等位時，使用此欄位。</span><span class="sxs-lookup"><span data-stu-id="31588-167">For example, you can use this field when working with unions that are not represented in metadata directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.LayoutKind Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.LayoutKind Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.StructLayoutAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As LayoutKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::InteropServices::LayoutKind Value { System::Runtime::InteropServices::LayoutKind get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : System.Runtime.InteropServices.LayoutKind" Usage="System.Runtime.InteropServices.StructLayoutAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.LayoutKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31588-168">取得 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 值，指定類別或結構的排列方式。</span><span class="sxs-lookup"><span data-stu-id="31588-168">Gets the <see cref="T:System.Runtime.InteropServices.LayoutKind" /> value that specifies how the class or structure is arranged.</span></span></summary>
        <value><span data-ttu-id="31588-169">其中一個列舉值，指定類別或結構的排列方式。</span><span class="sxs-lookup"><span data-stu-id="31588-169">One of the enumeration values that specifies how the class or structure is arranged.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>