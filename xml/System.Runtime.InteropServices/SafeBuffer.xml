<Type Name="SafeBuffer" FullName="System.Runtime.InteropServices.SafeBuffer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="161b0716eaeda14a15288164577a8e7f548e32c6" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58736461" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SafeBuffer extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeBuffer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeBuffer&#xA;Inherits SafeHandleZeroOrMinusOneIsInvalid" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeBuffer abstract : Microsoft::Win32::SafeHandles::SafeHandleZeroOrMinusOneIsInvalid" />
  <TypeSignature Language="F#" Value="type SafeBuffer = class&#xA;    inherit SafeHandleZeroOrMinusOneIsInvalid&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.InteropServices.SafeHandle</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netstandard-1.2">
      <AttributeName>System.Obsolete("SafeBuffer may be unavailable in future releases.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netstandard-1.2">
      <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供可用於讀取和寫入的受控制記憶體緩衝區。 嘗試存取受控制緩衝區之外的記憶體 (不足和滿溢) 會引發例外狀況。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須呼叫<xref:System.Runtime.InteropServices.SafeBuffer.Initialize%2A?displayProperty=nameWithType>方法之前使用的任何執行個體<xref:System.Runtime.InteropServices.SafeBuffer>。 若要避免競爭情況，當您儲存的執行個體<xref:System.Runtime.InteropServices.SafeBuffer>物件在靜態變數中，您應該使用其中一種下列方法：  
  
-   發佈時建立鎖定<xref:System.Runtime.InteropServices.SafeBuffer>。  
  
-   建立本機變數，初始化<xref:System.Runtime.InteropServices.SafeBuffer>，然後指派<xref:System.Runtime.InteropServices.SafeBuffer>到靜態變數，例如，藉由使用<xref:System.Threading.Interlocked.CompareExchange%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  靜態類別建構函式中的指派會隱含地被鎖定。  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeBuffer (bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeBuffer(bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeBuffer : bool -&gt; System.Runtime.InteropServices.SafeBuffer" Usage="new System.Runtime.InteropServices.SafeBuffer ownsHandle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ownsHandle"><see langword="true" /> 表示確實在結束階段釋放控制代碼，否則為 <see langword="false" />，用以免除確實釋放 (不建議)。</param>
        <summary>初始化 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 類別的新執行個體，並且指定是否要確實地釋放緩衝區控制代碼。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="AcquirePointer">
      <MemberSignature Language="C#" Value="public void AcquirePointer (ref byte* pointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquirePointer(unsigned int8*&amp; pointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquirePointer(System::Byte* % pointer);" />
      <MemberSignature Language="F#" Value="member this.AcquirePointer :  -&gt; unit" Usage="safeBuffer.AcquirePointer pointer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pointer">位元組指標 (以傳址方式傳遞)，用來從 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 物件中接收指標。 您必須先將這個指標設定為 <see langword="null" />，再呼叫這個方法。</param>
        <summary>從 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 物件取得記憶體區塊的指標。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A>傳回時，您應該執行驗證檢查的界限`pointer`參數是`null`。 如果不是`null`，您必須呼叫<xref:System.Runtime.InteropServices.SafeBuffer.ReleasePointer%2A?displayProperty=nameWithType>限制的執行區域 (CER) 中的方法。  
  
 <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> 呼叫<xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A?displayProperty=nameWithType>方法，並公開的指標。 不同於<xref:System.Runtime.InteropServices.SafeBuffer.Read%2A>方法，它不會變更目前位置的指標。  
  
 下列範例示範如何使用<xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A>方法：  
  
```  
byte* pointer = null;  
RuntimeHelpers.PrepareConstrainedRegions();  
try {  
    MySafeBuffer.AcquirePointer(ref pointer);  
    // Use pointer here, with your own bounds checking.  
    }  
finally {  
    if (pointer != null)  
        MySafeBuffer.ReleasePointer();  
    }  
```  
  
 如果您轉型`pointer`（這是一個位元組的指標） 為不同的型別 （T *） 的指標，您可能會有指標對齊問題。  
  
 您必須負責檢查與這個指標的所有界限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ByteLength">
      <MemberSignature Language="C#" Value="public ulong ByteLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 ByteLength" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeBuffer.ByteLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ByteLength As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::UInt64 ByteLength { System::UInt64 get(); };" />
      <MemberSignature Language="F#" Value="member this.ByteLength : uint64" Usage="System.Runtime.InteropServices.SafeBuffer.ByteLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得緩衝區的大小，以位元組為單位。</summary>
        <value>記憶體緩衝區的位元組數目。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定要配置的記憶體緩衝區大小。 您必須先呼叫這個方法，才能夠使用 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (ulong numBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(unsigned int64 numBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (numBytes As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize(System::UInt64 numBytes);" />
      <MemberSignature Language="F#" Value="member this.Initialize : uint64 -&gt; unit" Usage="safeBuffer.Initialize numBytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numBytes" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="numBytes">緩衝區中的位元組數目。</param>
        <summary>定義記憶體區域的配置大小 (以位元組為單位)。 您必須先呼叫這個方法，才能夠使用 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="numBytes" /> 小於零。  
  
-或- 
 <paramref name="numBytes" /> 大於可用的位址空間。</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (uint numElements, uint sizeOfEachElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(unsigned int32 numElements, unsigned int32 sizeOfEachElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (numElements As UInteger, sizeOfEachElement As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize(System::UInt32 numElements, System::UInt32 sizeOfEachElement);" />
      <MemberSignature Language="F#" Value="member this.Initialize : uint32 * uint32 -&gt; unit" Usage="safeBuffer.Initialize (numElements, sizeOfEachElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numElements" Type="System.UInt32" />
        <Parameter Name="sizeOfEachElement" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="numElements">緩衝區中的項目數。</param>
        <param name="sizeOfEachElement">緩衝區中每個項目的大小。</param>
        <summary>使用指定的項目數目和項目大小，指定記憶體緩衝區的配置大小。 您必須先呼叫這個方法，才能夠使用 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會定義記憶體區域的所需的大小，乘以每個項目的大小陣列中元素數目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="numElements" /> 小於零。  
  
-或- 
 <paramref name="sizeOfEachElement" /> 小於零。  
  
-或- 
 <paramref name="numElements" /> 乘以 <paramref name="sizeOfEachElement" /> 大於可用的位址空間。</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Initialize&lt;T&gt; (uint numElements) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int32 numElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize``1(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize(Of T As Structure) (numElements As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void Initialize(System::UInt32 numElements);" />
      <MemberSignature Language="F#" Value="member this.Initialize : uint32 -&gt; unit (requires 'T : struct)" Usage="safeBuffer.Initialize numElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="numElements" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配置記憶體的實值型別。</typeparam>
        <param name="numElements">要配置記憶體之實值型別的項目數目。</param>
        <summary>指定實值型別的數目，定義記憶體區域的配置大小。 您必須先呼叫這個方法，才能夠使用 <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> 執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="numElements" /> 小於零。  
  
-或- 
 <paramref name="numElements" /> 乘以每個元素的大小，大於可用的位址空間。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public override bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeBuffer.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeBuffer.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T Read&lt;T&gt; (ulong byteOffset) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T Read&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read(Of T As Structure) (byteOffset As ULong) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class T Read(System::UInt64 byteOffset);" />
      <MemberSignature Language="F#" Value="member this.Read : uint64 -&gt; 'T (requires 'T : struct)" Usage="safeBuffer.Read byteOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <typeparam name="T">要讀取的值類型。</typeparam>
        <param name="byteOffset">要從中讀取實值型別的位置。 您可能必須考慮對齊問題。</param>
        <summary>從記憶體中指定的位移讀取實值型別。</summary>
        <returns>從記憶體讀取的實值型別。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)" />
      </Docs>
    </Member>
    <Member MemberName="ReadArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void ReadArray&lt;T&gt; (ulong byteOffset, T[] array, int index, int count) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadArray&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.ReadArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadArray(Of T As Structure) (byteOffset As ULong, array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void ReadArray(System::UInt64 byteOffset, cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadArray : uint64 * 'T[] * int * int -&gt; unit (requires 'T : struct)" Usage="safeBuffer.ReadArray (byteOffset, array, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">要讀取的值類型。</typeparam>
        <param name="byteOffset">要開始讀取的來源位置。</param>
        <param name="array">要寫入的輸出陣列。</param>
        <param name="index">在輸出陣列中開始寫入的位置。</param>
        <param name="count">從輸入陣列讀取並寫入輸出陣列的實值型別數目。</param>
        <summary>從記憶體中的位移開始讀取指定數目的實值型別，並從陣列中的索引處開始寫入。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零。  
  
-或- 
 <paramref name="count" /> 小於零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">陣列的長度減去索引會小於 <paramref name="count" />。</exception>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.WriteArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReleasePointer">
      <MemberSignature Language="C#" Value="public void ReleasePointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleasePointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.ReleasePointer" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleasePointer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleasePointer();" />
      <MemberSignature Language="F#" Value="member this.ReleasePointer : unit -&gt; unit" Usage="safeBuffer.ReleasePointer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" /> 方法所取得的指標。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法傳回之後，就無法使用的指標。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (ulong byteOffset, T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T As Structure) (byteOffset As ULong, value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void Write(System::UInt64 byteOffset, T value);" />
      <MemberSignature Language="F#" Value="member this.Write : uint64 * 'T -&gt; unit (requires 'T : struct)" Usage="safeBuffer.Write (byteOffset, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">要寫入的值類型。</typeparam>
        <param name="byteOffset">要開始寫入的位置。 您可能必須考慮對齊問題。</param>
        <param name="value">要寫入的值。</param>
        <summary>將實值型別寫入至記憶體中指定的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於下列程式碼：  
  
```  
*(T*)(bytePtr + byteOffset) = value;  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)" />
      </Docs>
    </Member>
    <Member MemberName="WriteArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void WriteArray&lt;T&gt; (ulong byteOffset, T[] array, int index, int count) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteArray&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.WriteArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteArray(Of T As Structure) (byteOffset As ULong, array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void WriteArray(System::UInt64 byteOffset, cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteArray : uint64 * 'T[] * int * int -&gt; unit (requires 'T : struct)" Usage="safeBuffer.WriteArray (byteOffset, array, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">要寫入的值類型。</typeparam>
        <param name="byteOffset">要寫入的記憶體中的位置。</param>
        <param name="array">輸入陣列。</param>
        <param name="index">陣列中要開始讀取的位移。</param>
        <param name="count">要寫入的實值型別數目。</param>
        <summary>先從輸入陣列中指定的位置開始讀取位元組，再將指定數目的實值型別寫入至記憶體位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 輸入陣列中的每個項目是由類別的泛型實值型別所組成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 或 <paramref name="count" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">輸入陣列的長度減去 <paramref name="index" /> 小於 <paramref name="count" />。</exception>
        <exception cref="T:System.InvalidOperationException">尚未呼叫 <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> 方法。</exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.ReadArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>