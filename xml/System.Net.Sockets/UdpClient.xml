<Type Name="UdpClient" FullName="System.Net.Sockets.UdpClient">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="245b7bab0477b3744774cfadd7975c02388156f5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36474036" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UdpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UdpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.UdpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class UdpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UdpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type UdpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供使用者資料包通訊協定 (UDP) 網路服務。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient>類別會提供簡單的方法，以傳送和接收無連接的 UDP 資料包封鎖同步模式。 UDP 是一種無連接的傳輸通訊協定，因為您不需要建立遠端主機連接前傳送和接收資料。 您執行動作，不過，有下列兩種方式之一建立預設遠端主機的選項：  
  
-   建立的執行個體<xref:System.Net.Sockets.UdpClient>類別使用的遠端主機名稱和連接埠號碼做為參數。  
  
-   建立的執行個體<xref:System.Net.Sockets.UdpClient>類別，然後呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。  
  
 您可以使用任何中提供的傳送方法<xref:System.Net.Sockets.UdpClient>將資料傳送到遠端裝置。 使用<xref:System.Net.Sockets.UdpClient.Receive%2A>方法，以接收來自遠端主機的資料。  
  
> [!NOTE]
>  請勿呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>使用主機名稱或<xref:System.Net.IPEndPoint>如果您已經指定預設遠端主機。 如果您這樣做，<xref:System.Net.Sockets.UdpClient>將會擲回例外狀況。  
  
 <xref:System.Net.Sockets.UdpClient> 方法也可讓您傳送和接收多點傳送的資料包。 使用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法來訂閱<xref:System.Net.Sockets.UdpClient>至多點傳送群組。 使用<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法來取消訂閱<xref:System.Net.Sockets.UdpClient>從多點傳送群組。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Net.Sockets.UdpClient>11000 的連接埠上使用主機名稱 www.contoso.com 的連線。 小型字串訊息會傳送至兩個不同的遠端主機的機器。 <xref:System.Net.Sockets.UdpClient.Receive%2A>方法會封鎖執行，直到接收訊息。 使用<xref:System.Net.IPEndPoint>傳遞至<xref:System.Net.Sockets.UdpClient.Receive%2A>，顯示回應主機的身分識別。  
  
 [!code-cpp[Classic UdpClientExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClientExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClientExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClientExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClientExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">若要建立傳出連線，或接受連入要求。</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會建立新<xref:System.Net.Sockets.UdpClient>並允許基礎的服務提供者指派最適合的本機 IPv4 位址和連接埠號碼。 如果使用這個建構函式，則<xref:System.Net.Sockets.UdpClient>執行個體已設定無法變更或覆寫具有 IPv6 目標的連線方法呼叫的 IPv4 位址系列。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 這個建構函式不適合用來聯結多點傳送的群組，因為它不會執行通訊端繫結。 此外，它只適用於 IPv4 位址類型。  
  
   
  
## Examples  
 下列範例示範如何使用預設建構函式建立的執行個體<xref:System.Net.Sockets.UdpClient>類別。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">您想通訊的本機通訊埠編號。</param>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體，並將它繫結至提供的本機通訊埠編號。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會建立基礎<xref:System.Net.Sockets.Socket>並將它連結至您要通訊的通訊埠編號。 如果您只想要設定的本機連接埠號碼，請使用這個建構函式。 基礎的服務提供者會指派本機 IP 位址。 如果您將 0 傳遞至建構函式時，基礎的服務提供者會指派通訊埠編號。 如果使用這個建構函式，則<xref:System.Net.Sockets.UdpClient>執行個體已設定無法變更或覆寫具有 IPv6 目標的連線方法呼叫的 IPv4 位址系列。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 這個建構函式只適用於 IPv4 位址類型。  
  
   
  
## Examples  
 下列範例示範如何使用本機連接埠號碼建立的執行個體<xref:System.Net.Sockets.UdpClient>類別。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 參數大於 <see cref="F:System.Net.IPEndPoint.MaxPort" /> 或小於 <see cref="F:System.Net.IPEndPoint.MinPort" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" />，表示繫結 UDP 連接的本機端點。</param>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體，並將它繫結至指定的本機端點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會建立新<xref:System.Net.Sockets.UdpClient>和繫結至<xref:System.Net.IPEndPoint>所指定`localEP`參數。 在呼叫這個建構函式之前，您必須建立<xref:System.Net.IPEndPoint>使用您想要傳送和接收資料的 IP 位址和連接埠號碼。 您不需要指定本機 IP 位址和連接埠號碼來傳送和接收資料。 如果不這麼做，基礎的服務提供者會指派最適合的本機 IP 位址和連接埠號碼。  
  
 如果使用這個建構函式，則<xref:System.Net.Sockets.UdpClient>執行個體已設定與所指定的位址系列`localEP`無法變更或覆寫與不同的位址系列的連線方法呼叫的參數。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列範例示範如何建立執行個體<xref:System.Net.Sockets.UdpClient>類別使用的本機端點。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值，指定通訊端的定址配置。</param>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `family`參數會決定接聽程式使用 IP 第 4 版 (IPv4) 位址或 IP 版本 6 (IPv6) 位址。 若要使用 IPv4 位址，將傳遞<xref:System.Net.Sockets.AddressFamily.InterNetwork>值。 若要使用 IPv6 位址，將傳遞<xref:System.Net.Sockets.AddressFamily.InterNetworkV6>值。 傳遞任何其他值會導致方法會擲回<xref:System.ArgumentException>。  
  
 如果使用這個建構函式，則<xref:System.Net.Sockets.UdpClient>執行個體已設定與所指定的位址系列`family`無法變更或覆寫與不同的位址系列的連線方法呼叫的參數。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>不適用於聯結多點傳送的群組，因為它不會執行通訊端繫結。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> 不是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port, System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port, valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer, family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port, System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int * System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (port, family)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="port">通訊埠，將會在此處接聽連入的連接嘗試。</param>
        <param name="family">其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值，指定通訊端的定址配置。</param>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體，並將它繫結至提供的本機通訊埠編號。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會建立基礎<xref:System.Net.Sockets.Socket>並將它連結至您要通訊的通訊埠編號。  
  
 `family`參數會決定接聽程式使用 IP 第 4 版 (IPv4) 位址或 IP 版本 6 (IPv6) 位址。 若要使用 IPv4 位址，將傳遞<xref:System.Net.Sockets.AddressFamily.InterNetwork>值。 若要使用 IPv6 位址，將傳遞<xref:System.Net.Sockets.AddressFamily.InterNetworkV6>值。 傳遞任何其他值會導致方法會擲回<xref:System.ArgumentException>。  
  
 如果使用這個建構函式，則<xref:System.Net.Sockets.UdpClient>執行個體已設定與所指定的位址系列`family`無法變更或覆寫與不同的位址系列的連線方法呼叫的參數。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立使用多點傳送群組中的 UDP 用戶端。  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#3)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> 不是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 大於 <see cref="F:System.Net.IPEndPoint.MaxPort" /> 或小於 <see cref="F:System.Net.IPEndPoint.MinPort" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : string * int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">您想連接的遠端 DNS 主機名稱。</param>
        <param name="port">您想連接的遠端通訊埠編號。</param>
        <summary>初始化 <see cref="T:System.Net.Sockets.UdpClient" /> 類別的新執行個體，並建立預設遠端主機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式初始化新<xref:System.Net.Sockets.UdpClient>和建立遠端主機使用`hostname`和`port`參數。 建立預設遠端主機是選擇性的。 如果您使用這個建構函式，您不必在每次呼叫中指定遠端主機<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 指定預設遠端主機限制為只有該主機。 您可以隨時變更預設遠端主機，藉由呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您想要在呼叫中指定遠端主機<xref:System.Net.Sockets.UdpClient.Send%2A>方法時，請勿使用這個建構函式。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列範例示範如何建立執行個體<xref:System.Net.Sockets.UdpClient>類別使用主機名稱和連接埠號碼。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 不在 <see cref="F:System.Net.IPEndPoint.MinPort" /> 和 <see cref="F:System.Net.IPEndPoint.MaxPort" /> 之間。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.UdpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否已經建立預設的遠端主機。</summary>
        <value>如果連接為作用中，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類別衍生自<xref:System.Net.Sockets.UdpClient>可以使用這個屬性來判斷是否已成功建立預設遠端主機。 您可以建立預設遠端主機，使用適當的建構函式，或藉由呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您沒有建立預設遠端主機，您就無法呼叫中指定遠端主機<xref:System.Net.Sockets.UdpClient.Send%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.UdpClient" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="udpClient.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">布林值，指定是否啟用或停用 NAT 周遊。</param>
        <summary>啟用或停用在 <see cref="T:System.Net.Sockets.UdpClient" /> 執行個體上的網路位址轉譯 (NAT) 周遊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.AllowNatTraversal%2A>方法用來啟用或停用的 NAT 周遊<xref:System.Net.Sockets.UdpClient>執行個體。 您可以使用 Teredo、 6to4 或 ISATAP 通道提供 NAT 周遊。  
  
 當`allowed`參數為 false，<xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel>相關聯的通訊端上的選項設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>。 此明確地停用的 NAT 周遊<xref:System.Net.Sockets.UdpClient>執行個體。  
  
 當`allowed`參數為 true，<xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel>相關聯的通訊端上的選項設定為<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>。 這可能會讓 NAT 周遊<xref:System.Net.Sockets.UdpClient>根據在系統上的防火牆規則。  
  
 Teredo 位址是 IPv6 位址首碼為 2001年:: / 32。 Teredo 位址可透過一般的 DNS 名稱解析傳回或列舉為指派給本機介面的 IPv6 位址。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.UdpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已從網路接收且可供讀取的資料量。</summary>
        <value>從網路接收之資料的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Available%2A>屬性用來決定的資料量排入佇列進行讀取的網路緩衝區中。 如果資料是提供，呼叫<xref:System.Net.Sockets.NetworkStream.Read%2A>取得的資料。 如果沒有資料可用，<xref:System.Net.Sockets.UdpClient.Available%2A>屬性會傳回 0。  
  
 如果遠端主機關機或關閉連接，<xref:System.Net.Sockets.UdpClient.Available%2A>屬性會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件位於 MSDN library 中[ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)/ 如需詳細的說明發生錯誤。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.UdpClient.Available%2A>屬性。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginReceive (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>非同步接收遠端主機的資料包。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，參考非同步接收。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.UdpClient.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.UdpClient.EndReceive%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖，直到作業完成為止，使用<xref:System.Net.Sockets.UdpClient.Receive%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.UdpClient.BeginReceive%2A>以非同步方式接收伺服器回應。  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將資料包非同步傳送至遠端主機。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">
          <see cref="T:System.Byte" /> 陣列，包含要傳送的資料。</param>
        <param name="bytes">要傳送的位元組數。</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">包含傳送作業相關資訊的使用者定義物件。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>將資料包非同步傳送至遠端主機。 目的端由先前對 <see cref="Overload:System.Net.Sockets.UdpClient.Connect" /> 的呼叫指定。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，參考非同步傳送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.UdpClient.BeginSend%2A>作業必須完成呼叫<xref:System.Net.Sockets.UdpClient.EndSend%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.UdpClient.Send%2A>方法多載。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.UdpClient.BeginSend%2A>以非同步方式傳送伺服器要求。  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * System.Net.IPEndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, endPoint, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">
          <see cref="T:System.Byte" /> 陣列，包含要傳送的資料。</param>
        <param name="bytes">要傳送的位元組數。</param>
        <param name="endPoint">
          <see cref="T:System.Net.EndPoint" />，表示資料的目的端。</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">包含傳送作業相關資訊的使用者定義物件。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>將資料包非同步傳送至目的端。 目的端由 <see cref="T:System.Net.EndPoint" /> 指定。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，參考非同步傳送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.UdpClient.BeginSend%2A>作業必須完成呼叫<xref:System.Net.Sockets.UdpClient.EndSend%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.UdpClient.Send%2A>方法多載。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.UdpClient.BeginSend%2A>以非同步方式傳送伺服器要求。  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, string hostname, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, hostname As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, hostname, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">
          <see cref="T:System.Byte" /> 陣列，包含要傳送的資料。</param>
        <param name="bytes">要傳送的位元組數。</param>
        <param name="hostname">目的主機。</param>
        <param name="port">目的通訊埠編號。</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">包含傳送作業相關資訊的使用者定義物件。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>將資料包非同步傳送至目的端。 目的端由主機名稱和通訊埠編號指定。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，參考非同步傳送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.UdpClient.BeginSend%2A>作業必須完成呼叫<xref:System.Net.Sockets.UdpClient.EndSend%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.UdpClient.Send%2A>方法多載。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.UdpClient.BeginSend%2A>以非同步方式傳送伺服器要求。  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.UdpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定基礎網路 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <value>基礎網路 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> 建立<xref:System.Net.Sockets.Socket>用來傳送和接收資料透過網路。 類別衍生自<xref:System.Net.Sockets.UdpClient>可以使用這個屬性來取得或設定此<xref:System.Net.Sockets.Socket>。 使用基礎<xref:System.Net.Sockets.Socket>從傳回<xref:System.Net.Sockets.UdpClient.Client%2A>如果您需要存取超過其<xref:System.Net.Sockets.UdpClient>提供。 您也可以使用<xref:System.Net.Sockets.UdpClient.Client%2A>設基礎<xref:System.Net.Sockets.Socket>至現有<xref:System.Net.Sockets.Socket>。 這非常有用，如果您想要充分利用的簡易性<xref:System.Net.Sockets.UdpClient>使用預先存在<xref:System.Net.Sockets.Socket>。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Net.Sockets.UdpClient.Client%2A>屬性。 在此範例中，啟用廣播基礎<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="udpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉 UDP 連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Close%2A>停用基礎<xref:System.Net.Sockets.Socket>和所有相關聯的 managed 和 unmanaged 資源釋出<xref:System.Net.Sockets.UdpClient>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列範例會示範右<xref:System.Net.Sockets.UdpClient>藉由呼叫<xref:System.Net.Sockets.UdpClient.Close%2A>方法。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立預設遠端主機。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (endPoint As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="udpClient.Connect endPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" />，指定您想傳送資料所至的網路端點。</param>
        <summary>使用指定的網路端點，建立預設的遠端主機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A>方法使用，建立預設遠端主機中指定的值`endPoint`參數。 一旦建立，您不必在每次呼叫中指定遠端主機<xref:System.Net.Sockets.UdpClient.Send%2A>方法。  
  
 建立預設遠端主機是選擇性的。 指定預設遠端主機限制為只有該主機。 如果您想要傳送資料包至不同的遠端主機，您必須進行另一個呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法或建立另一個<xref:System.Net.Sockets.UdpClient>但不使用預設遠端主機。 如果您已建立預設遠端主機，而且您也提供遠端主機呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>方法，<xref:System.Net.Sockets.UdpClient.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法時，除了指定的預設將會被捨棄，從位址到達任何資料包。 您無法設定預設遠端主機到廣播位址，使用這個方法，除非您繼承自<xref:System.Net.Sockets.UdpClient>，使用用戶端方法，取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。  
  
 不過您可以、 廣播到預設的資料會廣播位址，255.255.255.255，如果您指定<xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType>呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 如果您的應用程式需要較大的控制權廣播位址，您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!NOTE]
>  因為 UDP 通訊協定是無連線、<xref:System.Net.Sockets.UdpClient.Connect%2A>方法不會封鎖。 請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，如果您想要接收乘以資料包。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Net.IPEndPoint>建立預設遠端主機。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endPoint" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress addr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress addr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ addr, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.Connect (addr, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addr">您想連接的遠端主機的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">您想傳送資料所至的通訊埠編號。</param>
        <summary>使用指定的 IP 位址和通訊埠編號，建立預設遠端主機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A>方法使用，建立預設遠端主機中指定的值`addr`和`port`參數。 一旦建立，您不必在每次呼叫中指定遠端主機<xref:System.Net.Sockets.UdpClient.Send%2A>方法。  
  
 建立預設遠端主機是選擇性的。 指定預設遠端主機限制為只有該主機。 如果您想要傳送資料包至不同的遠端主機，您必須進行另一個呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法或建立另一個<xref:System.Net.Sockets.UdpClient>但不使用預設遠端主機。 如果您已建立預設遠端主機，而且您也提供遠端主機呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>方法，<xref:System.Net.Sockets.UdpClient.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法時，除了指定的預設將會被捨棄，從位址到達任何資料包。 您無法設定預設遠端主機到廣播位址，使用這個方法，除非您繼承自<xref:System.Net.Sockets.UdpClient>，使用用戶端方法，取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。  
  
 不過您可以、 廣播到預設的資料會廣播位址，255.255.255.255，如果您指定<xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType>呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 如果您的應用程式需要較大的控制權廣播位址，您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!NOTE]
>  因為 UDP 通訊協定是無連線、<xref:System.Net.Sockets.UdpClient.Connect%2A>方法不會封鎖。 請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，如果您想要接收乘以資料包。  
  
   
  
## Examples  
 下列範例會使用 IP 位址和連接埠號碼來與遠端主機連接。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addr" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 不在 <see cref="F:System.Net.IPEndPoint.MinPort" /> 和 <see cref="F:System.Net.IPEndPoint.MaxPort" /> 之間。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="udpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">您想傳送資料所至的遠端主機的 DNS 名稱。</param>
        <param name="port">您想傳送資料所至的遠端主機的通訊埠編號。</param>
        <summary>使用指定的主機名稱和通訊埠編號，建立預設遠端主機。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A>方法使用，建立預設遠端主機中指定的值`port`和`hostname`參數。 一旦建立，您不必在每次呼叫中指定遠端主機<xref:System.Net.Sockets.UdpClient.Send%2A>方法。  
  
 建立預設遠端主機是選擇性的。 指定預設遠端主機限制為只有該主機。 如果您想要傳送資料包至不同的遠端主機，您必須進行另一個呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法或建立另一個<xref:System.Net.Sockets.UdpClient>但不使用預設遠端主機。  
  
 如果您已建立預設遠端主機，而且您也提供遠端主機呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>方法，<xref:System.Net.Sockets.UdpClient.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法時，除了指定的預設將會被捨棄，從位址到達任何資料包。 您無法設定預設遠端主機到廣播位址，使用這個方法，除非您繼承自<xref:System.Net.Sockets.UdpClient>，使用用戶端方法，取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。  
  
 不過您可以、 廣播到預設的資料會廣播位址，255.255.255.255，如果您指定<xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType>呼叫<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 如果您的應用程式需要較大的控制權廣播位址，您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!NOTE]
>  因為 UDP 通訊協定是無連線、<xref:System.Net.Sockets.UdpClient.Connect%2A>方法不會封鎖。 請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，如果您想要接收乘以資料包。  
  
   
  
## Examples  
 下列範例會使用數字以連線至遠端主機的主機名稱和連接埠。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 不在 <see cref="F:System.Net.IPEndPoint.MinPort" /> 和 <see cref="F:System.Net.IPEndPoint.MaxPort" /> 之間。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="udpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.UdpClient" /> 使用的 Managed 和 Unmanaged 資源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="udpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Net.Sockets.UdpClient" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`與`disposing`設`false`。  
  
 當`disposing`參數為 true，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.Net.Sockets.UdpClient>參考。 這個方法會叫用每個參考物件的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。在覆寫<see langword="Dispose(Boolean)" />小心不要參考物件已處置過的早期呼叫中<see langword="Dispose" />。如需有關如何實作<see langword="Dispose(Boolean)" />，請參閱 [實作 Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)。如需有關<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱 [清理 Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) 上和 [覆寫 Finalize 方法] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.UdpClient.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.UdpClient" /> 是否允許將網際網路通訊協定 (IP) 資料包分散。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.UdpClient" /> 允許資料包分散，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資料包需要片段，其大小超過最大傳輸單位 (MTU) 的傳輸媒介時。 傳送主控件，或中繼路由器可能被分割資料包。 如果必須分散資料包 (datagram)，而<xref:System.Net.Sockets.Socket.DontFragment%2A>選項設定，資料包作業會捨棄，並且傳回給寄件者的資料包傳送網際網路控制訊息通訊協定 (ICMP) 錯誤訊息。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.DontFragment%2A>屬性。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">只可以為使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 旗標或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 旗標的通訊端設定這個屬性。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DropMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留多點傳送 (Multicast) 群組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.DropMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">要保留的多點傳送群組其 <see cref="T:System.Net.IPAddress" />。</param>
        <summary>保留多點傳送 (Multicast) 群組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法會提領<xref:System.Net.Sockets.UdpClient>從多點傳送群組所指定識別<xref:System.Net.IPAddress>。 在呼叫<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法時，基礎<xref:System.Net.Sockets.Socket>將網際網路群組管理通訊協定 (IGMP) 封包傳送至路由器，從多點傳送群組中移除的路由器。 之後<xref:System.Net.Sockets.UdpClient>會提領從群組中，它將不再能夠接收資料包傳送至該群組。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列範例會示範如何藉由提供多點傳送的位址中卸除多點傳送的群組。  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">IP 位址與 <see cref="T:System.Net.Sockets.AddressFamily" /> 值不相容，這個值定義著通訊端的定址配置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr, int32 ifindex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress, ifindex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr, int ifindex);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.DropMulticastGroup (multicastAddr, ifindex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="ifindex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">要保留的多點傳送群組其 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="ifindex">要保留之多點傳送群組的本機位址。</param>
        <summary>保留多點傳送 (Multicast) 群組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法會提領<xref:System.Net.Sockets.UdpClient>從多點傳送群組所指定識別<xref:System.Net.IPAddress>。 在呼叫<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法時，基礎<xref:System.Net.Sockets.Socket>將網際網路群組管理通訊協定 (IGMP) 封包傳送至路由器，從多點傳送群組中移除的路由器。 之後<xref:System.Net.Sockets.UdpClient>會提領從群組中，它將不再能夠接收資料包傳送至該群組。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列程式碼範例示範如何藉由提供多點傳送的位址中卸除多點傳送的群組。  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">IP 位址與 <see cref="T:System.Net.Sockets.AddressFamily" /> 值不相容，這個值定義著通訊端的定址配置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.UdpClient" /> 是否可以傳送或接收廣播封包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.UdpClient" /> 允許廣播封包，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 廣播會限制為特定的子網路。 您可以將封包傳送到 255.255.255.255; 廣播給您本機子網路或者，您可以使用導向的廣播的位址，也就是使用中的主機部分設定的所有位元的網際網路通訊協定 (IP) 位址的網路部分。 例如，如果您的 IP 位址是的 192.168.1.40 （類別 C 位址，與網路部分為的前三個八位元的主機部分是最後一個八位元），導向的廣播的位址為 192.168.1.255。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.UdpClient.EnableBroadcast%2A>屬性。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] EndReceive(class System.IAsyncResult asyncResult, class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ EndReceive(IAsyncResult ^ asyncResult, System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; byte[]" Usage="udpClient.EndReceive (asyncResult, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 物件，由對 <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" /> 的呼叫傳回。</param>
        <param name="remoteEP">指定的遠端端點。</param>
        <summary>結束暫止的非同步接收。</summary>
        <returns>如果成功，即為包含資料包資料的位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖直到作業完成。  
  
 若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.UdpClient.Receive%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.UdpClient.BeginSend%2A>完成伺服器回應的非同步接收。  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取基礎 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="udpClient.EndSend asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 物件，由對 <see cref="Overload:System.Net.Sockets.UdpClient.BeginSend" /> 的呼叫傳回。</param>
        <summary>結束暫止的非同步傳送。</summary>
        <returns>如果成功，則為要傳送至 <see cref="T:System.Net.Sockets.UdpClient" /> 的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖直到作業完成。  
  
 若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.UdpClient.Send%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.UdpClient.BeginSend%2A>完成的伺服器要求的非同步傳送。  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取基礎通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.UdpClient" /> 是否只允許一個用戶端使用連接埠。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.UdpClient" /> 只允許一個用戶端使用特定通訊埠則為 <see langword="true" />；否則為 <see langword="false" />。 若為 Windows Server 2003 和 Windows XP Service Pack 2 (含) 以後版本，則預設值為 <see langword="true" />；若為所有其他版本，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，多個用戶端可以使用特定通訊埠。不過，只有其中一個用戶端可以執行網路流量傳送至連接埠的作業。 您可以使用<xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A>防止多個用戶端使用特定通訊埠的屬性。  
  
 基礎通訊端的用戶端連接埠繫結之前，必須設定這個屬性。 如果您呼叫<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=nameWithType>， <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>， <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>，或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>、 用戶端連接埠繫結副作用的建構函式，而您之後無法設定<xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A>屬性  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Net.Sockets.UdpClient>，以及取得和設定<xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A>屬性。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取基礎通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!UdpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="udpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="JoinMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Net.Sockets.UdpClient" /> 加入至多點傳送群組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">您要聯結的群組其多點傳送 <see cref="T:System.Net.IPAddress" />。</param>
        <summary>將 <see cref="T:System.Net.Sockets.UdpClient" /> 加入至多點傳送群組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法會訂閱<xref:System.Net.Sockets.UdpClient>使用指定的多點傳送群組<xref:System.Net.IPAddress>。 在呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法時，基礎<xref:System.Net.Sockets.Socket>網際網路群組管理通訊協定 (IGMP) 封包傳送到要求的多點傳送群組成員資格的路由器。 多點傳送的位址範圍位於 224.0.0.0 至 239.255.255.255。 如果您指定在這個範圍之外的位址，或提出要求時的路由器不是多點傳送的啟用，<xref:System.Net.Sockets.UdpClient>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。 一次<xref:System.Net.Sockets.UdpClient>列為使用多點傳送群組的成員身分的路由器，它能夠接收 multicasted 資料包傳送至指定<xref:System.Net.IPAddress>。  
  
> [!NOTE]
>  您必須建立<xref:System.Net.Sockets.UdpClient>使用多點傳送連接埠號碼; 否則您將無法接收 multicasted 資料包。 請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法，或<xref:System.Net.Sockets.UdpClient.Receive%2A>方法將無法運作。 您不需要屬於要傳送資料包至多點傳送的 IP 位址的多點傳送群組。  
  
 之前聯結多點傳送的群組時，請確定通訊端繫結至連接埠或端點。 您可透過呼叫其中一個接受連接埠或端點做為參數的建構函式。  
  
 若要停止接收乘以資料包，呼叫<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法，並提供<xref:System.Net.IPAddress>從中您想要退出的群組。  
  
> [!NOTE]
>  在 IPv6 的情況下，有數個多點傳送的位址範圍，您可以選擇。 請參閱 IETF RFC 2375。  
  
> [!NOTE]
>  您不能呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>建構不含特定本機連接埠 (也就使用<xref:System.Net.Sockets.UdpClient.%23ctor>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29>建構函式)。  
  
   
  
## Examples  
 下列程式碼範例示範如何藉由提供多點傳送的位址聯結多點傳送的群組。  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#1)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">IP 位址與 <see cref="T:System.Net.Sockets.AddressFamily" /> 值不相容，這個值定義著通訊端的定址配置。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(int32 ifindex, class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (ifindex As Integer, multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(int ifindex, System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : int * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (ifindex, multicastAddr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifindex" Type="System.Int32" />
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="ifindex">要加入多點傳送群組的本機 IP 位址相關聯的介面索引。</param>
        <param name="multicastAddr">您要聯結的群組其多點傳送 <see cref="T:System.Net.IPAddress" />。</param>
        <summary>將 <see cref="T:System.Net.Sockets.UdpClient" /> 加入至多點傳送群組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 聯結多點傳送的群組，請務必先通訊端會繫結至連接埠或端點。 您可以呼叫其中一個可接受連接埠或端點做為參數的建構函式。  
  
 `infindex`參數用來識別相同連結上的硬體介面。  
  
> [!NOTE]
>  有數個多點傳送的位址範圍，可從中選擇。 請參閱 IETF RFC 2375。  
  
> [!NOTE]
>  您不能呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>建構不含特定本機連接埠 (也就使用<xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=nameWithType>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>建構函式)。  
  
   
  
## Examples  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#5)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, int32 timeToLive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, timeToLive As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, int timeToLive);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, timeToLive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="timeToLive" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">要聯結的多點傳送群組其 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="timeToLive">存活時間 (TTL)，以路由器躍點為測量單位。</param>
        <summary>使用指定的存活時間 (Time to Live，TTL) 將 <see cref="T:System.Net.Sockets.UdpClient" /> 加入至多點傳送群組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法會訂閱<xref:System.Net.Sockets.UdpClient>使用指定的多點傳送群組<xref:System.Net.IPAddress>。 在呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法時，基礎<xref:System.Net.Sockets.Socket>網際網路群組管理通訊協定 (IGMP) 封包傳送到要求的多點傳送群組成員資格的路由器。 多點傳送的位址範圍位於 224.0.0.0 至 239.255.255.255。 如果您指定在這個範圍之外的位址，或提出要求時的路由器不是多點傳送的啟用，<xref:System.Net.Sockets.UdpClient>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。 `timeToLive`參數會指定乘以資料包捨棄之前，所允許多少路由器躍點。 一次<xref:System.Net.Sockets.UdpClient>列為使用多點傳送群組的成員身分的路由器，它能夠接收 multicasted 資料包傳送至指定<xref:System.Net.IPAddress>。  
  
> [!NOTE]
>  您必須建立<xref:System.Net.Sockets.UdpClient>使用多點傳送連接埠號碼否則您將無法接收 multicasted 資料包。 請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法或 receive 方法將無法運作。 您不需要屬於要傳送資料包至多點傳送的 IP 位址的多點傳送群組。  
  
 在聯結多點傳送的群組之前，確定通訊端繫結至連接埠或端點。 您可透過呼叫其中一個連接埠或端點接受做為參數的建構函式。  
  
 若要停止接收乘以資料包，呼叫<xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>方法，並提供<xref:System.Net.IPAddress>從中您想要退出的群組。  
  
> [!NOTE]
>  您不能呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>建構不含特定本機連接埠 (也就使用<xref:System.Net.Sockets.UdpClient.%23ctor>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29>建構函式)。  
  
   
  
## Examples  
 下列範例會示範如何藉由提供兩個參數，多點傳送的位址及數字，代表在 TTL 聯結多點傳送的群組。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">提供的 TTL 沒有位於 0 和 255 之間</exception>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">IP 位址與 <see cref="T:System.Net.Sockets.AddressFamily" /> 值不相容，這個值定義著通訊端的定址配置。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, class System.Net.IPAddress localAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, localAddress As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, System::Net::IPAddress ^ localAddress);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, localAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="localAddress" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">您要聯結的群組其多點傳送 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="localAddress">本機 <see cref="T:System.Net.IPAddress" />。</param>
        <summary>將 <see cref="T:System.Net.Sockets.UdpClient" /> 加入至多點傳送群組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 聯結多點傳送的群組之前，請務必，繫結至連接埠或端點的通訊端。 您可以呼叫其中一個可接受連接埠或端點做為參數的建構函式。  
  
> [!NOTE]
>  有數個多點傳送的位址範圍，可從中選擇。 您可以在 IETF RFC 2375 找到它們。  
  
> [!NOTE]
>  您不能呼叫<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>上<xref:System.Net.Sockets.UdpClient>建構不含特定本機連接埠 (也就使用<xref:System.Net.Sockets.UdpClient.%23ctor>或<xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29>建構函式)。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>方法。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.UdpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定輸出多點傳送封包是否會傳遞至傳送應用程式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.UdpClient" /> 會接收輸出多點傳送封包，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多點傳送是網際網路上的多對多通訊的擴充方法。 如果處理程序訂閱多點傳送位址，任何封包傳送程序會收到其他每個已訂閱的多點傳送位址的處理序。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.UdpClient.MulticastLoopback%2A>屬性。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.UdpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public byte[] Receive (ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Receive(class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Receive(System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Receive :  -&gt; byte[]" Usage="udpClient.Receive remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.IPEndPoint" />，表示傳送資料的遠端主機。</param>
        <summary>傳回由遠端主機傳送的 UDP 資料包。</summary>
        <returns>
          <see cref="T:System.Byte" /> 型別的陣列，包含資料包資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Receive%2A>方法將會封鎖直到資料包 (datagram) 收到來自遠端主機。 當資料可供使用，<xref:System.Net.Sockets.UdpClient.Receive%2A>方法會讀取第一個加入佇列資料包，並傳回位元組陣列形式的資料部分。 這個方法會填入`remoteEP`參數<xref:System.Net.IPAddress>和寄件者的連接埠號碼。  
  
 如果您指定預設遠端主機中的<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，<xref:System.Net.Sockets.UdpClient.Receive%2A>方法會接受該主控件只從資料包。 將捨棄所有其他資料包。  
  
 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
> [!NOTE]
>  如果您想要接收的資料包乘以，請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.UdpClient.Receive%2A>方法。 <xref:System.Net.Sockets.UdpClient>您用來接收資料包必須使用多點傳送連接埠號碼來建立。  
  
   
  
## Examples  
 下列範例會示範<xref:System.Net.Sockets.UdpClient.Receive%2A>方法。 <xref:System.Net.Sockets.UdpClient.Receive%2A>方法會封鎖執行，直到其接收到訊息。 使用<xref:System.Net.IPEndPoint>傳遞至<xref:System.Net.Sockets.UdpClient.Receive%2A>，顯示回應主機的身分識別。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;valuetype System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.ReceiveAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync () As Task(Of UdpReceiveResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::UdpReceiveResult&gt; ^ ReceiveAsync();" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;" Usage="udpClient.ReceiveAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同步傳回由遠端主機傳送的 UDP 資料包。</summary>
        <returns>傳回 <see cref="T:System.Threading.Tasks.Task`1" />。  工作物件，表示非同步作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項作業不會封鎖。 傳回<xref:System.Threading.Tasks.Task%601>> 在收到 UDP 封包之後，物件會完成。  
  
 如果您指定預設遠端主機中的<xref:System.Net.Sockets.UdpClient.Connect%2A>方法，這個方法會接受該主控件只從資料包。 將捨棄所有其他資料包。  
  
 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
> [!WARNING]
>  如果您想要接收的資料包乘以，請勿呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法之前呼叫這個方法。 <xref:System.Net.Sockets.UdpClient>您用來接收資料包必須使用多點傳送連接埠號碼來建立。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">基礎 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 UDP 資料包傳送至遠端主機。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int -&gt; int" Usage="udpClient.Send (dgram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">
          <see cref="T:System.Byte" /> 型別的陣列，指定您想傳送的 UDP 資料包 (表示為位元組陣列)。</param>
        <param name="bytes">資料包中的位元組數。</param>
        <summary>將 UDP 資料包傳送至遠端主機。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會資料包傳送至遠端主機中建立<xref:System.Net.Sockets.UdpClient.Connect%2A>方法並傳回傳送的位元組數。 如果您不會呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>之前呼叫這個多載，<xref:System.Net.Sockets.UdpClient.Send%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 如果您想要傳送資料包至不同的遠端主機，您必須呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法並指定所需的遠端主機。 使用其他<xref:System.Net.Sockets.UdpClient.Send%2A>方法多載來傳送資料包至廣播位址。  
  
   
  
## Examples  
 下列範例會示範<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 您必須建立預設遠端主機，然後再使用這個多載。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已經建立預設遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.IPEndPoint -&gt; int" Usage="udpClient.Send (dgram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dgram">
          <see cref="T:System.Byte" /> 型別的陣列，指定您想傳送的 UDP 資料包 (表示為位元組陣列)。</param>
        <param name="bytes">資料包中的位元組數目。</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" />，表示傳送資料包的目標主機和通訊埠。</param>
        <summary>將 UDP 資料包傳送至指定遠端端點上的主機。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A>方法傳送資料包至指定的端點，並傳回成功傳送的位元組數目。 之前呼叫這個多載，您必須先建立<xref:System.Net.IPEndPoint>使用您資料包傳送遠端主機的 IP 位址和連接埠號碼。 您可以傳送資料包至預設廣播位址，255.255.255.255，藉由指定<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>如<xref:System.Net.IPAddress.Address%2A>屬性<xref:System.Net.IPEndPoint>。 建立這之後<xref:System.Net.IPEndPoint>，將它傳遞給<xref:System.Net.Sockets.UdpClient.Send%2A>方法以做為`endPoint`參數。  
  
 如果您想要傳送資料包到任何其他的廣播位址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法，以取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!NOTE]
>  未提供`endPoint`參數，這個方法，如果您已建立與遠端主機<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您這樣做，<xref:System.Net.Sockets.UdpClient.Send%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列範例會示範<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 這個範例會使用<xref:System.Net.IPEndPoint>來指定目標主機。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已經建立預設遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, hostname As String, port As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * string * int -&gt; int" Usage="udpClient.Send (dgram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">
          <see cref="T:System.Byte" /> 型別的陣列，指定您想傳送的 UDP 資料包 (表示為位元組陣列)。</param>
        <param name="bytes">資料包中的位元組數。</param>
        <param name="hostname">您要傳送資料包之目標遠端主機的名稱。</param>
        <param name="port">您要用來通訊的遠端連接埠號碼。</param>
        <summary>將 UDP 資料包傳送至指定遠端主機上的指定通訊埠。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A>方法會傳送資料包至指定的值`hostname`和`port`參數，並傳回成功傳送的位元組數目。 您也可以指定"255.255.255.255 」 到預設的廣播位址傳送資料包`hostname`參數值。  
  
 如果您想要傳送資料包到任何其他的廣播位址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法，以取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!NOTE]
>  未提供主機名稱或通訊埠編號，這個方法，如果您已建立與遠端主機<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您這樣做，<xref:System.Net.Sockets.UdpClient.Send%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列範例會示範<xref:System.Net.Sockets.UdpClient.Send%2A>方法。 此範例會使用主機名稱和連接埠號碼來識別目標主機。  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已經建立預設遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 UDP 資料包非同步傳送至遠端主機。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">
          <see cref="T:System.Byte" /> 型別的陣列，指定您想傳送的 UDP 資料包 (表示為位元組陣列)。</param>
        <param name="bytes">資料包中的位元組數。</param>
        <summary>將 UDP 資料包非同步傳送至遠端主機。</summary>
        <returns>傳回 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會資料包傳送至遠端主機中建立<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您不會呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>之前呼叫這個多載，這個方法會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 如果您想要傳送資料包至不同的遠端主機，您必須呼叫<xref:System.Net.Sockets.UdpClient.Connect%2A>方法並指定所需的遠端主機。 使用其他<xref:System.Net.Sockets.UdpClient.SendAsync%2A>方法多載來傳送資料包至廣播位址。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已經建立預設遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * System.Net.IPEndPoint -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="datagram">
          <see cref="T:System.Byte" /> 型別的陣列，指定您想傳送的 UDP 資料包 (表示為位元組陣列)。</param>
        <param name="bytes">資料包中的位元組數。</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" />，表示傳送資料包的目標主機和通訊埠。</param>
        <summary>將 UDP 資料包非同步傳送至遠端主機。</summary>
        <returns>傳回 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法會傳送資料包至指定的端點。 之前呼叫這個多載，您必須先建立<xref:System.Net.IPEndPoint>使用您資料包傳送遠端主機的 IP 位址和連接埠號碼。 您可以傳送資料包至預設廣播位址，255.255.255.255，藉由指定<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>如<xref:System.Net.IPAddress.Address%2A>屬性<xref:System.Net.IPEndPoint>。 建立這之後<xref:System.Net.IPEndPoint>，將它傳遞給方法的這個`endPoint`參數。  
  
 如果您想要傳送資料包到任何其他的廣播位址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法，以取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!WARNING]
>  未提供`endPoint`參數，這個方法，如果您已建立與遠端主機<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您這樣做，此方法會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已經建立預設遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, hostname As String, port As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * string * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">
          <see cref="T:System.Byte" /> 型別的陣列，指定您想傳送的 UDP 資料包 (表示為位元組陣列)。</param>
        <param name="bytes">資料包中的位元組數。</param>
        <param name="hostname">您要傳送資料包之目標遠端主機的名稱。</param>
        <param name="port">您要用來通訊的遠端連接埠號碼。</param>
        <summary>將 UDP 資料包非同步傳送至遠端主機。</summary>
        <returns>傳回 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會將所指定的值傳送資料包`hostname`和`port`參數。 您也可以指定"255.255.255.255 」 到預設的廣播位址傳送資料包`hostname`參數值。  
  
 如果您想要傳送資料包到任何其他的廣播位址，使用<xref:System.Net.Sockets.UdpClient.Client%2A>方法，以取得基礎<xref:System.Net.Sockets.Socket>，並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也可以還原成使用<xref:System.Net.Sockets.Socket>類別。  
  
> [!WARNING]
>  未提供主機名稱或通訊埠編號，這個方法，如果您已建立與遠端主機<xref:System.Net.Sockets.UdpClient.Connect%2A>方法。 如果您這樣做，此方法會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 一旦您取得這個程式碼，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已經建立預設遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.UdpClient.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定由 <see cref="T:System.Net.Sockets.UdpClient" /> 傳送之網際網路通訊協定 (IP) 封包的存留時間 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值會指出最大的封包可以周遊路由器捨棄封包，以及網際網路控制訊息通訊協定 (ICMP) 」 已經超過 TTL"之前的路由器數目寄件者會傳回錯誤訊息。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.UdpClient.Ttl%2A>屬性。  
  
 [!code-cpp[System.Net.Sockets.UdpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>