<Type Name="SocketAsyncEventArgs" FullName="System.Net.Sockets.SocketAsyncEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="86c2d378408e4fecc830c9cfc8926c4c96e55097" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460922" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SocketAsyncEventArgs : EventArgs, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SocketAsyncEventArgs extends System.EventArgs implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.SocketAsyncEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class SocketAsyncEventArgs&#xA;Inherits EventArgs&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SocketAsyncEventArgs : EventArgs, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>代表非同步通訊端作業。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.SocketAsyncEventArgs>類別是一組增強功能的一部分<xref:System.Net.Sockets.Socket?displayProperty=nameWithType>提供可供專業化的高效能通訊端應用程式的另一種非同步模式的類別。 這個類別被專為需要高效能的網路伺服器應用程式。 應用程式可以只使用增強的非同步模式，或只在目標區域 （例如，接收大量的資料時）。  
  
 這些增強功能的主要功能是在大量的非同步通訊端 I/O 期間，避免重複配置和同步處理物件。 目前所實作的 Begin/End 設計模式<xref:System.Net.Sockets.Socket?displayProperty=nameWithType>類別會要求<xref:System.IAsyncResult?displayProperty=nameWithType>即將配置給每個非同步通訊端作業的物件。  
  
 在新<xref:System.Net.Sockets.Socket?displayProperty=nameWithType>類別增強功能，作業會描述可重複使用的非同步通訊端<xref:System.Net.Sockets.SocketAsyncEventArgs>物件配置和維護的應用程式。 高效能通訊端應用程式最知道必須維持的重疊通訊端作業量。 應用程式可以視需要建立許多 <xref:System.Net.Sockets.SocketAsyncEventArgs> 物件。 例如，如果伺服器應用程式需要 15 通訊端接受作業未完成隨時支援內送的用戶端連線比率，它可以配置可重複使用 15<xref:System.Net.Sockets.SocketAsyncEventArgs>用於此用途的物件。  
  
 以這個類別執行非同步通訊端作業的模式，包含下列步驟：  
  
1.  配置新 <xref:System.Net.Sockets.SocketAsyncEventArgs> 內容物件，或從應用程式集區取得一個可用的內容物件。  
  
2.  在內容上的設定屬性的物件作業有關要執行 （完成回呼方法、 資料緩衝區，緩衝區，而且要傳送，例如資料的最大數量的位移）。  
  
3.  呼叫適當的通訊端方法 (xxxAsync) 來啟始非同步作業。  
  
4.  如果非同步通訊端方法 (xxxAsync) 會傳回 true，回呼中，查詢完成狀態的內容屬性。  
  
5.  如果非同步通訊端方法 (xxxAsync) 會傳回 false，以同步方式完成作業。 可以查詢內容屬性以取得作業結果。  
  
6.  重複使用內容進行另一個作業、將它放入集區，或是將它捨棄。  
  
 新的非同步通訊端作業內容物件的存留期取決於所參考的應用程式程式碼和非同步 I/O 的參考。 應用程式不需要在送出作為其中一個非同步通訊端作業方法的參數之後，保留對非同步通訊端作業內容物件的參考。 在完成回呼傳回之前，它會一直被參考。 不過它的好處是保留內容的參考，如此就可以為未來的非同步通訊端作業重複使用的應用程式。  
  
   
  
## Examples  
 下列程式碼範例會實作使用的通訊端伺服器的連線邏輯<xref:System.Net.Sockets.SocketAsyncEventArgs>類別。 接受連接之後, 從用戶端讀取所有資料會都傳送回用戶端。 讀取和回用戶端模式會繼續，直到用戶端中斷連線為止。 中的程式碼範例會顯示這個範例會使用 BufferManager 類別<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法。 中的程式碼範例會顯示用在此範例中的 SocketAsyncEventArgsPool 類別<xref:System.Net.Sockets.SocketAsyncEventArgs.%23ctor%2A>建構函式。  
  
 [!code-csharp[NCLAsyncSocketServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IAsyncResult" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketAsyncEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketAsyncEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>建立空的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個建構函式之後，所有屬性都會都有其預設值：  
  
-   物件參考將會是 null  
  
-   屬性會傳回整數，會傳回零。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.LastOperation%2A>屬性將會等於<xref:System.Net.Sockets.SocketAsyncOperation.None>。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A>屬性將會等於<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread?displayProperty=nameWithType>，指定沒有旗標將會使用。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A>屬性將會等於<xref:System.Net.Sockets.SocketAsyncOperation.None>。  
  
 呼叫端必須設定適當的屬性之前將物件傳遞至適當的非同步通訊端 (xxxAsync) 方法。  
  
   
  
## Examples  
 下列程式碼範例代表集合的可重複使用<xref:System.Net.Sockets.SocketAsyncEventArgs>物件。  
  
 [!code-csharp[NCLAsyncSocketServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支援平台。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket AcceptSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptSocket As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ AcceptSocket { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要使用的通訊端，或是已建立並且使用非同步通訊端方法接受連線的通訊端。</summary>
        <value>要使用的 <see cref="T:System.Net.Sockets.Socket" />，或是已建立並且使用非同步通訊端方法接受連線的通訊端。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可以用來提供已建立<xref:System.Net.Sockets.Socket>，將使用的非同步通訊端接受作業。 完成接受作業的詳細資訊，則表示已接受的連線通訊端。 如果未提供 （設定為 null），然後再呼叫<xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>方法，新的通訊端將會自動建立和完成回呼，這個屬性可以存取。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public byte[] Buffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Buffer As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Buffer { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要和非同步通訊端方法一起使用的資料緩衝區。</summary>
        <value>
          <see cref="T:System.Byte" /> 陣列，表示要和非同步通訊端方法一起使用的資料緩衝區。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會取得目前與相關聯的資料緩衝區<xref:System.Net.Sockets.SocketAsyncEventArgs>執行個體。 若要設定緩衝區，<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>必須使用的方法。  
  
 這個屬性搭配<xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>，和<xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="BufferList">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; BufferList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; BufferList" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferList As IList(Of ArraySegment(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ BufferList { System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ get(); void set(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要和非同步通訊端方法一起使用的資料緩衝區之陣列。</summary>
        <value>
          <see cref="T:System.Collections.IList" />，表示要和非同步通訊端方法一起使用的資料緩衝區之陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性搭配<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>方法。  
  
 這個屬性用來提供多個緩衝區的資料傳送，或是提供多個緩衝區，用來儲存資料的非同步通訊端作業，可以傳送或接收資料。 使用多個緩衝區<xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>屬性受到<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>方法。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>屬性設定為非 null 值，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>屬性必須是 null，而且會忽略<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>方法。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>已設為非 null 值，並嘗試設定<xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>屬性設為非 null 值，會發生例外狀況。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>屬性設定為非 null 值，<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentException>。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>參數已忽略由<xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Set 作業指定了不明確的緩衝區。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性設定成非 Null 值，且嘗試將 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性設定為非 Null 值，就會發生這個例外狀況。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      </Docs>
    </Member>
    <Member MemberName="BytesTransferred">
      <MemberSignature Language="C#" Value="public int BytesTransferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesTransferred" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.BytesTransferred" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesTransferred As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesTransferred { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得通訊端作業中所傳輸的位元組數目。</summary>
        <value>
          <see cref="T:System.Int32" />，內含通訊端作業中所傳輸的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性提供傳輸中的非同步通訊端作業可以接收或傳送資料位元組的數目。 如果讀取作業傳回零，則遠端端點已經關閉連接。  
  
 這個屬性由不含所有的非同步通訊端作業設定<xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; Completed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Net.Sockets.SocketAsyncEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Completed As EventHandler(Of SocketAsyncEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Net::Sockets::SocketAsyncEventArgs ^&gt; ^ Completed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用來完成非同步作業的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed>事件可讓用戶端應用程式來完成非同步通訊端作業。 事件處理常式應該附加至事件內<xref:System.Net.Sockets.SocketAsyncEventArgs>非同步通訊端作業啟動時，執行個體，否則應用程式將無法以判斷完成作業。  
  
 完成回呼委派，參考<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed>事件包含程式邏輯，以完成處理用戶端的非同步通訊端作業。  
  
 當事件發出信號時，應用程式會使用<xref:System.Net.Sockets.SocketAsyncEventArgs>物件參數來取得已完成的非同步通訊端作業的狀態。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectByNameError">
      <MemberSignature Language="C#" Value="public Exception ConnectByNameError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception ConnectByNameError" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectByNameError As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ ConnectByNameError { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得使用 <see cref="T:System.Net.DnsEndPoint" /> 時發生連接失敗的例外狀況 (Exception)。</summary>
        <value>
          <see cref="T:System.Exception" />，指出當指定 <see cref="T:System.Net.DnsEndPoint" /> 屬性的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 條件下發生連接錯誤的原因。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果發生連接失敗時<xref:System.Net.DnsEndPoint>指定<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A>屬性，<xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A>屬性會包含指出詳細的通訊端錯誤原因的例外狀況。  
  
 當<xref:System.Net.IPEndPoint>指定<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A>屬性和連線失敗，就會發生，<xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A>屬性會是`null`參考。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A>屬性永遠會設定在連線失敗的情況下。 <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A>屬性包含有關失敗的詳細資訊，如果它無法連接到<xref:System.Net.DnsEndPoint>。 如果只想要應用程式連線作業是否成功或失敗，則應用程式只需要檢查<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />
      </Docs>
    </Member>
    <Member MemberName="ConnectSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket ConnectSocket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket ConnectSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ConnectSocket" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectSocket As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ ConnectSocket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> 方法成功完成後已建立和連接的 <see cref="Overload:System.Net.Sockets.Socket.ConnectAsync" /> 物件。</summary>
        <value>連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成功完成後<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，這個屬性包含新建立且已連線<xref:System.Net.Sockets.Socket>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得非同步作業中要傳送或接收的資料量上限 (以位元組為單位)。</summary>
        <value>
          <see cref="T:System.Int32" />，內含要傳送或接收的資料量上限 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性由呼叫設定<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>方法。  
  
 這個屬性搭配<xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>，和<xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectReuseSocket">
      <MemberSignature Language="C#" Value="public bool DisconnectReuseSocket { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisconnectReuseSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      <MemberSignature Language="VB.NET" Value="Public Property DisconnectReuseSocket As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisconnectReuseSocket { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定在中斷連接作業後是否可以重複使用通訊端。</summary>
        <value>
          <see cref="T:System.Boolean" />，指定在中斷連接作業後是否可以重複使用通訊端。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性用來改變行為<xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>方法。 如果為 true，通訊端中斷<xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>方法可以重複使用之後中斷連線完成後續的通訊端在接受或連線作業。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 執行個體所使用的 Unmanaged 資源，並選擇性地處置 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`與`disposing`設`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.Net.Sockets.SocketAsyncEventArgs> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 `Dispose()` 方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。 覆寫 <see langword="Dispose(Boolean)" /> 時，請小心不要參考到先前已在對 <see langword="Dispose" /> 的早期呼叫中被處置 (Dispose) 的物件。 如需有關如何實作<see langword="Dispose(Boolean)" />，請參閱[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 如需有關<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[覆寫 Finalize 方法](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SocketAsyncEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SocketAsyncEventArgs ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 類別所使用的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.SocketAsyncEventArgs>類別完成項關閉<xref:System.Net.Sockets.SocketAsyncEventArgs>以及釋放相關聯的資源<xref:System.Net.Sockets.SocketAsyncEventArgs>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastOperation">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketAsyncOperation LastOperation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketAsyncOperation LastOperation" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.LastOperation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastOperation As SocketAsyncOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketAsyncOperation LastOperation { System::Net::Sockets::SocketAsyncOperation get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketAsyncOperation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得最近使用這個內容物件執行的通訊端作業類型。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketAsyncOperation" /> 執行個體，代表最近使用這個內容物件執行的通訊端作業類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性描述最近使用這個完成的非同步通訊端作業<xref:System.Net.Sockets.SocketAsyncEventArgs>物件。 這個屬性的值將會是<xref:System.Net.Sockets.SocketAsyncOperation.None?displayProperty=nameWithType>直到<xref:System.Net.Sockets.SocketAsyncEventArgs>執行個體做為開頭的非同步通訊端作業。 這個屬性然後將設定的作業正在執行中方法會採用型別<xref:System.Net.Sockets.SocketAsyncEventArgs>做為參數。 這個屬性會可更容易使用多個類型的非同步通訊端作業的單一完成回呼委派。  
  
 這個屬性就持續有效中<xref:System.Net.Sockets.SocketAsyncEventArgs>執行個體，直到<xref:System.Net.Sockets.SocketAsyncEventArgs>執行個體用於另一個非同步通訊端 (xxxAsync) 作業。  
  
 這個屬性是設定的所有非同步通訊端 (xxxAsync) 方法。  
  
 在呼叫非同步通訊端方法 (xxxAsync)<xref:System.Net.Sockets.Socket?displayProperty=nameWithType>類別會設定這個屬性值。 這個屬性是用於與應用程式實作 SocketAsyncCallback 完成常式。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketAsyncOperation" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBuffer">
      <MemberSignature Language="C#" Value="public Memory&lt;byte&gt; MemoryBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Memory`1&lt;unsigned int8&gt; MemoryBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MemoryBuffer As Memory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Memory&lt;System::Byte&gt; MemoryBuffer { Memory&lt;System::Byte&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public int Offset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Offset" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Offset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Offset { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性所參考之資料緩衝區中的位移 (以位元組為單位)。</summary>
        <value>
          <see cref="T:System.Int32" />，內含 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性所參考之資料緩衝區中的位移 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性描述中的資料開始的位元組位移<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>屬性。 這個值由呼叫設定<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>方法。  
  
 這個屬性不適用於<xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>屬性。  
  
 這個屬性搭配<xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>，和<xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      </Docs>
    </Member>
    <Member MemberName="OnCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnCompleted (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCompleted(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCompleted (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCompleted(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">收到信號的事件。</param>
        <summary>代表在非同步作業完成時所呼叫的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是可由使用者程式碼呼叫。 取得呼叫這個方法的內部資訊<xref:System.Net.Sockets.SocketAsyncEventArgs>物件目前的作業完成時。 這個方法會用於所有的非同步通訊端 (xxxAsync) 方法。  
  
 建立繼承自一個類別的應用程式<xref:System.Net.Sockets.SocketAsyncEventArgs>可以覆寫這個方法，以連線到這個完成的通知，並清除任何它的作業已配置的資源。 預設實作只會引發<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed>事件。  
  
 這個方法用來攔截 (hook) 做為後續的非同步通訊端作業完成回呼的事件處理常式。 呼叫者必須實作繼承自這個方法，再開始使用其中一種非同步 (xxxAsync) 方法的非同步通訊端作業至少一個回呼委派<xref:System.Net.Sockets.Socket?displayProperty=nameWithType>類別。  
  
 呼叫端的<xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A>方法可讓用戶端應用程式來完成非同步通訊端作業。 起始非同步通訊端作業時，就必須實作的回呼委派。 完成回呼 delegate(s) 繼承自<xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A>方法必須包含程式邏輯，以完成處理用戶端的非同步通訊端作業。  
  
 非同步作業會收到信號時，應用程式使用<xref:System.Net.Sockets.SocketAsyncEventArgs>物件參數來取得已完成的非同步通訊端作業的狀態。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromPacketInfo">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.IPPacketInformation ReceiveMessageFromPacketInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.IPPacketInformation ReceiveMessageFromPacketInfo" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ReceiveMessageFromPacketInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReceiveMessageFromPacketInfo As IPPacketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::IPPacketInformation ReceiveMessageFromPacketInfo { System::Net::Sockets::IPPacketInformation get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.IPPacketInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得接收之封包的 IP 位址和介面。</summary>
        <value>
          <see cref="T:System.Net.Sockets.IPPacketInformation" /> 執行個體，內含接收之封包的目的地 IP 位址和介面。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會提供有關使用所接收的封包資訊<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>方法。  
  
 這個屬性搭配<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="T:System.Net.Sockets.IPPacketInformation" />
        <altmember cref="P:System.Net.Sockets.IPPacketInformation.Address" />
        <altmember cref="P:System.Net.Sockets.IPPacketInformation.Interface" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); void set(System::Net::EndPoint ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定非同步作業的遠端 IP 端點。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" />，表示非同步作業的遠端 IP 端點。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性指定遠端端點。 這個屬性可以指定要用來連接使用的遠端端點<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>方法。 這個屬性可以指定要使用的資料傳送至遠端端點<xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>方法。 這個屬性可以指定遠端端點從收到的資料使用<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>或<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>方法。  
  
 這個屬性所指定的遠端端點可以包括 IPv4 或 IPv6 位址。  
  
 這個屬性搭配<xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsElements">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SendPacketsElement[] SendPacketsElements { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SendPacketsElement[] SendPacketsElements" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsElements As SendPacketsElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ SendPacketsElements { cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ get(); void set(cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SendPacketsElement[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要為 <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法所使用的非同步作業傳送的緩衝區陣列。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SendPacketsElement" /> 物件的陣列，表示要傳送的緩衝區之陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在記憶體中的記憶體資料緩衝區一組檔案，可代表緩衝區的陣列。 這個屬性搭配<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SendPacketsElement" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsFlags">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TransmitFileOptions SendPacketsFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.TransmitFileOptions SendPacketsFlags" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsFlags As TransmitFileOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::TransmitFileOptions SendPacketsFlags { System::Net::Sockets::TransmitFileOptions get(); void set(System::Net::Sockets::TransmitFileOptions value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TransmitFileOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 方法所使用之非同步作業的 <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 值的位元組合。</summary>
        <value>
          <see cref="T:System.Net.Sockets.TransmitFileOptions" />，內含要和非同步作業一起使用的值位元組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會指定<xref:System.Net.Sockets.TransmitFileOptions>，由<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.TransmitFileOptions" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsSendSize">
      <MemberSignature Language="C#" Value="public int SendPacketsSendSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendPacketsSendSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsSendSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsSendSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendPacketsSendSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("unused property")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳送作業中所使用的資料區塊大小 (以位元組為單位)。</summary>
        <value>
          <see cref="T:System.Int32" />，內含傳送作業中所使用的資料區塊大小 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性設為零，可讓通訊端層，選取預設的傳送大小。 將此屬性設定為 0xFFFFFFFF 可讓呼叫端控制的大小和每個傳送要求的內容，方法是使用<xref:System.Net.Sockets.SendPacketsElement.EndOfPacket%2A?displayProperty=nameWithType>屬性。 這項功能可用於會個別傳送要求的大小限制的訊息通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.SendPacketsElement.EndOfPacket" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBuffer">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化要和非同步通訊端方法一起使用的資料緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>屬性設為 null 和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>屬性為零。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (Memory&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(valuetype System.Memory`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Memory{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (buffer As Memory(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(Memory&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">作業開始的資料緩衝區位移 (以位元組為單位)。</param>
        <param name="count">緩衝區中要傳送或接收的資料量上限 (以位元組為單位)。</param>
        <summary>設定要和非同步通訊端方法一起使用的資料緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `offset`和`count`參數不可為負數。 組合`offset`和`count`參數必須在範圍中的緩衝區陣列<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>屬性。  
  
 這個方法會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>屬性`count`參數和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>屬性`offset`參數。 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>屬性為 null，則這個方法會忽略`offset`和`count`參數和集合<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>屬性設定為 0。  
  
 這個方法不會變更<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">引數超出範圍。 如果 <paramref name="offset" /> 參數小於零或大於 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性中的陣列長度，就會發生這個例外狀況。 如果 <paramref name="count" /> 參數小於零或大於 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性中的陣列長度減去 <paramref name="offset" /> 參數，也會發生這個例外狀況。</exception>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </Member>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要和非同步通訊端方法一起使用的資料緩衝區。</param>
        <param name="offset">作業開始的資料緩衝區位移 (以位元組為單位)。</param>
        <param name="count">緩衝區中要傳送或接收的資料量上限 (以位元組為單位)。</param>
        <summary>設定要和非同步通訊端方法一起使用的資料緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `offset`和`count`參數不可為負數。 組合`offset`和`count`參數必須是在中的資料陣列的界限內`buffer`參數。  
  
 這個方法會設定 [SetBuffer 方法 (位元組\<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A > 屬性來`buffer`參數時，[SetBuffer 方法 (位元組\<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A > 屬性來`count`參數，而 [SetBuffer 方法 (位元組\<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A > 屬性來`offset`參數。  
  
   
  
## Examples  
 下列程式碼範例會建立單一大型緩衝區，它可以分割並指派給 [SetBuffer 方法 (位元組\<xref:System.Net.Sockets.SocketAsyncEventArgs > 物件使用與每個通訊端的 I/O 作業。 這可用來輕易地重複使用緩衝區，並防範分割堆積記憶體。  
  
 [!code-csharp[NCLAsyncSocketServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定了不明確的緩衝區。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性都不是 null，就會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引數超出範圍。 如果 <paramref name="offset" /> 參數小於零或大於 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性中的陣列長度，就會發生這個例外狀況。 如果 <paramref name="count" /> 參數小於零或大於 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 屬性中的陣列長度減去 <paramref name="offset" /> 參數，也會發生這個例外狀況。</exception>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </Member>
    <Member MemberName="SocketClientAccessPolicyProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketClientAccessPolicyProtocol As SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { System::Net::Sockets::SocketClientAccessPolicyProtocol get(); void set(System::Net::Sockets::SocketClientAccessPolicyProtocol value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketClientAccessPolicyProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要用來下載通訊端用戶端存取原則檔案的通訊協定。</summary>
        <value>傳回 <see cref="T:System.Net.Sockets.SocketClientAccessPolicyProtocol" />。  
  
 要用來下載通訊端用戶端存取原則檔案的通訊協定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.SocketClientAccessPolicyProtocol>指定要下載用戶端存取原則檔案的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SocketError">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketError SocketError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketError SocketError" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketError As SocketError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketError SocketError { System::Net::Sockets::SocketError get(); void set(System::Net::Sockets::SocketError value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketError</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定非同步通訊端作業的結果。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketError" />，表示非同步通訊端作業的結果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性提供非同步通訊端作業的完成狀態。 值為<xref:System.Net.Sockets.SocketError.Success?displayProperty=nameWithType>指出作業成功完成。 這個屬性主要用於應用程式的事件處理常式。  
  
 這個屬性適用於所有的非同步通訊端 (xxxAsync) 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketError" />
      </Docs>
    </Member>
    <Member MemberName="SocketFlags">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketFlags SocketFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketFlags SocketFlags" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketFlags As SocketFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketFlags SocketFlags { System::Net::Sockets::SocketFlags get(); void set(System::Net::Sockets::SocketFlags value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得非同步通訊端作業的結果，或設定非同步作業的行為。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketFlags" />，表示非同步通訊端作業的結果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 屬性會指定的位元組合<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>用於非同步通訊端作業。  
  
 這個屬性搭配<xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>， <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>，和<xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="UserToken">
      <MemberSignature Language="C#" Value="public object UserToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object UserToken" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      <MemberSignature Language="VB.NET" Value="Public Property UserToken As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ UserToken { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個非同步通訊端作業相關聯的使用者或應用程式物件。</summary>
        <value>物件，表示與這個非同步通訊端作業相關聯的使用者或應用程式物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可以由應用程式用來與應用程式狀態物件關聯<xref:System.Net.Sockets.SocketAsyncEventArgs>物件。 主要是這個屬性是方法，讓應用程式傳遞至應用程式的事件處理常式 （例如，非同步作業完成方法） 的狀態。  
  
 這個屬性適用於所有的非同步通訊端 (xxxAsync) 方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>