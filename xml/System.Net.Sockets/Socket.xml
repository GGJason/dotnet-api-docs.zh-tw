<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="4e975-101">實作 Berkeley 通訊端介面。</span><span class="sxs-lookup"><span data-stu-id="4e975-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-102"><xref:System.Net.Sockets.Socket>類別會提供一組豐富的方法和屬性的網路通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="4e975-103"><xref:System.Net.Sockets.Socket>類別可讓您同時執行同步和非同步資料傳輸使用任何通訊協定中所列<xref:System.Net.Sockets.ProtocolType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="4e975-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="4e975-104"><xref:System.Net.Sockets.Socket>類別遵循非同步方法的.NET Framework 命名模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="4e975-105">例如，同步<xref:System.Net.Sockets.Socket.Receive%2A>方法對應於非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="4e975-106">如果您的應用程式只需要一個執行緒在執行期間，使用下列方法，專為同步作業模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="4e975-107">如果您使用連線導向的通訊協定，例如 TCP，您的伺服器可以接聽的連接使用<xref:System.Net.Sockets.Socket.Listen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="4e975-108"><xref:System.Net.Sockets.Socket.Accept%2A>方法會處理任何連入連線要求，並傳回<xref:System.Net.Sockets.Socket>可用來與遠端主機通訊資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="4e975-109">使用此傳回<xref:System.Net.Sockets.Socket>呼叫<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="4e975-110">呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.Listen%2A>方法，如果您想要指定本機 IP 位址和連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="4e975-111">如果您想要為您指派可用的通訊埠的基礎服務提供者，請使用零的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="4e975-112">如果您想要連接到接聽的主機，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-113">若要進行通訊的資料，呼叫<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="4e975-114">如果您使用無連接的通訊協定，例如 UDP，您不需要完全接聽的連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="4e975-115">呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，以接受任何內送的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="4e975-116">使用<xref:System.Net.Sockets.Socket.SendTo%2A>資料包傳送至遠端主機的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="4e975-117">若要處理執行期間使用個別執行緒的通訊，請使用下列方法，專為非同步作業模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="4e975-118">如果您使用連線導向的通訊協定，例如 TCP，使用<xref:System.Net.Sockets.Socket>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>，和<xref:System.Net.Sockets.Socket.EndConnect%2A>要用來接聽主機連接的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="4e975-119">使用<xref:System.Net.Sockets.Socket.BeginSend%2A>和<xref:System.Net.Sockets.Socket.EndSend%2A>或<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>非同步通訊資料的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="4e975-120">可處理連入連線要求使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>和<xref:System.Net.Sockets.Socket.EndAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="4e975-121">如果您使用無連接的通訊協定，例如 UDP，您可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.EndSendTo%2A>傳送資料包，並<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>和<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>來接收資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="4e975-122">如果您執行多個通訊端上的非同步作業，它們不一定會完成啟動它們的順序中。</span><span class="sxs-lookup"><span data-stu-id="4e975-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="4e975-123">當您完成傳送和接收資料，請使用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以停用<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-124">在呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法釋放相關聯的所有資源<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="4e975-125"><xref:System.Net.Sockets.Socket>類別可讓您設定您<xref:System.Net.Sockets.Socket>使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="4e975-126">擷取使用這些設定<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-127">如果您要撰寫相當簡單的應用程式，且不需要最大效能，請考慮使用<xref:System.Net.Sockets.TcpClient>， <xref:System.Net.Sockets.TcpListener>，和<xref:System.Net.Sockets.UdpClient>。</span><span class="sxs-lookup"><span data-stu-id="4e975-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="4e975-128">這些類別提供更簡單且更容易使用的介面，以<xref:System.Net.Sockets.Socket>通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-129">下列程式碼範例示範如何<xref:System.Net.Sockets.Socket>類別可以用來將資料傳送至 HTTP 伺服器，並接收回應。</span><span class="sxs-lookup"><span data-stu-id="4e975-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="4e975-130">這個範例會封鎖直到接收整個頁面。</span><span class="sxs-lookup"><span data-stu-id="4e975-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-131">若要建立傳出連線，或接受連入要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="4e975-132">這個類別的執行個體都是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="4e975-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-133">初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-133">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="4e975-134"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 傳回的通訊端資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-134">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="4e975-135">使用從 <see cref="T:System.Net.Sockets.Socket" /> 傳回的指定值，初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-135">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-136">如果您呼叫<xref:System.Net.Sockets.Socket.%23ctor%2A>多次包含相同的位元組陣列，為每個呼叫的引數的建構函式，您將建立受管理的多個<xref:System.Net.Sockets.Socket>與相同的基礎通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-136">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="4e975-137">這種做法不鼓勵。</span><span class="sxs-lookup"><span data-stu-id="4e975-137">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="4e975-138">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-138">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="4e975-139">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-139">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-140">使用指定的通訊端類型和通訊協定，初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-140">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-141">`socketType`參數指定的型別<xref:System.Net.Sockets.Socket>類別和`protocolType`參數會指定使用的通訊協定<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-141">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-142">兩個參數不是獨立的。</span><span class="sxs-lookup"><span data-stu-id="4e975-142">The two parameters are not independent.</span></span> <span data-ttu-id="4e975-143">通常<xref:System.Net.Sockets.Socket>型別是隱含的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-143">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="4e975-144">如果的組合<xref:System.Net.Sockets.Socket>類型及通訊協定造成類型無效<xref:System.Net.Sockets.Socket>，這個建構函式會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-144">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-145">如果這個建構函式擲回<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-145">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-146">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-146">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-147">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-147">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-148">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-148">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-149"><paramref name="socketType" /> 和 <paramref name="protocolType" /> 組合產生無效通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-149">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="4e975-150">其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-150">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="4e975-151">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-151">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="4e975-152">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-152">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-153">使用指定的通訊協定家族 (Family)、通訊端類型和通訊協定，初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-153">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-154">`addressFamily`參數指定的定址配置<xref:System.Net.Sockets.Socket>類別使用，`socketType`參數指定的型別<xref:System.Net.Sockets.Socket>類別，而`protocolType`參數會指定使用的通訊協定<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-154">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-155">三個參數不是獨立的。</span><span class="sxs-lookup"><span data-stu-id="4e975-155">The three parameters are not independent.</span></span> <span data-ttu-id="4e975-156">有些位址系列限制，並通常可以使用哪些通訊協定<xref:System.Net.Sockets.Socket>型別是隱含的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-156">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="4e975-157">如果位址系列的組合<xref:System.Net.Sockets.Socket>類型和通訊協定無效的輸入結果<xref:System.Net.Sockets.Socket>，這個建構函式會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-157">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-158">如果這個建構函式擲回<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-158">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-159">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-159">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-160">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-160">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-161">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-161">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-162">下列程式碼範例示範如何建立執行個體<xref:System.Net.Sockets.Socket>類別。</span><span class="sxs-lookup"><span data-stu-id="4e975-162">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-163"><paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 組合所產生的無效通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-163">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e975-164">建立新建立連接的新 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-164">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="4e975-165">新建立連接的新 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-165">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-166"><xref:System.Net.Sockets.Socket.Accept%2A> 以同步方式暫止的連接要求的第一個擷取的連接要求的佇列接聽的通訊端，然後建立並傳回新<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-166"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-167">您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-167">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="4e975-168">不過，您可以呼叫<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>方法傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-168">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="4e975-169">封鎖模式中，在<xref:System.Net.Sockets.Socket.Accept%2A>封鎖，直到連入連線嘗試會排入佇列。</span><span class="sxs-lookup"><span data-stu-id="4e975-169">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="4e975-170">一旦接受連線，則原始<xref:System.Net.Sockets.Socket>會繼續佇列的連入連線要求直到您關閉它。</span><span class="sxs-lookup"><span data-stu-id="4e975-170">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="4e975-171">如果您呼叫這個方法，使用非封鎖<xref:System.Net.Sockets.Socket>，和任何連接要求會排入佇列，<xref:System.Net.Sockets.Socket.Accept%2A>會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-171">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-172">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-172">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-173">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-173">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-174">然後再呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法，您必須先呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-174">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-175">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-176">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-177">下列程式碼範例可接受簡單<xref:System.Net.Sockets.Socket>連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-177">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-178">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-178">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-179"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-179">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-180">接受的通訊端並未接聽連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-180">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="4e975-181">您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-181">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-182"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-182">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-183">開始非同步作業以接受連入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-183">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="4e975-184">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-184">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-185">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-185">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-186">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-186">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-187">不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-187">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-188">可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法來以非同步方式處理傳入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-188">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="4e975-189">以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-189">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="4e975-190">然後再呼叫<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-190">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="4e975-191">若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將它連結<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-191">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="4e975-192">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：</span><span class="sxs-lookup"><span data-stu-id="4e975-192">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-193">呼叫端可以選擇性地指定現有<xref:System.Net.Sockets.Socket>用於連入連線，藉由指定<xref:System.Net.Sockets.Socket>搭配<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-193">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="4e975-194">如果<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性是 null，新<xref:System.Net.Sockets.Socket>建構具有相同<xref:System.Net.Sockets.Socket.AddressFamily%2A>， <xref:System.Net.Sockets.Socket.SocketType%2A>，和<xref:System.Net.Sockets.Socket.ProtocolType%2A>與目前<xref:System.Net.Sockets.Socket>並設定為<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-194">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="4e975-195">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-195">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-196">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-196">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-197">（選擇性） 緩衝區可能會提供用來接收資料後，通訊端上的初始區塊<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。</span><span class="sxs-lookup"><span data-stu-id="4e975-197">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="4e975-198">在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設為包含資料的緩衝區來接收和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設為接收緩衝區中的資料位元組的數目上限。</span><span class="sxs-lookup"><span data-stu-id="4e975-198">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="4e975-199">這些屬性可以使用設定<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-199">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e975-200">傳入緩衝區的一部分會可供內部使用基礎 Winsock AcceptEx 呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-200">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="4e975-201">這表示傳回的資料量會一律的值小於<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>提供執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-201">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="4e975-202">在內部使用的緩衝區數量有所不同通訊端位址系列。</span><span class="sxs-lookup"><span data-stu-id="4e975-202">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="4e975-203">所需的最小緩衝區大小為 288 個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-203">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="4e975-204">如果指定較大的緩衝區大小，則<xref:System.Net.Sockets.Socket>預期某些額外的資料以外 Winsock AcceptEx 呼叫所收到的資料，並會等候，直到接收到此額外的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-204">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="4e975-205">如果發生逾時，會重設連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-205">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="4e975-206">因此，如果一段指定的預期有額外的資料，然後緩衝區大小應該設定最小緩衝區大小加上此一數量。</span><span class="sxs-lookup"><span data-stu-id="4e975-206">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="4e975-207">完成回呼方法應該檢查<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>屬性來判斷如果<xref:System.Net.Sockets.Socket.AcceptAsync%2A>作業已順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-207">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="4e975-208"><xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>可能已不接受任何連線時，在某些情況下會發生事件，而且會導致<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>屬性設定為<xref:System.Net.Sockets.SocketError.ConnectionReset>。</span><span class="sxs-lookup"><span data-stu-id="4e975-208">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="4e975-209">這可能是因為連接埠掃描使用半開啟 SYN 類型掃描 (SYN]-> [SYN ACK]-> [RST 順序)。</span><span class="sxs-lookup"><span data-stu-id="4e975-209">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="4e975-210">使用應用程式<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法應該準備好處理這個狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-210">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-211">引數無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-211">An argument is not valid.</span></span> <span data-ttu-id="4e975-212">如果提供的緩衝區不夠大，就會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-212">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="4e975-213">緩衝區必須至少為 2 \* (sizeof(SOCKADDR_STORAGE + 16) 位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-213">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
 <span data-ttu-id="4e975-214">如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，也會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-214">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-215">引數超出範圍。</span><span class="sxs-lookup"><span data-stu-id="4e975-215">An argument is out of range.</span></span> <span data-ttu-id="4e975-216">如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小於 0，就會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-216">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-217">要求了無效的作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-217">An invalid operation was requested.</span></span> <span data-ttu-id="4e975-218">如果接受的 <see cref="T:System.Net.Sockets.Socket" /> 不接聽連接或接受的通訊端已繫結，就會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-218">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
 <span data-ttu-id="4e975-219">您必須先呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法，再呼叫 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-219">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
 <span data-ttu-id="4e975-220">此例外狀況也會在已與通訊端連線，或是通訊端作業已使用指定的 <paramref name="e" /> 參數進行時發生。</span><span class="sxs-lookup"><span data-stu-id="4e975-220">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-221">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-221">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-222">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-222">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-223"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-223">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-224">取得 <see cref="T:System.Net.Sockets.Socket" /> 的通訊協定家族 (Family)。</span><span class="sxs-lookup"><span data-stu-id="4e975-224">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-225">其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-225">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-226"><xref:System.Net.Sockets.AddressFamily>定址配置，所指定的執行個體<xref:System.Net.Sockets.Socket>類別可以使用。</span><span class="sxs-lookup"><span data-stu-id="4e975-226">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="4e975-227">這個屬性是唯讀的而且時，會設定<xref:System.Net.Sockets.Socket>建立。</span><span class="sxs-lookup"><span data-stu-id="4e975-227">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-228">下列程式碼範例顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>至主控台。</span><span class="sxs-lookup"><span data-stu-id="4e975-228">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-229">取得已從網路接收且可供讀取的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-229">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="4e975-230">從網路收到的和可供讀取的資料位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-230">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-231">如果您使用非封鎖<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A>是好的方法，以判斷資料是否會排入佇列進行讀取，然後再呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-231">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-232">可用的資料時的資料總量排入佇列進行讀取的網路緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-232">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="4e975-233">如果沒有資料會排入佇列中的網路緩衝區，<xref:System.Net.Sockets.Socket.Available%2A>傳回 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-233">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="4e975-234">如果遠端主機關機或關閉連接，<xref:System.Net.Sockets.Socket.Available%2A>可以擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-234">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-235">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-235">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-236">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-236">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-237">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-237">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-238">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-238">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-239">下列程式碼範例會比較的結果呼叫 IOControl FIONREAD 與可用的屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-239">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-240">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-240">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-241"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-241">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-242">開始非同步作業以接受連入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-242">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="4e975-243"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-243">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-244">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-244">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-245">開始非同步作業以接受連入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-245">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="4e975-246">參考非同步 <see cref="T:System.IAsyncResult" /> 建立作業的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-246">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-247">可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來以非同步方式處理傳入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-247">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="4e975-248">以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-248">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="4e975-249">然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-249">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="4e975-250">您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-250">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-251">若要這樣做，在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-251">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="4e975-252">如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-252">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-253">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-253">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-254">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-254">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="4e975-255">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-255">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="4e975-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> 會傳回新<xref:System.Net.Sockets.Socket>物件可用來傳送和接收資料的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="4e975-257">您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-257">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="4e975-258">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-258">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-259">在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="4e975-259">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="4e975-260">系統可能也會使用呼叫執行緒來叫用回呼方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-260">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="4e975-261">在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>屬性傳回<xref:System.IAsyncResult>設表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-261">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="4e975-262">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-262">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-263">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-263">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-264">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-264">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="4e975-265">後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-265">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-266">您可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-266">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-267">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-267">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-268">取得這個程式碼之後，請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</span><span class="sxs-lookup"><span data-stu-id="4e975-268">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-269">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-269">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-270">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-270">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-271">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-271">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-272">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-272">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-273">下列程式碼範例會嘗試以非同步方式接收連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-273">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-274"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-274">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-275">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-275">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-276">接受的通訊端並未接聽連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-276">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="4e975-277">您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-277">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="4e975-278">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-278">-or-</span></span>  
  
 <span data-ttu-id="4e975-279">接受的通訊端已繫結。</span><span class="sxs-lookup"><span data-stu-id="4e975-279">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-280"><paramref name="receiveSize" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-280"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-281">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-281">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="4e975-282">要從寄件者接受的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-282">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-283"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-283">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-284">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-284">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-285">開始非同步作業以接收連入連線嘗試，並接收用戶端應用程式傳送的第一個資料區塊。</span><span class="sxs-lookup"><span data-stu-id="4e975-285">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="4e975-286">參考非同步 <see cref="T:System.IAsyncResult" /> 建立作業的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-286">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-287">可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來以非同步方式處理傳入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-287">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="4e975-288">以非同步方式接受連線，可讓您傳送和接收不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-288">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="4e975-289">這個多載可讓您指定要接受在初始中傳送的位元組數目`receiveSize`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-289">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="4e975-290">然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-290">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="4e975-291">您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-291">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-292">若要這樣做，在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-292">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="4e975-293">如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-293">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-294">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-294">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-295">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-295">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="4e975-296">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-296">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="4e975-297"><xref:System.Net.Sockets.Socket.EndAccept%2A> 傳回新<xref:System.Net.Sockets.Socket>可用來傳送和接收資料的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-297"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="4e975-298">您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-298">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="4e975-299">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-299">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-300">在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="4e975-300">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="4e975-301">系統可能也會使用呼叫執行緒來叫用回呼方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-301">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="4e975-302">在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>屬性傳回<xref:System.IAsyncResult>設表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-302">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="4e975-303">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-303">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-304">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-304">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="4e975-305">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-305">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="4e975-306">後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-306">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-307">您可以呼叫使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼的物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-307">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-308">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-308">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-309">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-309">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-310">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-310">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-311">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-311">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-312">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-312">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-313">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-313">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-314">下列程式碼範例會開啟通訊端，並接受非同步連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-314">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="4e975-315">在此範例中，通訊端接受初始的 10 個位元組的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-315">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="4e975-316">接收的位元組數目和資料會顯示在主控台上的回呼委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-316">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="4e975-317">請參閱<xref:System.Net.Sockets.Socket.BeginReceive%2A>的收到的剩餘資料的方式說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-317">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-318"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-318">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-319">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-319">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-320">接受的通訊端並未接聽連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-320">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="4e975-321">您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-321">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="4e975-322">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-322">-or-</span></span>  
  
 <span data-ttu-id="4e975-323">接受的通訊端已繫結。</span><span class="sxs-lookup"><span data-stu-id="4e975-323">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-324"><paramref name="receiveSize" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-324"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-325">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-325">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="4e975-326">已接受的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-326">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="4e975-327">此值可為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-327">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="4e975-328">要接收的最大位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-328">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-329"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-329">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-330">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-330">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-331">開始非同步作業以接收指定通訊端的連入連線嘗試，並接收用戶端應用程式傳送的第一個資料區塊。</span><span class="sxs-lookup"><span data-stu-id="4e975-331">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="4e975-332"><see cref="T:System.IAsyncResult" /> 物件，參考非同步 <see cref="T:System.Net.Sockets.Socket" /> 物件建立。</span><span class="sxs-lookup"><span data-stu-id="4e975-332">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-333">可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來以非同步方式處理傳入的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-333">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="4e975-334">以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-334">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="4e975-335">這個多載可讓您指定的可接受通訊端`acceptSocket`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-335">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="4e975-336">如果這個參數是`null`，由可接受的通訊端<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-336">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-337">您可以指定要接受在初始中傳送的位元組數目`receiveSize`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-337">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="4e975-338">然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-338">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="4e975-339">您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-339">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-340">若要這樣做，在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-340">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="4e975-341">如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-341">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-342">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-342">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-343">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-343">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="4e975-344">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-344">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="4e975-345"><xref:System.Net.Sockets.Socket.EndAccept%2A> 傳回新<xref:System.Net.Sockets.Socket>物件可用來傳送和接收資料的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-345"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="4e975-346">您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-346">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="4e975-347">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-347">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-348">在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="4e975-348">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="4e975-349">系統可能也會使用呼叫執行緒來叫用回呼方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-349">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="4e975-350">在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>屬性傳回<xref:System.IAsyncResult>設表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-350">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="4e975-351">如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-351">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-352">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-352">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-353">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-353">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="4e975-354">後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-354">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-355">您可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼的物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-355">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-356">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-356">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-357">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-357">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-358">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-359">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-360">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-360">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-361">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-361">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-362">下列程式碼範例會開啟通訊端，並接受非同步連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-362">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="4e975-363">在此範例中，通訊端接受初始的 10 個位元組的資料和`acceptSocket`參數是`null`，可以強制<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來建立可接受的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-363">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="4e975-364">接收的位元組數目和資料會顯示在主控台上的回呼委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-364">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="4e975-365">請參閱<xref:System.Net.Sockets.Socket.BeginReceive%2A>的收到的剩餘資料的方式說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-365">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-366"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-366">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-367">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-367">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-368">接受的通訊端並未接聽連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-368">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="4e975-369">您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-369">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="4e975-370">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-370">-or-</span></span>  
  
 <span data-ttu-id="4e975-371">接受的通訊端已繫結。</span><span class="sxs-lookup"><span data-stu-id="4e975-371">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-372"><paramref name="receiveSize" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-372"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-373">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-373">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-374">開始遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-374">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback"><span data-ttu-id="4e975-375"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-375">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-376">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-376">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-377">開始遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-377">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="4e975-378">參考非同步連接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-378">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-379">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法會啟動非同步要求，以連接至`remoteEP`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-379">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="4e975-380">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.BeginConnect%2A>建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-380">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="4e975-381">連接或以非同步方式設定預設遠端主機可讓您傳送和接收不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-381">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-382">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-382">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="4e975-383">在非常小，您必須傳遞<xref:System.Net.Sockets.Socket>至<xref:System.Net.Sockets.Socket.BeginConnect%2A>透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-383">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="4e975-384">如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>，以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-384">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="4e975-385">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-385">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-386">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-386">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="4e975-387">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndConnect%2A>直到<xref:System.Net.Sockets.Socket>順利連線，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-387">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="4e975-388">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-388">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="4e975-389">在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="4e975-389">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-390">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-390">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-391">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-391">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-392">您可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-392">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="4e975-393">如果您呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-393">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-394">如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。</span><span class="sxs-lookup"><span data-stu-id="4e975-394">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="4e975-395">如果您不能<xref:System.Net.Sockets.Socket.BeginConnect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-395">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-396">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-396">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="4e975-397">如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-397">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-398">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法一次所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-398">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="4e975-399">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-399">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-400">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-400">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="4e975-401">後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-401">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-402">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-402">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-403">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-403">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-404">如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-404">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="4e975-405">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-405">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-406">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-406">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-407">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-407">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-408">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-408">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-409">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-409">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-410">下列程式碼範例會起始非同步連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-410">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-411"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-411"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-412">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-412">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-413"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-413">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-414">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-414">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-415">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-415">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4e975-416">遠端主機的 <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-416">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="4e975-417">遠端主機的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-417">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="4e975-418">包含連線作業資訊的使用者定義物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-418">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="4e975-419">作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-419">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-420">開始遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-420">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="4e975-421">此主機是由 <see cref="T:System.Net.IPAddress" /> 和連接埠號碼所指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-421">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="4e975-422">參考非同步連接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-422">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-423">非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-423">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="4e975-424">一般而言，方法由叫用`requestCallback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-424">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-425">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-425">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-426">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載，或<xref:System.Net.Sockets.Socket.EndConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-426">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-427">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-427">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-428">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-428">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="4e975-429">後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-429">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="4e975-430">如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="4e975-430">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-431">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-431">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-432">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-432">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-433">如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-433">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="4e975-434">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-434">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="4e975-435">也<xref:System.Net.EndPoint>也就是使用必須不同。</span><span class="sxs-lookup"><span data-stu-id="4e975-435">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-436">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-436">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-437">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-437">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-438">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-438">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-439">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-439">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-440">下列程式碼範例會起始非同步連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-440">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-441"><paramref name="address" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-441"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-442">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-442">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-443"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-443">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-444"><see cref="T:System.Net.Sockets.Socket" /> 不在通訊端系列。</span><span class="sxs-lookup"><span data-stu-id="4e975-444">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-445">連接埠號碼無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-445">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-446"><paramref name="address" /> 的長度為零。</span><span class="sxs-lookup"><span data-stu-id="4e975-446">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-447">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-447">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="4e975-448">至少一個 <see cref="T:System.Net.IPAddress" />，指定遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-448">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="4e975-449">遠端主機的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-449">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="4e975-450">包含連線作業資訊的使用者定義物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-450">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="4e975-451">作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-451">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-452">開始遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-452">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="4e975-453">主機是由 <see cref="T:System.Net.IPAddress" /> 陣列和通訊埠編號指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-453">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="4e975-454"><see cref="T:System.IAsyncResult" />，其會參考非同步連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-454">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-455">非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-455">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="4e975-456">一般而言，方法由叫用`requestCallback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-456">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-457">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-457">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-458">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-458">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="4e975-459">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-459">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-460">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-460">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="4e975-461">後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-461">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="4e975-462">如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-462">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-463">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-463">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-464">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-464">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-465">如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-465">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="4e975-466">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-466">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="4e975-467">也<xref:System.Net.EndPoint>也就是使用必須不同。</span><span class="sxs-lookup"><span data-stu-id="4e975-467">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-468">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-468">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-469">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-469">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-470">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-470">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-471">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-471">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-472">下列程式碼範例會起始非同步連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-472">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-473"><paramref name="addresses" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-473"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-474">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-474">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-475"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-475">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-476">這個方法對使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的通訊端有效。</span><span class="sxs-lookup"><span data-stu-id="4e975-476">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-477">連接埠號碼無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-477">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-478"><paramref name="address" /> 的長度為零。</span><span class="sxs-lookup"><span data-stu-id="4e975-478">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-479">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-479">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="4e975-480">遠端主機的名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-480">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="4e975-481">遠端主機的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-481">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="4e975-482">包含連線作業資訊的使用者定義物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-482">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="4e975-483">作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-483">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-484">開始遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-484">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="4e975-485">此主機是由主機名稱和連接埠號碼指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-485">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="4e975-486">參考非同步連接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-486">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-487">非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-487">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="4e975-488">一般而言，方法由叫用`requestCallback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-488">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-489">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-489">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-490">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-490">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="4e975-491">若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-491">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-492">當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-492">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="4e975-493">後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-493">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="4e975-494">如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="4e975-494">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-495">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-495">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-496">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-496">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-497">如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-497">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="4e975-498">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-498">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="4e975-499">也<xref:System.Net.EndPoint>也就是使用必須不同。</span><span class="sxs-lookup"><span data-stu-id="4e975-499">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-500">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-500">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-501">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-501">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-502">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-502">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-503">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-503">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-504">下列程式碼範例會起始非同步連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-504">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-505"><paramref name="host" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-505"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-506"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-506">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-507">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</span><span class="sxs-lookup"><span data-stu-id="4e975-507">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-508">連接埠號碼無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-508">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-509">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-509">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="4e975-510">如果這個通訊端可以在關閉連接後重複使用，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-510"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-511"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-511">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-512">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-512">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-513">開始非同步要求，以中斷遠端端點的連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-513">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-514"><see cref="T:System.IAsyncResult" /> 物件，參考非同步作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-514">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-515">如果您使用連線導向的通訊協定，您可以呼叫<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法，以從遠端端點要求中斷連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-515">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="4e975-516">如果`reuseSocket`是`true`，您可以重複使用的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-516">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="4e975-517"><xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法使用另一個執行緒來叫用指定的回呼方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-517">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="4e975-518"><xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法會封鎖直到暫止的中斷連線已完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-518">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="4e975-519">如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-519">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-520">如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-520">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-521">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-521">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-522">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-522">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-523">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-523">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-524">下列程式碼範例會建立通訊端的非同步通訊，並將部分資料傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-524">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="4e975-525">當已傳送資料時，<xref:System.Net.Sockets.Socket.Shutdown%2A>呼叫來停止傳送和接收活動。</span><span class="sxs-lookup"><span data-stu-id="4e975-525">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="4e975-526">然後<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>呼叫來開始中斷連線要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-526">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="4e975-527">當要求完成時，<xref:System.Net.Sockets.Socket.Connected%2A>屬性會查詢以測試是否已中斷連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-527">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-528">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="4e975-528">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-529"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-529">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-530">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-530">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-531">開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-531">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-532"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-532">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-533"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-533">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-534"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-534">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-535">使用者定義的物件，包含接收作業的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-535">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="4e975-536">作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-536">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-537">開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-537">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-538">參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-538">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-539">非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-539">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="4e975-540">一般而言，方法由叫用`callback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-540">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-541">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-541">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-542">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-542">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="4e975-543">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-543">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-544">如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-544">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-545">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-545">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-546">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-546">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-547">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-547">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-548">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-548">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-549">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-549">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-550">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-550">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-551">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-551">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-552">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-552">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-553">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-553">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-554"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-554"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-555">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-555">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="4e975-556">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-556"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-557"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-557">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-558"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-558">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-559"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-559">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-560"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-560">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-561">使用者定義的物件，包含接收作業的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-561">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="4e975-562">作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-562">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-563">開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-563">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-564">參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-564">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-565">非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-565">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="4e975-566">一般而言，方法由叫用`callback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-566">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-567">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-567">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-568">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-568">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="4e975-569">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-569">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-570">如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-570">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-571">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-571">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-572">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-572">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-573">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-573">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-574">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-574">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-575">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-575">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-576">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-576">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-577">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-577">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-578">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-578">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-579">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-579">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-580"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-580"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-581">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-581">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="4e975-582">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-582"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-583"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-583">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-584">「緩衝區」<c></c>參數中要儲存已接收資料的以零起始的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-584">The zero-based position in the <c>buffer</c> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-585">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-585">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><span data-ttu-id="4e975-586"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-586">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-587">使用者定義的物件，包含接收作業的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-587">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="4e975-588">作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-588">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-589">開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-589">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-590">參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-590">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-591">非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-591">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="4e975-592">一般而言，方法由叫用`callback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-592">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-593">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-593">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-594">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-594">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="4e975-595">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-595">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-596">如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-596">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-597">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-597">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-598">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-598">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-599">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-599">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-600">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-600">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-601">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-601">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-602">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-602">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-603">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-603">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-604">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-604">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-605">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-605">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-606">下列程式碼範例會開始以非同步方式接收的資料連接<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-606">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-607"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-607"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-608">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-608">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="4e975-609">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-609"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-610"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-610"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-611">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-611">-or-</span></span>  
  
 <span data-ttu-id="4e975-612"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-612"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-613">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-613">-or-</span></span>  
  
 <span data-ttu-id="4e975-614"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-614"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-615">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-615">-or-</span></span>  
  
 <span data-ttu-id="4e975-616"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-616"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-617"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-617">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-618">「緩衝區」<c></c>中存放已接收資料的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-618">The location in <c>buffer</c> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-619">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-619">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback"><span data-ttu-id="4e975-620"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-620">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-621">使用者定義的物件，包含接收作業的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-621">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="4e975-622">作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-622">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="4e975-623">開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-623">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-624">參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-624">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-625">非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-625">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="4e975-626">一般而言，方法由叫用`callback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-626">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-627">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-627">This method does not block until the operation is complete.</span></span> <span data-ttu-id="4e975-628">若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-628">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="4e975-629">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-629">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-630">如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-630">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-631">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-631">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-632">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-632">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-633">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-633">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-634">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-634">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-635">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-635">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-636">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-636">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-637">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-637">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-638">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-638">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-639">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-639">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-640"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-640"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-641">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-641">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="4e975-642">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-642"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-643"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-643"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-644">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-644">-or-</span></span>  
  
 <span data-ttu-id="4e975-645"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-645"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-646">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-646">-or-</span></span>  
  
 <span data-ttu-id="4e975-647"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-647"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-648">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-648">-or-</span></span>  
  
 <span data-ttu-id="4e975-649"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-649"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-650"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-650">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-651">「緩衝區」<c></c>參數中要儲存資料的以零起始的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-651">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-652">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-652">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><span data-ttu-id="4e975-653"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-653">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-654">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-654">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-655">開始從指定的網路裝置非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-655">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="4e975-656">參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-656">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-657"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法開始非同步讀取從遠端主機的 無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-657">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="4e975-658">呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法可讓您接收不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-658">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-659">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-659">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-660">若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-660">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="4e975-661">如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-661">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-662">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-662">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-663">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-663">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-664">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，系統會使用另一個執行緒來執行指定的回呼方法，它會封鎖在<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>直到<xref:System.Net.Sockets.Socket>擲回例外狀況或讀取資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-664">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="4e975-665">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-665">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-666">當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-666">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-667">如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-667">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-668">然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，或<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-668">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-669">這個方法會讀取資料到`buffer`參數，以及擷取遠端裝載傳送資料的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-669">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="4e975-670">如需如何擷取此端點資訊，請參閱<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-670">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="4e975-671">這個方法是最有用，如果您想要以非同步方式接收來自未知的主機或多部主機的 無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-671">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="4e975-672">在這些情況下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-672">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="4e975-673">如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-673">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-674">如果您使用的不可靠的通訊協定，將會遺失過多的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-674">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="4e975-675">如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-675">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="4e975-676">若要保證，應用程式應該明確繫結遠端主機端點便會永遠傳回<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，然後再呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法`optionLevel`參數設定為<xref:System.Net.Sockets.SocketOptionLevel.IP>或<xref:System.Net.Sockets.SocketOptionLevel.IPv6>適時`optionName`參數設定為<xref:System.Net.Sockets.SocketOptionName.PacketInformation>，而`optionValue`參數以啟用此選項，然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-676">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-677">否則，便可將不會傳回當寄件者已傳送的資料包的數字之前已呼叫收件者, 的遠端主機端點<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-677">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-678">雖然<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。</span><span class="sxs-lookup"><span data-stu-id="4e975-678">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="4e975-679">如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，或藉由呼叫接受連入連線要求<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-679">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-680">如果您呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，然後再建立或接受連線，您會收到<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-680">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-681">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-681">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-682">在任一情況下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-682">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-683">使用連線導向的通訊端<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>會讀取位於最高達指定的位元組數目的資料量`size`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-683">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="4e975-684">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-684">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-685">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-685">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-686">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-686">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-687">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-687">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-688">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-688">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-689">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-689">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-690">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-690">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-691">下列程式碼範例會從遠端主機，以非同步方式接收無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-691">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-692"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-692"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-693">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-693">-or-</span></span>  
  
 <span data-ttu-id="4e975-694"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-694"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-695">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-695">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-696"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-696"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-697">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-697">-or-</span></span>  
  
 <span data-ttu-id="4e975-698"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-698"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-699">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-699">-or-</span></span>  
  
 <span data-ttu-id="4e975-700"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-700"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-701">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-701">-or-</span></span>  
  
 <span data-ttu-id="4e975-702"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-702"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-703"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-703">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-704">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-704">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-705"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-705">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-706">「緩衝區」<c></c>參數中要儲存資料的以零起始的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-706">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-707">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-707">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-708"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-708">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-709"><see cref="T:System.Net.EndPoint" />，表示資料的來源。</span><span class="sxs-lookup"><span data-stu-id="4e975-709">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-710"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-710">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-711">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-711">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-712">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，開始以非同步方式接收指定之位元組數目的資料至資料緩衝區的指定位置，並儲存端點和封包資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-712">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information..</span></span></summary>
        <returns><span data-ttu-id="4e975-713">參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-713">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-714">非同步接收作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-714">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="4e975-715">一般而言，方法由叫用`asyncCallback`委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-715">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="4e975-716">這個方法不會封鎖直到作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-716">This method does not block until the operation completes.</span></span> <span data-ttu-id="4e975-717">若要封鎖的作業完成之前，請使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-717">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-718">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-718">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-719">如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="4e975-719">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="4e975-720">這個方法會讀取資料到`buffer`參數，和擷取遠端裝載的端點從中傳送資料，以及收到的封包的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-720">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="4e975-721">如需如何擷取此端點資訊，請參閱<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-721">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="4e975-722">這個方法是最有用，如果您想要以非同步方式接收來自未知的主機或多部主機的 無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-722">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-723">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-723">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-724">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-724">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-725">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-725">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-726">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-726">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-727">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-727">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-728">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-728">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-729"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-729"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-730">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-730">-or-</span></span>  
  
 <span data-ttu-id="4e975-731"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-731"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-732">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-732">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-733"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-733"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-734">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-734">-or-</span></span>  
  
 <span data-ttu-id="4e975-735"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-735"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-736">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-736">-or-</span></span>  
  
 <span data-ttu-id="4e975-737"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-737"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-738">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-738">-or-</span></span>  
  
 <span data-ttu-id="4e975-739"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-739"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-740"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-740">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-741">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="4e975-741">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-742">非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-742">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-743"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-743">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-744"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-744">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-745"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-745">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-746">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-746">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-747">非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-747">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-748">參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-748">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-749"><xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-749">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-750"><xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-750"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-751">呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-751">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-752">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-752">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="4e975-753">若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-753">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="4e975-754">如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-754">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-755">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-755">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-756">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-756">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="4e975-757">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-757">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="4e975-758">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-758">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e975-759">當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-759">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-760">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-760">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-761">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-761">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-762">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-762">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="4e975-763">還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-763">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-764">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-764">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-765">您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-765">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-766">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-766">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-767">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-767">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-768">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-768">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-769">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-769">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-770">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-770">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-771">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-771">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-772">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-772">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-773">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-773">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-774">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-774">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-775">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-775">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-776">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-776">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-777">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-777">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-778">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-778">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-779"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-779"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-780"><paramref name="buffers" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-780"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-781">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-781">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-782">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-782">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-783"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-783">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-784"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-784">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-785"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-785">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-786"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-786">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-787"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-787">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-788">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-788">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-789">非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-789">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-790">參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-790">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-791"><xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-791">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-792"><xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-792"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-793">呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-793">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-794">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-794">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="4e975-795">若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-795">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="4e975-796">如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-796">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-797">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-797">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-798">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-798">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="4e975-799">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-799">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="4e975-800">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-800">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e975-801">在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。</span><span class="sxs-lookup"><span data-stu-id="4e975-801">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-802">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-802">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-803">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-803">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-804">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-804">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="4e975-805">還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-805">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-806">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-806">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-807">您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-807">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-808">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-808">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-809">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-809">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-810">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-810">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-811">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-811">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-812">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-812">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-813">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-813">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-814">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-814">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-815">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-816">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-817">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-818">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-819">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-819">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-820">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-820">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-821"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-821"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-822"><paramref name="buffers" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-822"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-823">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-823">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-824">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-824">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-825"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-825">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-826"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-826">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-827">「緩衝區」<c></c>參數中要開始傳送資料的以零起始的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-827">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-828">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-828">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-829"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-829">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-830"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-830">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-831"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-831">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-832">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-832">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-833">非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-833">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-834">參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-834">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-835"><xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-835">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-836"><xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-836"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-837">呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-837">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-838">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-838">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="4e975-839">若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-839">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="4e975-840">如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-840">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-841">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-841">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-842">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-842">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="4e975-843">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-843">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="4e975-844">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-844">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e975-845">當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-845">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-846">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-846">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-847">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-847">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-848">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-848">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="4e975-849">還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-849">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-850">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-850">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-851">您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-851">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-852">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-852">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-853">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-853">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-854">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-854">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-855">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-855">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-856">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-856">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-857">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-857">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-858">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-858">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-859">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-859">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-860">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-860">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-861">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-861">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-862">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-862">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-863">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-863">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-864">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-864">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-865"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-865"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-866">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-866">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-867">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-867">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-868"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-868"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-869">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-869">-or-</span></span>  
  
 <span data-ttu-id="4e975-870"><paramref name="offset" /> 小於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-870"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-871">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-871">-or-</span></span>  
  
 <span data-ttu-id="4e975-872"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-872"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-873">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-873">-or-</span></span>  
  
 <span data-ttu-id="4e975-874"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-874"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-875"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-875">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-876"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-876">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-877">「緩衝區」<c></c>參數中要開始傳送資料的以零起始的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-877">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-878">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-878">The number of bytes to send.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><span data-ttu-id="4e975-879"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-879">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-880">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-880">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-881">非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-881">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-882">參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-882">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-883"><xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-883">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="4e975-884"><xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-884"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-885">呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-885">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-886">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-886">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="4e975-887">若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-887">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="4e975-888">如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-888">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-889">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-889">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-890">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-890">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="4e975-891">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-891">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="4e975-892">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-892">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e975-893">當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-893">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-894">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-894">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-895">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-895">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-896">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-896">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="4e975-897">還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-897">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-898">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-898">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-899">您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-899">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-900">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-900">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-901">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-901">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-902">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-902">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-903">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-903">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-904">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-904">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-905">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-905">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-906">`state` 是使用者定義的具現化。</span><span class="sxs-lookup"><span data-stu-id="4e975-906">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-907">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-907">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-908">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-908">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-909">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-909">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-910">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-910">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-911">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-911">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-912">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-912">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-913">下列程式碼範例會開始以非同步方式將資料傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-913">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-914"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-914"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-915">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-915">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-916">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-916">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-917"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-917"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-918">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-918">-or-</span></span>  
  
 <span data-ttu-id="4e975-919"><paramref name="offset" /> 小於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-919"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-920">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-920">-or-</span></span>  
  
 <span data-ttu-id="4e975-921"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-921"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-922">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-922">-or-</span></span>  
  
 <span data-ttu-id="4e975-923"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-923"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-924"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-924">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-925">將檔案以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-925">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="4e975-926">字串，包含要傳送之檔案的路徑和名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-926">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="4e975-927">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-927">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-928"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-928">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-929">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-929">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-930">使用 <see cref="T:System.Net.Sockets.Socket" /> 旗標，將檔案 <paramref name="fileName" /> 傳送至已連接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-930">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="4e975-931"><see cref="T:System.IAsyncResult" /> 物件，表示非同步傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-931">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-932">這個多載會將該檔案傳送`fileName`連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-932">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="4e975-933">如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-933">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="4e975-934">使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。</span><span class="sxs-lookup"><span data-stu-id="4e975-934">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="4e975-935">如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-935">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="4e975-936">這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。</span><span class="sxs-lookup"><span data-stu-id="4e975-936">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="4e975-937">如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-937">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="4e975-938"><xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>，<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-938">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="4e975-939"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> 擲回例外狀況，如果您不先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-939"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-940">呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法可讓您傳送不同的執行緒中的檔案。</span><span class="sxs-lookup"><span data-stu-id="4e975-940">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-941">若要完成此作業，您可以建立所叫用回呼方法<xref:System.AsyncCallback>委派參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-941">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="4e975-942">若要這樣做，請在最起碼`state`參數必須包含<xref:System.Net.Sockets.Socket>物件正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-942">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="4e975-943">如果您的回呼需要詳細資訊，您可以建立類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-943">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-944">傳遞至這個自訂物件的執行個體<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-944">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-945">叫用回呼方法必須<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-945">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="4e975-946">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>傳送整個檔案，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-946">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="4e975-947">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-947">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-948">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSendFile%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-948">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-949">無連接的通訊協定，您必須確定檔案的大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-949">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-950">如果是的話，不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-950">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-951">如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-951">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-952">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-952">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-953">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-953">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-954">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-954">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-955">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-955">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-956">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-956">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-957">下列程式碼範例會建立，並連接的非同步通訊的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-957">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="4e975-958">首先，「 text.txt"的檔案會非同步地傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-958">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="4e975-959">委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-959">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-960"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-960">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-961">通訊端未連線至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-961">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="4e975-962">找不到檔案 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-962">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-963">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-963">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-964">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-964">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="4e975-965">字串，包含要傳送之檔案的路徑和名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-965">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="4e975-966">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-966">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="4e975-967">包含傳送檔案前要傳送之資料的 <see cref="T:System.Byte" /> 陣列。</span><span class="sxs-lookup"><span data-stu-id="4e975-967">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="4e975-968">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-968">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="4e975-969">包含傳送檔案後要傳送之資料的 <see cref="T:System.Byte" /> 陣列。</span><span class="sxs-lookup"><span data-stu-id="4e975-969">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="4e975-970">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-970">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="4e975-971"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-971">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="4e975-972">這個作業完成時要叫用的 <see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-972">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="4e975-973">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-973">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-974">使用者定義的物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-974">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="4e975-975">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-975">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="4e975-976">將檔案和資料緩衝區以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-976">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="4e975-977"><see cref="T:System.IAsyncResult" /> 物件，表示非同步作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-977">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-978">這個多載都需要您想要傳送的檔案和的位元組合名稱<xref:System.Net.Sockets.TransmitFileOptions>值。</span><span class="sxs-lookup"><span data-stu-id="4e975-978">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="4e975-979">`preBuffer`參數會包含您想要位在檔案之前的任何資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-979">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="4e975-980">`postBuffer` 包含您想要遵循之檔案的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-980">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="4e975-981">如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-981">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="4e975-982">使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。</span><span class="sxs-lookup"><span data-stu-id="4e975-982">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="4e975-983">如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-983">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="4e975-984">`flags`參數提供視窗通訊端服務提供者，以及其他資訊的檔案傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-984">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="4e975-985">如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="4e975-985">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="4e975-986">這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。</span><span class="sxs-lookup"><span data-stu-id="4e975-986">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="4e975-987">如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-987">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="4e975-988"><xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-988">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="4e975-989"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> 擲回例外狀況，如果您不先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-989"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="4e975-990">呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法可讓您傳送不同的執行緒中的檔案。</span><span class="sxs-lookup"><span data-stu-id="4e975-990">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-991">若要完成此作業，您可以建立所叫用回呼方法<xref:System.AsyncCallback>委派參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-991">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="4e975-992">若要這樣做，請在最起碼`state`參數必須包含<xref:System.Net.Sockets.Socket>物件正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-992">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="4e975-993">如果您的回呼需要詳細資訊，您可以建立類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-993">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="4e975-994">傳遞至這個自訂物件的執行個體<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-994">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-995">叫用回呼方法必須<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-995">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="4e975-996">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>傳送整個檔案，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-996">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="4e975-997">如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-997">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-998">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSendFile%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-998">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-999">您也必須確定檔案的大小不超過最大的封包大小基礎的服務提供者的無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-999">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-1000">如果是的話，不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1000">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1001">如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1001">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1002">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1002">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1003">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1003">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1004">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1004">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1005">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1005">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-1006">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-1006">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1007">下列程式碼範例會建立連接的非同步通訊的通訊端並開始以非同步方式至遠端主機傳送檔案"text.txt"。</span><span class="sxs-lookup"><span data-stu-id="4e975-1007">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="4e975-1008">在此範例中，`preBuffer`和`postBuffer`的資料建立檔案與預設傳送<xref:System.Net.Sockets.TransmitFileOptions>會使用值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1008">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="4e975-1009">委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-1009">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1010"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1010">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1011">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1011">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-1012">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-1012">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1013">作業系統不是 Windows NT (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-1013">The operating system is not Windows NT or later.</span></span>  
  
 <span data-ttu-id="4e975-1014">\-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1014">\- or -</span></span>  
  
 <span data-ttu-id="4e975-1015">通訊端未連線至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1015">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="4e975-1016">找不到檔案 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1016">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-1017"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1017">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-1018">「緩衝區」<c></c>中以零起始的位置，資料要在此處開始傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1018">The zero-based position in <c>buffer</c> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-1019">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1019">The number of bytes to send.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><span data-ttu-id="4e975-1020"><see cref="T:System.AsyncCallback" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1020">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="4e975-1021">物件，包含這個要求的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1021">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="4e975-1022">以非同步方式將資料傳送至特定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1022">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="4e975-1023">參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1023">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1024"><xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法會啟動非同步傳送作業中指定遠端主機`remoteEP`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1024">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="4e975-1025">呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1025">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="4e975-1026">適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSendTo%2A>無連線和連線導向的通訊協定的運作方式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1026">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="4e975-1027">您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1027">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="4e975-1028">若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1028">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="4e975-1029">如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>，以及其他必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1029">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="4e975-1030">傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，透過`state`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1030">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="4e975-1031">叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1031">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="4e975-1032">當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSendTo%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1032">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="4e975-1033">如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1033">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e975-1034">當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1034">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="4e975-1035">如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1035">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="4e975-1036">如果您使用連線導向的通訊協定，您必須先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，或<xref:System.Net.Sockets.Socket.BeginSendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1036">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1037"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> 將會忽略`remoteEP`參數，並將傳送資料至<xref:System.Net.EndPoint>中建立<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1037"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1038">如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1038">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-1039">您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1039">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="4e975-1040">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。</span><span class="sxs-lookup"><span data-stu-id="4e975-1040">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="4e975-1041">您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1041">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-1042">在此情況下，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1042">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="4e975-1043">如果您希望基礎的服務提供者，選取可用的通訊埠，請使用零的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1043">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="4e975-1044">如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-1044">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="4e975-1045">如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1045">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-1046">-您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1046">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-1047">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.EndSendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1047">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-1048">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1048">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1049">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1050">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1050">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1051">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1052">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1053">（安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1053">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="4e975-1054">在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。</span><span class="sxs-lookup"><span data-stu-id="4e975-1054">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1055">下列程式碼範例以非同步方式將資料傳送至指定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1055">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1056"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1056"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-1057">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1057">-or-</span></span>  
  
 <span data-ttu-id="4e975-1058"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1058"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1059">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1059">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-1060"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-1060"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-1061">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1061">-or-</span></span>  
  
 <span data-ttu-id="4e975-1062"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-1062"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-1063">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1063">-or-</span></span>  
  
 <span data-ttu-id="4e975-1064"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-1064"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-1065">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1065">-or-</span></span>  
  
 <span data-ttu-id="4e975-1066"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1066"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1067"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1067">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1068">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1068">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="4e975-1069">要與 <see cref="T:System.Net.EndPoint" /> 關聯的本機 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1069">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="4e975-1070">使 <see cref="T:System.Net.Sockets.Socket" /> 與本機端點建立關聯。</span><span class="sxs-lookup"><span data-stu-id="4e975-1070">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1071">使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果您需要使用特定的本機端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1071">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="4e975-1072">您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>才能呼叫<xref:System.Net.Sockets.Socket.Listen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1072">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="4e975-1073">您不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前使用<xref:System.Net.Sockets.Socket.Connect%2A>方法除非您需要使用特定的本機端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1073">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="4e975-1074">您可以使用<xref:System.Net.Sockets.Socket.Bind%2A>無連線和連線導向的通訊協定上的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1074">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="4e975-1075">然後再呼叫<xref:System.Net.Sockets.Socket.Bind%2A>，您必須先建立本機<xref:System.Net.IPEndPoint>從您要通訊的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1075">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="4e975-1076">如果您並不在意哪些本機位址指派，您可以建立<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>位址參數，以及基礎的服務提供者會指派最適當的網路位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-1076">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="4e975-1077">這有助於簡化您的應用程式，如果您有多個網路介面。</span><span class="sxs-lookup"><span data-stu-id="4e975-1077">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="4e975-1078">如果您並不在意哪些本機連接埠使用，您可以建立<xref:System.Net.IPEndPoint>使用連接埠號碼 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-1078">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="4e975-1079">在此情況下，服務提供者會指派可用的通訊埠編號介於 1024年到 5000 之間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1079">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="4e975-1080">如果您使用上述的方法，您可以探索哪些本機網路位址和通訊埠編號已被指派藉由呼叫<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1080">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="4e975-1081">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>之後所做的呼叫，則不會傳回在本機指派的網路位址，直到<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1081">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="4e975-1082">如果您使用無連接的通訊協定，您不會存取此資訊之前，您已經完成傳送或接收。</span><span class="sxs-lookup"><span data-stu-id="4e975-1082">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="4e975-1083">如果想要接收介面資訊上收到的封包的 UDP 通訊端<xref:System.Net.Sockets.Socket.SetSocketOption%2A>通訊端選項設為應該明確地呼叫方法<xref:System.Net.Sockets.SocketOptionName.PacketInformation>後立即呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1083">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1084">如果您想要接收多點傳送的資料包，您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>多點傳送連接埠號碼的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1084">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1085">您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果您想要接收無連接的資料包使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1085">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1086">如果您收到<xref:System.Net.Sockets.SocketException>呼叫時<xref:System.Net.Sockets.Socket.Bind%2A>方法，請使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1086">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1087">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1087">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1088">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1088">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1089">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1089">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1090">下列程式碼範例繫結<xref:System.Net.Sockets.Socket>使用指定的本機端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1090">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1091"><paramref name="localEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1091"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1092">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1092">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1093"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1093">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1094">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1094">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-1095">接受來自所定義的主機連接的<paramref name="localEP" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1095">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="4e975-1096">相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="4e975-1096">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1097">取得或設定值，指出 <see cref="T:System.Net.Sockets.Socket" /> 是否處於區塊模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1097">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1098">如果 <see cref="T:System.Net.Sockets.Socket" /> 可區塊化，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1098"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4e975-1099">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1099">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1100"><xref:System.Net.Sockets.Socket.Blocking%2A>屬性會指出是否<xref:System.Net.Sockets.Socket>處於封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1100">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="4e975-1101">如果您封鎖模式中，而使方法呼叫它不會立即完成，您的應用程式將會封鎖執行，直到完成要求的作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1101">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="4e975-1102">如果您想要繼續，即使未完成要求的作業、 變更執行<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1102">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="4e975-1103"><xref:System.Net.Sockets.Socket.Blocking%2A>屬性具有非同步方法沒有作用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1103">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="4e975-1104">如果您是傳送和接收資料，以非同步方式，而且想要封鎖執行，使用<xref:System.Threading.ManualResetEvent>類別。</span><span class="sxs-lookup"><span data-stu-id="4e975-1104">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1105">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1105">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1106">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1106">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1107">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1107">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1108">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1108">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1109">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1109">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1110"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1110">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-1111"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，藉由呼叫一個 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法來要求與遠端主機連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1111">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="4e975-1112">取消遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1112">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1113"><xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>方法會取消遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1113">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-1114"><paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-1114">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1115">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1115">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1116"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1117">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1117">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1118">關閉 <see cref="T:System.Net.Sockets.Socket" /> 連接並釋放所有相關資源。</span><span class="sxs-lookup"><span data-stu-id="4e975-1118">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e975-1119">關閉 <see cref="T:System.Net.Sockets.Socket" /> 連接並釋放所有相關資源。</span><span class="sxs-lookup"><span data-stu-id="4e975-1119">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1120"><xref:System.Net.Sockets.Socket.Close%2A>方法關閉遠端主機連接，並釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1120">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1121">在關閉時<xref:System.Net.Sockets.Socket.Connected%2A>屬性設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1121">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="4e975-1122">如需連線導向的通訊協定，建議您呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1122">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="4e975-1123">這可確保所有資料都傳送及接收連線的通訊端上之前它已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1123">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="4e975-1124">如果您需要呼叫<xref:System.Net.Sockets.Socket.Close%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以確保資料佇列的傳出傳輸將傳送藉由設定<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>選項設定為`false`並指定非零逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="4e975-1124">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="4e975-1125"><xref:System.Net.Sockets.Socket.Close%2A> 然後會封鎖直到這項資料會傳送，或直到指定的逾時過期為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1125"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="4e975-1126">如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>至`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋放連接，並會自動捨棄傳出佇列的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1126">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1127">若要設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項`false`，建立<xref:System.Net.Sockets.LingerOption>，enabled 的屬性設定為`true`，並設定<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性所需的逾時期間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1127">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="4e975-1128">使用此<xref:System.Net.Sockets.LingerOption>連同<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1128">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1129">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1129">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1130">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1130">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1131">下列程式碼範例會關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1131">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="4e975-1132">最多等候 <c>timeout</c> 秒以傳送任何剩餘的資料，然後關閉通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1132">Wait up to <c>timeout</c> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="4e975-1133">關閉 <see cref="T:System.Net.Sockets.Socket" /> 連線，並釋放所有具指定逾時的關聯資源，以允許傳送佇列的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1133">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1134"><xref:System.Net.Sockets.Socket.Close%2A>方法關閉遠端主機連接，並釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1134">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1135">在關閉時<xref:System.Net.Sockets.Socket.Connected%2A>屬性設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1135">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="4e975-1136">如需連線導向的通訊協定，建議您呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1136">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="4e975-1137">這可確保所有資料都傳送及接收連線的通訊端上之前它已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1137">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="4e975-1138">如果您需要呼叫<xref:System.Net.Sockets.Socket.Close%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以確保資料佇列的傳出傳輸將傳送藉由設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>選項設定為`false`並指定非零逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="4e975-1138">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="4e975-1139"><xref:System.Net.Sockets.Socket.Close%2A> 然後會封鎖直到這項資料會傳送，或直到指定的逾時過期為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1139"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="4e975-1140">如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>至`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋放連接，並會自動捨棄傳出佇列的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1140">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1141">若要設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項`false`，建立<xref:System.Net.Sockets.LingerOption>，enabled 的屬性設定為`true`，並設定<xref:System.Net.Sockets.LingerOption.LingerTime%2A>所需的逾時期限的屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1141">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="4e975-1142">使用此<xref:System.Net.Sockets.LingerOption>連同<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1142">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1143">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1143">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1144">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1144">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1145">下列程式碼範例示範如何關閉<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1145">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1146">建立與遠端主機的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1146">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="4e975-1147">代表遠端裝置的 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1147">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="4e975-1148">建立與遠端主機的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1148">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1149">如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1149">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="4e975-1150">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1150">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="4e975-1151">在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>，您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1151">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1152">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1152">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-1153">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1153">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="4e975-1154">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-1154">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-1155">如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1155">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1156">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1156">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1157">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1157">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="4e975-1158"><xref:System.Net.Sockets.Socket.Connect%2A>方法將會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1158">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-1159">如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1159">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="4e975-1160">因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1160">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="4e975-1161">您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1161">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1162">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1162">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="4e975-1163">如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-1163">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="4e975-1164">使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1164">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1165">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1165">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="4e975-1166">如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1166">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="4e975-1167">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1167">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1168">如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1168">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="4e975-1169">使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1169">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="4e975-1170">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-1170">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1171">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1171">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1172">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1172">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1173">下列程式碼範例會連接到遠端端點，然後驗證該連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1173">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1174"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1174"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1175">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1175">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1176"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1176">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1177">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1177">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1178">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1178">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-1179">用於連接至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1179">for connecting to the remote host.</span></span> <span data-ttu-id="4e975-1180">相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="4e975-1180">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="4e975-1181">遠端主機的 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-1181">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="4e975-1182">遠端主機的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1182">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="4e975-1183">建立與遠端主機的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1183">Establishes a connection to a remote host.</span></span> <span data-ttu-id="4e975-1184">此主機是由 IP 位址和連接埠號碼所指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1184">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1185">如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1185">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="4e975-1186">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1186">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="4e975-1187">在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1187">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1188">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1188">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-1189">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1189">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="4e975-1190">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-1190">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-1191">如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1191">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1192">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1192">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1193">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1193">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="4e975-1194"><xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1194"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-1195">如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1195">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="4e975-1196">因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1196">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="4e975-1197">您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1197">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1198">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1198">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="4e975-1199">如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-1199">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="4e975-1200">使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1200">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1201">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1201">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="4e975-1202">如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1202">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="4e975-1203">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1203">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1204">如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1204">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="4e975-1205">使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1205">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="4e975-1206">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-1206">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1207">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1207">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1208">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1208">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1209">下列程式碼範例會連接到遠端端點，然後驗證該連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1209">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1210"><paramref name="address" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1210"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-1211">連接埠號碼無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-1211">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1212">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1212">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1213"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1213">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1214">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1214">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-1215"><paramref name="address" /> 的長度為零。</span><span class="sxs-lookup"><span data-stu-id="4e975-1215">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1216">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1216">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="4e975-1217">遠端主機的 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-1217">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="4e975-1218">遠端主機的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1218">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="4e975-1219">建立與遠端主機的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1219">Establishes a connection to a remote host.</span></span> <span data-ttu-id="4e975-1220">主機是由 IP 位址陣列和連接埠號碼所指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1220">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1221">這個方法通常用來呼叫之後立即<xref:System.Net.Dns.GetHostAddresses%2A>，其可以傳回多個 IP 位址的單一主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1221">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="4e975-1222">如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1222">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="4e975-1223">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1223">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="4e975-1224">在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1224">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1225">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1225">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-1226">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1226">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="4e975-1227">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-1227">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-1228">如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1228">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1229">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1229">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1230">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1230">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="4e975-1231"><xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1231"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-1232">如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1232">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="4e975-1233">因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1233">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="4e975-1234">您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1234">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1235">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1235">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="4e975-1236">如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-1236">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="4e975-1237">使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1237">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1238">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1238">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="4e975-1239">如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1239">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="4e975-1240">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1240">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1241">如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1241">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="4e975-1242">使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1242">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="4e975-1243">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-1243">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1244">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1244">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1245">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1245">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1246">下列程式碼範例會連接到遠端端點，然後驗證該連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1246">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1247"><paramref name="addresses" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1247"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-1248">連接埠號碼無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-1248">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1249">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1249">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1250"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1250">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1251">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1251">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-1252"><paramref name="address" /> 的長度為零。</span><span class="sxs-lookup"><span data-stu-id="4e975-1252">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1253">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1253">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="4e975-1254">遠端主機的名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-1254">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="4e975-1255">遠端主機的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1255">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="4e975-1256">建立與遠端主機的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1256">Establishes a connection to a remote host.</span></span> <span data-ttu-id="4e975-1257">此主機是由主機名稱和連接埠號碼指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1257">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1258">如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1258">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="4e975-1259">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1259">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="4e975-1260">在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1260">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1261">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1261">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-1262">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1262">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="4e975-1263">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-1263">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-1264">如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1264">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1265">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1265">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1266">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1266">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="4e975-1267"><xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1267"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-1268">如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1268">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="4e975-1269">因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1269">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="4e975-1270">您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1270">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1271">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1271">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="4e975-1272">如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-1272">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="4e975-1273">使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1273">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="4e975-1274">如果已啟用 IPv6 和<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>呼叫方法來連線到主機解析為這兩個 IPv6 和 IPv4 位址，來嘗試連接到 IPv6 位址將會先的 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-1274">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="4e975-1275">這可能會有延遲的時間來建立連接，如果主機並未接聽 IPv6 位址的效果。</span><span class="sxs-lookup"><span data-stu-id="4e975-1275">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1276">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1276">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="4e975-1277">如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1277">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="4e975-1278">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1278">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1279">如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1279">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="4e975-1280">使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1280">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="4e975-1281">這是基礎提供者的限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-1281">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1282">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1282">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1283">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1283">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1284">下列程式碼範例會連接到遠端端點，然後驗證該連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1284">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1285"><paramref name="host" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1285"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-1286">連接埠號碼無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-1286">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1287">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1287">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1288"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1288">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1289">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1289">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1290">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1290">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1291">開始與遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1291">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-1292"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1292">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1293">開始與遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1293">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="4e975-1294">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1294">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-1295">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1295">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-1296">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1296">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-1297">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-1297">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1298">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會啟動遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1298">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="4e975-1299">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="4e975-1300">若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1300">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="4e975-1301">呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>連線至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1301">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="4e975-1302">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1302">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-1303">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1303">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-1304">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1304">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-1305">您可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1305">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="4e975-1306">如果您呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-1306">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-1307">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法一次所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1307">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="4e975-1308">如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1308">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="4e975-1309">如果不這麼做，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1309">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-1310">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：</span><span class="sxs-lookup"><span data-stu-id="4e975-1310">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-1311">（選擇性） 緩衝區可能會提供其會以不可分割方式之後通訊端上傳送<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。</span><span class="sxs-lookup"><span data-stu-id="4e975-1311">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="4e975-1312">在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設為包含資料的緩衝區，才能傳送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設定以傳送緩衝區中的資料位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1312">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="4e975-1313">一旦建立連接之後，會傳送此緩衝區的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1313">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="4e975-1314">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1314">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="4e975-1315">如果您使用無連接的通訊協定，服務提供者會指派本機網路 IP 位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1315">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="4e975-1316"><xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.NotSupportedException>如果的位址系列<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不相同的位址系列。</span><span class="sxs-lookup"><span data-stu-id="4e975-1316">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1317">如果您收到<xref:System.Net.Sockets.SocketException>呼叫此方法時，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1317">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1318">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1318">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-1319">引數無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-1319">An argument is not valid.</span></span> <span data-ttu-id="4e975-1320">如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，就會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1320">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-1321"><paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-1321">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1322"><see cref="T:System.Net.Sockets.Socket" /> 正在接聽，或是通訊端作業正在進行並且使用 <paramref name="e" /> 參數所指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1322">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1323">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1323">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1324">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-1324">Windows XP or later is required for this method.</span></span> <span data-ttu-id="4e975-1325">如果本機端點和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是同一個通訊協定家族 (Family)，也會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1325">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1326"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1327">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1327">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="4e975-1328">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1328">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="4e975-1329">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1329">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="4e975-1330"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1330">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1331">開始與遠端主機連接的非同步要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1331">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="4e975-1332">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1332">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-1333">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1333">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-1334">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1334">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-1335">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-1335">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1336">如果您使用連線導向的通訊協定，M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 方法開始的非同步要求連接至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1336">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="4e975-1337">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立預設遠端主機所指定`socketType`和`protocolType`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1337">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="4e975-1338">若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1338">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="4e975-1339">呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>連線至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1339">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="4e975-1340">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1340">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-1341">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1341">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-1342">如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前傳送和接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1342">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="4e975-1343">您可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>與遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1343">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="4e975-1344">如果您呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-1344">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="4e975-1345">如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法一次所需的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1345">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="4e975-1346">如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1346">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="4e975-1347">如果不這麼做，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1347">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-1348">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：</span><span class="sxs-lookup"><span data-stu-id="4e975-1348">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-1349">（選擇性） 緩衝區可能會提供其會以不可分割方式之後通訊端上傳送<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。</span><span class="sxs-lookup"><span data-stu-id="4e975-1349">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="4e975-1350">在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設為包含資料的緩衝區，才能傳送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設定以傳送緩衝區中的資料位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1350">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="4e975-1351">一旦建立連接之後，會傳送此緩衝區的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1351">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="4e975-1352">如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-1352">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="4e975-1353">如果您使用無連接的通訊協定，服務提供者會指派本機網路 IP 位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1353">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="4e975-1354"><xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.NotSupportedException>如果的位址系列<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不相同的位址系列。</span><span class="sxs-lookup"><span data-stu-id="4e975-1354">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1355">如果您收到<xref:System.Net.Sockets.SocketException>呼叫此方法時，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1355">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1356">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1356">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-1357">引數無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-1357">An argument is not valid.</span></span> <span data-ttu-id="4e975-1358">如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，就會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1358">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-1359"><paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-1359">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1360"><see cref="T:System.Net.Sockets.Socket" /> 正在接聽，或是通訊端作業正在進行並且使用 <paramref name="e" /> 參數所指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1360">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1361">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1361">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1362">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-1362">Windows XP or later is required for this method.</span></span> <span data-ttu-id="4e975-1363">如果本機端點和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是同一個通訊協定家族 (Family)，也會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1363">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1364"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1365">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1365">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1366">取得值，指出上一個 <see cref="T:System.Net.Sockets.Socket" /> 或 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 作業是否將 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 連接至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1366">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1367">如果最近一次的作業是將 <see cref="T:System.Net.Sockets.Socket" /> 連接到遠端資源，則為 <see langword="true" />，否則，即為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1367"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1368">`Connected`屬性取得的連接狀態<xref:System.Net.Sockets.Socket>最後一次的 I/O 作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1368">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="4e975-1369">當它傳回`false`、<xref:System.Net.Sockets.Socket>可能永遠不會連線，或已中斷連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1369">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="4e975-1370">值<xref:System.Net.Sockets.Socket.Connected%2A>屬性會反映最新的作業連接的狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1370">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="4e975-1371">如果您需要判斷目前的連接狀態，請呼叫未封鎖、 零位元組傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1371">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="4e975-1372">如果呼叫成功傳回，或是擲回 WAEWOULDBLOCK 錯誤程式碼 (10035)，是仍然會連接通訊端。否則，通訊端已中斷連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1372">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="4e975-1373">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>使用者資料包通訊協定 (UDP) 通訊端上<xref:System.Net.Sockets.Socket.Connected%2A>屬性一律會傳回`true`; 不過，此動作不會變更 UDP 固有無連線性質。</span><span class="sxs-lookup"><span data-stu-id="4e975-1373">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1374">下列程式碼範例會連接到遠端端點，檢查<xref:System.Net.Sockets.Socket.Connected%2A>屬性，並檢查連接的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1374">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="4e975-1375">如果這個通訊端可以在關閉目前連線後重複使用，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1375"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="4e975-1376">關閉通訊端連線並允許重複使用通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1376">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1377">如果您使用連線導向的通訊協定，您可以使用這個方法，以關閉通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1377">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="4e975-1378">這個方法會結束連接與集<xref:System.Net.Sockets.Socket.Connected%2A>屬性`false`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1378">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="4e975-1379">不過，如果`reuseSocket`是`true`，您可以重複使用的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1379">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="4e975-1380">若要確保所有資料都傳送及接收通訊端關閉之前，您應該呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Disconnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1380">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1381">如果您需要呼叫<xref:System.Net.Sockets.Socket.Disconnect%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以設定<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>選項設定為`false`並指定非零的逾時間隔，以確保資料佇列的傳出傳輸傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1381">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="4e975-1382"><xref:System.Net.Sockets.Socket.Disconnect%2A> 然後會封鎖直到傳送資料，或直到指定的逾時過期為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1382"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="4e975-1383">如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>至`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋放連接，並會自動捨棄傳出佇列的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1383">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1384">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1384">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1385">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1385">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1386">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1386">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1387">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1387">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1388">下列程式碼範例會建立同步通訊的通訊端，並將部分資料傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1388">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="4e975-1389">然後它會呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，以停止傳送並接收活動，以及<xref:System.Net.Sockets.Socket.Disconnect%2A>以關閉通訊端連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1389">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4e975-1390">這個方法需要 Windows 2000 (含) 以前版本，否則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-1390">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1391"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1391">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1392">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1392">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-1393"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1393">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1394">開始非同步要求，以中斷遠端端點的連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1394">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-1395">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1395">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-1396">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1396">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-1397">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1397">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-1398">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-1398">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1399">使用連線導向的通訊協定，當呼叫<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>方法會要求中斷連線從遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1399">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="4e975-1400">如果您設定<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>至`true`中`e`參數時，通訊端可以重複使用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1400">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-1401"><paramref name="e" /> 參數不可以是 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-1401">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1402">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-1402">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1403">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-1403">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1404"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1404">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1405">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1405">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1406">將 <see cref="T:System.Net.Sockets.Socket" /> 類別目前的執行個體所使用的資源全部釋出。</span><span class="sxs-lookup"><span data-stu-id="4e975-1406">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e975-1407">將 <see cref="T:System.Net.Sockets.Socket" /> 類別目前的執行個體所使用的資源全部釋出。</span><span class="sxs-lookup"><span data-stu-id="4e975-1407">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1408">`Dispose` 使用完畢時，請呼叫 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1408">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1409">`Dispose` 方法會將 <xref:System.Net.Sockets.Socket> 保留在無法使用的狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1409">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="4e975-1410">在呼叫`Dispose`，您必須釋放所有參考<xref:System.Net.Sockets.Socket>讓記憶體回收行程可以回收記憶體的<xref:System.Net.Sockets.Socket>所佔用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1410">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="4e975-1411">如需詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1411">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1412">在您釋放最後一個 `Dispose` 參考之前，請務必呼叫 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1412">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1413">否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Net.Sockets.Socket> 物件的 `Finalize` 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1413">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="4e975-1414"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源；<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="4e975-1414"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="4e975-1415">釋放 <see cref="T:System.Net.Sockets.Socket" /> 所使用的 Unmanaged 資源，並選擇性處置 Managed 資源。</span><span class="sxs-lookup"><span data-stu-id="4e975-1415">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1416">這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1416">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="4e975-1417">`Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1417">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="4e975-1418"><xref:System.Object.Finalize%2A> 叫用`Dispose`與`disposing`設`false`。</span><span class="sxs-lookup"><span data-stu-id="4e975-1418"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="4e975-1419">`disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.Net.Sockets.Socket> 參考的任何 Managed 物件所掌握的資源。</span><span class="sxs-lookup"><span data-stu-id="4e975-1419">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="4e975-1420">這個方法會叫用每個參考物件的 `Dispose()` 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1420">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1421">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1421">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1422">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1422">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="4e975-1423"><see langword="Dispose" /> 可以被其他物件呼叫多次。</span><span class="sxs-lookup"><span data-stu-id="4e975-1423"><see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="4e975-1424">覆寫 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 時，請小心不要參考到先前已在對 <see langword="Dispose" /> 的早期呼叫中被處置 (Dispose) 的物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1424">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="4e975-1425">如需有關如何實作<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />，請參閱[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1425">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
 <span data-ttu-id="4e975-1426">如需有關<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[覆寫 Finalize 方法](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1426">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1427">取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允許將網際網路通訊協定 (IP) 資料包分散。</span><span class="sxs-lookup"><span data-stu-id="4e975-1427">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1428">如果 <see cref="T:System.Net.Sockets.Socket" /> 允許資料包分散，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1428"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4e975-1429">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1429">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1430">資料包需要片段，其大小超過最大傳輸單位 (MTU) 的傳輸媒介時。</span><span class="sxs-lookup"><span data-stu-id="4e975-1430">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="4e975-1431">傳送主控件 （所有的網際網路通訊協定版本） 或中繼路由器 (Internet Protocol Version 4 只) 可能分段資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1431">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="4e975-1432">如果必須分散資料包 (datagram)，而<xref:System.Net.Sockets.Socket.DontFragment%2A>選項設定，資料包作業會捨棄，並且傳回給寄件者的資料包傳送網際網路控制訊息通訊協定 (ICMP) 錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="4e975-1432">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="4e975-1433">傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1433">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1434">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.DontFragment%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1434">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1435">這個屬性只可為 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 家族中的通訊端設定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1435">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1436">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1436">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1437"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1437">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1438">取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否為適用於 IPv4 和 IPv6 的雙重模式通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1438">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1439">如果 <see cref="T:System.Net.Sockets.Socket" /> 是雙重模式通訊端，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1439"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4e975-1440">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1440">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="4e975-1441">建立重複通訊端參考的目標處理序 ID。</span><span class="sxs-lookup"><span data-stu-id="4e975-1441">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="4e975-1442">複製目標處理序的通訊端參考，並關閉這個處理序的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1442">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="4e975-1443">要傳遞至目標處理序的通訊端參考。</span><span class="sxs-lookup"><span data-stu-id="4e975-1443">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1444">目標處理序應使用<xref:System.Net.Sockets.Socket.%23ctor%2A>建立重複的通訊端執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-1444">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="4e975-1445">如果您呼叫<xref:System.Net.Sockets.Socket.%23ctor%2A>多次包含相同的位元組陣列，為每個呼叫的引數的建構函式，您將建立受管理的多個<xref:System.Net.Sockets.Socket>具有相同的基礎通訊端的執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-1445">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="4e975-1446">這種做法不鼓勵。</span><span class="sxs-lookup"><span data-stu-id="4e975-1446">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="4e975-1447">如果處理程序建立通訊端會使用非同步方法 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>或<xref:System.Net.Sockets.Socket.BeginSend%2A>)，必須先設定處理程序<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>屬性設為 true，否則繫結至所建立的處理序，可能會造成完成通訊埠的通訊端<xref:System.ArgumentNullException>上目標處理序擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1447">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-1448"><paramref name="targetProcessID" /> 不是有效的處理序 ID。</span><span class="sxs-lookup"><span data-stu-id="4e975-1448"><paramref name="targetProcessID" /> is not a valid process id.</span></span>  
  
 <span data-ttu-id="4e975-1449">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1449">-or-</span></span>  
  
 <span data-ttu-id="4e975-1450">複製通訊端參考失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-1450">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1451">取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以傳送或接收廣播封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1451">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1452">如果 <see cref="T:System.Net.Sockets.Socket" /> 允許廣播封包，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1452"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4e975-1453">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1453">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1454">廣播限制為特定的子網路，而且必須使用使用者資料包通訊協定 (UDP)。針對網際網路通訊協定第 4 版，您可以廣播給您本機子網路封包傳送為 255.255.255.255。或者，您可以使用導向的廣播的位址，也就是使用中的主機部分設定的所有位元的網際網路通訊協定 (IP) 位址的網路部分。</span><span class="sxs-lookup"><span data-stu-id="4e975-1454">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="4e975-1455">例如，如果您的 IP 位址為 192.168.1.40 （類別 C 位址，與網路遮罩為 255.255.255.0 的網路部分是的前三個八位元及主機部分是最後一個八位元） 導向的廣播的位址為 192.168.1.255。</span><span class="sxs-lookup"><span data-stu-id="4e975-1455">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="4e975-1456">傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1456">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1457">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1457">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1458">這個選項只對資料包通訊端有效。</span><span class="sxs-lookup"><span data-stu-id="4e975-1458">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1459"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1459">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1460">非同步接受連入連線嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-1460">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-1461"><see cref="T:System.Byte" /> 型別的陣列，包含已傳輸的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1461">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="4e975-1462"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1462">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="4e975-1463">以非同步方式接受連入連線嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 物件，以處理遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1463">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="4e975-1464">這個方法會傳回包含已傳輸之初始資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1464">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="4e975-1465"><see cref="T:System.Net.Sockets.Socket" /> 物件，可處理與遠端主機的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1465">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1466"><xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1466"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="4e975-1467">然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立回呼方法所叫用<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1467">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1468">這個回呼方法會在個別的執行緒中執行，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1468">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="4e975-1469">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1469">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="4e975-1470">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>順利完成連接嘗試的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1470">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="4e975-1471">`buffer`的這個多載的參數包含資料的呼叫中收到<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`參數會包含在呼叫中已傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1471">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="4e975-1472"><xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖，直到連接已暫止的連入連線佇列中。</span><span class="sxs-lookup"><span data-stu-id="4e975-1472">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="4e975-1473"><xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可以用來傳送和接收來自遠端主機的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1473">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1474">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1474">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1475">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1475">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1476">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1476">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1477">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1477">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1478">下列程式碼範例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>即可建立和連線通訊端並接受初始的 10 個位元組的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1478">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="4e975-1479">委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndAccept%2A>來結束非同步的要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1479">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="4e975-1480">傳送的位元組數和資料會傳回`buffer`和`bytesTransferred`參數，這個方法會顯示在主控台上。</span><span class="sxs-lookup"><span data-stu-id="4e975-1480">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1481">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-1481">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1482"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1482">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1483"><paramref name="asyncResult" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1483"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1484"><paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</span><span class="sxs-lookup"><span data-stu-id="4e975-1484"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1485">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1485"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1486">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤</span><span class="sxs-lookup"><span data-stu-id="4e975-1486">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="4e975-1487">以非同步方式接受連入的連接嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 來處理遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1487">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="4e975-1488"><see cref="T:System.Net.Sockets.Socket" />，將處理與遠端主機的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1488">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1489"><xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1489"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="4e975-1490">然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1490">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1491">這個回呼方法會在個別的執行緒中執行，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1491">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="4e975-1492">它必須接受`asyncResult`參數所傳回的<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1492">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1493">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1493">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="4e975-1494">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>順利完成連接嘗試的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1494">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="4e975-1495"><xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖，直到連接已暫止的連入連線佇列中。</span><span class="sxs-lookup"><span data-stu-id="4e975-1495">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="4e975-1496"><xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可以用來傳送和接收來自遠端主機的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1496">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1497">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1497">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1498">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1498">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1499">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1499">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1500">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1500">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1501">下列程式碼範例會結束的非同步要求，並建立新<xref:System.Net.Sockets.Socket>接受連入連線要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1501">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="4e975-1502">如需示範如何透過通訊端的非同步通訊的完整範例，請參閱[通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1502">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1503"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1503"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1504"><paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</span><span class="sxs-lookup"><span data-stu-id="4e975-1504"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1505">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1505">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-1506">如需詳細資訊，請參閱＜備註＞一節。</span><span class="sxs-lookup"><span data-stu-id="4e975-1506">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1507"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1507">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1508">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1508"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1509">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-1509">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-1510"><see cref="T:System.Byte" /> 型別的陣列，包含已傳輸的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1510">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="4e975-1511">已傳輸的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1511">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="4e975-1512"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1512">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="4e975-1513">以非同步方式接受連入連線嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 物件，以處理遠端主機通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1513">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="4e975-1514">這個方法會傳回包含已傳輸之初始資料和位元組數的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1514">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="4e975-1515"><see cref="T:System.Net.Sockets.Socket" /> 物件，可處理與遠端主機的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1515">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1516"><xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1516"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="4e975-1517">然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立回呼方法所叫用<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1517">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1518">這個回呼方法會在個別的執行緒中執行，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1518">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="4e975-1519">它必須接受`asyncResult`參數所傳回的<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1519">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1520">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1520">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="4e975-1521">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>順利完成連接嘗試的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1521">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="4e975-1522">`buffer`的這個多載的參數包含資料的呼叫中收到<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`參數會包含在呼叫中已傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1522">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="4e975-1523"><xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖，直到連接已暫止的連入連線佇列中。</span><span class="sxs-lookup"><span data-stu-id="4e975-1523">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="4e975-1524"><xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可以用來傳送和接收來自遠端主機的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1524">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1525">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1525">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1526">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1526">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1527">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1527">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1528">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1528">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1529">下列程式碼範例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>即可建立和連線通訊端並接受初始的 10 個位元組的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1529">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="4e975-1530">委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndAccept%2A>來結束非同步的要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1530">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="4e975-1531">傳送的位元組數和資料會傳回`buffer`和`bytesTransferred`參數，這個方法會顯示在主控台上。</span><span class="sxs-lookup"><span data-stu-id="4e975-1531">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1532">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-1532">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1533"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1533">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1534"><paramref name="asyncResult" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1534"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1535"><paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</span><span class="sxs-lookup"><span data-stu-id="4e975-1535"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1536">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1536"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1537">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1537">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="4e975-1538">結束擱置的非同步連接要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1538">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1539"><xref:System.Net.Sockets.Socket.EndConnect%2A> 完成非同步的遠端主機連接要求的封鎖方法以啟動<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1539"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1540">然後再呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1540">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1541">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1541">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="4e975-1542">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginConnect%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1542">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1543">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1543">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="4e975-1544">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>順利完成連接嘗試的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1544">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1545">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1545">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1546">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1546">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1547">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1547">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1548">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1548">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1549">下列程式碼範例會結束非同步的連接嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-1549">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="4e975-1550">如需示範如何透過通訊端的非同步通訊的完整範例，請參閱[通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1550">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1551"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1551"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1552"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1552"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1553"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> 是先前用來呼叫非同步連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1553"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1554">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1554">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1555"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1555">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="4e975-1556"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1556">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1557">結束暫止非同步中斷連接要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1557">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1558"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1558"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="4e975-1559"><xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法會封鎖，直到完成中斷連線為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1559">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="4e975-1560">如需非同步作業的資訊，請參閱 MSDN library 中的非同步程式設計的概觀主題。</span><span class="sxs-lookup"><span data-stu-id="4e975-1560">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1561">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1561">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1562">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1562">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1563">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1563">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1564">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1564">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1565">下列程式碼範例會建立通訊端的非同步通訊，並將部分資料傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-1565">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="4e975-1566">當已傳送資料時，<xref:System.Net.Sockets.Socket.Shutdown%2A>呼叫來停止傳送和接收活動。</span><span class="sxs-lookup"><span data-stu-id="4e975-1566">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="4e975-1567">然後<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>呼叫來開始中斷連線要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1567">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="4e975-1568">委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndDisconnect%2A>來結束非同步的要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-1568">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="4e975-1569">當要求完成時，<xref:System.Net.Sockets.Socket.Connected%2A>屬性會查詢以測試是否已中斷連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-1569">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1570">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="4e975-1570">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1571"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1571">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1572"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1572"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1573"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1573"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1574"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> 是先前用來呼叫非同步連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1574"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1575">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1575">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="4e975-1576">中斷連接要求已逾時。</span><span class="sxs-lookup"><span data-stu-id="4e975-1576">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1577">結束擱置的非同步讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-1577">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="4e975-1578">結束擱置的非同步讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-1578">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="4e975-1579">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1579">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1580"><xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1580">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1581">然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1581">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1582">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1582">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="4e975-1583">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginReceive%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1583">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1584">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1584">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="4e975-1585">擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1585">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="4e975-1586">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法已成功完成讀取的作業，並傳回讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1586">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="4e975-1587"><xref:System.Net.Sockets.Socket.EndReceive%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1587">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-1588">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>會讀取內送的網路緩衝區中有可用的第一個加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1588">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="4e975-1589">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會讀取使用最多為您所指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1589">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="4e975-1590">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1590">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-1591">若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>，然後將解壓縮所產生的狀態物件中包含的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1591">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="4e975-1592">若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1592">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1593">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1593">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1594">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1594">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1595">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-1595">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-1596">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-1596">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1597">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1597">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1598">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1598">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1599">下列程式碼範例會暫止的非同步讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-1599">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="4e975-1600">如需示範如何透過通訊端的非同步通訊的完整範例，請參閱[通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1600">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1601"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1601"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1602"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1602"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1603">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1603"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1604">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1604">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1605"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1605">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="4e975-1606"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1606">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-1607"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1607">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="4e975-1608">結束擱置的非同步讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-1608">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="4e975-1609">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1609">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1610"><xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1610">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1611">然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1611">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1612">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1612">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="4e975-1613">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginReceive%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1613">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1614">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1614">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="4e975-1615">擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1615">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="4e975-1616">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法已成功完成讀取的作業，並傳回讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1616">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="4e975-1617"><xref:System.Net.Sockets.Socket.EndReceive%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1617">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-1618">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>會讀取內送的網路緩衝區中有可用的第一個加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1618">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="4e975-1619">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會讀取使用最多為您所指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1619">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="4e975-1620">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1620">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-1621">若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>，然後將解壓縮所產生的狀態物件中包含的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1621">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1622">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1622">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1623">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1623">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1624">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-1624">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-1625">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-1625">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1626">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1626">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1627">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1627">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1628"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1628"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1629"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1629"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1630">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1630"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1631">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1631">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1632"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1632">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary><span data-ttu-id="4e975-1633">從指定的端點結束暫止的非同步讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-1633">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-1634">如果成功，則傳回接收的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1634">If successful, the number of bytes received.</span></span> <span data-ttu-id="4e975-1635">如果不成功，則傳回 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-1635">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1636"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1636">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1637">然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1637">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1638">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1638">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="4e975-1639">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1639">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1640">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1640">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-1641">擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1641">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="4e975-1642">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法已成功完成讀取的作業，並傳回讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1642">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="4e975-1643"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-1643">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-1644">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>會讀取內送的網路緩衝區中有可用的第一個加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1644">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="4e975-1645">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法會讀取使用最多為您所指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1645">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-1646">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1646">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="4e975-1647">若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>物件，並擷取產生的狀態物件中包含的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1647">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="4e975-1648">若要識別原始主機，請解壓縮<xref:System.Net.EndPoint>並將其轉換<xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1648">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="4e975-1649">使用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法，以取得 IP 位址和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法，以取得連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1649">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1650">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1650">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1651">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1651">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1652">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1652">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1653">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1653">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1654">下列程式碼範例會暫止的非同步讀取從特定<xref:System.Net.EndPoint>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1654">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1655"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1655"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1656"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1656"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1657">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1657"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1658">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1658">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1659"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1659">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="4e975-1660"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1660">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-1661">接收封包之 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-1661">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="4e975-1662">來源 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1662">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="4e975-1663">接收之封包的 <see cref="T:System.Net.IPAddress" /> 和介面。</span><span class="sxs-lookup"><span data-stu-id="4e975-1663">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="4e975-1664">從指定的端點結束暫止的非同步讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-1664">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="4e975-1665">這個方法還會比 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 提供更多的封包資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1665">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-1666">如果成功，則傳回接收的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1666">If successful, the number of bytes received.</span></span> <span data-ttu-id="4e975-1667">如果不成功，則傳回 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-1667">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1668">如果作業尚未完成，這個方法會封鎖，直到它執行。</span><span class="sxs-lookup"><span data-stu-id="4e975-1668">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="4e975-1669">若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1669">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-1670">檢查`ipPacketInformation`如果您需要知道資料包使用單點傳播、 多點傳送或廣播位址來傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1670">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1671"><paramref name="asyncResult" /> 是 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="4e975-1671"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
 <span data-ttu-id="4e975-1672">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1672">-or-</span></span>  
  
 <span data-ttu-id="4e975-1673"><paramref name="endPoint" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1673"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1674"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1674"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1675">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1675"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1676">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1676">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1677"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1677">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1678">結束暫止的非同步傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1678">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="4e975-1679">結束暫止的非同步傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1679">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="4e975-1680">如果成功，則將位元組數目傳送至 <see cref="T:System.Net.Sockets.Socket" />，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1680">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1681"><xref:System.Net.Sockets.Socket.EndSend%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSend%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1681"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="4e975-1682">然後再呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1682">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1683">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1683">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="4e975-1684">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginSend%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1684">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1685">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1685">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1686">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSend%2A>方法已成功完成傳送作業並傳回傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1686">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="4e975-1687">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1687">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-1688">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到緩衝區的某些訊息已傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1688">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="4e975-1689">如果傳回的值從<xref:System.Net.Sockets.Socket.EndSend%2A>表示緩衝區無法完全傳送時，呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法一次，修改要保存未傳送的資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1689">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="4e975-1690">沒有保證您傳送的資料就會立即出現在網路。</span><span class="sxs-lookup"><span data-stu-id="4e975-1690">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-1691">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1691">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-1692">成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1692">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1693">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1693">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1694">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1694">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1695">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-1695">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-1696">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-1696">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1697">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1697">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-1698">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1698">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1699">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1699">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1700">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1700">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1701">下列程式碼範例會結束暫止的非同步傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1701">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1702"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1702"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1703"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1703"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1704">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1704"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1705">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1705">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1706"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1706">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="4e975-1707"><see cref="T:System.IAsyncResult" />，存放這個非同步作業的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1707">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-1708"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1708">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="4e975-1709">結束暫止的非同步傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1709">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="4e975-1710">如果成功，則將位元組數目傳送至 <see cref="T:System.Net.Sockets.Socket" />，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1710">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1711"><xref:System.Net.Sockets.Socket.EndSend%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSend%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1711"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="4e975-1712">然後再呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1712">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1713">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1713">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="4e975-1714">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginSend%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1714">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1715">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1715">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1716">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSend%2A>方法已成功完成傳送作業並傳回傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1716">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="4e975-1717">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1717">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-1718">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到緩衝區的某些訊息已傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1718">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="4e975-1719">如果傳回的值從<xref:System.Net.Sockets.Socket.EndSend%2A>表示緩衝區無法完全傳送時，呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法一次，修改要保存未傳送的資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-1719">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="4e975-1720">沒有保證您傳送的資料就會立即出現在網路。</span><span class="sxs-lookup"><span data-stu-id="4e975-1720">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-1721">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1721">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-1722">成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1722">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1723">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1723">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1724">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1724">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1725">該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。</span><span class="sxs-lookup"><span data-stu-id="4e975-1725">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="4e975-1726">如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="4e975-1726">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1727">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1727">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-1728">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1728">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1729">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1729">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1730">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1730">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1731"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1731"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1732"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1732"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1733">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1733"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1734">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1734">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1735"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1735">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="4e975-1736"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1736">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1737">結束檔案的暫止非同步傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1737">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1738"><xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSendFile%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1738"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="4e975-1739">然後再呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1739">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1740">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1740">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="4e975-1741">回呼方法必須接受<xref:System.IAsyncResult>所傳回物件<xref:System.Net.Sockets.Socket.BeginSendFile%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1741">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1742">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1742">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1743">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSendFile%2A>順利完成傳送作業的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1743">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="4e975-1744">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSendFile%2A>封鎖，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1744">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="4e975-1745">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSendFile%2A>封鎖，直到整個檔案傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-1745">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="4e975-1746">沒有保證您傳送的資料就會立即出現在網路。</span><span class="sxs-lookup"><span data-stu-id="4e975-1746">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-1747">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1747">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-1748">成功完成<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1748">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1749">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1749">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1750">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1750">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1751">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1751">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1752">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1752">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1753">下列程式碼範例會建立連接的非同步通訊的通訊端並開始以非同步方式至遠端主機傳送檔案"text.txt"。</span><span class="sxs-lookup"><span data-stu-id="4e975-1753">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="4e975-1754">委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-1754">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-1755">這個方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="4e975-1755">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1756"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1756">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1757"><paramref name="asyncResult" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1757"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1758"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1758"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1759">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 用於非同步 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1759"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1760">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1760">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-1761">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-1761">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary><span data-ttu-id="4e975-1762">結束暫止的非同步傳送至指定的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-1762">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="4e975-1763">如果成功，則傳送位元組數目，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1763">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1764"><xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1764"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="4e975-1765">然後再呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-1765">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="4e975-1766">不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1766">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="4e975-1767">回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginSendTo%2A>做為參數的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1767">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="4e975-1768">在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1768">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1769">取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法已成功完成傳送作業並傳回傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1769">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="4e975-1770">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSendTo%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1770">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-1771">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSendTo%2A>會阻擋，直到傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1771">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="4e975-1772">沒有保證您傳送的資料就會立即出現在網路。</span><span class="sxs-lookup"><span data-stu-id="4e975-1772">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-1773">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1773">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-1774">成功完成<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1774">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1775">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1775">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1776">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1776">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1777">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1777">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1778">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1778">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1779">下列程式碼範例會結束非同步傳送至特定位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-1779">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-1780"><paramref name="asyncResult" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1780"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-1781"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1781"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1782">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1782"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1783">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1783">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1784"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1784">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1785">取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否只允許一個處理序繫結至通訊埠。</span><span class="sxs-lookup"><span data-stu-id="4e975-1785">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1786">如果 <see cref="T:System.Net.Sockets.Socket" /> 只允許一個通訊端繫結至特定通訊埠，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1786"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4e975-1787">預設值是<see langword="true" />為 Windows Server 2003 和 Windows XP Service Pack 2 和<see langword="false" />對於所有其他版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-1787">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1788">如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`false`，可以使用多個通訊端<xref:System.Net.Sockets.Socket.Bind%2A>繫結至特定的連接埠的方法，不過只有其中一個通訊端可以執行網路流量傳送至連接埠的作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-1788">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="4e975-1789">如果多個通訊端嘗試使用<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>方法來將繫結至特定的連接埠，然後更特定的 IP 位址，一個會處理傳送至該通訊埠的網路流量。</span><span class="sxs-lookup"><span data-stu-id="4e975-1789">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="4e975-1790">如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`true`，第一次使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，以嘗試繫結至特定的連接埠，不論網際網路通訊協定 (IP) 位址，將會成功，則會使用所有後續的<xref:System.Net.Sockets.Socket.Bind%2A>會嘗試將該連接埠繫結的方法失敗，直到原始的繫結通訊端被終結。</span><span class="sxs-lookup"><span data-stu-id="4e975-1790">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="4e975-1791">這個屬性必須先設定<xref:System.Net.Sockets.Socket.Bind%2A>呼叫; 否則為<xref:System.InvalidOperationException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-1791">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1792">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1792">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1793">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1794"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4e975-1795">已為這個 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 呼叫 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1795"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e975-1796">釋放 <see cref="T:System.Net.Sockets.Socket" /> 類別所使用的資源。</span><span class="sxs-lookup"><span data-stu-id="4e975-1796">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1797"><xref:System.Net.Sockets.Socket>類別完成項呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法，關閉<xref:System.Net.Sockets.Socket>以及釋放相關聯的資源<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1797">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1798">傳回 <see cref="T:System.Net.Sockets.Socket" /> 選項值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1798">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-1799">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1799">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-1800">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1800">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-1801">傳回指定 <see cref="T:System.Net.Sockets.Socket" /> 選項的值，表示為物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1801">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="4e975-1802">表示選項值的物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1802">An object that represents the value of the option.</span></span> <span data-ttu-id="4e975-1803">當 <paramref name="optionName" /> 參數設為 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 時，傳回值將會是 <see cref="T:System.Net.Sockets.LingerOption" /> 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-1803">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="4e975-1804">當 <paramref name="optionName" /> 設為 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 時，傳回值將會是 <see cref="T:System.Net.Sockets.MulticastOption" /> 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-1804">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="4e975-1805">當 <paramref name="optionName" /> 是其他的任何值時，傳回的值則是一個整數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1805">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1806"><xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1806"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1807">若要取得使用此多載<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，和<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-1807">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="4e975-1808">如<xref:System.Net.Sockets.SocketOptionName.Linger>選項，請使用<xref:System.Net.Sockets.Socket>如`optionLevel`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1808">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="4e975-1809">如<xref:System.Net.Sockets.SocketOptionName.AddMembership>和<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1809">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="4e975-1810">如果您想要設定任何上述選項的值，請使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1810">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1811">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1812">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1812">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1813">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1813">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1814">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1814">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1815">下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="4e975-1815">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1816">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1816">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="4e975-1817">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1817">-or-</span></span>  
  
 <span data-ttu-id="4e975-1818"><paramref name="optionName" /> 設定為不支援的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1818"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1819"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1819">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-1820">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1820">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-1821">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1821">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="4e975-1822"><see cref="T:System.Byte" /> 型別的陣列，將要接收選項設定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1822">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="4e975-1823">傳回指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定，表示為位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="4e975-1823">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1824"><xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1824"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-1825">在此方法成功完成時，陣列會指定由`optionValue`參數包含指定的值<xref:System.Net.Sockets.Socket>選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-1825">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="4e975-1826">當長度`optionValue`陣列的儲存值加上指定所需的位元組數目小於<xref:System.Net.Sockets.Socket>選項，<xref:System.Net.Sockets.Socket.GetSocketOption%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1826">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1827">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1827">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1828">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1828">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="4e975-1829">布林值或整數都由任何通訊端使用這個多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-1829">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1830">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1830">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1831">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1831">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1832">下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="4e975-1832">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1833">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1833">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="4e975-1834">\-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1834">\- or -</span></span>  
  
 <span data-ttu-id="4e975-1835">在 .NET Compact Framework 應用程式中，Windows CE 的預設緩衝區空間設為 32768 個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1835">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="4e975-1836">您可以呼叫 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，以變更每個通訊端緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1836">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1837"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1837">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-1838">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1838">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-1839">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1839">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="4e975-1840">要限制的傳回值長度，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="4e975-1840">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="4e975-1841">以陣列傳回指定 <see cref="T:System.Net.Sockets.Socket" /> 選項的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1841">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="4e975-1842"><see cref="T:System.Byte" /> 型別的陣列，包含通訊端選項值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1842">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1843">`optionLength`參數集傳回的位元組陣列的大小上限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1843">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="4e975-1844">如果選項值需要更少個位元組，陣列將只包含多個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1844">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="4e975-1845">如果選項值需要更多的位元組<xref:System.Net.Sockets.Socket.GetSocketOption%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1845">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-1846">布林值或整數都由任何通訊端使用這個多載。</span><span class="sxs-lookup"><span data-stu-id="4e975-1846">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1847">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1847">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1848">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1848">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1849">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1849">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1850">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1850">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1851">下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="4e975-1851">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1852">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1852">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="4e975-1853">\-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1853">\- or -</span></span>  
  
 <span data-ttu-id="4e975-1854">在 .NET Compact Framework 應用程式中，Windows CE 的預設緩衝區空間設為 32768 個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-1854">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="4e975-1855">您可以呼叫 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，以變更每個通訊端緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1855">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1856"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1856">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1857">取得 <see cref="T:System.Net.Sockets.Socket" /> 的作業系統處理。</span><span class="sxs-lookup"><span data-stu-id="4e975-1857">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-1858"><see cref="T:System.IntPtr" />，表示 <see cref="T:System.Net.Sockets.Socket" /> 的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1858">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-1859">設定 <see cref="T:System.Net.Sockets.Socket" /> 的低階作業系統模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1859">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="4e975-1860"><see cref="T:System.Int32" /> 值，指定要執行之作業的控制碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1860">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="4e975-1861"><see cref="T:System.Byte" /> 陣列，包含作業所需的輸入資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1861">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="4e975-1862"><see cref="T:System.Byte" /> 陣列，包含作業傳回的輸出資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1862">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1863">使用數值控制碼，設定 <see cref="T:System.Net.Sockets.Socket" /> 的低階作業模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1863">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="4e975-1864"><paramref name="optionOutValue" /> 中的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1864">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1865"><xref:System.Net.Sockets.Socket.IOControl%2A>方法提供低層級存取作業系統<xref:System.Net.Sockets.Socket>基礎的目前執行個體<xref:System.Net.Sockets.Socket>類別。</span><span class="sxs-lookup"><span data-stu-id="4e975-1865">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="4e975-1866">如需詳細資訊，請參閱 MSDN library 中的 WSAIoctl 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1866">For more information, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1867">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1867">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1868">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1868">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1869">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1869">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1870">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1870">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1871">下列程式碼範例會比較 FIONREAD 和 [可用性] 內容的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-1871">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1872">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1872">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1873"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1873">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1874">已嘗試不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 屬性來變更封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1874">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-1875">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-1875">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4e975-1876">執行 unmanaged 程式碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1876">to execute unmanaged code.</span></span> <span data-ttu-id="4e975-1877">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1877">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="4e975-1878"><see cref="T:System.Net.Sockets.IOControlCode" /> 值，指定要執行之作業的控制碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1878">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="4e975-1879"><see cref="T:System.Byte" /> 型別的陣列，包含作業所需的輸入資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1879">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="4e975-1880"><see cref="T:System.Byte" /> 型別的陣列，包含作業傳回的輸出資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1880">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="4e975-1881">使用 <see cref="T:System.Net.Sockets.Socket" /> 列舉型別指定控制碼，以設定 <see cref="T:System.Net.Sockets.IOControlCode" /> 的低階作業模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1881">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="4e975-1882"><paramref name="optionOutValue" /> 中的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-1882">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1883">這個方法會提供作業系統的低層級存取<xref:System.Net.Sockets.Socket>基礎的目前執行個體<xref:System.Net.Sockets.Socket>類別。</span><span class="sxs-lookup"><span data-stu-id="4e975-1883">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="4e975-1884">如需詳細資訊，請參閱 MSDN library 中的 WSAIoctl 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-1884">For more, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1885">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1885">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1886">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1886">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1887">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1887">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1888">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1888">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1889">下列程式碼範例會比較呼叫的結果<xref:System.Net.Sockets.Socket.IOControl%2A>與<xref:System.Net.Sockets.IOControlCode.DataToRead>和<xref:System.Net.Sockets.Socket.Available%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1889">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1890">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1890">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1891"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1891">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-1892">已嘗試不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 屬性來變更封鎖模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1892">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="4e975-1893">執行 unmanaged 程式碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1893">to execute unmanaged code.</span></span> <span data-ttu-id="4e975-1894">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1894">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1895">取得值，指出 <see cref="T:System.Net.Sockets.Socket" /> 是否繫結至特定的本機通訊埠。</span><span class="sxs-lookup"><span data-stu-id="4e975-1895">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1896">如果 <see cref="T:System.Net.Sockets.Socket" /> 繫結至本機通訊埠，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1896"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1897">通訊端視為已繫結至本機連接埠如果明確繫結呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，或隱含地繫結，透過呼叫的成員，像是<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，會使用暫時的本機連接埠 （可用的通訊埠大於1024，選取作業系統。)伺服器會使用<xref:System.Net.Sockets.Socket.Bind%2A>繫結的已知的連接埠，讓用戶端可能會連線到它們的方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1897">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1898">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.IsBound%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1898">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1899">取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否會延遲關閉通訊端，以嘗試傳送所有暫止資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1899">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="4e975-1900"><see cref="T:System.Net.Sockets.LingerOption" />，指定關閉通訊端時如何延遲。</span><span class="sxs-lookup"><span data-stu-id="4e975-1900">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1901"><xref:System.Net.Sockets.Socket.LingerState%2A>屬性變更的方式<xref:System.Net.Sockets.Socket.Close%2A>方法的行為。</span><span class="sxs-lookup"><span data-stu-id="4e975-1901">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="4e975-1902">這個屬性集修改的條件的連線可以來重設 Winsock 時。</span><span class="sxs-lookup"><span data-stu-id="4e975-1902">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="4e975-1903">連接重設仍可能是根據 IP 通訊協定行為。</span><span class="sxs-lookup"><span data-stu-id="4e975-1903">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="4e975-1904">這個屬性會控制的呼叫之後，連線導向的連接將維持開啟的時間長度<xref:System.Net.Sockets.Socket.Close%2A>時仍可傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1904">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="4e975-1905">當您呼叫方法，將資料傳送至對等時，這項資料會在傳出的網路緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-1905">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="4e975-1906">這個屬性可以用來確保這些資料會傳送至遠端主機之前<xref:System.Net.Sockets.TcpClient.Close%2A>方法會卸除連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1906">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="4e975-1907">若要啟用延遲，請建立<xref:System.Net.Sockets.LingerOption>執行個體包含所需的值，並設定<xref:System.Net.Sockets.Socket.LingerState%2A>屬性與這個執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-1907">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="4e975-1908">下表描述的行為<xref:System.Net.Sockets.Socket.Close%2A>的可能值的方法<xref:System.Net.Sockets.LingerOption.Enabled%2A>屬性和<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性儲存在<xref:System.Net.Sockets.Socket.LingerState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1908">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="4e975-1909">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="4e975-1909">LingerState.Enabled</span></span>|<span data-ttu-id="4e975-1910">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="4e975-1910">LingerState.LingerTime</span></span>|<span data-ttu-id="4e975-1911">行為</span><span class="sxs-lookup"><span data-stu-id="4e975-1911">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="4e975-1912">`false` （已停用），預設值</span><span class="sxs-lookup"><span data-stu-id="4e975-1912">`false` (disabled), the default value</span></span>|<span data-ttu-id="4e975-1913">不適用，在逾時 （預設值）。</span><span class="sxs-lookup"><span data-stu-id="4e975-1913">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="4e975-1914">嘗試將預設 IP 通訊協定等候逾時到期之前傳送暫止的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1914">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="4e975-1915">`true` （已啟用）</span><span class="sxs-lookup"><span data-stu-id="4e975-1915">`true` (enabled)</span></span>|<span data-ttu-id="4e975-1916">非零的逾時</span><span class="sxs-lookup"><span data-stu-id="4e975-1916">A nonzero time-out</span></span>|<span data-ttu-id="4e975-1917">嘗試傳送暫止資料，直到指定的逾時到期，而如果嘗試失敗，則 Winsock 重設連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1917">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="4e975-1918">`true` （已啟用）</span><span class="sxs-lookup"><span data-stu-id="4e975-1918">`true` (enabled)</span></span>|<span data-ttu-id="4e975-1919">零逾時。</span><span class="sxs-lookup"><span data-stu-id="4e975-1919">A zero timeout.</span></span>|<span data-ttu-id="4e975-1920">會捨棄任何暫止的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1920">Discards any pending data.</span></span> <span data-ttu-id="4e975-1921">連接導向通訊端 (例如 TCP)，Winsock 重設連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-1921">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="4e975-1922">IP 堆疊計算預設 IP 通訊協定逾時期間，若要使用的連線的來回時間為基礎。</span><span class="sxs-lookup"><span data-stu-id="4e975-1922">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="4e975-1923">在大部分情況下，堆疊計算的逾時值為更有相關性比其中一個應用程式所定義的。</span><span class="sxs-lookup"><span data-stu-id="4e975-1923">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="4e975-1924">這是預設行為是通訊端時<xref:System.Net.Sockets.Socket.LingerState%2A>屬性未設定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1924">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="4e975-1925">當<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性儲存在<xref:System.Net.Sockets.Socket.LingerState%2A>屬性設定大於預設 IP 通訊協定等候逾時，仍將套用的預設 IP 通訊協定逾時，覆寫。</span><span class="sxs-lookup"><span data-stu-id="4e975-1925">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1926">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.LingerState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1926">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1927">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1927">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1928"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1928">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="4e975-1929">暫止連接佇列的最大長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-1929">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="4e975-1930">將 <see cref="T:System.Net.Sockets.Socket" /> 置於接聽狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1930">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1931"><xref:System.Net.Sockets.Socket.Listen%2A> 會導致連線導向<xref:System.Net.Sockets.Socket>接聽連入連線嘗試。</span><span class="sxs-lookup"><span data-stu-id="4e975-1931"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="4e975-1932">`backlog`參數會指定可排入佇列接受連入連線的數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-1932">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="4e975-1933">若要判斷您可以指定的連線的數目上限，擷取<xref:System.Net.Sockets.SocketOptionName.MaxConnections>值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1933">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="4e975-1934"><xref:System.Net.Sockets.Socket.Listen%2A> 不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="4e975-1934"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="4e975-1935">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1935">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1936">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1936">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="4e975-1937">使用<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>以接受來自佇列的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1937">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1938">您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法之前先呼叫<xref:System.Net.Sockets.Socket.Listen%2A>，或<xref:System.Net.Sockets.Socket.Listen%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-1938">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1939">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1939">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1940">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1940">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1941">待處理項目參數會限制為不同的值視作業系統而定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1941">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="4e975-1942">您可以指定較高的值，但是待處理項目會受到限制基礎作業系統。</span><span class="sxs-lookup"><span data-stu-id="4e975-1942">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1943">下列程式碼範例使用<xref:System.Net.Sockets.Socket>來接聽連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-1943">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1944">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1944">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1945"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1945">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1946">取得本機端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1946">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="4e975-1947"><see cref="T:System.Net.EndPoint" />，<see cref="T:System.Net.Sockets.Socket" /> 正將它用於通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1947">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1948"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性會取得<xref:System.Net.EndPoint>本機 IP 位址和連接埠編號，其中包含您<xref:System.Net.Sockets.Socket>繫結。</span><span class="sxs-lookup"><span data-stu-id="4e975-1948">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="4e975-1949">您必須將此轉型<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>之前擷取的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1949">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="4e975-1950">您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法來擷取本機<xref:System.Net.IPAddress>，而<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法來擷取本機連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1950">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="4e975-1951"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性通常設定進行的呼叫之後<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1951">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-1952">如果您允許系統在將通訊端的本機 IP 位址和連接埠號碼指派<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>之後第一項 I/O 作業將會設定屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1952">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="4e975-1953">連線導向的通訊協定，第一項 I/O 作業將會是呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1953">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-1954">無連接的通訊協定，第一項 I/O 作業會是任何傳送或接收呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-1954">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1955">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-1955">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-1956">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-1956">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-1957">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-1957">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-1958">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1958">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1959">下列程式碼範例會擷取，並顯示本機和遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-1959">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1960">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1960">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1961"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1961">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1962">取得或設定值，指定輸出多點傳送封包是否會傳遞至傳送應用程式。</span><span class="sxs-lookup"><span data-stu-id="4e975-1962">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1963">如果 <see cref="T:System.Net.Sockets.Socket" /> 會接收輸出多點傳送封包，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1963"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1964">多點傳送是網際網路上的多對多通訊的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1964">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="4e975-1965">處理序會訂閱的多點傳送位址。接著，每個訂閱多點傳送位址的處理序會接收任何已訂閱的處理序所傳送的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-1965">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="4e975-1966">傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1966">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1967">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1967">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1968">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1968">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1969"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1969">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1970">取得或設定 <see cref="T:System.Boolean" /> 值，指定資料流 <see cref="T:System.Net.Sockets.Socket" /> 是否使用 Nagle 演算法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1970">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1971">如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 演算法，則為 <see langword="false" />，否則為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1971"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="4e975-1972">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1972">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1973">Nagle 演算法被為了減少網路流量，讓通訊端緩衝小型封包然後結合並在某些情況下一個封包中傳送它們。</span><span class="sxs-lookup"><span data-stu-id="4e975-1973">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="4e975-1974">TCP 封包包含 40 個位元組的標頭加上傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-1974">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="4e975-1975">小型資料封包傳送時使用的 TCP，TCP 標頭造成的負擔可能會變得的網路流量的重要部分。在繁重的網路壅塞造成這項負擔可能會導致遺失的資料包和重新傳輸，以及因壅塞的過多的傳播時間。</span><span class="sxs-lookup"><span data-stu-id="4e975-1975">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="4e975-1976">Nagle 演算法禁止傳送新的 TCP segmentswhen 新輸出的資料到達時使用者如果在連接上的任何 previouslytransmitted 資料會維持未認可。</span><span class="sxs-lookup"><span data-stu-id="4e975-1976">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="4e975-1977">大部分的網路應用程式應該使用 Nagle 演算法。</span><span class="sxs-lookup"><span data-stu-id="4e975-1977">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="4e975-1978">使用者資料包通訊協定 (UDP) 通訊端上設定這個屬性會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="4e975-1978">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-1979">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.NoDelay%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-1979">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-1980">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-1980">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-1981"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-1981">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1982">指出基礎作業系統和網路配置器是否支援網際網路通訊協定第 4 版 (IPv4)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1982">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1983">如果作業系統和網路配置器支援 IPv4 通訊協定則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1983"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1984">作業系統可能會支援 IPv4 和 IPv6 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1984">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-1985">指出基礎作業系統和網路配置器是否支援網際網路通訊協定第 6 版 (IPv6)。</span><span class="sxs-lookup"><span data-stu-id="4e975-1985">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value>
          <span data-ttu-id="4e975-1986">如果作業系統和網路配置器支援 IPv6 通訊協定則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1986"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-1987">作業系統可能會支援 IPv4 和 IPv6 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1987">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="4e975-1988">等待回應的時間，以微秒為單位。</span><span class="sxs-lookup"><span data-stu-id="4e975-1988">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="4e975-1989">其中一個 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-1989">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-1990">決定 <see cref="T:System.Net.Sockets.Socket" /> 的狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-1990">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-1991"><see cref="T:System.Net.Sockets.Socket" /> 的狀態，根據從 <paramref name="mode" /> 參數中傳遞的輪詢模式值而定。</span><span class="sxs-lookup"><span data-stu-id="4e975-1991">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <span data-ttu-id="4e975-1992"><list type="table"><listheader><term> 模式</span><span class="sxs-lookup"><span data-stu-id="4e975-1992"><list type="table"><listheader><term> Mode</span></span>  
  
 <span data-ttu-id="4e975-1993"></term><description> 傳回值</span><span class="sxs-lookup"><span data-stu-id="4e975-1993"></term><description> Return Value</span></span>  
  
 <span data-ttu-id="4e975-1994">如果已呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 且連接暫止時，則為 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-1994"></description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span>  
  
 <span data-ttu-id="4e975-1995">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1995">-or-</span></span>  
  
 <span data-ttu-id="4e975-1996">如果資料可供讀取，則為 <see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-1996"><see langword="true" /> if data is available for reading;</span></span>  
  
 <span data-ttu-id="4e975-1997">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-1997">-or-</span></span>  
  
 <span data-ttu-id="4e975-1998">如果連接已經關閉、重設或結束，則為 <see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-1998"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span>  
  
 <span data-ttu-id="4e975-1999">否則，傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-1999">otherwise, returns <see langword="false" />.</span></span>  
  
 <span data-ttu-id="4e975-2000">如果處理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 且已成功建立連接時，則為 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-2000"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span>  
  
 <span data-ttu-id="4e975-2001">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2001">-or-</span></span>  
  
 <span data-ttu-id="4e975-2002">如果可以傳送資料，則為 <see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-2002"><see langword="true" /> if data can be sent;</span></span>  
  
 <span data-ttu-id="4e975-2003">否則，傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2003">otherwise, returns <see langword="false" />.</span></span>  
  
 <span data-ttu-id="4e975-2004">如果處理的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 沒有封鎖且連接已失敗時，則為 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-2004"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span>  
  
 <span data-ttu-id="4e975-2005">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2005">-or-</span></span>  
  
 <span data-ttu-id="4e975-2006">如果未設定 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 且 Out-of-Band Data 可用時，則為 <see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="4e975-2006"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span>  
  
 <span data-ttu-id="4e975-2007">否則，傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2007">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2008"><xref:System.Net.Sockets.Socket.Poll%2A>方法會檢查的狀態<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2008">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-2009">指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>如`selectMode`參數，來判斷如果<xref:System.Net.Sockets.Socket>是否可讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2009">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="4e975-2010">指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>判斷<xref:System.Net.Sockets.Socket>是可寫入。</span><span class="sxs-lookup"><span data-stu-id="4e975-2010">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="4e975-2011">使用<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>偵測錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-2011">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="4e975-2012"><xref:System.Net.Sockets.Socket.Poll%2A> 將會封鎖執行，直到指定的時間長度，以測量`microseconds`，捨棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-2012"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="4e975-2013">設定`microSeconds`負整數，如果您想要無限期地等待回應的參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2013">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="4e975-2014">如果您想要檢查多個通訊端的狀態，您可能會偏好使用<xref:System.Net.Sockets.Socket.Select%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2014">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2015">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2015">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2016">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2016">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2017">這個方法無法偵測某些類型的連線問題，例如中斷的網路纜線，或遠端主機已強制關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2017">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="4e975-2018">您必須嘗試傳送或接收資料，以偵測這類錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2018">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2019">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2019">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2020">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2020">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2021">下列程式碼範例會建立通訊端、 連接到伺服器，並使用<xref:System.Net.Sockets.Socket.Poll%2A>檢查通訊端的狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-2021">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-2022"><paramref name="mode" /> 參數不是其中一個 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2022">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2023">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2023">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-2024">請參閱下面的＜備註＞。</span><span class="sxs-lookup"><span data-stu-id="4e975-2024">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2025"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2025">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-2026">取得 <see cref="T:System.Net.Sockets.Socket" /> 的通訊協定 (Protocol) 類型。</span><span class="sxs-lookup"><span data-stu-id="4e975-2026">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-2027">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2027">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2028"><xref:System.Net.Sockets.Socket.ProtocolType%2A>時設定屬性<xref:System.Net.Sockets.Socket>建立，並指定所使用的通訊協定<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2028">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2029">下列程式碼範例顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>至主控台。</span><span class="sxs-lookup"><span data-stu-id="4e975-2029">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-2030">從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2030">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2031"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2031">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="4e975-2032">從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料至接收緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2032">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="4e975-2033">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2033">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2034"><xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2034">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2035">您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2035">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2036">這個多載只會要求您提供接收緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2036">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="4e975-2037">緩衝區位移的預設值為 0，大小預設為參數的長度的緩衝區，而<xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2037">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="4e975-2038">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2038">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2039"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2039">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2040">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2040">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2041"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2041"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2042">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2042">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2043">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2043">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2044">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2044">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2045">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2045">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2046">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2046">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2047">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2047">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="4e975-2048">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2048">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2049">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2049">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2050">如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2050">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2051">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2051">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2052">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2052">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2053">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2053">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2054">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2054">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2055">下列程式碼範例會收到上連接的資料<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2055">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2056"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2056"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2057">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2057">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2058"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2058">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2059">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2059">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2060">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2060">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2061">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2061">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-2062"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2062">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="4e975-2063">從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料至接收緩衝區清單中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2063">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="4e975-2064">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2064">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2065">這個方法會將資料讀入緩衝區參數，並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2065">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2066">您可以從連線導向和無連線通訊端呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-2066">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2067">這個多載都需要您提供一個或多個接收緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2067">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="4e975-2068">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2068">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2069"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2069">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2070">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2070">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2071"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2071"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2072">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2072">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2073">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2073">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2074">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2074">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2075">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2075">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2076">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2076">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2077">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2077">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="4e975-2078">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2078">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2079">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2079">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2080">如果您接收的資料包大於大小`buffers`參數，`buffers`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2080">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2081">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2081">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2082">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2082">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="4e975-2083">**請注意**應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2083">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2084">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2084">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-2085"><paramref name="buffer" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2085">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2086">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2086">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2087"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2087">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2088"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2088">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2089"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2089">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2090">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2090">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2091">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2091">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2092"><xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2092">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2093">您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2093">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2094">這個多載只會要求您提供接收緩衝區和必要<xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2094">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="4e975-2095">緩衝區位移的預設值為 0，且大小預設值為位元組參數的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2095">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="4e975-2096">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2096">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2097"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2097">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2098">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2098">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2099"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2099"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2100">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-2100">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-2101">如果您是在未封鎖模式中，而且沒有可用的通訊協定堆疊緩衝區中的資料<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2101">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2102">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2102">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2103">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，再試一次您接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-2103">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2104">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小可用的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2104">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="4e975-2105">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2105">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2106">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2106">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2107">如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2107">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2108">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2108">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2109">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2109">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2110">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2110">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2111">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2111">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2112">下列程式碼範例會指定資料緩衝區，並<xref:System.Net.Sockets.SocketFlags>接收上連接的資料<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2112">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2113"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2113"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2114">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2114">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2115"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2115">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2116">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2116">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2117">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2117">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2118">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2118">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-2119"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2119">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2120"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2120">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2121">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區清單中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2121">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2122">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2122">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2123">這個方法會讀取資料到`buffers`參數，並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2123">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2124">您可以從連線導向和無連線通訊端呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-2124">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2125">這個多載都需要您提供一個或多個接收緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2125">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="4e975-2126"><xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2126">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="4e975-2127">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2127">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2128"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2128">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2129">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2129">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2130"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2130"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2131">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2131">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2132">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2132">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2133">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2133">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2134">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2134">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2135">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2135">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2136">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2136">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="4e975-2137">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2137">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2138">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2138">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2139">如果您接收的資料包大於大小`buffers`參數，`buffers`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2139">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2140">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2140">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2141">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2141">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2142">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2142">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2143">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2143">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2144">下列程式碼範例示範如何接收的資料連接的<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2144">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2145"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2145"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2146">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2146">-or-</span></span>  
  
 <span data-ttu-id="4e975-2147"><paramref name="buffers" />.Count 為零。</span><span class="sxs-lookup"><span data-stu-id="4e975-2147"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2148">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2148">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2149"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2149">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2150">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2150">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2151">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2151">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2152"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2152">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2153">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2153">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2154"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2154">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2155">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 將指定位元組數的資料接收至接收緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2155">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2156">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2156">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2157"><xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取資料到`buffer`參數，並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2157">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2158">您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2158">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2159">這個多載只會要求您提供接收緩衝區中，您想要接收的位元組和必要數目<xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2159">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="4e975-2160">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2160">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2161"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2161">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2162">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2162">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2163"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2163"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2164">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2164">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2165">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2165">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2166">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2166">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2167">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2167">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2168">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，再試一次您接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-2168">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2169">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多為指定的位元組數目的資料量`size`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2169">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="4e975-2170">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2170">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2171">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2171">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2172">如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2172">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2173">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2173">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2174">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2174">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2175">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2176">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2177">下列接收資料找到`buffer`，並指定<xref:System.Net.Sockets.SocketFlags.None>如<xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2177">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2178"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2178"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2179"><paramref name="size" /> 超過 <paramref name="buffer" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="4e975-2179"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2180">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2180">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2181"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2181">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2182">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2182">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2183">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2183">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2184">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2184">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-2185"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2185">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2186"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2186">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-2187"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2187">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="4e975-2188">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區清單中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2188">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2189">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2189">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2190">這個方法會讀取資料到`buffers`參數，並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2190">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2191">您可以從連線導向和無連線通訊端呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-2191">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2192">這個多載都需要您提供一個或多個接收緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2192">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="4e975-2193"><xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2193">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="4e975-2194">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2194">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2195"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2195">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2196">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2196">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2198">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2198">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2199">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2199">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2200">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2200">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2201">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2201">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2202">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2202">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2203">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2203">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="4e975-2204">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2204">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2205">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2205">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2206">如果您接收的資料包大於大小`buffers`參數，`buffers`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2206">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2207">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2207">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2208">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2208">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2209">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2209">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2210">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2210">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2211"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2211"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2212">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2212">-or-</span></span>  
  
 <span data-ttu-id="4e975-2213"><paramref name="buffers" />.Count 為零。</span><span class="sxs-lookup"><span data-stu-id="4e975-2213"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2214">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2214">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2215"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2216">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2216">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2217">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2217">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2218">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2218">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-2219">「緩衝區」<c></c>中存放已接收資料的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2219">The location in <c>buffer</c> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2220">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2220">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2221"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2221">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2222">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 將指定的位元組數接收到接收緩衝區的指定位移位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2222">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2223">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2223">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2224"><xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2224">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2225">您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2225">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2226">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2226">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2227"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2227">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2228">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2228">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2229"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2229"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2230">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2230">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2231">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2231">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2232">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2232">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2233">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2233">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-2234">請參閱下面的備註。</span><span class="sxs-lookup"><span data-stu-id="4e975-2234">See Remarks below.</span></span> <span data-ttu-id="4e975-2235">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2235">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2236">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2236">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2237">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多的 size 參數所指定的位元組數目的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2237">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="4e975-2238">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2238">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2239">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2239">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2240">如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2240">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2241">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2241">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2242">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2242">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2243">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2243">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2244">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2244">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2245">下列程式碼範例指定資料緩衝區、 位移、 大小和通訊端旗標才能接收資料，在連接上的<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2245">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2246"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2246"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2247"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2247"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2248">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2248">-or-</span></span>  
  
 <span data-ttu-id="4e975-2249"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2249"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-2250">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2250">-or-</span></span>  
  
 <span data-ttu-id="4e975-2251"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2251"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2252">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2252">-or-</span></span>  
  
 <span data-ttu-id="4e975-2253"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2253"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2254"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2254"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2255">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2255">-or-</span></span>  
  
 <span data-ttu-id="4e975-2256">未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2256">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="4e975-2257">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2257">-or-</span></span>  
  
 <span data-ttu-id="4e975-2258">在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2258">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2259"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2259">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2260">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2260">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2261">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2261">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2262">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2262">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2263"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2263">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-2264">「緩衝區」<c></c>參數中的位置，可儲存接收的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2264">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2265">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2265">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2266"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2266">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-2267"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2267">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="4e975-2268">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2268">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2269">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2269">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2270"><xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2270">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="4e975-2271">您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2271">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="4e975-2272">如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2272">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="4e975-2273"><xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2273">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2274">如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2274">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2275"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2275"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="4e975-2276">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2276">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2277">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2277">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2278">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2278">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2279">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2279">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-2280">請參閱下面的備註。</span><span class="sxs-lookup"><span data-stu-id="4e975-2280">See Remarks below.</span></span> <span data-ttu-id="4e975-2281">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2281">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2282">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2282">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2283">如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多的 size 參數所指定的位元組數目的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2283">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="4e975-2284">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2284">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="4e975-2285">如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2285">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="4e975-2286">如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-2286">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2287">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2287">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2288">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2288">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2289">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2289">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2290">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2290">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2291"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2291"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2292"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2292"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2293">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2293">-or-</span></span>  
  
 <span data-ttu-id="4e975-2294"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2294"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-2295">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2295">-or-</span></span>  
  
 <span data-ttu-id="4e975-2296"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2296"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2297">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2297">-or-</span></span>  
  
 <span data-ttu-id="4e975-2298"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2298"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2299"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2299"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2300">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2300">-or-</span></span>  
  
 <span data-ttu-id="4e975-2301">未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2301">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
 <span data-ttu-id="4e975-2302">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2302">-or-</span></span>  
  
 <span data-ttu-id="4e975-2303">在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2303">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2304"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2304">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2305">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2305">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2306">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2306">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2307">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2307">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-2308"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-2308">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-2309">開始非同步要求，以接收來自已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2309">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="4e975-2310">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2310">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-2311">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2311">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-2312">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2312">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-2313">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-2313">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2314"><xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法用在通訊端或繫結無連接的通訊端連線，以及用來讀取內送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2314">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="4e975-2315">必須知道通訊端的本機位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-2315">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="4e975-2316">繫結無連接的通訊端，此函式會限制已接受已接收的訊息的位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-2316">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="4e975-2317">函式只會傳回在連接中指定的遠端位址的訊息。</span><span class="sxs-lookup"><span data-stu-id="4e975-2317">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="4e975-2318">從其他位址的訊息被丟棄。</span><span class="sxs-lookup"><span data-stu-id="4e975-2318">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="4e975-2319"><xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性`e`參數提供視窗通訊端服務提供者，以及讀取要求的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2319">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="4e975-2320">如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2320">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4e975-2321">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：</span><span class="sxs-lookup"><span data-stu-id="4e975-2321">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="4e975-2322"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4e975-2322"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="4e975-2323"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定</span><span class="sxs-lookup"><span data-stu-id="4e975-2323"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="4e975-2324"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定</span><span class="sxs-lookup"><span data-stu-id="4e975-2324"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-2325">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2325">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-2326">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2326">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-2327">位元組資料流樣式通訊端，內送資料放入緩衝區為止緩衝區已滿，連接會關閉，或已用完內部的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2327">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="4e975-2328">訊息導向的通訊端，內送訊息會放入之前的相關聯的緩衝區大小總計的緩衝區`e`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2328">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="4e975-2329">如果訊息是大於緩衝區，訊息的第一個部分填滿緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2329">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="4e975-2330">連線導向的通訊端，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法可以指定其中一種相依於通訊端是否位元組資料流或訊息導向的兩個虛擬電路正常終止。</span><span class="sxs-lookup"><span data-stu-id="4e975-2330">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="4e975-2331">位元組資料流，讀取零個位元組表示正常關閉，曾將讀取任何多個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2331">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="4e975-2332">訊息導向的通訊端，其中是通常允許零個位元組的訊息，<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAEDISCON 錯誤程式碼 (10101) 用來表示非失誤性結束。</span><span class="sxs-lookup"><span data-stu-id="4e975-2332">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="4e975-2333">在任何情況下，<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生 Winsock WSAECONNRESET 錯誤碼 (10054) 會指出發生失敗的關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2333">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-2334">引數無效。</span><span class="sxs-lookup"><span data-stu-id="4e975-2334">An argument was invalid.</span></span> <span data-ttu-id="4e975-2335"><paramref name="e" /> 參數上的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性必須參考有效的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2335">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="4e975-2336">這兩個屬性可能有一個已經設定，但不會同時都已設定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2336">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-2337">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2337">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-2338">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-2338">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2339"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2339">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2340">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2340">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-2341">取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 之接收緩衝區的大小。</span><span class="sxs-lookup"><span data-stu-id="4e975-2341">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-2342"><see cref="T:System.Int32" />，包含接收緩衝區的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2342">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="4e975-2343">預設值為 8192。</span><span class="sxs-lookup"><span data-stu-id="4e975-2343">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2344">較大的緩衝區大小可能會減少空認可 （TCP 封包沒有資料部分），但也可能會延遲連線困難的辨識。</span><span class="sxs-lookup"><span data-stu-id="4e975-2344">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="4e975-2345">請考慮增加緩衝區大小，如果您正在傳送大型檔案，或您使用高頻寬、 高延遲的連線 （例如衛星寬頻提供者。）</span><span class="sxs-lookup"><span data-stu-id="4e975-2345">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2346">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2346">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2347">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2347">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2348"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2348">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-2349">為設定作業指定的值小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2349">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-2350">接收資料包以及儲存來源端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2350">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2351">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2351">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-2352">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</span><span class="sxs-lookup"><span data-stu-id="4e975-2352">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="4e975-2353">接收資料包至資料緩衝區中，並儲存端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2353">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-2354">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2354">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2355"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2355">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="4e975-2356">這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2356">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="4e975-2357">這個多載只會要求您提供接收`buffer`，和<xref:System.Net.EndPoint>表示遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2357">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="4e975-2358">緩衝區位移預設值為 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2358">The buffer offset defaults to 0.</span></span> <span data-ttu-id="4e975-2359">大小的預設值的長度為`buffer`參數和`socketFlags`值預設為<xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2359">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2360">然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2360">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-2361">如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2361">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-2362">無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2362">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="4e975-2363">如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2363">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2364">如果您使用的不可靠的通訊協定，將會遺失過多的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2364">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="4e975-2365">如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2365">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="4e975-2366">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-2366">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-2367">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2367">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2368">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2368">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2369">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2369">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2370">雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。</span><span class="sxs-lookup"><span data-stu-id="4e975-2370">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="4e975-2371">如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2371">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2372">如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2372">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2373">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2373">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2374">在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2374">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-2375">使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取最多資料，因為可用的大小直到`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-2375">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="4e975-2376">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2376">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2377">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2377">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2378">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2378">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2379"><xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2379">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2380">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2380">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2381">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2381">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2382">下列程式碼範例會從遠端主機接收無連線的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2382">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2383"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2383"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2384">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2384">-or-</span></span>  
  
 <span data-ttu-id="4e975-2385"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2385"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2386">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2386">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2387"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2387">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2388">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2388">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2389">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2389">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2390">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2390">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2391"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2391">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2392"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2392">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-2393">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</span><span class="sxs-lookup"><span data-stu-id="4e975-2393">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="4e975-2394">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，接收資料包至資料緩衝區中，並儲存端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2394">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-2395">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2395">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2396"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2396">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="4e975-2397">這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2397">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="4e975-2398">這個多載只會要求您提供接收緩衝區，視需要<xref:System.Net.Sockets.SocketFlags>，和<xref:System.Net.EndPoint>表示遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2398">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="4e975-2399">位移的預設值為 0 而且大小預設為緩衝區參數的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2399">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2400">然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2400">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-2401">如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2401">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-2402">無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2402">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="4e975-2403">如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2403">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2404">如果您使用的不可靠的通訊協定，將會遺失過多的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2404">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="4e975-2405">如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2405">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="4e975-2406">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-2406">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-2407">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2407">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2408">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2408">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2409">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2409">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2410">雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。</span><span class="sxs-lookup"><span data-stu-id="4e975-2410">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="4e975-2411">如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2411">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2412">如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2412">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2413">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2413">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2414">在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2414">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-2415">使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取最多資料，因為可用的大小直到`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-2415">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="4e975-2416">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2416">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2417">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2417">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2418">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2418">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2419"><xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2419">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2420">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2420">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2421">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2421">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2422">下列程式碼範例會從遠端主機接收無連線的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2422">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="4e975-2423"><xref:System.Net.Sockets.SocketFlags> 傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2423"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2424"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2424"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2425">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2425">-or-</span></span>  
  
 <span data-ttu-id="4e975-2426"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2426"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2427">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2427">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2428"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2428">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2429">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2429">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2430">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2430">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2431">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2431">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2432">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2432">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2433">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2433">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2434"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2434">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-2435">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</span><span class="sxs-lookup"><span data-stu-id="4e975-2435">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="4e975-2436">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，接收指定的位元組數至資料緩衝區中，並儲存端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2436">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-2437">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2437">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2438"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2438">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="4e975-2439">這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2439">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="4e975-2440">這個多載只會要求您提供接收緩衝區中，您想要接收所需的位元組數目<xref:System.Net.Sockets.SocketFlags>，和<xref:System.Net.EndPoint>表示遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2440">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="4e975-2441">緩衝區位移預設值為 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2441">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="4e975-2442">無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2442">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="4e975-2443">如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2443">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2444">如果您使用的不可靠的通訊協定，將會遺失過多的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2444">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="4e975-2445">如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2445">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="4e975-2446">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-2446">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-2447">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2447">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2448">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2448">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2449">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2449">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2450">雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。</span><span class="sxs-lookup"><span data-stu-id="4e975-2450">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="4e975-2451">如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2451">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2452">如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2452">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2453">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2453">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2454">在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2454">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-2455">使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取位於最高達指定的位元組數目的資料量`size`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2455">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="4e975-2456">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2456">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2457">然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2457">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-2458">如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2458">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2459">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2459">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2460">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2460">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2461"><xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2461">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2462">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2463">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2464">下列程式碼範例會從遠端主機接收無連線的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2464">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="4e975-2465">緩衝區大小，和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2465">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2466"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2466"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2467">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2467">-or-</span></span>  
  
 <span data-ttu-id="4e975-2468"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2468"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2469"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2469"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2470">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2470">-or-</span></span>  
  
 <span data-ttu-id="4e975-2471"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2471"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2472"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2472"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2473">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2473">-or-</span></span>  
  
 <span data-ttu-id="4e975-2474">未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2474">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="4e975-2475">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2475">-or-</span></span>  
  
 <span data-ttu-id="4e975-2476">在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2476">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2477"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2477">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-2478">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-2478">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2479">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2479">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2480">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2480">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2481">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2481">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-2482">「緩衝區」<c></c>參數中的位置，可儲存接收的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2482">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2483">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2483">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2484"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2484">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-2485">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</span><span class="sxs-lookup"><span data-stu-id="4e975-2485">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="4e975-2486">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將指定的資料位元組數目接收至資料緩衝區的指定位置，並儲存端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2486">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-2487">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2487">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2488"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2488">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="4e975-2489">這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2489">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="4e975-2490">無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2490">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="4e975-2491">如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2491">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2492">如果您使用的不可靠的通訊協定，將會遺失過多的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2492">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="4e975-2493">如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2493">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="4e975-2494">如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。</span><span class="sxs-lookup"><span data-stu-id="4e975-2494">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="4e975-2495">如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2495">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2496">您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2496">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="4e975-2497">當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。</span><span class="sxs-lookup"><span data-stu-id="4e975-2497">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="4e975-2498">雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。</span><span class="sxs-lookup"><span data-stu-id="4e975-2498">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="4e975-2499">如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2499">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-2500">如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2500">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2501">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2501">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="4e975-2502">在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2502">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-2503">使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取最多到所指定的位元組數量可用的資料量`size`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2503">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="4e975-2504">如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2504">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2505">然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2505">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-2506">如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2506">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2507">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2507">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2508">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2508">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2509"><xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2509">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2510">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2510">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2511">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2511">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2512">下列程式碼範例會從遠端主機接收無連線的資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2512">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="4e975-2513">位移、 緩衝區大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2513">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2514"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2514"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2515">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2515">-or-</span></span>  
  
 <span data-ttu-id="4e975-2516"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2516"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2517"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2517"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2518">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2518">-or-</span></span>  
  
 <span data-ttu-id="4e975-2519"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2519"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-2520">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2520">-or-</span></span>  
  
 <span data-ttu-id="4e975-2521"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2521"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2522">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2522">-or-</span></span>  
  
 <span data-ttu-id="4e975-2523"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去位移參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2523"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2524"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2524"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2525">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2525">-or-</span></span>  
  
 <span data-ttu-id="4e975-2526">未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2526">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="4e975-2527">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2527">-or-</span></span>  
  
 <span data-ttu-id="4e975-2528">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2528">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2529"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2529">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2530">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2530">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2531">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2531">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-2532"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-2532">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-2533">開始從指定的網路裝置非同步接收資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2533">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="4e975-2534">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2534">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-2535">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2535">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-2536">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2536">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-2537">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-2537">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2538"><xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法主要用來接收無連接的通訊端上的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2538">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="4e975-2539">必須知道通訊端的本機位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-2539">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="4e975-2540">呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>的接收來源資料之遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2540">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="4e975-2541"><xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性`e`參數提供視窗通訊端服務提供者，以及讀取要求的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2541">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="4e975-2542">如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2542">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4e975-2543">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：</span><span class="sxs-lookup"><span data-stu-id="4e975-2543">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-2544">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2544">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-2545">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2545">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-2546">訊息導向的通訊端，內送訊息會放入緩衝區的大小總計之前的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2546">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="4e975-2547"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2547">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="4e975-2548">位元組資料流樣式通訊端，內送資料放入緩衝區為止緩衝區已滿，連接會關閉，或已用完內部的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2548">For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="4e975-2549"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2549">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-2550"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-2550">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-2551">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2551">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-2552">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-2552">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2553"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2553">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2554">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2554">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2555">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2555">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-2556">「緩衝區」<c></c>參數中的位置，可儲存接收的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2556">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2557">要接收的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2557">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2558"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2558">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-2559">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</span><span class="sxs-lookup"><span data-stu-id="4e975-2559">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="4e975-2560">保留位址及介面資訊的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2560">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="4e975-2561">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將指定的資料位元組數目接收至資料緩衝區的指定位置，並儲存端點及封包資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2561">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="4e975-2562">收到的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2562">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2563"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機資料已傳送的端點，以及收到的封包的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2563">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="4e975-2564"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法主要用來接收訊息資料，無連接的通訊端上。</span><span class="sxs-lookup"><span data-stu-id="4e975-2564">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="4e975-2565">必須知道通訊端的本機位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-2565">The socket's local address must be known.</span></span> <span data-ttu-id="4e975-2566">這個方法只用於資料包與原始通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2566">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="4e975-2567">必須初始化通訊端通訊端類型設定為<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2567">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="4e975-2568">這可以使用建構通訊端時<xref:System.Net.Sockets.Socket.%23ctor%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2568">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2569">訊息導向的通訊端，內送訊息會放入`buffer`參數中指定的總大小最`size`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2569">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="4e975-2570">`offset`參數會決定在何處`buffer`將資料放在。</span><span class="sxs-lookup"><span data-stu-id="4e975-2570">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="4e975-2571">實際的資料量放入`buffer`傳回<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2571">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-2572"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法方法會設定自動<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`它稱為第一次指定<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2572">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-2573">不過，傳回<xref:System.Net.Sockets.IPPacketInformation>物件才會對封包抵達本機電腦，設定通訊端選項之後有效。</span><span class="sxs-lookup"><span data-stu-id="4e975-2573">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="4e975-2574">如果通訊端時繫結至本機端點傳送封包之間 (明確地<xref:System.Net.Sockets.Socket.Bind%2A>方法，或以隱含方式的其中一個<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和其第一次呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>若要呼叫的方法，<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會傳回不正確<xref:System.Net.Sockets.IPPacketInformation>這些封包的物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2574">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="4e975-2575">為了確保所有<xref:System.Net.Sockets.IPPacketInformation>物件有效，而且應用程式應該設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`本機端點，使用繫結之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2575">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="4e975-2576">應用程式可以檢查`ipPacketInformation`參數，需要知道資料包使用單點傳播、 多點傳送或廣播位址來傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2576">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2577"><xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2577">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2578">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2578">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2579">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2579">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2580"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2580"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-2581">\-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2581">\- or-</span></span>  
  
 <span data-ttu-id="4e975-2582"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2582"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2583"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2583"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2584">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2584">-or-</span></span>  
  
 <span data-ttu-id="4e975-2585"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2585"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-2586">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2586">-or-</span></span>  
  
 <span data-ttu-id="4e975-2587"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2587"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2588">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2588">-or-</span></span>  
  
 <span data-ttu-id="4e975-2589"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去位移參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2589"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2590"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2590"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2591">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2591">-or-</span></span>  
  
 <span data-ttu-id="4e975-2592">未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2592">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="4e975-2593">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2593">-or-</span></span>  
  
 <span data-ttu-id="4e975-2594">.NET Framework 正在 AMD 64 位元處理器上執行。</span><span class="sxs-lookup"><span data-stu-id="4e975-2594">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
 <span data-ttu-id="4e975-2595">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2595">-or-</span></span>  
  
 <span data-ttu-id="4e975-2596">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2596">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2597"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2597">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-2598">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</span><span class="sxs-lookup"><span data-stu-id="4e975-2598">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="4e975-2599">接受來自網路的連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2599">for accepting connections from the network.</span></span> <span data-ttu-id="4e975-2600">關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2600">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-2601"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-2601">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-2602">使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />，開始以非同步方式將指定之位元組數目的資料，接收至資料緩衝區的指定位置，並儲存端點和封包資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2602">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="4e975-2603">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2603">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-2604">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2604">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-2605">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2605">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-2606">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-2606">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2607"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法主要用來接收訊息資料，無連接的通訊端上。</span><span class="sxs-lookup"><span data-stu-id="4e975-2607">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="4e975-2608">必須知道通訊端的本機位址。</span><span class="sxs-lookup"><span data-stu-id="4e975-2608">The socket's local address must be known.</span></span> <span data-ttu-id="4e975-2609">這個方法只用於資料包與原始通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2609">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="4e975-2610">必須初始化通訊端通訊端類型設定為<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2610">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="4e975-2611">這可以使用建構通訊端時<xref:System.Net.Sockets.Socket.%23ctor%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2611">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2612">呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>的接收來源資料之遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-2612">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="4e975-2613">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：</span><span class="sxs-lookup"><span data-stu-id="4e975-2613">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-2614">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2614">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-2615">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2615">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-2616">訊息導向的通訊端，內送訊息會放入緩衝區的大小總計之前的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2616">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="4e975-2617"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及資料量。</span><span class="sxs-lookup"><span data-stu-id="4e975-2617">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="4e975-2618"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法會自動設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`它稱為第一次指定<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2618">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-2619">不過，<xref:System.Net.Sockets.IPPacketInformation>物件才會對封包抵達本機電腦，設定通訊端選項之後有效。</span><span class="sxs-lookup"><span data-stu-id="4e975-2619">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="4e975-2620">如果通訊端通訊端繫結至本機端點時傳送封包之間 (明確地<xref:System.Net.Sockets.Socket.Bind%2A>方法，或以隱含方式的其中一個<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和第一個呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法將會導致無效<xref:System.Net.Sockets.IPPacketInformation>這些封包的物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2620">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="4e975-2621">為了確保所有<xref:System.Net.Sockets.IPPacketInformation>物件有效，而且應用程式應該設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`本機端點，使用繫結之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2621">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="4e975-2622">應用程式可以檢查所產生的<xref:System.Net.Sockets.IPPacketInformation>物件是否需要知道資料包使用單點傳播、 多點傳送或廣播位址來傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2622">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-2623"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-2623">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-2624">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-2624">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2625"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2625">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2626">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2626">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-2627">取得或設定值，指定同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼叫逾時之前的時間長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2627">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="4e975-2628">逾時值 (以毫秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2628">The time-out value, in milliseconds.</span></span> <span data-ttu-id="4e975-2629">預設值為 0，表示無限的逾時期間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2629">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="4e975-2630">指定 -1 也表示無限的逾時期間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2630">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2631">此選項適用於同步<xref:System.Net.Sockets.Socket.Receive%2A>僅呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-2631">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="4e975-2632">如果超過逾時期限，<xref:System.Net.Sockets.Socket.Receive%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2632">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2633">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2633">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2634">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2635"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-2636">為設定作業指定的值小於 -1。</span><span class="sxs-lookup"><span data-stu-id="4e975-2636">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-2637">取得遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2637">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="4e975-2638"><see cref="T:System.Net.EndPoint" />，<see cref="T:System.Net.Sockets.Socket" /> 正在與其通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2638">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2639">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性會取得<xref:System.Net.EndPoint>，其中包含遠端 IP 位址和連接埠號碼的<xref:System.Net.Sockets.Socket>連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-2639">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="4e975-2640">如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>包含預設遠端 IP 位址和連接埠號碼與<xref:System.Net.Sockets.Socket>將與其通訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2640">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="4e975-2641">您必須將此轉型<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>之前擷取的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2641">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="4e975-2642">您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法來擷取遠端<xref:System.Net.IPAddress>，而<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法來擷取遠端連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2642">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="4e975-2643"><xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>設定後呼叫<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2643">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2644">如果您嘗試存取此屬性之前，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2644">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2645">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2645">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2646">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2646">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2647">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2647">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2648">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2648">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2649">下列程式碼範例會擷取，並顯示本機和遠端端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-2649">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2650">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2651"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2651">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="4e975-2652">要檢查可讀性的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2652">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="4e975-2653">要檢查可寫性的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2653">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="4e975-2654">要檢查錯誤的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2654">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="4e975-2655">逾時值 (以微秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2655">The time-out value, in microseconds.</span></span> <span data-ttu-id="4e975-2656">-1 值表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="4e975-2656">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="4e975-2657">判斷一或多個通訊端的狀態。</span><span class="sxs-lookup"><span data-stu-id="4e975-2657">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2658"><xref:System.Net.Sockets.Socket.Select%2A> 是一種靜態方法，會判斷一或多個狀態<xref:System.Net.Sockets.Socket>執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-2658"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="4e975-2659">您必須將放入一個或多個通訊端<xref:System.Collections.IList>才能夠使用<xref:System.Net.Sockets.Socket.Select%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2659">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="4e975-2660">藉由呼叫檢查可讀性<xref:System.Net.Sockets.Socket.Select%2A>與<xref:System.Collections.IList>為`checkRead`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2660">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="4e975-2661">若要檢查您的通訊端的可寫性，請使用`checkWrite`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2661">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="4e975-2662">用於偵測錯誤狀態，請使用`checkError`。</span><span class="sxs-lookup"><span data-stu-id="4e975-2662">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="4e975-2663">在呼叫<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>將會填入符合條件的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2663">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="4e975-2664">如果您是在接聽狀態中，可讀性表示呼叫<xref:System.Net.Sockets.Socket.Accept%2A>而不會封鎖將會成功。</span><span class="sxs-lookup"><span data-stu-id="4e975-2664">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="4e975-2665">如果您已接受連接，可讀性表示資料可供讀取。</span><span class="sxs-lookup"><span data-stu-id="4e975-2665">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="4e975-2666">在這些情況下，所有的接收作業會成功，而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="4e975-2666">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="4e975-2667">也可能表示可讀性是否遠端<xref:System.Net.Sockets.Socket>已關閉連線關閉，則在此情況下呼叫<xref:System.Net.Sockets.Socket.Receive%2A>會立即傳回並傳回零個位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2667">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="4e975-2668"><xref:System.Net.Sockets.Socket.Select%2A> 傳回時至少要有一個感興趣的通訊端 (在通訊端`checkRead`， `checkWrite`，和`checkError`列出) 符合指定的準則，或`microSeconds`參數超出、 何者較早。</span><span class="sxs-lookup"><span data-stu-id="4e975-2668"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="4e975-2669">設定`microSeconds`為-1 指定無限逾時。</span><span class="sxs-lookup"><span data-stu-id="4e975-2669">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="4e975-2670">若要以非封鎖式呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，可寫性表示您已成功連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-2670">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="4e975-2671">如果您已經建立連接，可寫性表示所有傳送的作業將會成功而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="4e975-2671">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="4e975-2672">如果您所做的非封鎖式呼叫<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`參數會識別尚未成功連線的通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-2672">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2673">使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，如果您只想要判斷狀態的單一<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2673">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2674">這個方法無法偵測某些類型的連線問題，例如中斷的網路纜線，或遠端主機已強制關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2674">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="4e975-2675">您必須嘗試傳送或接收資料，以偵測這類錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2675">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2676">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2676">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2677">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2677">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2678">下列程式碼範例使用<xref:System.Net.Sockets.Socket.Select%2A>來判斷哪些接聽的通訊端具有連線要求。</span><span class="sxs-lookup"><span data-stu-id="4e975-2678">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-2679"><paramref name="checkRead" /> 參數是 <see langword="null" /> 或空白。</span><span class="sxs-lookup"><span data-stu-id="4e975-2679">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
 <span data-ttu-id="4e975-2680">-和-</span><span class="sxs-lookup"><span data-stu-id="4e975-2680">-and-</span></span>  
  
 <span data-ttu-id="4e975-2681"><paramref name="checkWrite" /> 參數是 <see langword="null" /> 或空白。</span><span class="sxs-lookup"><span data-stu-id="4e975-2681">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span>  
  
 <span data-ttu-id="4e975-2682">-和-</span><span class="sxs-lookup"><span data-stu-id="4e975-2682">-and-</span></span>  
  
 <span data-ttu-id="4e975-2683"><paramref name="checkError" /> 參數是 <see langword="null" /> 或空白。</span><span class="sxs-lookup"><span data-stu-id="4e975-2683">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2684">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2684">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-2685">傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2685">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2686">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2686">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="4e975-2687">傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2687">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2688">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2688">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2689"><xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2689"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="4e975-2690"><xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2690"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-2691">這個多載都需要緩衝區，其中包含您想要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2691">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="4e975-2692"><xref:System.Net.Sockets.SocketFlags>將預設值為 0，緩衝區位移的預設值為 0，而且要傳送的緩衝區大小的預設值的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2692">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="4e975-2693">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2693">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2694">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2694">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2695">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2695">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-2696">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2696">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2697">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2697">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2698">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2698">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2699">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2699">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2700">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2700">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2701">在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2701">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="4e975-2702">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2702">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="4e975-2703">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2703">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2704">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2704">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2705">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2705">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2706">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2706">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2707">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2707">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2708">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2708">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2709">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2709">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2710">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2710">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2711">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2711">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2712">下列程式碼範例示範如何在連接上傳送的資料<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2712">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2713"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2713"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2714">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2714">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2715"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2715">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-2716"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2716">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="4e975-2717">將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2717">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2718">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2718">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2719"><xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2719"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-2720">這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2720">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="4e975-2721">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2721">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2722">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2722">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2723">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2723">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-2724">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2724">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2725">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2725">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2726">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2726">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2727">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2727">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2728">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2728">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2729">在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2729">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="4e975-2730">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2730">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="4e975-2731">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2731">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2732">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2732">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2733">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2733">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2734">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2734">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2735">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2735">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2736">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2736">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2737">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2737">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2738">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2739">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2740"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2740"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-2741"><paramref name="buffers" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-2741"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2742">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2742">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-2743">請參閱以下註解章節。</span><span class="sxs-lookup"><span data-stu-id="4e975-2743">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2744"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2744">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2745">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2745">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2746"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2746">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2747">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，傳送資料至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2747">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2748">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2748">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2749"><xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2749"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="4e975-2750"><xref:System.Net.Sockets.Socket.Send%2A>方法可以使用連線導向和無連接通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2750">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-2751">其中包含您想要傳送的資料緩衝區和的位元組合，這個多載需要<xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2751">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="4e975-2752">緩衝區位移為 0，而且要傳送的緩衝區大小的預設值的位元組數目的預設值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2752">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="4e975-2753">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數的值，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2753">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-2754">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2754">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2755">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2755">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2756">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2756">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-2757">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，再每次呼叫<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2757">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2758">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2758">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2759">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2759">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2760">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2760">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2761">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2761">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2762">在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2762">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="4e975-2763">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2763">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="4e975-2764">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2764">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2765">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2765">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2766">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2766">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2767">您必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2767">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-2768">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2768">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2769">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2769">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2770">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2770">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2771">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2771">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2772">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2772">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2773">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2773">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2774">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2774">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2775">下列程式碼範例示範如何在連接上傳送的資料<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2775">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2776"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2776"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2777">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2777">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2778"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2778">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-2779"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2779">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2780"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2780">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2781">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2781">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2782">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2782">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2783">這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2783">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="4e975-2784"><xref:System.Net.Sockets.SocketFlags>值預設為 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2784">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="4e975-2785">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketFlags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2785">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-2786">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2786">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2787">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2787">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2788">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2788">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-2789">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2789">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2790">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2790">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2791">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2791">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2792">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2792">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2793">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2793">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2794">在非封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2794">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="4e975-2795">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2795">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="4e975-2796">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2796">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2797">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2797">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2798">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2798">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2799">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2799">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2800">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2800">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2801">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2801">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2802">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2802">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2803">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2803">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2804">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2804">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2805"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2805"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-2806"><paramref name="buffers" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-2806"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2807">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2807">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2808"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2808">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2809">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2809">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2810">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2810">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2811"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2811">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2812">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，傳送指定的資料位元組數至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2812">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2813">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2813">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2814"><xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2814"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="4e975-2815"><xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2815"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-2816">這個多載都需要包含您想要傳送，您想要傳送的位元組數目和任何的位元組合的資料的緩衝區<xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2816">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="4e975-2817">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2817">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-2818">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2818">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2819">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2819">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2820">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2820">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-2821">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，再每次呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2821">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="4e975-2822">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2822">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2823">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2823">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2824">使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2824">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2825">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2825">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2826">在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送您要求的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2826">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="4e975-2827">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2827">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="4e975-2828">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2828">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2829">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2829">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2830">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2830">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2831">您必須確定大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2831">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-2832">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2832">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2833">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2833">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2834">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2834">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2835">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2835">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2836">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2836">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2837">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2837">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2838">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2838">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2839">下列程式碼範例會將傳送緩衝區中找到的資料，並指定<xref:System.Net.Sockets.SocketFlags.None>如<xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2839">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2840"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2840"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2841"><paramref name="size" /> 小於 0 或超過緩衝區的大小。</span><span class="sxs-lookup"><span data-stu-id="4e975-2841"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2842"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2842"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2843">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2843">-or-</span></span>  
  
 <span data-ttu-id="4e975-2844">存取通訊端時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2844">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2845"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2845">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="4e975-2846"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2846">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2847"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2847">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-2848"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2848">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="4e975-2849">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2849">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2850">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2850">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2851">這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2851">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="4e975-2852"><xref:System.Net.Sockets.SocketFlags>值預設為 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2852">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="4e975-2853">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketFlags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2853">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-2854">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2854">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2855">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2855">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2856">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2856">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-2857">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2857">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2858">您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2858">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2859">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2859">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2860">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2860">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2861">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2861">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2862">在非封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2862">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="4e975-2863">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-2863">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="4e975-2864">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2864">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2865">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2865">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2866">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2866">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2867">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2867">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2868">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2868">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2869">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2869">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2870">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2870">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2871">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2871">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2872">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2872">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2873"><paramref name="buffers" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2873"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4e975-2874"><paramref name="buffers" /> 是空的。</span><span class="sxs-lookup"><span data-stu-id="4e975-2874"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2875">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2875">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2876"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2876">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2877">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2877">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-2878">資料緩衝區中要開始傳送資料的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2878">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2879">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2879">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2880"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2880">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-2881">從指定位移開始，並使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將資料的指定位元組數傳送到連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2881">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-2882">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2882">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2883"><xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2883"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="4e975-2884"><xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2884"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-2885">在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2885">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-2886">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2886">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2887">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2887">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2888">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2888">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-2889">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2889">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2890">還是可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2890">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2891">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2891">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2892">您也必須確定大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2892">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-2893">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2893">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-2894">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2894">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2895">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2895">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2896">在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送您要求的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2896">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="4e975-2897">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2897">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="4e975-2898">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2898">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2899">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2899">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2900">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2900">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2901">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2901">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2902">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2902">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2903">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2903">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2904">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2904">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2905">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2905">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2906">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2906">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2907">下列程式碼範例會指定資料緩衝區、 位移、 大小，和<xref:System.Net.Sockets.SocketFlags>將資料傳送至連接<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2907">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2908"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2908"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2909"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2909"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2910">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2910">-or-</span></span>  
  
 <span data-ttu-id="4e975-2911"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2911"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-2912">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2912">-or-</span></span>  
  
 <span data-ttu-id="4e975-2913"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2913"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2914">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2914">-or-</span></span>  
  
 <span data-ttu-id="4e975-2915"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2915"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2916"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2916"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2917">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2917">-or-</span></span>  
  
 <span data-ttu-id="4e975-2918">在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2918">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2919"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2919">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-2920">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2920">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-2921">資料緩衝區中要開始傳送資料的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-2921">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-2922">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2922">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-2923"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2923">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="4e975-2924"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2924">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="4e975-2925">從指定的位移開始並使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將指定的資料位元組數傳送至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="4e975-2925">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="4e975-2926">已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-2926">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2927"><xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2927"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="4e975-2928"><xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2928"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-2929">在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2929">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-2930">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2930">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2931">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-2931">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-2932">如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2932">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-2933">如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2933">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="4e975-2934">還是可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2934">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="4e975-2935">您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2935">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2936">您也必須確定大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-2936">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-2937">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2937">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-2938">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2938">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-2939">如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2939">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-2940">在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送您要求的位元組數目少於可順利完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-2940">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="4e975-2941">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-2941">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="4e975-2942">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-2942">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-2943">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2943">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-2944">成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-2944">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2945">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-2945">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-2946">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-2946">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2947">傳送成功完成並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2947">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="4e975-2948">如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-2948">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-2949">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2949">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-2950">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2950">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2951">下列程式碼範例會指定資料緩衝區、 位移、 大小，和<xref:System.Net.Sockets.SocketFlags>將資料傳送至連接<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2951">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-2952"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2952"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-2953"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2953"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2954">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2954">-or-</span></span>  
  
 <span data-ttu-id="4e975-2955"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-2955"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-2956">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2956">-or-</span></span>  
  
 <span data-ttu-id="4e975-2957"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2957"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-2958">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2958">-or-</span></span>  
  
 <span data-ttu-id="4e975-2959"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-2959"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-2960"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-2960"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-2961">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-2961">-or-</span></span>  
  
 <span data-ttu-id="4e975-2962">在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2962">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2963"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2963">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-2964"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-2964">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-2965">將資料以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2965">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="4e975-2966">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2966">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-2967">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-2967">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-2968">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2968">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-2969">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-2969">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2970"><xref:System.Net.Sockets.Socket.SendAsync%2A>方法用來寫入輸出資料從一個或多個連線導向的通訊端使用緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2970">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="4e975-2971">這個方法也可用，不過，在無連線通訊端連線作業中指定遠端主機上。</span><span class="sxs-lookup"><span data-stu-id="4e975-2971">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="4e975-2972"><xref:System.Net.Sockets.Socket.SendAsync%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-2972">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-2973">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：</span><span class="sxs-lookup"><span data-stu-id="4e975-2973">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="4e975-2974"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4e975-2974"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="4e975-2975"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定</span><span class="sxs-lookup"><span data-stu-id="4e975-2975"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="4e975-2976"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定</span><span class="sxs-lookup"><span data-stu-id="4e975-2976"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-2977">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.SendAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2977">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-2978">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-2978">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-2979"><xref:System.Net.Sockets.Socket.SendAsync%2A>方法會擲回例外狀況，如果您不先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-2979">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="4e975-2980">呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2980">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="4e975-2981">訊息導向的通訊端，並不會超過訊息大小上限為基礎的 Windows 通訊端服務提供者。</span><span class="sxs-lookup"><span data-stu-id="4e975-2981">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="4e975-2982">如果資料太長，無法透過基礎的服務提供者以不可分割方式傳遞，傳送任何資料而<xref:System.Net.Sockets.Socket.SendAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAEMSGSIZE 錯誤程式碼 (10040)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2982">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="4e975-2983">請注意，成功完成<xref:System.Net.Sockets.Socket.SendAsync%2A>方法並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-2983">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-2984"><paramref name="e" /> 參數上的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性必須參考有效的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="4e975-2984">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="4e975-2985">這兩個屬性可能有一個已經設定，但不會同時都已設定。</span><span class="sxs-lookup"><span data-stu-id="4e975-2985">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-2986">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-2986">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-2987">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-2987">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2988"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2988">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2989">尚未透過 <see cref="T:System.Net.Sockets.Socket" />、<see cref="M:System.Net.Sockets.Socket.Accept" /> 或 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法取得 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />，或尚未連接。</span><span class="sxs-lookup"><span data-stu-id="4e975-2989">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-2990">取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 之傳送緩衝區的大小。</span><span class="sxs-lookup"><span data-stu-id="4e975-2990">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-2991"><see cref="T:System.Int32" />，包含傳送緩衝區的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="4e975-2991">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="4e975-2992">預設值為 8192。</span><span class="sxs-lookup"><span data-stu-id="4e975-2992">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-2993">較大的緩衝區大小可能會延遲連線困難的辨識。</span><span class="sxs-lookup"><span data-stu-id="4e975-2993">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="4e975-2994">請考慮增加緩衝區大小，如果您正在傳送大型檔案，或您使用高頻寬、 高延遲的連線 （例如衛星寬頻提供者。）</span><span class="sxs-lookup"><span data-stu-id="4e975-2994">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-2995">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.SendBufferSize%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-2995">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-2996">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-2996">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-2997"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-2997">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-2998">為設定作業指定的值小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-2998">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-2999">將檔案和選擇性資料同步傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-2999">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="4e975-3000">包含要傳送之檔案的路徑與名稱的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3000">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="4e975-3001">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3001">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="4e975-3002">使用 <see cref="T:System.Net.Sockets.Socket" /> 傳輸旗標，將檔案 <paramref name="fileName" /> 傳送至已連接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3002">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3003">這個多載會將該檔案傳送`fileName`連線通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-3003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="4e975-3004">`flags`參數預設值為<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)，而`preBuffer`和`postBuffer`參數預設為`null`。</span><span class="sxs-lookup"><span data-stu-id="4e975-3004">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="4e975-3005">如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-3005">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="4e975-3006">使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。</span><span class="sxs-lookup"><span data-stu-id="4e975-3006">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="4e975-3007">如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-3007">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="4e975-3008">這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。</span><span class="sxs-lookup"><span data-stu-id="4e975-3008">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="4e975-3009">如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3009">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="4e975-3010"><xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式將檔案傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3010"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-3011"><xref:System.Net.Sockets.Socket.SendFile%2A> 可用來同時連線導向及無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3011"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-3012">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，否則<xref:System.Net.Sockets.Socket.SendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-3012">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="4e975-3013">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-3013">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-3014">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendFile%2A>封鎖，直到檔案傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-3014">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="4e975-3015">在未封鎖模式中，<xref:System.Net.Sockets.Socket.SendFile%2A>可能之前已傳送整個檔案已成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-3015">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="4e975-3016">沒有保證您傳送的資料就會立即出現在網路。</span><span class="sxs-lookup"><span data-stu-id="4e975-3016">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-3017">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3017">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-3018">成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3018">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3019">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3019">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3020">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3020">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3021">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3021">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3022">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3022">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3023">下列程式碼範例會建立和連接通訊端，然後將檔案傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3023">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="4e975-3024">檔案"test.txt"位於本機電腦的根目錄中。</span><span class="sxs-lookup"><span data-stu-id="4e975-3024">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-3025">通訊端未連線至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3025">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3026"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3026">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-3027"><see cref="T:System.Net.Sockets.Socket" /> 物件不是處於封鎖模式，而且無法接受此同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-3027">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="4e975-3028">找不到檔案 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3028">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3029">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3029">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="4e975-3030">包含要傳送之檔案的路徑與名稱的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3030">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="4e975-3031">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3031">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="4e975-3032">包含傳送檔案前要傳送之資料的 <see cref="T:System.Byte" /> 陣列。</span><span class="sxs-lookup"><span data-stu-id="4e975-3032">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="4e975-3033">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3033">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="4e975-3034">包含傳送檔案後要傳送之資料的 <see cref="T:System.Byte" /> 陣列。</span><span class="sxs-lookup"><span data-stu-id="4e975-3034">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="4e975-3035">這個參數可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3035">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="4e975-3036">一或多個 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3036">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="4e975-3037">使用指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，將檔案 <paramref name="fileName" /> 和資料緩衝區傳送到連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3037">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3038">這個多載都需要您想要傳送的檔案和的位元組合名稱<xref:System.Net.Sockets.TransmitFileOptions>值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3038">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="4e975-3039">`preBuffer`參數會包含您想要位在檔案之前的任何資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3039">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="4e975-3040">`postBuffer` 包含您想要遵循之檔案的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3040">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="4e975-3041">如果`fileName`是在目前工作目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-3041">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="4e975-3042">使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。</span><span class="sxs-lookup"><span data-stu-id="4e975-3042">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="4e975-3043">`flags`參數提供視窗通訊端服務提供者，以及其他資訊的檔案傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-3043">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="4e975-3044">如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3044">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="4e975-3045">這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。</span><span class="sxs-lookup"><span data-stu-id="4e975-3045">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="4e975-3046">如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3046">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="4e975-3047"><xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式將檔案傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3047"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-3048"><xref:System.Net.Sockets.Socket.SendFile%2A> 可用來同時連線導向及無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3048"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="4e975-3049">如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法; 否則<xref:System.Net.Sockets.Socket.SendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3049">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3050">如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。</span><span class="sxs-lookup"><span data-stu-id="4e975-3050">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="4e975-3051">如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendFile%2A>封鎖，直到整個檔案傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-3051">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="4e975-3052">在未封鎖模式中，<xref:System.Net.Sockets.Socket.SendFile%2A>可能之前已傳送整個檔案已成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-3052">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="4e975-3053">沒有保證您傳送的資料就會立即出現在網路。</span><span class="sxs-lookup"><span data-stu-id="4e975-3053">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-3054">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3054">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-3055">成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3055">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3056">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3056">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3057">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3057">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3058">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3058">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3059">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3059">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3060">下列程式碼範例會建立，並連接通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-3060">The following code example creates and connects a socket.</span></span> <span data-ttu-id="4e975-3061">檔案"test.txt"位於本機電腦的根目錄中。</span><span class="sxs-lookup"><span data-stu-id="4e975-3061">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="4e975-3062">在此範例中，我們建立緩衝和後置的資料，並將它們傳送給遠端主機中的檔案。</span><span class="sxs-lookup"><span data-stu-id="4e975-3062">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="4e975-3063">預設值<xref:System.Net.Sockets.TransmitFileOptions>可用。</span><span class="sxs-lookup"><span data-stu-id="4e975-3063">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-3064">作業系統不是 Windows NT (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-3064">The operating system is not Windows NT or later.</span></span>  
  
 <span data-ttu-id="4e975-3065">\-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3065">\- or -</span></span>  
  
 <span data-ttu-id="4e975-3066">通訊端未連線至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3066">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3067"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3067">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-3068"><see cref="T:System.Net.Sockets.Socket" /> 物件不是處於封鎖模式，而且無法接受此同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-3068">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="4e975-3069">找不到檔案 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3069">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3070">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3070">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-3071"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-3071">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-3072">以非同步的方式將檔案的集合或記憶體中資料緩衝區傳送至連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3072">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="4e975-3073">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3073">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-3074">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3074">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-3075">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3075">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-3076">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-3076">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3077"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法用來將集合的檔案，或在記憶體中資料緩衝區傳送至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3077">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="4e975-3078"><xref:System.Net.Sockets.Socket>必須先連接至遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3078">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="4e975-3079">如果<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>的工作目錄中檔案的參考，可能會識別與檔案的名稱; 否則必須指定完整路徑和檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-3079">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="4e975-3080">支援萬用字元和 UNC 共用名稱。</span><span class="sxs-lookup"><span data-stu-id="4e975-3080">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="4e975-3081">如果找不到檔案，<xref:System.IO.FileNotFoundException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="4e975-3081">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="4e975-3082">若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3082">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="4e975-3083"><xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>屬性`e`參數提供視窗通訊端服務提供者，以及其他資訊的檔案傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-3083">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="4e975-3084">如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3084">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="4e975-3085">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：</span><span class="sxs-lookup"><span data-stu-id="4e975-3085">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-3086">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3086">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-3087">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3087">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-3088">這個方法會使用位於 Windows Sockets 2 API TransmitPackets 函式。</span><span class="sxs-lookup"><span data-stu-id="4e975-3088">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="4e975-3089">如需有關 TransmitPackets 函式和其旗標的詳細資訊，請參閱 MSDN Library 中的 Windows Sockets 文件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3089">For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="4e975-3090">雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以建立預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3090">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="4e975-3091">您也必須確定檔案的大小不超過最大的封包大小基礎的服務提供者的無連接的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3091">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-3092">如果是的話，不會傳送資料包和<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-3092">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="4e975-3093"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合根據自選的作業系統，使用它。</span><span class="sxs-lookup"><span data-stu-id="4e975-3093">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="4e975-3094">在 Windows server 版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合用於高效能。</span><span class="sxs-lookup"><span data-stu-id="4e975-3094">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="4e975-3095">在 Windows 用戶端版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合用於最小記憶體和資源使用率。</span><span class="sxs-lookup"><span data-stu-id="4e975-3095">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="4e975-3096">使用<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>加上旗標<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>屬性`e`參數可以提供效能優勢明顯。</span><span class="sxs-lookup"><span data-stu-id="4e975-3096">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="4e975-3097">如果執行緒起始<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法呼叫的使用大量計算，可能是，雖然不太可能，Apc 可能無法啟動。</span><span class="sxs-lookup"><span data-stu-id="4e975-3097">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="4e975-3098">請注意，核心和使用者模式 Apc 之間的差異。</span><span class="sxs-lookup"><span data-stu-id="4e975-3098">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="4e975-3099">在執行緒處於等候狀態時，就會啟動核心 Apc。</span><span class="sxs-lookup"><span data-stu-id="4e975-3099">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="4e975-3100">當執行緒在警示的等待狀態時，會啟動使用者模式 Apc</span><span class="sxs-lookup"><span data-stu-id="4e975-3100">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="4e975-3101">找不到 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 屬性中指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="4e975-3101">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-3102">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-3102">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-3103">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-3103">Windows XP or later is required for this method.</span></span> <span data-ttu-id="4e975-3104">如果 <see cref="T:System.Net.Sockets.Socket" /> 未連接至遠端主機，也會發生這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4e975-3104">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3105"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3105">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3106">正在使用無連接的 <see cref="T:System.Net.Sockets.Socket" />，且正在傳送的檔案超出基礎傳輸的封包大小上限。</span><span class="sxs-lookup"><span data-stu-id="4e975-3106">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-3107">取得或設定值，指定同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼叫逾時之前的時間長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-3107">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="4e975-3108">逾時值 (以毫秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3108">The time-out value, in milliseconds.</span></span> <span data-ttu-id="4e975-3109">如果您將屬性設為 1 到 499 之間的值，則會將值變更為 500。</span><span class="sxs-lookup"><span data-stu-id="4e975-3109">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="4e975-3110">預設值為 0，表示無限的逾時期間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3110">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="4e975-3111">指定 -1 也表示無限的逾時期間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3111">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3112">此選項適用於同步<xref:System.Net.Sockets.Socket.Send%2A>僅呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e975-3112">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="4e975-3113">如果超過逾時期限，<xref:System.Net.Sockets.Socket.Send%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3113">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3114">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.SendTimeout%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-3114">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3115">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3115">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3116"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-3117">為設定作業指定的值小於 -1。</span><span class="sxs-lookup"><span data-stu-id="4e975-3117">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-3118">傳送資料至特定的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-3118">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-3119">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3119">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-3120"><see cref="T:System.Net.EndPoint" />，表示資料的目的端。</span><span class="sxs-lookup"><span data-stu-id="4e975-3120">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="4e975-3121">傳送資料至指定的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-3121">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="4e975-3122">已傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3122">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3123">在這個多載，緩衝區位移為 0 時，要傳送的大小的預設值的位元組數目的預設值`buffer`參數，而<xref:System.Net.Sockets.SocketFlags>值預設為 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-3123">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="4e975-3124">如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3124">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-3125">您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3125">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="4e975-3126">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。</span><span class="sxs-lookup"><span data-stu-id="4e975-3126">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="4e975-3127">您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-3127">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="4e975-3128">如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-3128">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="4e975-3129">適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3129">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="4e975-3130">如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3130">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-3131">如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3131">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3132">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3132">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-3133">在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3133">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-3134">封鎖的通訊端會阻擋，直到傳送的所有位元組緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="4e975-3134">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="4e975-3135">因為未封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的位元組中的所有`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-3135">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="4e975-3136">您的應用程式必須負責記錄傳送的位元組數，以及重試此作業，直到應用程式傳送的位元組中的所有`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-3136">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="4e975-3137">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-3137">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-3138">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3138">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="4e975-3139">成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3139">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="4e975-3140">如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-3140">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-3141">如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3141">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-3142">您也必須確定傳送的位元組數目不超過最大的封包大小基礎的服務提供者。</span><span class="sxs-lookup"><span data-stu-id="4e975-3142">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-3143">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3143">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3144">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3144">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3145">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3145">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3146">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3146">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3147">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3147">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3148">下列程式碼範例會將無連線資料包傳送至指定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3148">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-3149"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3149"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-3150">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3150">-or-</span></span>  
  
 <span data-ttu-id="4e975-3151"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3151"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3152">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3152">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3153"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-3154">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3154">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-3155"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-3155">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-3156"><see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-3156">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="4e975-3157">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送資料至特定端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-3157">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-3158">已傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3158">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3159">在這個多載，緩衝區位移為 0，而且要傳送的大小的預設值的位元組數目的預設值`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-3159">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="4e975-3160">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3160">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-3161">如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3161">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-3162">您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3162">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="4e975-3163">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。</span><span class="sxs-lookup"><span data-stu-id="4e975-3163">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="4e975-3164">您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-3164">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="4e975-3165">如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-3165">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="4e975-3166">適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3166">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="4e975-3167">如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3167">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-3168">如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3168">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3169">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3169">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-3170">在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3170">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-3171">封鎖的通訊端將會封鎖直到所要求的位元組中的所有`buffer`傳送。</span><span class="sxs-lookup"><span data-stu-id="4e975-3171">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="4e975-3172">因為未封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的位元組中的所有`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-3172">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="4e975-3173">您的應用程式必須負責記錄傳送的位元組數，以及重試此作業，直到應用程式傳送的位元組中的所有`buffer`。</span><span class="sxs-lookup"><span data-stu-id="4e975-3173">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="4e975-3174">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-3174">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-3175">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量傳出資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3175">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="4e975-3176">成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3176">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="4e975-3177">如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-3177">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-3178">如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3178">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-3179">您也必須確定傳送的位元組數目不超過最大的封包大小基礎的服務提供者。</span><span class="sxs-lookup"><span data-stu-id="4e975-3179">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-3180">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3180">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3181">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3182">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3182">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3183">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3184">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3185">下列程式碼範例會將無連線資料包傳送至指定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3185">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="4e975-3186"><xref:System.Net.Sockets.SocketFlags> 傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3186"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-3187"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3187"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-3188">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3188">-or-</span></span>  
  
 <span data-ttu-id="4e975-3189"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3189"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3190">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3190">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3191"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3191">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-3192">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3192">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-3193">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3193">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-3194"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-3194">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-3195"><see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-3195">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="4e975-3196">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送指定位元組數目的資料至指定的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-3196">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-3197">已傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3197">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3198">在這個多載，緩衝區位移預設值為 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-3198">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="4e975-3199">如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3199">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-3200">如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3200">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-3201">您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3201">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="4e975-3202">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。</span><span class="sxs-lookup"><span data-stu-id="4e975-3202">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="4e975-3203">您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-3203">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="4e975-3204">如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-3204">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="4e975-3205">適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3205">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="4e975-3206">如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3206">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-3207">如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3207">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3208">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3208">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-3209">在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3209">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-3210">封鎖的通訊端會阻擋，直到傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-3210">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="4e975-3211">因為未封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的所有要求在單一作業中的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-3211">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="4e975-3212">負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-3212">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="4e975-3213">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-3213">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-3214">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量傳出資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3214">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="4e975-3215">成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3215">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="4e975-3216">如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-3216">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-3217">如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3217">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-3218">您也必須確定傳送的位元組數目不超過最大的封包大小基礎的服務提供者。</span><span class="sxs-lookup"><span data-stu-id="4e975-3218">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-3219">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3219">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3220">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3220">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3221">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3221">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3222">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3222">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3223">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3223">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3224">下列程式碼範例會將無連線資料包傳送至指定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3224">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="4e975-3225">大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3225">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-3226"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3226"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-3227">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3227">-or-</span></span>  
  
 <span data-ttu-id="4e975-3228"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3228"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-3229">指定的 <paramref name="size" /> 超過 <paramref name="buffer" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="4e975-3229">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3230">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3230">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3231"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="4e975-3232">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3232">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="4e975-3233">資料緩衝區中要開始傳送資料的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-3233">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="4e975-3234">要傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3234">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="4e975-3235"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-3235">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="4e975-3236"><see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</span><span class="sxs-lookup"><span data-stu-id="4e975-3236">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="4e975-3237">從緩衝區中的指定位置開始且使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送指定位元組數目的資料至指定的端點。</span><span class="sxs-lookup"><span data-stu-id="4e975-3237">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="4e975-3238">已傳送的位元組數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3238">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3239">在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3239">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-3240">如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3240">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="4e975-3241">您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3241">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="4e975-3242">如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。</span><span class="sxs-lookup"><span data-stu-id="4e975-3242">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="4e975-3243">您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。</span><span class="sxs-lookup"><span data-stu-id="4e975-3243">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="4e975-3244">如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。</span><span class="sxs-lookup"><span data-stu-id="4e975-3244">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="4e975-3245">適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3245">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="4e975-3246">如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3246">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="4e975-3247">如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3247">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3248">您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3248">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="4e975-3249">在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3249">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="4e975-3250">封鎖的通訊端會阻擋，直到傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-3250">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="4e975-3251">因為非封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的所有要求在單一作業中的位元組。</span><span class="sxs-lookup"><span data-stu-id="4e975-3251">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="4e975-3252">您必須負責應用程式記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="4e975-3252">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="4e975-3253">也是您所傳送的資料就會立即出現在網路不保證。</span><span class="sxs-lookup"><span data-stu-id="4e975-3253">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="4e975-3254">若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量傳出資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3254">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="4e975-3255">成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。</span><span class="sxs-lookup"><span data-stu-id="4e975-3255">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="4e975-3256">如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。</span><span class="sxs-lookup"><span data-stu-id="4e975-3256">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="4e975-3257">如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3257">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e975-3258">您也必須確定大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-3258">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-3259">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3259">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3260">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3260">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3261">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3261">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3262">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3262">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3263">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3263">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3264">下列程式碼範例會將無連線資料包傳送至指定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3264">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="4e975-3265">位移、 大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3265">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-3266"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3266"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="4e975-3267">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3267">-or-</span></span>  
  
 <span data-ttu-id="4e975-3268"><paramref name="remoteEP" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3268"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4e975-3269"><paramref name="offset" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-3269"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-3270">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3270">-or-</span></span>  
  
 <span data-ttu-id="4e975-3271"><paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。</span><span class="sxs-lookup"><span data-stu-id="4e975-3271"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="4e975-3272">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3272">-or-</span></span>  
  
 <span data-ttu-id="4e975-3273"><paramref name="size" /> 小於 0。</span><span class="sxs-lookup"><span data-stu-id="4e975-3273"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="4e975-3274">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3274">-or-</span></span>  
  
 <span data-ttu-id="4e975-3275"><paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3275"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="4e975-3276"><paramref name="socketFlags" /> 不是有效的值組合。</span><span class="sxs-lookup"><span data-stu-id="4e975-3276"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="4e975-3277">-或-</span><span class="sxs-lookup"><span data-stu-id="4e975-3277">-or-</span></span>  
  
 <span data-ttu-id="4e975-3278">在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3278">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3279"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3279">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="4e975-3280">呼叫堆疊中的呼叫端沒有所需的使用權限。</span><span class="sxs-lookup"><span data-stu-id="4e975-3280">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4e975-3281"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-3281">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="4e975-3282">以非同步方式將資料傳送至特定的遠端主機。</span><span class="sxs-lookup"><span data-stu-id="4e975-3282">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="4e975-3283">如果 I/O 作業暫止，則傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3283">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="4e975-3284">作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3284">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="4e975-3285">如果 I/O 作業同步完成，則傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3285">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="4e975-3286">在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</span><span class="sxs-lookup"><span data-stu-id="4e975-3286">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3287"><xref:System.Net.Sockets.Socket.SendToAsync%2A>方法會啟動非同步傳送作業中指定遠端主機<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性`e`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3287">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="4e975-3288">呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法可讓您傳送不同的執行緒中的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3288">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="4e975-3289">雖然這個方法適用於無連接的通訊協定<xref:System.Net.Sockets.Socket.SendToAsync%2A>無連線和連線導向的通訊協定的運作方式。</span><span class="sxs-lookup"><span data-stu-id="4e975-3289">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="4e975-3290">若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3290">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="4e975-3291">下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：</span><span class="sxs-lookup"><span data-stu-id="4e975-3291">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="4e975-3292">呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法，如此將可在回呼方法中擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3292">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="4e975-3293">如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3293">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="4e975-3294">如果您使用連線導向的通訊協定，您必須先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3294">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="4e975-3295">否則<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3295">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3296">當使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法將會忽略<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性，並將傳送資料至<xref:System.Net.EndPoint?displayProperty=nameWithType>中建立<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3296">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-3297">如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3297">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="4e975-3298">您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.SendAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3298">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="4e975-3299">如果您呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性將會覆寫指定的預設遠端主機，如，傳送作業只。</span><span class="sxs-lookup"><span data-stu-id="4e975-3299">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="4e975-3300">您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3300">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="4e975-3301">在此情況下，基礎的服務提供者將會指派最適當的區域網路 IP 位址和連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3301">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="4e975-3302">如果您希望基礎的服務提供者，選取可用的通訊埠，請使用零的連接埠號碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3302">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="4e975-3303">如果您需要識別指派的本機網路 IP 位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件發出信號和呼叫相關聯的委派。</span><span class="sxs-lookup"><span data-stu-id="4e975-3303">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="4e975-3304">如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>為 true。</span><span class="sxs-lookup"><span data-stu-id="4e975-3304">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="4e975-3305">您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。</span><span class="sxs-lookup"><span data-stu-id="4e975-3305">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="4e975-3306">如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3306">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="4e975-3307">如果您指定中的 DontRoute 旗標<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性，將不會路由傳送的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3307">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="4e975-3308">訊息導向的通訊端，必須小心不必超過訊息大小上限為基礎的傳輸。</span><span class="sxs-lookup"><span data-stu-id="4e975-3308">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="4e975-3309">如果緩衝區的大小超過最大的封包大小基礎的服務提供者，不會傳送資料包和<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3309">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="4e975-3310">成功完成<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法並不表示已成功傳送資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3310">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e975-3311"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</span><span class="sxs-lookup"><span data-stu-id="4e975-3311">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-3312">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</span><span class="sxs-lookup"><span data-stu-id="4e975-3312">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-3313">這個方法需要 Windows XP (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="4e975-3313">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3314"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3314">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3315">指定的通訊協定是連接導向的，但尚未連接 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3315">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="4e975-3316">要設定在這個通訊端上的 IP 保護層級。</span><span class="sxs-lookup"><span data-stu-id="4e975-3316">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="4e975-3317">設定通訊端上的 IP 保護層級。</span><span class="sxs-lookup"><span data-stu-id="4e975-3317">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3318"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法可讓限制來接聽指定的範圍，例如具有相同位址連結本機或網站本機首碼的 IPv6 或 IP 通訊端。</span><span class="sxs-lookup"><span data-stu-id="4e975-3318">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="4e975-3319">這個通訊端選項可讓應用程式置於 IPv6 或 IP 通訊端的存取限制。</span><span class="sxs-lookup"><span data-stu-id="4e975-3319">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="4e975-3320">這類限制可以讓應用程式在私人 LAN 上執行，簡便又穩當地強化應用程式對外部攻擊的抵禦。</span><span class="sxs-lookup"><span data-stu-id="4e975-3320">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="4e975-3321">這個通訊端選項也可用來移除存取限制，如果`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3321">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="4e975-3322">這個通訊端選項可放大或縮小接聽通訊端的範圍，根據需要啟用公用和私用使用者的無限制存取，或視需要限制成僅可存取相同的站台。</span><span class="sxs-lookup"><span data-stu-id="4e975-3322">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="4e975-3323">這個通訊端選項已定義 <xref:System.Net.Sockets.IPProtectionLevel> 列舉中所指定的保護層級。</span><span class="sxs-lookup"><span data-stu-id="4e975-3323">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="4e975-3324"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法用來啟用或停用網路位址周遊 (NAT) 的<xref:System.Net.Sockets.Socket>執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-3324">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="4e975-3325">您可以使用 Teredo、 6to4 或 ISATAP 通道提供 NAT 周遊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3325">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="4e975-3326">當`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，或<xref:System.Net.Sockets.IPProtectionLevel.Restricted>，這明確停用的 NAT 周遊<xref:System.Net.Sockets.Socket>執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e975-3326">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="4e975-3327">當`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，這可能會讓 NAT 周遊<xref:System.Net.Sockets.Socket>根據在系統上的防火牆規則。</span><span class="sxs-lookup"><span data-stu-id="4e975-3327">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e975-3328"><paramref name="level" /> 參數不可為 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3328">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="4e975-3329">IP 保護層級不能設定為未指定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3329">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-3330">通訊端的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必須是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或  <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3330">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4e975-3331">設定 <see cref="T:System.Net.Sockets.Socket" /> 選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3331">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-3332">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3332">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-3333">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3333">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="4e975-3334">選項的值，表示為 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3334">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="4e975-3335">將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設為指定的 <see cref="T:System.Boolean" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3335">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3336"><xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3336"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-3337">設定`optionValue`至`true`啟用選項，或`false`停用選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3337">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="4e975-3338"><xref:System.Net.Sockets.Socket> 選項會分組層級的通訊協定支援。</span><span class="sxs-lookup"><span data-stu-id="4e975-3338"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="4e975-3339">以下列出各種<xref:System.Net.Sockets.Socket>可以使用這個多載來設定的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3339">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="4e975-3340">這些選項會依適當分組<xref:System.Net.Sockets.SocketOptionLevel>值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3340">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="4e975-3341">如果您想要設定任何這些選項，請務必使用適當<xref:System.Net.Sockets.SocketOptionLevel>值`optionLevel`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3341">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="4e975-3342">若要設定您選擇的選項中必須指定`optionName`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3342">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="4e975-3343">如果您想要取得任何所列的選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3343">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-3344"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3344"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="4e975-3345"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3345"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="4e975-3346"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3346"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="4e975-3347"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3347"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="4e975-3348">如需有關這些選項的詳細資訊，請參閱<xref:System.Net.Sockets.SocketOptionName>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="4e975-3348">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3349">如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3349">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3350">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3350">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3351">下列程式碼範例會開啟通訊端，並可讓`DontLinger`和`OutOfBandInline`通訊端選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3351">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3352"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3352">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3353">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3353">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-3354">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3354">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-3355">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3355">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="4e975-3356"><see cref="T:System.Byte" /> 型別的陣列，表示選項的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3356">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="4e975-3357">將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定值，表示為位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="4e975-3357">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3358"><xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3358"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-3359">使用這個多載，來設定那些<xref:System.Net.Sockets.Socket>需要做為選項值的位元組陣列的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3359">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3360">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3360">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3361">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3361">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3362">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3362">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3363">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3363">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3364">下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3364">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3365">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3365">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3366"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3366">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-3367">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3367">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-3368">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3368">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="4e975-3369">選項的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3369">A value of the option.</span></span></param>
        <summary><span data-ttu-id="4e975-3370">將指定 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定的整數值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3370">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3371"><xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3371"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-3372">選項與<xref:System.Boolean>資料類型，請啟用選項，則為非零值和零值，以停用此選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3372">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="4e975-3373">具有整數資料類型的選項，指定適當的值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3373">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="4e975-3374"><xref:System.Net.Sockets.Socket> 選項會分組層級的通訊協定支援。</span><span class="sxs-lookup"><span data-stu-id="4e975-3374"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="4e975-3375">以下列出各種<xref:System.Net.Sockets.Socket>可以使用這個多載來設定的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3375">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="4e975-3376">這些選項會依適當分組<xref:System.Net.Sockets.SocketOptionLevel>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3376">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="4e975-3377">如果您想要設定任何這些選項，請務必使用適當<xref:System.Net.Sockets.SocketOptionLevel>如`optionLevel`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3377">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="4e975-3378">若要設定您選擇的選項中必須指定`optionName`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3378">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="4e975-3379">如果您想要取得任何所列的選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3379">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="4e975-3380"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3380"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="4e975-3381"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3381"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="4e975-3382"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3382"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="4e975-3383"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3383"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="4e975-3384"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 您可以將使用這個多載的選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3384"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="4e975-3385">如需有關這些選項的詳細資訊，請參閱<xref:System.Net.Sockets.SocketOptionName>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="4e975-3385">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3386">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3386">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3387">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3387">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3388">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3388">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3389">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3389">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3390">下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3390">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3391">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3391">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3392"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3392">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="4e975-3393">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3393">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="4e975-3394">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3394">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="4e975-3395"><see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，包含選項值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3395">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="4e975-3396">將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定值，表示為物件。</span><span class="sxs-lookup"><span data-stu-id="4e975-3396">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3397"><xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3397"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-3398">若要設定使用這個多載<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，和<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>選項。</span><span class="sxs-lookup"><span data-stu-id="4e975-3398">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="4e975-3399">如<xref:System.Net.Sockets.SocketOptionName.Linger>選項，請使用<xref:System.Net.Sockets.Socket>如`optionLevel`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3399">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="4e975-3400">如<xref:System.Net.Sockets.SocketOptionName.AddMembership>和<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3400">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="4e975-3401">如果您想要取得任何上述選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e975-3401">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3402">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3402">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3403">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3403">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3404">下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3404">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4e975-3405"><paramref name="optionValue" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3405"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3406">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3406">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3407"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3407">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="4e975-3408">其中一個 <see cref="T:System.Net.Sockets.SocketShutdown" /> 值，指定將不再允許的作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-3408">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="4e975-3409">暫停 <see cref="T:System.Net.Sockets.Socket" /> 上的傳送和接收作業。</span><span class="sxs-lookup"><span data-stu-id="4e975-3409">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3410">當使用連線導向<xref:System.Net.Sockets.Socket>，務必呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>方法在關閉前的<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3410">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-3411">這可確保所有資料都傳送及接收連線的通訊端上之前它已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3411">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="4e975-3412">呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法來釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3412">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="4e975-3413">請勿嘗試重複使用<xref:System.Net.Sockets.Socket>關閉後。</span><span class="sxs-lookup"><span data-stu-id="4e975-3413">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="4e975-3414">下表顯示<xref:System.Net.Sockets.SocketShutdown>列舉值的有效`how`參數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3414">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="4e975-3415">值</span><span class="sxs-lookup"><span data-stu-id="4e975-3415">Value</span></span>|<span data-ttu-id="4e975-3416">描述</span><span class="sxs-lookup"><span data-stu-id="4e975-3416">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="4e975-3417">傳送</span><span class="sxs-lookup"><span data-stu-id="4e975-3417">Send</span></span>|<span data-ttu-id="4e975-3418">停用傳送這個<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3418">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="4e975-3419">接收</span><span class="sxs-lookup"><span data-stu-id="4e975-3419">Receive</span></span>|<span data-ttu-id="4e975-3420">停用接收此<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3420">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="4e975-3421">兩種模式</span><span class="sxs-lookup"><span data-stu-id="4e975-3421">Both</span></span>|<span data-ttu-id="4e975-3422">停用傳送和接收此<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3422">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="4e975-3423">設定`how`至<xref:System.Net.Sockets.SocketShutdown.Send>指定後續的呼叫<xref:System.Net.Sockets.Socket.Send%2A>不允許。</span><span class="sxs-lookup"><span data-stu-id="4e975-3423">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="4e975-3424">如果您使用無連線<xref:System.Net.Sockets.Socket>，並指定<xref:System.Net.Sockets.SocketShutdown.Send>會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="4e975-3424">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="4e975-3425">設定`how`至<xref:System.Net.Sockets.SocketShutdown.Receive>指定後續的呼叫<xref:System.Net.Sockets.Socket.Receive%2A>不允許。</span><span class="sxs-lookup"><span data-stu-id="4e975-3425">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="4e975-3426">這會有較低的通訊協定層不會影響。</span><span class="sxs-lookup"><span data-stu-id="4e975-3426">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="4e975-3427">如果您使用連線導向的通訊協定，則連線會終止，如果下列條件存在之後呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>:</span><span class="sxs-lookup"><span data-stu-id="4e975-3427">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="4e975-3428">正在等待接收內送的網路緩衝區的資料。</span><span class="sxs-lookup"><span data-stu-id="4e975-3428">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="4e975-3429">詳細資料已送達。</span><span class="sxs-lookup"><span data-stu-id="4e975-3429">More data has arrived.</span></span>  
  
 <span data-ttu-id="4e975-3430">如果您使用無連接的通訊協定，資料包所接受和排入佇列。</span><span class="sxs-lookup"><span data-stu-id="4e975-3430">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="4e975-3431">不過，如果沒有緩衝區空間供其他傳入資料包，都會被捨棄，寄件者會傳回任何錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3431">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="4e975-3432">使用<xref:System.Net.Sockets.Socket.Shutdown%2A>上無連線<xref:System.Net.Sockets.Socket>不建議使用。</span><span class="sxs-lookup"><span data-stu-id="4e975-3432">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="4e975-3433">設定`how`至<xref:System.Net.Sockets.SocketShutdown.Both>停用這兩個傳送和接收 （如上所述）。</span><span class="sxs-lookup"><span data-stu-id="4e975-3433">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3434">如果您收到<xref:System.Net.Sockets.SocketException>呼叫時<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，請使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3434">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3435">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3435">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e975-3436">在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3436">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="4e975-3437">如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="4e975-3437">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3438">下列程式碼範例使用<xref:System.Net.Sockets.Socket.Shutdown%2A>停用<xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3438">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3439">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3439">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3440"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-3441">取得 <see cref="T:System.Net.Sockets.Socket" /> 的類型。</span><span class="sxs-lookup"><span data-stu-id="4e975-3441">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-3442">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3442">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3443"><xref:System.Net.Sockets.Socket.SocketType%2A> 是唯讀的而且會設定當<xref:System.Net.Sockets.Socket>建立。</span><span class="sxs-lookup"><span data-stu-id="4e975-3443"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3444">下列程式碼範例顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>至主控台。</span><span class="sxs-lookup"><span data-stu-id="4e975-3444">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-3445">取得值，指出 IPv4 支援是否可用並在目前的主機上啟用。</span><span class="sxs-lookup"><span data-stu-id="4e975-3445">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-3446">如果目前的主機支援 IPv4 通訊協定，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3446"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3447">作業系統可能會支援 IPv4 和 IPv6 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3447">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-3448">取得值，指出「架構」是否對某些已過時 <see cref="T:System.Net.Dns" /> 成員支援 IPv6。</span><span class="sxs-lookup"><span data-stu-id="4e975-3448">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-3449">如果「架構」對某些已過時的 <see cref="T:System.Net.Dns" /> 方法支援 IPv6，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3449"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3450">作業系統可能會支援 IPv4 和 IPv6 通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3450">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-3451">取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 傳送之網際網路通訊協定 (IP) 封包的存留時間 (TTL) 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3451">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="4e975-3452">TTL 值。</span><span class="sxs-lookup"><span data-stu-id="4e975-3452">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3453">TTL 值會指出最大的封包可以周遊路由器捨棄封包，以及網際網路控制訊息通訊協定 (ICMP) 」 已經超過 TTL"之前的路由器數目寄件者會傳回錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="4e975-3453">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="4e975-3454">TTL 值可能設定的值，從 0 到 255。</span><span class="sxs-lookup"><span data-stu-id="4e975-3454">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="4e975-3455">當未設定這個屬性時，通訊端的預設 TTL 值為 32。</span><span class="sxs-lookup"><span data-stu-id="4e975-3455">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="4e975-3456">如果已建立成功的連線使用通訊端傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會忽略 TCP/IP 堆疊。</span><span class="sxs-lookup"><span data-stu-id="4e975-3456">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="4e975-3457">如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="4e975-3457">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="4e975-3458">取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。</span><span class="sxs-lookup"><span data-stu-id="4e975-3458">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e975-3459">下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.Ttl%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4e975-3459">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="4e975-3460">TTL 值不能設定為負數。</span><span class="sxs-lookup"><span data-stu-id="4e975-3460">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4e975-3461">這個屬性只可為 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 家族中的通訊端設定。</span><span class="sxs-lookup"><span data-stu-id="4e975-3461">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="4e975-3462">嘗試存取通訊端時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3462">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="4e975-3463">當嘗試將 TTL 設定為大於 255 的值時，也會傳回這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="4e975-3463">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="4e975-3464"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</span><span class="sxs-lookup"><span data-stu-id="4e975-3464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4e975-3465">指定通訊端是否只應使用重疊的 I/O 模式。</span><span class="sxs-lookup"><span data-stu-id="4e975-3465">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value>
          <span data-ttu-id="4e975-3466">如果 <see cref="T:System.Net.Sockets.Socket" /> 只使用重疊的 I/O，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3466"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4e975-3467">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e975-3467">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e975-3468">將此屬性設定為`true`如<xref:System.Net.Sockets.Socket>您想要呼叫<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3468">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="4e975-3469">否則，架構可能會指派完成連接埠通訊端，會禁止使用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。</span><span class="sxs-lookup"><span data-stu-id="4e975-3469">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4e975-3470">通訊端已繫結至完成通訊埠。</span><span class="sxs-lookup"><span data-stu-id="4e975-3470">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>